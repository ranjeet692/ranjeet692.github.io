//seedrandom.min.js
!function (a, b, c, d, e, f, g, h, i) { function j(a) { var b, c = a.length, e = this, f = 0, g = e.i = e.j = 0, h = e.S = []; for (c || (a = [c++]); d > f;)h[f] = f++; for (f = 0; d > f; f++)h[f] = h[g = s & g + a[f % c] + (b = h[f])], h[g] = b; (e.g = function (a) { for (var b, c = 0, f = e.i, g = e.j, h = e.S; a--;)b = h[f = s & f + 1], c = c * d + h[s & (h[f] = h[g = s & g + b]) + (h[g] = b)]; return e.i = f, e.j = g, c })(d) } function k(a, b) { var c, d = [], e = typeof a; if (b && "object" == e) for (c in a) try { d.push(k(a[c], b - 1)) } catch (f) { } return d.length ? d : "string" == e ? a : a + "\0" } function l(a, b) { for (var c, d = a + "", e = 0; e < d.length;)b[s & e] = s & (c ^= 19 * b[s & e]) + d.charCodeAt(e++); return n(b) } function m(c) { try { return o ? n(o.randomBytes(d)) : (a.crypto.getRandomValues(c = new Uint8Array(d)), n(c)) } catch (e) { return [+new Date, a, (c = a.navigator) && c.plugins, a.screen, n(b)] } } function n(a) { return String.fromCharCode.apply(0, a) } var o, p = c.pow(d, e), q = c.pow(2, f), r = 2 * q, s = d - 1, t = c["seed" + i] = function (a, f, g) { var h = []; f = 1 == f ? { entropy: !0 } : f || {}; var o = l(k(f.entropy ? [a, n(b)] : null == a ? m() : a, 3), h), s = new j(h); return l(n(s.S), b), (f.pass || g || function (a, b, d) { return d ? (c[i] = a, b) : a })(function () { for (var a = s.g(e), b = p, c = 0; q > a;)a = (a + c) * d, b *= d, c = s.g(1); for (; a >= r;)a /= 2, b /= 2, c >>>= 1; return (a + c) / b }, o, "global" in f ? f.global : this == c) }; if (l(c[i](), b), g && g.exports) { g.exports = t; try { o = require("crypto") } catch (u) { } } else h && h.amd && h(function () { return t }) }(this, [], Math, 256, 6, 52, "object" == typeof module && module, "function" == typeof define && define, "random");

//jquery
/*! jQuery v2.2.4 | (c) jQuery Foundation | jquery.org/license */
!function (a, b) { "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function (a) { if (!a.document) throw new Error("jQuery requires a window with a document"); return b(a) } : b(a) }("undefined" != typeof window ? window : this, function (a, b) {
	var c = [], d = a.document, e = c.slice, f = c.concat, g = c.push, h = c.indexOf, i = {}, j = i.toString, k = i.hasOwnProperty, l = {}, m = "2.2.4", n = function (a, b) { return new n.fn.init(a, b) }, o = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, p = /^-ms-/, q = /-([\da-z])/gi, r = function (a, b) { return b.toUpperCase() }; n.fn = n.prototype = { jquery: m, constructor: n, selector: "", length: 0, toArray: function () { return e.call(this) }, get: function (a) { return null != a ? 0 > a ? this[a + this.length] : this[a] : e.call(this) }, pushStack: function (a) { var b = n.merge(this.constructor(), a); return b.prevObject = this, b.context = this.context, b }, each: function (a) { return n.each(this, a) }, map: function (a) { return this.pushStack(n.map(this, function (b, c) { return a.call(b, c, b) })) }, slice: function () { return this.pushStack(e.apply(this, arguments)) }, first: function () { return this.eq(0) }, last: function () { return this.eq(-1) }, eq: function (a) { var b = this.length, c = +a + (0 > a ? b : 0); return this.pushStack(c >= 0 && b > c ? [this[c]] : []) }, end: function () { return this.prevObject || this.constructor() }, push: g, sort: c.sort, splice: c.splice }, n.extend = n.fn.extend = function () { var a, b, c, d, e, f, g = arguments[0] || {}, h = 1, i = arguments.length, j = !1; for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || n.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++)if (null != (a = arguments[h])) for (b in a) c = g[b], d = a[b], g !== d && (j && d && (n.isPlainObject(d) || (e = n.isArray(d))) ? (e ? (e = !1, f = c && n.isArray(c) ? c : []) : f = c && n.isPlainObject(c) ? c : {}, g[b] = n.extend(j, f, d)) : void 0 !== d && (g[b] = d)); return g }, n.extend({ expando: "jQuery" + (m + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (a) { throw new Error(a) }, noop: function () { }, isFunction: function (a) { return "function" === n.type(a) }, isArray: Array.isArray, isWindow: function (a) { return null != a && a === a.window }, isNumeric: function (a) { var b = a && a.toString(); return !n.isArray(a) && b - parseFloat(b) + 1 >= 0 }, isPlainObject: function (a) { var b; if ("object" !== n.type(a) || a.nodeType || n.isWindow(a)) return !1; if (a.constructor && !k.call(a, "constructor") && !k.call(a.constructor.prototype || {}, "isPrototypeOf")) return !1; for (b in a); return void 0 === b || k.call(a, b) }, isEmptyObject: function (a) { var b; for (b in a) return !1; return !0 }, type: function (a) { return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? i[j.call(a)] || "object" : typeof a }, globalEval: function (a) { var b, c = eval; a = n.trim(a), a && (1 === a.indexOf("use strict") ? (b = d.createElement("script"), b.text = a, d.head.appendChild(b).parentNode.removeChild(b)) : c(a)) }, camelCase: function (a) { return a.replace(p, "ms-").replace(q, r) }, nodeName: function (a, b) { return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase() }, each: function (a, b) { var c, d = 0; if (s(a)) { for (c = a.length; c > d; d++)if (b.call(a[d], d, a[d]) === !1) break } else for (d in a) if (b.call(a[d], d, a[d]) === !1) break; return a }, trim: function (a) { return null == a ? "" : (a + "").replace(o, "") }, makeArray: function (a, b) { var c = b || []; return null != a && (s(Object(a)) ? n.merge(c, "string" == typeof a ? [a] : a) : g.call(c, a)), c }, inArray: function (a, b, c) { return null == b ? -1 : h.call(b, a, c) }, merge: function (a, b) { for (var c = +b.length, d = 0, e = a.length; c > d; d++)a[e++] = b[d]; return a.length = e, a }, grep: function (a, b, c) { for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++)d = !b(a[f], f), d !== h && e.push(a[f]); return e }, map: function (a, b, c) { var d, e, g = 0, h = []; if (s(a)) for (d = a.length; d > g; g++)e = b(a[g], g, c), null != e && h.push(e); else for (g in a) e = b(a[g], g, c), null != e && h.push(e); return f.apply([], h) }, guid: 1, proxy: function (a, b) { var c, d, f; return "string" == typeof b && (c = a[b], b = a, a = c), n.isFunction(a) ? (d = e.call(arguments, 2), f = function () { return a.apply(b || this, d.concat(e.call(arguments))) }, f.guid = a.guid = a.guid || n.guid++, f) : void 0 }, now: Date.now, support: l }), "function" == typeof Symbol && (n.fn[Symbol.iterator] = c[Symbol.iterator]), n.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (a, b) { i["[object " + b + "]"] = b.toLowerCase() }); function s(a) { var b = !!a && "length" in a && a.length, c = n.type(a); return "function" === c || n.isWindow(a) ? !1 : "array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a } var t = function (a) { var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + 1 * new Date, v = a.document, w = 0, x = 0, y = ga(), z = ga(), A = ga(), B = function (a, b) { return a === b && (l = !0), 0 }, C = 1 << 31, D = {}.hasOwnProperty, E = [], F = E.pop, G = E.push, H = E.push, I = E.slice, J = function (a, b) { for (var c = 0, d = a.length; d > c; c++)if (a[c] === b) return c; return -1 }, K = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", L = "[\\x20\\t\\r\\n\\f]", M = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", N = "\\[" + L + "*(" + M + ")(?:" + L + "*([*^$|!~]?=)" + L + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + M + "))|)" + L + "*\\]", O = ":(" + M + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + N + ")*)|.*)\\)|)", P = new RegExp(L + "+", "g"), Q = new RegExp("^" + L + "+|((?:^|[^\\\\])(?:\\\\.)*)" + L + "+$", "g"), R = new RegExp("^" + L + "*," + L + "*"), S = new RegExp("^" + L + "*([>+~]|" + L + ")" + L + "*"), T = new RegExp("=" + L + "*([^\\]'\"]*?)" + L + "*\\]", "g"), U = new RegExp(O), V = new RegExp("^" + M + "$"), W = { ID: new RegExp("^#(" + M + ")"), CLASS: new RegExp("^\\.(" + M + ")"), TAG: new RegExp("^(" + M + "|[*])"), ATTR: new RegExp("^" + N), PSEUDO: new RegExp("^" + O), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + L + "*(even|odd|(([+-]|)(\\d*)n|)" + L + "*(?:([+-]|)" + L + "*(\\d+)|))" + L + "*\\)|)", "i"), bool: new RegExp("^(?:" + K + ")$", "i"), needsContext: new RegExp("^" + L + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + L + "*((?:-\\d)?\\d*)" + L + "*\\)|)(?=[^-]|$)", "i") }, X = /^(?:input|select|textarea|button)$/i, Y = /^h\d$/i, Z = /^[^{]+\{\s*\[native \w/, $ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, _ = /[+~]/, aa = /'|\\/g, ba = new RegExp("\\\\([\\da-f]{1,6}" + L + "?|(" + L + ")|.)", "ig"), ca = function (a, b, c) { var d = "0x" + b - 65536; return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320) }, da = function () { m() }; try { H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType } catch (ea) { H = { apply: E.length ? function (a, b) { G.apply(a, I.call(b)) } : function (a, b) { var c = a.length, d = 0; while (a[c++] = b[d++]); a.length = c - 1 } } } function fa(a, b, d, e) { var f, h, j, k, l, o, r, s, w = b && b.ownerDocument, x = b ? b.nodeType : 9; if (d = d || [], "string" != typeof a || !a || 1 !== x && 9 !== x && 11 !== x) return d; if (!e && ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, p)) { if (11 !== x && (o = $.exec(a))) if (f = o[1]) { if (9 === x) { if (!(j = b.getElementById(f))) return d; if (j.id === f) return d.push(j), d } else if (w && (j = w.getElementById(f)) && t(b, j) && j.id === f) return d.push(j), d } else { if (o[2]) return H.apply(d, b.getElementsByTagName(a)), d; if ((f = o[3]) && c.getElementsByClassName && b.getElementsByClassName) return H.apply(d, b.getElementsByClassName(f)), d } if (c.qsa && !A[a + " "] && (!q || !q.test(a))) { if (1 !== x) w = b, s = a; else if ("object" !== b.nodeName.toLowerCase()) { (k = b.getAttribute("id")) ? k = k.replace(aa, "\\$&") : b.setAttribute("id", k = u), r = g(a), h = r.length, l = V.test(k) ? "#" + k : "[id='" + k + "']"; while (h--) r[h] = l + " " + qa(r[h]); s = r.join(","), w = _.test(a) && oa(b.parentNode) || b } if (s) try { return H.apply(d, w.querySelectorAll(s)), d } catch (y) { } finally { k === u && b.removeAttribute("id") } } } return i(a.replace(Q, "$1"), b, d, e) } function ga() { var a = []; function b(c, e) { return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e } return b } function ha(a) { return a[u] = !0, a } function ia(a) { var b = n.createElement("div"); try { return !!a(b) } catch (c) { return !1 } finally { b.parentNode && b.parentNode.removeChild(b), b = null } } function ja(a, b) { var c = a.split("|"), e = c.length; while (e--) d.attrHandle[c[e]] = b } function ka(a, b) { var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C); if (d) return d; if (c) while (c = c.nextSibling) if (c === b) return -1; return a ? 1 : -1 } function la(a) { return function (b) { var c = b.nodeName.toLowerCase(); return "input" === c && b.type === a } } function ma(a) { return function (b) { var c = b.nodeName.toLowerCase(); return ("input" === c || "button" === c) && b.type === a } } function na(a) { return ha(function (b) { return b = +b, ha(function (c, d) { var e, f = a([], c.length, b), g = f.length; while (g--) c[e = f[g]] && (c[e] = !(d[e] = c[e])) }) }) } function oa(a) { return a && "undefined" != typeof a.getElementsByTagName && a } c = fa.support = {}, f = fa.isXML = function (a) { var b = a && (a.ownerDocument || a).documentElement; return b ? "HTML" !== b.nodeName : !1 }, m = fa.setDocument = function (a) { var b, e, g = a ? a.ownerDocument || a : v; return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = n.documentElement, p = !f(n), (e = n.defaultView) && e.top !== e && (e.addEventListener ? e.addEventListener("unload", da, !1) : e.attachEvent && e.attachEvent("onunload", da)), c.attributes = ia(function (a) { return a.className = "i", !a.getAttribute("className") }), c.getElementsByTagName = ia(function (a) { return a.appendChild(n.createComment("")), !a.getElementsByTagName("*").length }), c.getElementsByClassName = Z.test(n.getElementsByClassName), c.getById = ia(function (a) { return o.appendChild(a).id = u, !n.getElementsByName || !n.getElementsByName(u).length }), c.getById ? (d.find.ID = function (a, b) { if ("undefined" != typeof b.getElementById && p) { var c = b.getElementById(a); return c ? [c] : [] } }, d.filter.ID = function (a) { var b = a.replace(ba, ca); return function (a) { return a.getAttribute("id") === b } }) : (delete d.find.ID, d.filter.ID = function (a) { var b = a.replace(ba, ca); return function (a) { var c = "undefined" != typeof a.getAttributeNode && a.getAttributeNode("id"); return c && c.value === b } }), d.find.TAG = c.getElementsByTagName ? function (a, b) { return "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0 } : function (a, b) { var c, d = [], e = 0, f = b.getElementsByTagName(a); if ("*" === a) { while (c = f[e++]) 1 === c.nodeType && d.push(c); return d } return f }, d.find.CLASS = c.getElementsByClassName && function (a, b) { return "undefined" != typeof b.getElementsByClassName && p ? b.getElementsByClassName(a) : void 0 }, r = [], q = [], (c.qsa = Z.test(n.querySelectorAll)) && (ia(function (a) { o.appendChild(a).innerHTML = "<a id='" + u + "'></a><select id='" + u + "-\r\\' msallowcapture=''><option selected=''></option></select>", a.querySelectorAll("[msallowcapture^='']").length && q.push("[*^$]=" + L + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || q.push("\\[" + L + "*(?:value|" + K + ")"), a.querySelectorAll("[id~=" + u + "-]").length || q.push("~="), a.querySelectorAll(":checked").length || q.push(":checked"), a.querySelectorAll("a#" + u + "+*").length || q.push(".#.+[+~]") }), ia(function (a) { var b = n.createElement("input"); b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && q.push("name" + L + "*[*^$|!~]?="), a.querySelectorAll(":enabled").length || q.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), q.push(",.*:") })), (c.matchesSelector = Z.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ia(function (a) { c.disconnectedMatch = s.call(a, "div"), s.call(a, "[s!='']:x"), r.push("!=", O) }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")), b = Z.test(o.compareDocumentPosition), t = b || Z.test(o.contains) ? function (a, b) { var c = 9 === a.nodeType ? a.documentElement : a, d = b && b.parentNode; return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d))) } : function (a, b) { if (b) while (b = b.parentNode) if (b === a) return !0; return !1 }, B = b ? function (a, b) { if (a === b) return l = !0, 0; var d = !a.compareDocumentPosition - !b.compareDocumentPosition; return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === n || a.ownerDocument === v && t(v, a) ? -1 : b === n || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1) } : function (a, b) { if (a === b) return l = !0, 0; var c, d = 0, e = a.parentNode, f = b.parentNode, g = [a], h = [b]; if (!e || !f) return a === n ? -1 : b === n ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0; if (e === f) return ka(a, b); c = a; while (c = c.parentNode) g.unshift(c); c = b; while (c = c.parentNode) h.unshift(c); while (g[d] === h[d]) d++; return d ? ka(g[d], h[d]) : g[d] === v ? -1 : h[d] === v ? 1 : 0 }, n) : n }, fa.matches = function (a, b) { return fa(a, null, null, b) }, fa.matchesSelector = function (a, b) { if ((a.ownerDocument || a) !== n && m(a), b = b.replace(T, "='$1']"), c.matchesSelector && p && !A[b + " "] && (!r || !r.test(b)) && (!q || !q.test(b))) try { var d = s.call(a, b); if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d } catch (e) { } return fa(b, n, null, [a]).length > 0 }, fa.contains = function (a, b) { return (a.ownerDocument || a) !== n && m(a), t(a, b) }, fa.attr = function (a, b) { (a.ownerDocument || a) !== n && m(a); var e = d.attrHandle[b.toLowerCase()], f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0; return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null }, fa.error = function (a) { throw new Error("Syntax error, unrecognized expression: " + a) }, fa.uniqueSort = function (a) { var b, d = [], e = 0, f = 0; if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) { while (b = a[f++]) b === a[f] && (e = d.push(f)); while (e--) a.splice(d[e], 1) } return k = null, a }, e = fa.getText = function (a) { var b, c = "", d = 0, f = a.nodeType; if (f) { if (1 === f || 9 === f || 11 === f) { if ("string" == typeof a.textContent) return a.textContent; for (a = a.firstChild; a; a = a.nextSibling)c += e(a) } else if (3 === f || 4 === f) return a.nodeValue } else while (b = a[d++]) c += e(b); return c }, d = fa.selectors = { cacheLength: 50, createPseudo: ha, match: W, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function (a) { return a[1] = a[1].replace(ba, ca), a[3] = (a[3] || a[4] || a[5] || "").replace(ba, ca), "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4) }, CHILD: function (a) { return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || fa.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && fa.error(a[0]), a }, PSEUDO: function (a) { var b, c = !a[6] && a[2]; return W.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && U.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3)) } }, filter: { TAG: function (a) { var b = a.replace(ba, ca).toLowerCase(); return "*" === a ? function () { return !0 } : function (a) { return a.nodeName && a.nodeName.toLowerCase() === b } }, CLASS: function (a) { var b = y[a + " "]; return b || (b = new RegExp("(^|" + L + ")" + a + "(" + L + "|$)")) && y(a, function (a) { return b.test("string" == typeof a.className && a.className || "undefined" != typeof a.getAttribute && a.getAttribute("class") || "") }) }, ATTR: function (a, b, c) { return function (d) { var e = fa.attr(d, a); return null == e ? "!=" === b : b ? (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e.replace(P, " ") + " ").indexOf(c) > -1 : "|=" === b ? e === c || e.slice(0, c.length + 1) === c + "-" : !1) : !0 } }, CHILD: function (a, b, c, d, e) { var f = "nth" !== a.slice(0, 3), g = "last" !== a.slice(-4), h = "of-type" === b; return 1 === d && 0 === e ? function (a) { return !!a.parentNode } : function (b, c, i) { var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase(), s = !i && !h, t = !1; if (q) { if (f) { while (p) { m = b; while (m = m[p]) if (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) return !1; o = p = "only" === a && !o && "nextSibling" } return !0 } if (o = [g ? q.firstChild : q.lastChild], g && s) { m = q, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n && j[2], m = n && q.childNodes[n]; while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) if (1 === m.nodeType && ++t && m === b) { k[a] = [w, n, t]; break } } else if (s && (m = b, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n), t === !1) while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) if ((h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) && ++t && (s && (l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), k[a] = [w, t]), m === b)) break; return t -= e, t === d || t % d === 0 && t / d >= 0 } } }, PSEUDO: function (a, b) { var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || fa.error("unsupported pseudo: " + a); return e[u] ? e(b) : e.length > 1 ? (c = [a, a, "", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ha(function (a, c) { var d, f = e(a, b), g = f.length; while (g--) d = J(a, f[g]), a[d] = !(c[d] = f[g]) }) : function (a) { return e(a, 0, c) }) : e } }, pseudos: { not: ha(function (a) { var b = [], c = [], d = h(a.replace(Q, "$1")); return d[u] ? ha(function (a, b, c, e) { var f, g = d(a, null, e, []), h = a.length; while (h--) (f = g[h]) && (a[h] = !(b[h] = f)) }) : function (a, e, f) { return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop() } }), has: ha(function (a) { return function (b) { return fa(a, b).length > 0 } }), contains: ha(function (a) { return a = a.replace(ba, ca), function (b) { return (b.textContent || b.innerText || e(b)).indexOf(a) > -1 } }), lang: ha(function (a) { return V.test(a || "") || fa.error("unsupported lang: " + a), a = a.replace(ba, ca).toLowerCase(), function (b) { var c; do if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) && 1 === b.nodeType); return !1 } }), target: function (b) { var c = a.location && a.location.hash; return c && c.slice(1) === b.id }, root: function (a) { return a === o }, focus: function (a) { return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex) }, enabled: function (a) { return a.disabled === !1 }, disabled: function (a) { return a.disabled === !0 }, checked: function (a) { var b = a.nodeName.toLowerCase(); return "input" === b && !!a.checked || "option" === b && !!a.selected }, selected: function (a) { return a.parentNode && a.parentNode.selectedIndex, a.selected === !0 }, empty: function (a) { for (a = a.firstChild; a; a = a.nextSibling)if (a.nodeType < 6) return !1; return !0 }, parent: function (a) { return !d.pseudos.empty(a) }, header: function (a) { return Y.test(a.nodeName) }, input: function (a) { return X.test(a.nodeName) }, button: function (a) { var b = a.nodeName.toLowerCase(); return "input" === b && "button" === a.type || "button" === b }, text: function (a) { var b; return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase()) }, first: na(function () { return [0] }), last: na(function (a, b) { return [b - 1] }), eq: na(function (a, b, c) { return [0 > c ? c + b : c] }), even: na(function (a, b) { for (var c = 0; b > c; c += 2)a.push(c); return a }), odd: na(function (a, b) { for (var c = 1; b > c; c += 2)a.push(c); return a }), lt: na(function (a, b, c) { for (var d = 0 > c ? c + b : c; --d >= 0;)a.push(d); return a }), gt: na(function (a, b, c) { for (var d = 0 > c ? c + b : c; ++d < b;)a.push(d); return a }) } }, d.pseudos.nth = d.pseudos.eq; for (b in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) d.pseudos[b] = la(b); for (b in { submit: !0, reset: !0 }) d.pseudos[b] = ma(b); function pa() { } pa.prototype = d.filters = d.pseudos, d.setFilters = new pa, g = fa.tokenize = function (a, b) { var c, e, f, g, h, i, j, k = z[a + " "]; if (k) return b ? 0 : k.slice(0); h = a, i = [], j = d.preFilter; while (h) { c && !(e = R.exec(h)) || (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = S.exec(h)) && (c = e.shift(), f.push({ value: c, type: e[0].replace(Q, " ") }), h = h.slice(c.length)); for (g in d.filter) !(e = W[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({ value: c, type: g, matches: e }), h = h.slice(c.length)); if (!c) break } return b ? h.length : h ? fa.error(a) : z(a, i).slice(0) }; function qa(a) { for (var b = 0, c = a.length, d = ""; c > b; b++)d += a[b].value; return d } function ra(a, b, c) { var d = b.dir, e = c && "parentNode" === d, f = x++; return b.first ? function (b, c, f) { while (b = b[d]) if (1 === b.nodeType || e) return a(b, c, f) } : function (b, c, g) { var h, i, j, k = [w, f]; if (g) { while (b = b[d]) if ((1 === b.nodeType || e) && a(b, c, g)) return !0 } else while (b = b[d]) if (1 === b.nodeType || e) { if (j = b[u] || (b[u] = {}), i = j[b.uniqueID] || (j[b.uniqueID] = {}), (h = i[d]) && h[0] === w && h[1] === f) return k[2] = h[2]; if (i[d] = k, k[2] = a(b, c, g)) return !0 } } } function sa(a) { return a.length > 1 ? function (b, c, d) { var e = a.length; while (e--) if (!a[e](b, c, d)) return !1; return !0 } : a[0] } function ta(a, b, c) { for (var d = 0, e = b.length; e > d; d++)fa(a, b[d], c); return c } function ua(a, b, c, d, e) { for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++)(f = a[h]) && (c && !c(f, d, e) || (g.push(f), j && b.push(h))); return g } function va(a, b, c, d, e, f) { return d && !d[u] && (d = va(d)), e && !e[u] && (e = va(e, f)), ha(function (f, g, h, i) { var j, k, l, m = [], n = [], o = g.length, p = f || ta(b || "*", h.nodeType ? [h] : h, []), q = !a || !f && b ? p : ua(p, m, a, h, i), r = c ? e || (f ? a : o || d) ? [] : g : q; if (c && c(q, r, h, i), d) { j = ua(r, n), d(j, [], h, i), k = j.length; while (k--) (l = j[k]) && (r[n[k]] = !(q[n[k]] = l)) } if (f) { if (e || a) { if (e) { j = [], k = r.length; while (k--) (l = r[k]) && j.push(q[k] = l); e(null, r = [], j, i) } k = r.length; while (k--) (l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l)) } } else r = ua(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r) }) } function wa(a) { for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = ra(function (a) { return a === b }, h, !0), l = ra(function (a) { return J(b, a) > -1 }, h, !0), m = [function (a, c, d) { var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d)); return b = null, e }]; f > i; i++)if (c = d.relative[a[i].type]) m = [ra(sa(m), c)]; else { if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) { for (e = ++i; f > e; e++)if (d.relative[a[e].type]) break; return va(i > 1 && sa(m), i > 1 && qa(a.slice(0, i - 1).concat({ value: " " === a[i - 2].type ? "*" : "" })).replace(Q, "$1"), c, e > i && wa(a.slice(i, e)), f > e && wa(a = a.slice(e)), f > e && qa(a)) } m.push(c) } return sa(m) } function xa(a, b) { var c = b.length > 0, e = a.length > 0, f = function (f, g, h, i, k) { var l, o, q, r = 0, s = "0", t = f && [], u = [], v = j, x = f || e && d.find.TAG("*", k), y = w += null == v ? 1 : Math.random() || .1, z = x.length; for (k && (j = g === n || g || k); s !== z && null != (l = x[s]); s++) { if (e && l) { o = 0, g || l.ownerDocument === n || (m(l), h = !p); while (q = a[o++]) if (q(l, g || n, h)) { i.push(l); break } k && (w = y) } c && ((l = !q && l) && r--, f && t.push(l)) } if (r += s, c && s !== r) { o = 0; while (q = b[o++]) q(t, u, g, h); if (f) { if (r > 0) while (s--) t[s] || u[s] || (u[s] = F.call(i)); u = ua(u) } H.apply(i, u), k && !f && u.length > 0 && r + b.length > 1 && fa.uniqueSort(i) } return k && (w = y, j = v), t }; return c ? ha(f) : f } return h = fa.compile = function (a, b) { var c, d = [], e = [], f = A[a + " "]; if (!f) { b || (b = g(a)), c = b.length; while (c--) f = wa(b[c]), f[u] ? d.push(f) : e.push(f); f = A(a, xa(e, d)), f.selector = a } return f }, i = fa.select = function (a, b, e, f) { var i, j, k, l, m, n = "function" == typeof a && a, o = !f && g(a = n.selector || a); if (e = e || [], 1 === o.length) { if (j = o[0] = o[0].slice(0), j.length > 2 && "ID" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) { if (b = (d.find.ID(k.matches[0].replace(ba, ca), b) || [])[0], !b) return e; n && (b = b.parentNode), a = a.slice(j.shift().value.length) } i = W.needsContext.test(a) ? 0 : j.length; while (i--) { if (k = j[i], d.relative[l = k.type]) break; if ((m = d.find[l]) && (f = m(k.matches[0].replace(ba, ca), _.test(j[0].type) && oa(b.parentNode) || b))) { if (j.splice(i, 1), a = f.length && qa(j), !a) return H.apply(e, f), e; break } } } return (n || h(a, o))(f, b, !p, e, !b || _.test(a) && oa(b.parentNode) || b), e }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ia(function (a) { return 1 & a.compareDocumentPosition(n.createElement("div")) }), ia(function (a) { return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href") }) || ja("type|href|height|width", function (a, b, c) { return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2) }), c.attributes && ia(function (a) { return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value") }) || ja("value", function (a, b, c) { return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue }), ia(function (a) { return null == a.getAttribute("disabled") }) || ja(K, function (a, b, c) { var d; return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null }), fa }(a); n.find = t, n.expr = t.selectors, n.expr[":"] = n.expr.pseudos, n.uniqueSort = n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains; var u = function (a, b, c) { var d = [], e = void 0 !== c; while ((a = a[b]) && 9 !== a.nodeType) if (1 === a.nodeType) { if (e && n(a).is(c)) break; d.push(a) } return d }, v = function (a, b) { for (var c = []; a; a = a.nextSibling)1 === a.nodeType && a !== b && c.push(a); return c }, w = n.expr.match.needsContext, x = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, y = /^.[^:#\[\.,]*$/; function z(a, b, c) { if (n.isFunction(b)) return n.grep(a, function (a, d) { return !!b.call(a, d, a) !== c }); if (b.nodeType) return n.grep(a, function (a) { return a === b !== c }); if ("string" == typeof b) { if (y.test(b)) return n.filter(b, a, c); b = n.filter(b, a) } return n.grep(a, function (a) { return h.call(b, a) > -1 !== c }) } n.filter = function (a, b, c) { var d = b[0]; return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function (a) { return 1 === a.nodeType })) }, n.fn.extend({ find: function (a) { var b, c = this.length, d = [], e = this; if ("string" != typeof a) return this.pushStack(n(a).filter(function () { for (b = 0; c > b; b++)if (n.contains(e[b], this)) return !0 })); for (b = 0; c > b; b++)n.find(a, e[b], d); return d = this.pushStack(c > 1 ? n.unique(d) : d), d.selector = this.selector ? this.selector + " " + a : a, d }, filter: function (a) { return this.pushStack(z(this, a || [], !1)) }, not: function (a) { return this.pushStack(z(this, a || [], !0)) }, is: function (a) { return !!z(this, "string" == typeof a && w.test(a) ? n(a) : a || [], !1).length } }); var A, B = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, C = n.fn.init = function (a, b, c) { var e, f; if (!a) return this; if (c = c || A, "string" == typeof a) { if (e = "<" === a[0] && ">" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : B.exec(a), !e || !e[1] && b) return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a); if (e[1]) { if (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(e[1], b && b.nodeType ? b.ownerDocument || b : d, !0)), x.test(e[1]) && n.isPlainObject(b)) for (e in b) n.isFunction(this[e]) ? this[e](b[e]) : this.attr(e, b[e]); return this } return f = d.getElementById(e[2]), f && f.parentNode && (this.length = 1, this[0] = f), this.context = d, this.selector = a, this } return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? void 0 !== c.ready ? c.ready(a) : a(n) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray(a, this)) }; C.prototype = n.fn, A = n(d); var D = /^(?:parents|prev(?:Until|All))/, E = { children: !0, contents: !0, next: !0, prev: !0 }; n.fn.extend({ has: function (a) { var b = n(a, this), c = b.length; return this.filter(function () { for (var a = 0; c > a; a++)if (n.contains(this, b[a])) return !0 }) }, closest: function (a, b) { for (var c, d = 0, e = this.length, f = [], g = w.test(a) || "string" != typeof a ? n(a, b || this.context) : 0; e > d; d++)for (c = this[d]; c && c !== b; c = c.parentNode)if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && n.find.matchesSelector(c, a))) { f.push(c); break } return this.pushStack(f.length > 1 ? n.uniqueSort(f) : f) }, index: function (a) { return a ? "string" == typeof a ? h.call(n(a), this[0]) : h.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 }, add: function (a, b) { return this.pushStack(n.uniqueSort(n.merge(this.get(), n(a, b)))) }, addBack: function (a) { return this.add(null == a ? this.prevObject : this.prevObject.filter(a)) } }); function F(a, b) { while ((a = a[b]) && 1 !== a.nodeType); return a } n.each({ parent: function (a) { var b = a.parentNode; return b && 11 !== b.nodeType ? b : null }, parents: function (a) { return u(a, "parentNode") }, parentsUntil: function (a, b, c) { return u(a, "parentNode", c) }, next: function (a) { return F(a, "nextSibling") }, prev: function (a) { return F(a, "previousSibling") }, nextAll: function (a) { return u(a, "nextSibling") }, prevAll: function (a) { return u(a, "previousSibling") }, nextUntil: function (a, b, c) { return u(a, "nextSibling", c) }, prevUntil: function (a, b, c) { return u(a, "previousSibling", c) }, siblings: function (a) { return v((a.parentNode || {}).firstChild, a) }, children: function (a) { return v(a.firstChild) }, contents: function (a) { return a.contentDocument || n.merge([], a.childNodes) } }, function (a, b) { n.fn[a] = function (c, d) { var e = n.map(this, b, c); return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = n.filter(d, e)), this.length > 1 && (E[a] || n.uniqueSort(e), D.test(a) && e.reverse()), this.pushStack(e) } }); var G = /\S+/g; function H(a) { var b = {}; return n.each(a.match(G) || [], function (a, c) { b[c] = !0 }), b } n.Callbacks = function (a) { a = "string" == typeof a ? H(a) : n.extend({}, a); var b, c, d, e, f = [], g = [], h = -1, i = function () { for (e = a.once, d = b = !0; g.length; h = -1) { c = g.shift(); while (++h < f.length) f[h].apply(c[0], c[1]) === !1 && a.stopOnFalse && (h = f.length, c = !1) } a.memory || (c = !1), b = !1, e && (f = c ? [] : "") }, j = { add: function () { return f && (c && !b && (h = f.length - 1, g.push(c)), function d(b) { n.each(b, function (b, c) { n.isFunction(c) ? a.unique && j.has(c) || f.push(c) : c && c.length && "string" !== n.type(c) && d(c) }) }(arguments), c && !b && i()), this }, remove: function () { return n.each(arguments, function (a, b) { var c; while ((c = n.inArray(b, f, c)) > -1) f.splice(c, 1), h >= c && h-- }), this }, has: function (a) { return a ? n.inArray(a, f) > -1 : f.length > 0 }, empty: function () { return f && (f = []), this }, disable: function () { return e = g = [], f = c = "", this }, disabled: function () { return !f }, lock: function () { return e = g = [], c || (f = c = ""), this }, locked: function () { return !!e }, fireWith: function (a, c) { return e || (c = c || [], c = [a, c.slice ? c.slice() : c], g.push(c), b || i()), this }, fire: function () { return j.fireWith(this, arguments), this }, fired: function () { return !!d } }; return j }, n.extend({ Deferred: function (a) { var b = [["resolve", "done", n.Callbacks("once memory"), "resolved"], ["reject", "fail", n.Callbacks("once memory"), "rejected"], ["notify", "progress", n.Callbacks("memory")]], c = "pending", d = { state: function () { return c }, always: function () { return e.done(arguments).fail(arguments), this }, then: function () { var a = arguments; return n.Deferred(function (c) { n.each(b, function (b, f) { var g = n.isFunction(a[b]) && a[b]; e[f[1]](function () { var a = g && g.apply(this, arguments); a && n.isFunction(a.promise) ? a.promise().progress(c.notify).done(c.resolve).fail(c.reject) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [a] : arguments) }) }), a = null }).promise() }, promise: function (a) { return null != a ? n.extend(a, d) : d } }, e = {}; return d.pipe = d.then, n.each(b, function (a, f) { var g = f[2], h = f[3]; d[f[1]] = g.add, h && g.add(function () { c = h }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function () { return e[f[0] + "With"](this === e ? d : this, arguments), this }, e[f[0] + "With"] = g.fireWith }), d.promise(e), a && a.call(e, e), e }, when: function (a) { var b = 0, c = e.call(arguments), d = c.length, f = 1 !== d || a && n.isFunction(a.promise) ? d : 0, g = 1 === f ? a : n.Deferred(), h = function (a, b, c) { return function (d) { b[a] = this, c[a] = arguments.length > 1 ? e.call(arguments) : d, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c) } }, i, j, k; if (d > 1) for (i = new Array(d), j = new Array(d), k = new Array(d); d > b; b++)c[b] && n.isFunction(c[b].promise) ? c[b].promise().progress(h(b, j, i)).done(h(b, k, c)).fail(g.reject) : --f; return f || g.resolveWith(k, c), g.promise() } }); var I; n.fn.ready = function (a) { return n.ready.promise().done(a), this }, n.extend({ isReady: !1, readyWait: 1, holdReady: function (a) { a ? n.readyWait++ : n.ready(!0) }, ready: function (a) { (a === !0 ? --n.readyWait : n.isReady) || (n.isReady = !0, a !== !0 && --n.readyWait > 0 || (I.resolveWith(d, [n]), n.fn.triggerHandler && (n(d).triggerHandler("ready"), n(d).off("ready")))) } }); function J() { d.removeEventListener("DOMContentLoaded", J), a.removeEventListener("load", J), n.ready() } n.ready.promise = function (b) { return I || (I = n.Deferred(), "complete" === d.readyState || "loading" !== d.readyState && !d.documentElement.doScroll ? a.setTimeout(n.ready) : (d.addEventListener("DOMContentLoaded", J), a.addEventListener("load", J))), I.promise(b) }, n.ready.promise(); var K = function (a, b, c, d, e, f, g) { var h = 0, i = a.length, j = null == c; if ("object" === n.type(c)) { e = !0; for (h in c) K(a, b, h, c[h], !0, f, g) } else if (void 0 !== d && (e = !0, n.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function (a, b, c) { return j.call(n(a), c) })), b)) for (; i > h; h++)b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c))); return e ? a : j ? b.call(a) : i ? b(a[0], c) : f }, L = function (a) { return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType }; function M() { this.expando = n.expando + M.uid++ } M.uid = 1, M.prototype = { register: function (a, b) { var c = b || {}; return a.nodeType ? a[this.expando] = c : Object.defineProperty(a, this.expando, { value: c, writable: !0, configurable: !0 }), a[this.expando] }, cache: function (a) { if (!L(a)) return {}; var b = a[this.expando]; return b || (b = {}, L(a) && (a.nodeType ? a[this.expando] = b : Object.defineProperty(a, this.expando, { value: b, configurable: !0 }))), b }, set: function (a, b, c) { var d, e = this.cache(a); if ("string" == typeof b) e[b] = c; else for (d in b) e[d] = b[d]; return e }, get: function (a, b) { return void 0 === b ? this.cache(a) : a[this.expando] && a[this.expando][b] }, access: function (a, b, c) { var d; return void 0 === b || b && "string" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, n.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b) }, remove: function (a, b) { var c, d, e, f = a[this.expando]; if (void 0 !== f) { if (void 0 === b) this.register(a); else { n.isArray(b) ? d = b.concat(b.map(n.camelCase)) : (e = n.camelCase(b), b in f ? d = [b, e] : (d = e, d = d in f ? [d] : d.match(G) || [])), c = d.length; while (c--) delete f[d[c]] } (void 0 === b || n.isEmptyObject(f)) && (a.nodeType ? a[this.expando] = void 0 : delete a[this.expando]) } }, hasData: function (a) { var b = a[this.expando]; return void 0 !== b && !n.isEmptyObject(b) } }; var N = new M, O = new M, P = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, Q = /[A-Z]/g; function R(a, b, c) {
		var d; if (void 0 === c && 1 === a.nodeType) if (d = "data-" + b.replace(Q, "-$&").toLowerCase(), c = a.getAttribute(d), "string" == typeof c) {
			try {
				c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : P.test(c) ? n.parseJSON(c) : c;
			} catch (e) { } O.set(a, b, c)
		} else c = void 0; return c
	} n.extend({ hasData: function (a) { return O.hasData(a) || N.hasData(a) }, data: function (a, b, c) { return O.access(a, b, c) }, removeData: function (a, b) { O.remove(a, b) }, _data: function (a, b, c) { return N.access(a, b, c) }, _removeData: function (a, b) { N.remove(a, b) } }), n.fn.extend({ data: function (a, b) { var c, d, e, f = this[0], g = f && f.attributes; if (void 0 === a) { if (this.length && (e = O.get(f), 1 === f.nodeType && !N.get(f, "hasDataAttrs"))) { c = g.length; while (c--) g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = n.camelCase(d.slice(5)), R(f, d, e[d]))); N.set(f, "hasDataAttrs", !0) } return e } return "object" == typeof a ? this.each(function () { O.set(this, a) }) : K(this, function (b) { var c, d; if (f && void 0 === b) { if (c = O.get(f, a) || O.get(f, a.replace(Q, "-$&").toLowerCase()), void 0 !== c) return c; if (d = n.camelCase(a), c = O.get(f, d), void 0 !== c) return c; if (c = R(f, d, void 0), void 0 !== c) return c } else d = n.camelCase(a), this.each(function () { var c = O.get(this, d); O.set(this, d, b), a.indexOf("-") > -1 && void 0 !== c && O.set(this, a, b) }) }, null, b, arguments.length > 1, null, !0) }, removeData: function (a) { return this.each(function () { O.remove(this, a) }) } }), n.extend({ queue: function (a, b, c) { var d; return a ? (b = (b || "fx") + "queue", d = N.get(a, b), c && (!d || n.isArray(c) ? d = N.access(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0 }, dequeue: function (a, b) { b = b || "fx"; var c = n.queue(a, b), d = c.length, e = c.shift(), f = n._queueHooks(a, b), g = function () { n.dequeue(a, b) }; "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire() }, _queueHooks: function (a, b) { var c = b + "queueHooks"; return N.get(a, c) || N.access(a, c, { empty: n.Callbacks("once memory").add(function () { N.remove(a, [b + "queue", c]) }) }) } }), n.fn.extend({ queue: function (a, b) { var c = 2; return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function () { var c = n.queue(this, a, b); n._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && n.dequeue(this, a) }) }, dequeue: function (a) { return this.each(function () { n.dequeue(this, a) }) }, clearQueue: function (a) { return this.queue(a || "fx", []) }, promise: function (a, b) { var c, d = 1, e = n.Deferred(), f = this, g = this.length, h = function () { --d || e.resolveWith(f, [f]) }; "string" != typeof a && (b = a, a = void 0), a = a || "fx"; while (g--) c = N.get(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h)); return h(), e.promise(b) } }); var S = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, T = new RegExp("^(?:([+-])=|)(" + S + ")([a-z%]*)$", "i"), U = ["Top", "Right", "Bottom", "Left"], V = function (a, b) { return a = b || a, "none" === n.css(a, "display") || !n.contains(a.ownerDocument, a) }; function W(a, b, c, d) { var e, f = 1, g = 20, h = d ? function () { return d.cur() } : function () { return n.css(a, b, "") }, i = h(), j = c && c[3] || (n.cssNumber[b] ? "" : "px"), k = (n.cssNumber[b] || "px" !== j && +i) && T.exec(n.css(a, b)); if (k && k[3] !== j) { j = j || k[3], c = c || [], k = +i || 1; do f = f || ".5", k /= f, n.style(a, b, k + j); while (f !== (f = h() / i) && 1 !== f && --g) } return c && (k = +k || +i || 0, e = c[1] ? k + (c[1] + 1) * c[2] : +c[2], d && (d.unit = j, d.start = k, d.end = e)), e } var X = /^(?:checkbox|radio)$/i, Y = /<([\w:-]+)/, Z = /^$|\/(?:java|ecma)script/i, $ = { option: [1, "<select multiple='multiple'>", "</select>"], thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] }; $.optgroup = $.option, $.tbody = $.tfoot = $.colgroup = $.caption = $.thead, $.th = $.td; function _(a, b) { var c = "undefined" != typeof a.getElementsByTagName ? a.getElementsByTagName(b || "*") : "undefined" != typeof a.querySelectorAll ? a.querySelectorAll(b || "*") : []; return void 0 === b || b && n.nodeName(a, b) ? n.merge([a], c) : c } function aa(a, b) { for (var c = 0, d = a.length; d > c; c++)N.set(a[c], "globalEval", !b || N.get(b[c], "globalEval")) } var ba = /<|&#?\w+;/; function ca(a, b, c, d, e) { for (var f, g, h, i, j, k, l = b.createDocumentFragment(), m = [], o = 0, p = a.length; p > o; o++)if (f = a[o], f || 0 === f) if ("object" === n.type(f)) n.merge(m, f.nodeType ? [f] : f); else if (ba.test(f)) { g = g || l.appendChild(b.createElement("div")), h = (Y.exec(f) || ["", ""])[1].toLowerCase(), i = $[h] || $._default, g.innerHTML = i[1] + n.htmlPrefilter(f) + i[2], k = i[0]; while (k--) g = g.lastChild; n.merge(m, g.childNodes), g = l.firstChild, g.textContent = "" } else m.push(b.createTextNode(f)); l.textContent = "", o = 0; while (f = m[o++]) if (d && n.inArray(f, d) > -1) e && e.push(f); else if (j = n.contains(f.ownerDocument, f), g = _(l.appendChild(f), "script"), j && aa(g), c) { k = 0; while (f = g[k++]) Z.test(f.type || "") && c.push(f) } return l } !function () { var a = d.createDocumentFragment(), b = a.appendChild(d.createElement("div")), c = d.createElement("input"); c.setAttribute("type", "radio"), c.setAttribute("checked", "checked"), c.setAttribute("name", "t"), b.appendChild(c), l.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = "<textarea>x</textarea>", l.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue }(); var da = /^key/, ea = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, fa = /^([^.]*)(?:\.(.+)|)/; function ga() { return !0 } function ha() { return !1 } function ia() { try { return d.activeElement } catch (a) { } } function ja(a, b, c, d, e, f) { var g, h; if ("object" == typeof b) { "string" != typeof c && (d = d || c, c = void 0); for (h in b) ja(a, h, c, d, b[h], f); return a } if (null == d && null == e ? (e = c, d = c = void 0) : null == e && ("string" == typeof c ? (e = d, d = void 0) : (e = d, d = c, c = void 0)), e === !1) e = ha; else if (!e) return a; return 1 === f && (g = e, e = function (a) { return n().off(a), g.apply(this, arguments) }, e.guid = g.guid || (g.guid = n.guid++)), a.each(function () { n.event.add(this, b, e, d, c) }) } n.event = { global: {}, add: function (a, b, c, d, e) { var f, g, h, i, j, k, l, m, o, p, q, r = N.get(a); if (r) { c.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = n.guid++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = function (b) { return "undefined" != typeof n && n.event.triggered !== b.type ? n.event.dispatch.apply(a, arguments) : void 0 }), b = (b || "").match(G) || [""], j = b.length; while (j--) h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o && (l = n.event.special[o] || {}, o = (e ? l.delegateType : l.bindType) || o, l = n.event.special[o] || {}, k = n.extend({ type: o, origType: q, data: d, handler: c, guid: c.guid, selector: e, needsContext: e && n.expr.match.needsContext.test(e), namespace: p.join(".") }, f), (m = i[o]) || (m = i[o] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, p, g) !== !1 || a.addEventListener && a.addEventListener(o, g)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), n.event.global[o] = !0) } }, remove: function (a, b, c, d, e) { var f, g, h, i, j, k, l, m, o, p, q, r = N.hasData(a) && N.get(a); if (r && (i = r.events)) { b = (b || "").match(G) || [""], j = b.length; while (j--) if (h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o) { l = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = i[o] || [], h = h[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), g = f = m.length; while (f--) k = m[f], !e && q !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && ("**" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k)); g && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete i[o]) } else for (o in i) n.event.remove(a, o + b[j], c, d, !0); n.isEmptyObject(i) && N.remove(a, "handle events") } }, dispatch: function (a) { a = n.event.fix(a); var b, c, d, f, g, h = [], i = e.call(arguments), j = (N.get(this, "events") || {})[a.type] || [], k = n.event.special[a.type] || {}; if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) { h = n.event.handlers.call(this, a, j), b = 0; while ((f = h[b++]) && !a.isPropagationStopped()) { a.currentTarget = f.elem, c = 0; while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped()) a.rnamespace && !a.rnamespace.test(g.namespace) || (a.handleObj = g, a.data = g.data, d = ((n.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== d && (a.result = d) === !1 && (a.preventDefault(), a.stopPropagation())) } return k.postDispatch && k.postDispatch.call(this, a), a.result } }, handlers: function (a, b) { var c, d, e, f, g = [], h = b.delegateCount, i = a.target; if (h && i.nodeType && ("click" !== a.type || isNaN(a.button) || a.button < 1)) for (; i !== this; i = i.parentNode || this)if (1 === i.nodeType && (i.disabled !== !0 || "click" !== a.type)) { for (d = [], c = 0; h > c; c++)f = b[c], e = f.selector + " ", void 0 === d[e] && (d[e] = f.needsContext ? n(e, this).index(i) > -1 : n.find(e, this, null, [i]).length), d[e] && d.push(f); d.length && g.push({ elem: i, handlers: d }) } return h < b.length && g.push({ elem: this, handlers: b.slice(h) }), g }, props: "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "), fixHooks: {}, keyHooks: { props: "char charCode key keyCode".split(" "), filter: function (a, b) { return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a } }, mouseHooks: { props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "), filter: function (a, b) { var c, e, f, g = b.button; return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || d, e = c.documentElement, f = c.body, a.pageX = b.clientX + (e && e.scrollLeft || f && f.scrollLeft || 0) - (e && e.clientLeft || f && f.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || f && f.scrollTop || 0) - (e && e.clientTop || f && f.clientTop || 0)), a.which || void 0 === g || (a.which = 1 & g ? 1 : 2 & g ? 3 : 4 & g ? 2 : 0), a } }, fix: function (a) { if (a[n.expando]) return a; var b, c, e, f = a.type, g = a, h = this.fixHooks[f]; h || (this.fixHooks[f] = h = ea.test(f) ? this.mouseHooks : da.test(f) ? this.keyHooks : {}), e = h.props ? this.props.concat(h.props) : this.props, a = new n.Event(g), b = e.length; while (b--) c = e[b], a[c] = g[c]; return a.target || (a.target = d), 3 === a.target.nodeType && (a.target = a.target.parentNode), h.filter ? h.filter(a, g) : a }, special: { load: { noBubble: !0 }, focus: { trigger: function () { return this !== ia() && this.focus ? (this.focus(), !1) : void 0 }, delegateType: "focusin" }, blur: { trigger: function () { return this === ia() && this.blur ? (this.blur(), !1) : void 0 }, delegateType: "focusout" }, click: { trigger: function () { return "checkbox" === this.type && this.click && n.nodeName(this, "input") ? (this.click(), !1) : void 0 }, _default: function (a) { return n.nodeName(a.target, "a") } }, beforeunload: { postDispatch: function (a) { void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result) } } } }, n.removeEvent = function (a, b, c) { a.removeEventListener && a.removeEventListener(b, c) }, n.Event = function (a, b) { return this instanceof n.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? ga : ha) : this.type = a, b && n.extend(this, b), this.timeStamp = a && a.timeStamp || n.now(), void (this[n.expando] = !0)) : new n.Event(a, b) }, n.Event.prototype = { constructor: n.Event, isDefaultPrevented: ha, isPropagationStopped: ha, isImmediatePropagationStopped: ha, isSimulated: !1, preventDefault: function () { var a = this.originalEvent; this.isDefaultPrevented = ga, a && !this.isSimulated && a.preventDefault() }, stopPropagation: function () { var a = this.originalEvent; this.isPropagationStopped = ga, a && !this.isSimulated && a.stopPropagation() }, stopImmediatePropagation: function () { var a = this.originalEvent; this.isImmediatePropagationStopped = ga, a && !this.isSimulated && a.stopImmediatePropagation(), this.stopPropagation() } }, n.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function (a, b) { n.event.special[a] = { delegateType: b, bindType: b, handle: function (a) { var c, d = this, e = a.relatedTarget, f = a.handleObj; return e && (e === d || n.contains(d, e)) || (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c } } }), n.fn.extend({ on: function (a, b, c, d) { return ja(this, a, b, c, d) }, one: function (a, b, c, d) { return ja(this, a, b, c, d, 1) }, off: function (a, b, c) { var d, e; if (a && a.preventDefault && a.handleObj) return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this; if ("object" == typeof a) { for (e in a) this.off(e, b, a[e]); return this } return b !== !1 && "function" != typeof b || (c = b, b = void 0), c === !1 && (c = ha), this.each(function () { n.event.remove(this, a, c, b) }) } }); var ka = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, la = /<script|<style|<link/i, ma = /checked\s*(?:[^=]|=\s*.checked.)/i, na = /^true\/(.*)/, oa = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; function pa(a, b) { return n.nodeName(a, "table") && n.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a } function qa(a) { return a.type = (null !== a.getAttribute("type")) + "/" + a.type, a } function ra(a) { var b = na.exec(a.type); return b ? a.type = b[1] : a.removeAttribute("type"), a } function sa(a, b) { var c, d, e, f, g, h, i, j; if (1 === b.nodeType) { if (N.hasData(a) && (f = N.access(a), g = N.set(b, f), j = f.events)) { delete g.handle, g.events = {}; for (e in j) for (c = 0, d = j[e].length; d > c; c++)n.event.add(b, e, j[e][c]) } O.hasData(a) && (h = O.access(a), i = n.extend({}, h), O.set(b, i)) } } function ta(a, b) { var c = b.nodeName.toLowerCase(); "input" === c && X.test(a.type) ? b.checked = a.checked : "input" !== c && "textarea" !== c || (b.defaultValue = a.defaultValue) } function ua(a, b, c, d) { b = f.apply([], b); var e, g, h, i, j, k, m = 0, o = a.length, p = o - 1, q = b[0], r = n.isFunction(q); if (r || o > 1 && "string" == typeof q && !l.checkClone && ma.test(q)) return a.each(function (e) { var f = a.eq(e); r && (b[0] = q.call(this, e, f.html())), ua(f, b, c, d) }); if (o && (e = ca(b, a[0].ownerDocument, !1, a, d), g = e.firstChild, 1 === e.childNodes.length && (e = g), g || d)) { for (h = n.map(_(e, "script"), qa), i = h.length; o > m; m++)j = e, m !== p && (j = n.clone(j, !0, !0), i && n.merge(h, _(j, "script"))), c.call(a[m], j, m); if (i) for (k = h[h.length - 1].ownerDocument, n.map(h, ra), m = 0; i > m; m++)j = h[m], Z.test(j.type || "") && !N.access(j, "globalEval") && n.contains(k, j) && (j.src ? n._evalUrl && n._evalUrl(j.src) : n.globalEval(j.textContent.replace(oa, ""))) } return a } function va(a, b, c) { for (var d, e = b ? n.filter(b, a) : a, f = 0; null != (d = e[f]); f++)c || 1 !== d.nodeType || n.cleanData(_(d)), d.parentNode && (c && n.contains(d.ownerDocument, d) && aa(_(d, "script")), d.parentNode.removeChild(d)); return a } n.extend({ htmlPrefilter: function (a) { return a.replace(ka, "<$1></$2>") }, clone: function (a, b, c) { var d, e, f, g, h = a.cloneNode(!0), i = n.contains(a.ownerDocument, a); if (!(l.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || n.isXMLDoc(a))) for (g = _(h), f = _(a), d = 0, e = f.length; e > d; d++)ta(f[d], g[d]); if (b) if (c) for (f = f || _(a), g = g || _(h), d = 0, e = f.length; e > d; d++)sa(f[d], g[d]); else sa(a, h); return g = _(h, "script"), g.length > 0 && aa(g, !i && _(a, "script")), h }, cleanData: function (a) { for (var b, c, d, e = n.event.special, f = 0; void 0 !== (c = a[f]); f++)if (L(c)) { if (b = c[N.expando]) { if (b.events) for (d in b.events) e[d] ? n.event.remove(c, d) : n.removeEvent(c, d, b.handle); c[N.expando] = void 0 } c[O.expando] && (c[O.expando] = void 0) } } }), n.fn.extend({ domManip: ua, detach: function (a) { return va(this, a, !0) }, remove: function (a) { return va(this, a) }, text: function (a) { return K(this, function (a) { return void 0 === a ? n.text(this) : this.empty().each(function () { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = a) }) }, null, a, arguments.length) }, append: function () { return ua(this, arguments, function (a) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var b = pa(this, a); b.appendChild(a) } }) }, prepend: function () { return ua(this, arguments, function (a) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var b = pa(this, a); b.insertBefore(a, b.firstChild) } }) }, before: function () { return ua(this, arguments, function (a) { this.parentNode && this.parentNode.insertBefore(a, this) }) }, after: function () { return ua(this, arguments, function (a) { this.parentNode && this.parentNode.insertBefore(a, this.nextSibling) }) }, empty: function () { for (var a, b = 0; null != (a = this[b]); b++)1 === a.nodeType && (n.cleanData(_(a, !1)), a.textContent = ""); return this }, clone: function (a, b) { return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function () { return n.clone(this, a, b) }) }, html: function (a) { return K(this, function (a) { var b = this[0] || {}, c = 0, d = this.length; if (void 0 === a && 1 === b.nodeType) return b.innerHTML; if ("string" == typeof a && !la.test(a) && !$[(Y.exec(a) || ["", ""])[1].toLowerCase()]) { a = n.htmlPrefilter(a); try { for (; d > c; c++)b = this[c] || {}, 1 === b.nodeType && (n.cleanData(_(b, !1)), b.innerHTML = a); b = 0 } catch (e) { } } b && this.empty().append(a) }, null, a, arguments.length) }, replaceWith: function () { var a = []; return ua(this, arguments, function (b) { var c = this.parentNode; n.inArray(this, a) < 0 && (n.cleanData(_(this)), c && c.replaceChild(b, this)) }, a) } }), n.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function (a, b) { n.fn[a] = function (a) { for (var c, d = [], e = n(a), f = e.length - 1, h = 0; f >= h; h++)c = h === f ? this : this.clone(!0), n(e[h])[b](c), g.apply(d, c.get()); return this.pushStack(d) } }); var wa, xa = { HTML: "block", BODY: "block" }; function ya(a, b) { var c = n(b.createElement(a)).appendTo(b.body), d = n.css(c[0], "display"); return c.detach(), d } function za(a) { var b = d, c = xa[a]; return c || (c = ya(a, b), "none" !== c && c || (wa = (wa || n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement), b = wa[0].contentDocument, b.write(), b.close(), c = ya(a, b), wa.detach()), xa[a] = c), c } var Aa = /^margin/, Ba = new RegExp("^(" + S + ")(?!px)[a-z%]+$", "i"), Ca = function (b) { var c = b.ownerDocument.defaultView; return c && c.opener || (c = a), c.getComputedStyle(b) }, Da = function (a, b, c, d) { var e, f, g = {}; for (f in b) g[f] = a.style[f], a.style[f] = b[f]; e = c.apply(a, d || []); for (f in b) a.style[f] = g[f]; return e }, Ea = d.documentElement; !function () { var b, c, e, f, g = d.createElement("div"), h = d.createElement("div"); if (h.style) { h.style.backgroundClip = "content-box", h.cloneNode(!0).style.backgroundClip = "", l.clearCloneStyle = "content-box" === h.style.backgroundClip, g.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", g.appendChild(h); function i() { h.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", h.innerHTML = "", Ea.appendChild(g); var d = a.getComputedStyle(h); b = "1%" !== d.top, f = "2px" === d.marginLeft, c = "4px" === d.width, h.style.marginRight = "50%", e = "4px" === d.marginRight, Ea.removeChild(g) } n.extend(l, { pixelPosition: function () { return i(), b }, boxSizingReliable: function () { return null == c && i(), c }, pixelMarginRight: function () { return null == c && i(), e }, reliableMarginLeft: function () { return null == c && i(), f }, reliableMarginRight: function () { var b, c = h.appendChild(d.createElement("div")); return c.style.cssText = h.style.cssText = "-webkit-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", c.style.marginRight = c.style.width = "0", h.style.width = "1px", Ea.appendChild(g), b = !parseFloat(a.getComputedStyle(c).marginRight), Ea.removeChild(g), h.removeChild(c), b } }) } }(); function Fa(a, b, c) { var d, e, f, g, h = a.style; return c = c || Ca(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, "" !== g && void 0 !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), c && !l.pixelMarginRight() && Ba.test(g) && Aa.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f), void 0 !== g ? g + "" : g } function Ga(a, b) { return { get: function () { return a() ? void delete this.get : (this.get = b).apply(this, arguments) } } } var Ha = /^(none|table(?!-c[ea]).+)/, Ia = { position: "absolute", visibility: "hidden", display: "block" }, Ja = { letterSpacing: "0", fontWeight: "400" }, Ka = ["Webkit", "O", "Moz", "ms"], La = d.createElement("div").style; function Ma(a) { if (a in La) return a; var b = a[0].toUpperCase() + a.slice(1), c = Ka.length; while (c--) if (a = Ka[c] + b, a in La) return a } function Na(a, b, c) { var d = T.exec(b); return d ? Math.max(0, d[2] - (c || 0)) + (d[3] || "px") : b } function Oa(a, b, c, d, e) { for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2)"margin" === c && (g += n.css(a, c + U[f], !0, e)), d ? ("content" === c && (g -= n.css(a, "padding" + U[f], !0, e)), "margin" !== c && (g -= n.css(a, "border" + U[f] + "Width", !0, e))) : (g += n.css(a, "padding" + U[f], !0, e), "padding" !== c && (g += n.css(a, "border" + U[f] + "Width", !0, e))); return g } function Pa(a, b, c) { var d = !0, e = "width" === b ? a.offsetWidth : a.offsetHeight, f = Ca(a), g = "border-box" === n.css(a, "boxSizing", !1, f); if (0 >= e || null == e) { if (e = Fa(a, b, f), (0 > e || null == e) && (e = a.style[b]), Ba.test(e)) return e; d = g && (l.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0 } return e + Oa(a, b, c || (g ? "border" : "content"), d, f) + "px" } function Qa(a, b) { for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++)d = a[g], d.style && (f[g] = N.get(d, "olddisplay"), c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && V(d) && (f[g] = N.access(d, "olddisplay", za(d.nodeName)))) : (e = V(d), "none" === c && e || N.set(d, "olddisplay", e ? c : n.css(d, "display")))); for (g = 0; h > g; g++)d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none")); return a } n.extend({ cssHooks: { opacity: { get: function (a, b) { if (b) { var c = Fa(a, "opacity"); return "" === c ? "1" : c } } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: { "float": "cssFloat" }, style: function (a, b, c, d) { if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) { var e, f, g, h = n.camelCase(b), i = a.style; return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c ? g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c, "string" === f && (e = T.exec(c)) && e[1] && (c = W(a, b, e), f = "number"), null != c && c === c && ("number" === f && (c += e && e[3] || (n.cssNumber[h] ? "" : "px")), l.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), g && "set" in g && void 0 === (c = g.set(a, c, d)) || (i[b] = c)), void 0) } }, css: function (a, b, c, d) { var e, f, g, h = n.camelCase(b); return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], g && "get" in g && (e = g.get(a, !0, c)), void 0 === e && (e = Fa(a, b, d)), "normal" === e && b in Ja && (e = Ja[b]), "" === c || c ? (f = parseFloat(e), c === !0 || isFinite(f) ? f || 0 : e) : e } }), n.each(["height", "width"], function (a, b) { n.cssHooks[b] = { get: function (a, c, d) { return c ? Ha.test(n.css(a, "display")) && 0 === a.offsetWidth ? Da(a, Ia, function () { return Pa(a, b, d) }) : Pa(a, b, d) : void 0 }, set: function (a, c, d) { var e, f = d && Ca(a), g = d && Oa(a, b, d, "border-box" === n.css(a, "boxSizing", !1, f), f); return g && (e = T.exec(c)) && "px" !== (e[3] || "px") && (a.style[b] = c, c = n.css(a, b)), Na(a, c, g) } } }), n.cssHooks.marginLeft = Ga(l.reliableMarginLeft, function (a, b) { return b ? (parseFloat(Fa(a, "marginLeft")) || a.getBoundingClientRect().left - Da(a, { marginLeft: 0 }, function () { return a.getBoundingClientRect().left })) + "px" : void 0 }), n.cssHooks.marginRight = Ga(l.reliableMarginRight, function (a, b) { return b ? Da(a, { display: "inline-block" }, Fa, [a, "marginRight"]) : void 0 }), n.each({ margin: "", padding: "", border: "Width" }, function (a, b) { n.cssHooks[a + b] = { expand: function (c) { for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; 4 > d; d++)e[a + U[d] + b] = f[d] || f[d - 2] || f[0]; return e } }, Aa.test(a) || (n.cssHooks[a + b].set = Na) }), n.fn.extend({ css: function (a, b) { return K(this, function (a, b, c) { var d, e, f = {}, g = 0; if (n.isArray(b)) { for (d = Ca(a), e = b.length; e > g; g++)f[b[g]] = n.css(a, b[g], !1, d); return f } return void 0 !== c ? n.style(a, b, c) : n.css(a, b) }, a, b, arguments.length > 1) }, show: function () { return Qa(this, !0) }, hide: function () { return Qa(this) }, toggle: function (a) { return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function () { V(this) ? n(this).show() : n(this).hide() }) } }); function Ra(a, b, c, d, e) { return new Ra.prototype.init(a, b, c, d, e) } n.Tween = Ra, Ra.prototype = { constructor: Ra, init: function (a, b, c, d, e, f) { this.elem = a, this.prop = c, this.easing = e || n.easing._default, this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (n.cssNumber[c] ? "" : "px") }, cur: function () { var a = Ra.propHooks[this.prop]; return a && a.get ? a.get(this) : Ra.propHooks._default.get(this) }, run: function (a) { var b, c = Ra.propHooks[this.prop]; return this.options.duration ? this.pos = b = n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Ra.propHooks._default.set(this), this } }, Ra.prototype.init.prototype = Ra.prototype, Ra.propHooks = { _default: { get: function (a) { var b; return 1 !== a.elem.nodeType || null != a.elem[a.prop] && null == a.elem.style[a.prop] ? a.elem[a.prop] : (b = n.css(a.elem, a.prop, ""), b && "auto" !== b ? b : 0) }, set: function (a) { n.fx.step[a.prop] ? n.fx.step[a.prop](a) : 1 !== a.elem.nodeType || null == a.elem.style[n.cssProps[a.prop]] && !n.cssHooks[a.prop] ? a.elem[a.prop] = a.now : n.style(a.elem, a.prop, a.now + a.unit) } } }, Ra.propHooks.scrollTop = Ra.propHooks.scrollLeft = { set: function (a) { a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now) } }, n.easing = { linear: function (a) { return a }, swing: function (a) { return .5 - Math.cos(a * Math.PI) / 2 }, _default: "swing" }, n.fx = Ra.prototype.init, n.fx.step = {}; var Sa, Ta, Ua = /^(?:toggle|show|hide)$/, Va = /queueHooks$/; function Wa() { return a.setTimeout(function () { Sa = void 0 }), Sa = n.now() } function Xa(a, b) { var c, d = 0, e = { height: a }; for (b = b ? 1 : 0; 4 > d; d += 2 - b)c = U[d], e["margin" + c] = e["padding" + c] = a; return b && (e.opacity = e.width = a), e } function Ya(a, b, c) { for (var d, e = (_a.tweeners[b] || []).concat(_a.tweeners["*"]), f = 0, g = e.length; g > f; f++)if (d = e[f].call(c, b, a)) return d } function Za(a, b, c) { var d, e, f, g, h, i, j, k, l = this, m = {}, o = a.style, p = a.nodeType && V(a), q = N.get(a, "fxshow"); c.queue || (h = n._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () { h.unqueued || i() }), h.unqueued++, l.always(function () { l.always(function () { h.unqueued--, n.queue(a, "fx").length || h.empty.fire() }) })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = n.css(a, "display"), k = "none" === j ? N.get(a, "olddisplay") || za(a.nodeName) : j, "inline" === k && "none" === n.css(a, "float") && (o.display = "inline-block")), c.overflow && (o.overflow = "hidden", l.always(function () { o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2] })); for (d in b) if (e = b[d], Ua.exec(e)) { if (delete b[d], f = f || "toggle" === e, e === (p ? "hide" : "show")) { if ("show" !== e || !q || void 0 === q[d]) continue; p = !0 } m[d] = q && q[d] || n.style(a, d) } else j = void 0; if (n.isEmptyObject(m)) "inline" === ("none" === j ? za(a.nodeName) : j) && (o.display = j); else { q ? "hidden" in q && (p = q.hidden) : q = N.access(a, "fxshow", {}), f && (q.hidden = !p), p ? n(a).show() : l.done(function () { n(a).hide() }), l.done(function () { var b; N.remove(a, "fxshow"); for (b in m) n.style(a, b, m[b]) }); for (d in m) g = Ya(p ? q[d] : 0, d, l), d in q || (q[d] = g.start, p && (g.end = g.start, g.start = "width" === d || "height" === d ? 1 : 0)) } } function $a(a, b) { var c, d, e, f, g; for (c in a) if (d = n.camelCase(c), e = b[d], f = a[c], n.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = n.cssHooks[d], g && "expand" in g) { f = g.expand(f), delete a[d]; for (c in f) c in a || (a[c] = f[c], b[c] = e) } else b[d] = e } function _a(a, b, c) { var d, e, f = 0, g = _a.prefilters.length, h = n.Deferred().always(function () { delete i.elem }), i = function () { if (e) return !1; for (var b = Sa || Wa(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++)j.tweens[g].run(f); return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1) }, j = h.promise({ elem: a, props: n.extend({}, b), opts: n.extend(!0, { specialEasing: {}, easing: n.easing._default }, c), originalProperties: b, originalOptions: c, startTime: Sa || Wa(), duration: c.duration, tweens: [], createTween: function (b, c) { var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing); return j.tweens.push(d), d }, stop: function (b) { var c = 0, d = b ? j.tweens.length : 0; if (e) return this; for (e = !0; d > c; c++)j.tweens[c].run(1); return b ? (h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j, b])) : h.rejectWith(a, [j, b]), this } }), k = j.props; for ($a(k, j.opts.specialEasing); g > f; f++)if (d = _a.prefilters[f].call(j, a, k, j.opts)) return n.isFunction(d.stop) && (n._queueHooks(j.elem, j.opts.queue).stop = n.proxy(d.stop, d)), d; return n.map(k, Ya, j), n.isFunction(j.opts.start) && j.opts.start.call(a, j), n.fx.timer(n.extend(i, { elem: a, anim: j, queue: j.opts.queue })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always) } n.Animation = n.extend(_a, { tweeners: { "*": [function (a, b) { var c = this.createTween(a, b); return W(c.elem, a, T.exec(b), c), c }] }, tweener: function (a, b) { n.isFunction(a) ? (b = a, a = ["*"]) : a = a.match(G); for (var c, d = 0, e = a.length; e > d; d++)c = a[d], _a.tweeners[c] = _a.tweeners[c] || [], _a.tweeners[c].unshift(b) }, prefilters: [Za], prefilter: function (a, b) { b ? _a.prefilters.unshift(a) : _a.prefilters.push(a) } }), n.speed = function (a, b, c) { var d = a && "object" == typeof a ? n.extend({}, a) : { complete: c || !c && b || n.isFunction(a) && a, duration: a, easing: c && b || b && !n.isFunction(b) && b }; return d.duration = n.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default, null != d.queue && d.queue !== !0 || (d.queue = "fx"), d.old = d.complete, d.complete = function () { n.isFunction(d.old) && d.old.call(this), d.queue && n.dequeue(this, d.queue) }, d }, n.fn.extend({ fadeTo: function (a, b, c, d) { return this.filter(V).css("opacity", 0).show().end().animate({ opacity: b }, a, c, d) }, animate: function (a, b, c, d) { var e = n.isEmptyObject(a), f = n.speed(b, c, d), g = function () { var b = _a(this, n.extend({}, a), f); (e || N.get(this, "finish")) && b.stop(!0) }; return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g) }, stop: function (a, b, c) { var d = function (a) { var b = a.stop; delete a.stop, b(c) }; return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), this.each(function () { var b = !0, e = null != a && a + "queueHooks", f = n.timers, g = N.get(this); if (e) g[e] && g[e].stop && d(g[e]); else for (e in g) g[e] && g[e].stop && Va.test(e) && d(g[e]); for (e = f.length; e--;)f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1)); !b && c || n.dequeue(this, a) }) }, finish: function (a) { return a !== !1 && (a = a || "fx"), this.each(function () { var b, c = N.get(this), d = c[a + "queue"], e = c[a + "queueHooks"], f = n.timers, g = d ? d.length : 0; for (c.finish = !0, n.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;)f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1)); for (b = 0; g > b; b++)d[b] && d[b].finish && d[b].finish.call(this); delete c.finish }) } }), n.each(["toggle", "show", "hide"], function (a, b) { var c = n.fn[b]; n.fn[b] = function (a, d, e) { return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(Xa(b, !0), a, d, e) } }), n.each({ slideDown: Xa("show"), slideUp: Xa("hide"), slideToggle: Xa("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function (a, b) { n.fn[a] = function (a, c, d) { return this.animate(b, a, c, d) } }), n.timers = [], n.fx.tick = function () { var a, b = 0, c = n.timers; for (Sa = n.now(); b < c.length; b++)a = c[b], a() || c[b] !== a || c.splice(b--, 1); c.length || n.fx.stop(), Sa = void 0 }, n.fx.timer = function (a) { n.timers.push(a), a() ? n.fx.start() : n.timers.pop() }, n.fx.interval = 13, n.fx.start = function () { Ta || (Ta = a.setInterval(n.fx.tick, n.fx.interval)) }, n.fx.stop = function () { a.clearInterval(Ta), Ta = null }, n.fx.speeds = { slow: 600, fast: 200, _default: 400 }, n.fn.delay = function (b, c) { return b = n.fx ? n.fx.speeds[b] || b : b, c = c || "fx", this.queue(c, function (c, d) { var e = a.setTimeout(c, b); d.stop = function () { a.clearTimeout(e) } }) }, function () { var a = d.createElement("input"), b = d.createElement("select"), c = b.appendChild(d.createElement("option")); a.type = "checkbox", l.checkOn = "" !== a.value, l.optSelected = c.selected, b.disabled = !0, l.optDisabled = !c.disabled, a = d.createElement("input"), a.value = "t", a.type = "radio", l.radioValue = "t" === a.value }(); var ab, bb = n.expr.attrHandle; n.fn.extend({ attr: function (a, b) { return K(this, n.attr, a, b, arguments.length > 1) }, removeAttr: function (a) { return this.each(function () { n.removeAttr(this, a) }) } }), n.extend({ attr: function (a, b, c) { var d, e, f = a.nodeType; if (3 !== f && 8 !== f && 2 !== f) return "undefined" == typeof a.getAttribute ? n.prop(a, b, c) : (1 === f && n.isXMLDoc(a) || (b = b.toLowerCase(), e = n.attrHooks[b] || (n.expr.match.bool.test(b) ? ab : void 0)), void 0 !== c ? null === c ? void n.removeAttr(a, b) : e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + ""), c) : e && "get" in e && null !== (d = e.get(a, b)) ? d : (d = n.find.attr(a, b), null == d ? void 0 : d)) }, attrHooks: { type: { set: function (a, b) { if (!l.radioValue && "radio" === b && n.nodeName(a, "input")) { var c = a.value; return a.setAttribute("type", b), c && (a.value = c), b } } } }, removeAttr: function (a, b) { var c, d, e = 0, f = b && b.match(G); if (f && 1 === a.nodeType) while (c = f[e++]) d = n.propFix[c] || c, n.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c) } }), ab = { set: function (a, b, c) { return b === !1 ? n.removeAttr(a, c) : a.setAttribute(c, c), c } }, n.each(n.expr.match.bool.source.match(/\w+/g), function (a, b) { var c = bb[b] || n.find.attr; bb[b] = function (a, b, d) { var e, f; return d || (f = bb[b], bb[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, bb[b] = f), e } }); var cb = /^(?:input|select|textarea|button)$/i, db = /^(?:a|area)$/i; n.fn.extend({ prop: function (a, b) { return K(this, n.prop, a, b, arguments.length > 1) }, removeProp: function (a) { return this.each(function () { delete this[n.propFix[a] || a] }) } }), n.extend({
		prop: function (a, b, c) {
			var d, e, f = a.nodeType; if (3 !== f && 8 !== f && 2 !== f) return 1 === f && n.isXMLDoc(a) || (b = n.propFix[b] || b, e = n.propHooks[b]),
				void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b]
		}, propHooks: { tabIndex: { get: function (a) { var b = n.find.attr(a, "tabindex"); return b ? parseInt(b, 10) : cb.test(a.nodeName) || db.test(a.nodeName) && a.href ? 0 : -1 } } }, propFix: { "for": "htmlFor", "class": "className" }
	}), l.optSelected || (n.propHooks.selected = { get: function (a) { var b = a.parentNode; return b && b.parentNode && b.parentNode.selectedIndex, null }, set: function (a) { var b = a.parentNode; b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex) } }), n.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () { n.propFix[this.toLowerCase()] = this }); var eb = /[\t\r\n\f]/g; function fb(a) { return a.getAttribute && a.getAttribute("class") || "" } n.fn.extend({ addClass: function (a) { var b, c, d, e, f, g, h, i = 0; if (n.isFunction(a)) return this.each(function (b) { n(this).addClass(a.call(this, b, fb(this))) }); if ("string" == typeof a && a) { b = a.match(G) || []; while (c = this[i++]) if (e = fb(c), d = 1 === c.nodeType && (" " + e + " ").replace(eb, " ")) { g = 0; while (f = b[g++]) d.indexOf(" " + f + " ") < 0 && (d += f + " "); h = n.trim(d), e !== h && c.setAttribute("class", h) } } return this }, removeClass: function (a) { var b, c, d, e, f, g, h, i = 0; if (n.isFunction(a)) return this.each(function (b) { n(this).removeClass(a.call(this, b, fb(this))) }); if (!arguments.length) return this.attr("class", ""); if ("string" == typeof a && a) { b = a.match(G) || []; while (c = this[i++]) if (e = fb(c), d = 1 === c.nodeType && (" " + e + " ").replace(eb, " ")) { g = 0; while (f = b[g++]) while (d.indexOf(" " + f + " ") > -1) d = d.replace(" " + f + " ", " "); h = n.trim(d), e !== h && c.setAttribute("class", h) } } return this }, toggleClass: function (a, b) { var c = typeof a; return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : n.isFunction(a) ? this.each(function (c) { n(this).toggleClass(a.call(this, c, fb(this), b), b) }) : this.each(function () { var b, d, e, f; if ("string" === c) { d = 0, e = n(this), f = a.match(G) || []; while (b = f[d++]) e.hasClass(b) ? e.removeClass(b) : e.addClass(b) } else void 0 !== a && "boolean" !== c || (b = fb(this), b && N.set(this, "__className__", b), this.setAttribute && this.setAttribute("class", b || a === !1 ? "" : N.get(this, "__className__") || "")) }) }, hasClass: function (a) { var b, c, d = 0; b = " " + a + " "; while (c = this[d++]) if (1 === c.nodeType && (" " + fb(c) + " ").replace(eb, " ").indexOf(b) > -1) return !0; return !1 } }); var gb = /\r/g, hb = /[\x20\t\r\n\f]+/g; n.fn.extend({ val: function (a) { var b, c, d, e = this[0]; { if (arguments.length) return d = n.isFunction(a), this.each(function (c) { var e; 1 === this.nodeType && (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : n.isArray(e) && (e = n.map(e, function (a) { return null == a ? "" : a + "" })), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e)) }); if (e) return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(gb, "") : null == c ? "" : c) } } }), n.extend({ valHooks: { option: { get: function (a) { var b = n.find.attr(a, "value"); return null != b ? b : n.trim(n.text(a)).replace(hb, " ") } }, select: { get: function (a) { for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++)if (c = d[i], (c.selected || i === e) && (l.optDisabled ? !c.disabled : null === c.getAttribute("disabled")) && (!c.parentNode.disabled || !n.nodeName(c.parentNode, "optgroup"))) { if (b = n(c).val(), f) return b; g.push(b) } return g }, set: function (a, b) { var c, d, e = a.options, f = n.makeArray(b), g = e.length; while (g--) d = e[g], (d.selected = n.inArray(n.valHooks.option.get(d), f) > -1) && (c = !0); return c || (a.selectedIndex = -1), f } } } }), n.each(["radio", "checkbox"], function () { n.valHooks[this] = { set: function (a, b) { return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) > -1 : void 0 } }, l.checkOn || (n.valHooks[this].get = function (a) { return null === a.getAttribute("value") ? "on" : a.value }) }); var ib = /^(?:focusinfocus|focusoutblur)$/; n.extend(n.event, { trigger: function (b, c, e, f) { var g, h, i, j, l, m, o, p = [e || d], q = k.call(b, "type") ? b.type : b, r = k.call(b, "namespace") ? b.namespace.split(".") : []; if (h = i = e = e || d, 3 !== e.nodeType && 8 !== e.nodeType && !ib.test(q + n.event.triggered) && (q.indexOf(".") > -1 && (r = q.split("."), q = r.shift(), r.sort()), l = q.indexOf(":") < 0 && "on" + q, b = b[n.expando] ? b : new n.Event(q, "object" == typeof b && b), b.isTrigger = f ? 2 : 3, b.namespace = r.join("."), b.rnamespace = b.namespace ? new RegExp("(^|\\.)" + r.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = e), c = null == c ? [b] : n.makeArray(c, [b]), o = n.event.special[q] || {}, f || !o.trigger || o.trigger.apply(e, c) !== !1)) { if (!f && !o.noBubble && !n.isWindow(e)) { for (j = o.delegateType || q, ib.test(j + q) || (h = h.parentNode); h; h = h.parentNode)p.push(h), i = h; i === (e.ownerDocument || d) && p.push(i.defaultView || i.parentWindow || a) } g = 0; while ((h = p[g++]) && !b.isPropagationStopped()) b.type = g > 1 ? j : o.bindType || q, m = (N.get(h, "events") || {})[b.type] && N.get(h, "handle"), m && m.apply(h, c), m = l && h[l], m && m.apply && L(h) && (b.result = m.apply(h, c), b.result === !1 && b.preventDefault()); return b.type = q, f || b.isDefaultPrevented() || o._default && o._default.apply(p.pop(), c) !== !1 || !L(e) || l && n.isFunction(e[q]) && !n.isWindow(e) && (i = e[l], i && (e[l] = null), n.event.triggered = q, e[q](), n.event.triggered = void 0, i && (e[l] = i)), b.result } }, simulate: function (a, b, c) { var d = n.extend(new n.Event, c, { type: a, isSimulated: !0 }); n.event.trigger(d, null, b) } }), n.fn.extend({ trigger: function (a, b) { return this.each(function () { n.event.trigger(a, b, this) }) }, triggerHandler: function (a, b) { var c = this[0]; return c ? n.event.trigger(a, b, c, !0) : void 0 } }), n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (a, b) { n.fn[b] = function (a, c) { return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b) } }), n.fn.extend({ hover: function (a, b) { return this.mouseenter(a).mouseleave(b || a) } }), l.focusin = "onfocusin" in a, l.focusin || n.each({ focus: "focusin", blur: "focusout" }, function (a, b) { var c = function (a) { n.event.simulate(b, a.target, n.event.fix(a)) }; n.event.special[b] = { setup: function () { var d = this.ownerDocument || this, e = N.access(d, b); e || d.addEventListener(a, c, !0), N.access(d, b, (e || 0) + 1) }, teardown: function () { var d = this.ownerDocument || this, e = N.access(d, b) - 1; e ? N.access(d, b, e) : (d.removeEventListener(a, c, !0), N.remove(d, b)) } } }); var jb = a.location, kb = n.now(), lb = /\?/; n.parseJSON = function (a) { return JSON.parse(a + "") }, n.parseXML = function (b) { var c; if (!b || "string" != typeof b) return null; try { c = (new a.DOMParser).parseFromString(b, "text/xml") } catch (d) { c = void 0 } return c && !c.getElementsByTagName("parsererror").length || n.error("Invalid XML: " + b), c }; var mb = /#.*$/, nb = /([?&])_=[^&]*/, ob = /^(.*?):[ \t]*([^\r\n]*)$/gm, pb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, qb = /^(?:GET|HEAD)$/, rb = /^\/\//, sb = {}, tb = {}, ub = "*/".concat("*"), vb = d.createElement("a"); vb.href = jb.href; function wb(a) { return function (b, c) { "string" != typeof b && (c = b, b = "*"); var d, e = 0, f = b.toLowerCase().match(G) || []; if (n.isFunction(c)) while (d = f[e++]) "+" === d[0] ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c) } } function xb(a, b, c, d) { var e = {}, f = a === tb; function g(h) { var i; return e[h] = !0, n.each(a[h] || [], function (a, h) { var j = h(b, c, d); return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1) }), i } return g(b.dataTypes[0]) || !e["*"] && g("*") } function yb(a, b) { var c, d, e = n.ajaxSettings.flatOptions || {}; for (c in b) void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]); return d && n.extend(!0, a, d), a } function zb(a, b, c) { var d, e, f, g, h = a.contents, i = a.dataTypes; while ("*" === i[0]) i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader("Content-Type")); if (d) for (e in h) if (h[e] && h[e].test(d)) { i.unshift(e); break } if (i[0] in c) f = i[0]; else { for (e in c) { if (!i[0] || a.converters[e + " " + i[0]]) { f = e; break } g || (g = e) } f = f || g } return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0 } function Ab(a, b, c, d) { var e, f, g, h, i, j = {}, k = a.dataTypes.slice(); if (k[1]) for (g in a.converters) j[g.toLowerCase()] = a.converters[g]; f = k.shift(); while (f) if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if ("*" === f) f = i; else if ("*" !== i && i !== f) { if (g = j[i + " " + f] || j["* " + f], !g) for (e in j) if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) { g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1])); break } if (g !== !0) if (g && a["throws"]) b = g(b); else try { b = g(b) } catch (l) { return { state: "parsererror", error: g ? l : "No conversion from " + i + " to " + f } } } return { state: "success", data: b } } n.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: jb.href, type: "GET", isLocal: pb.test(jb.protocol), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": ub, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": n.parseJSON, "text xml": n.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (a, b) { return b ? yb(yb(a, n.ajaxSettings), b) : yb(n.ajaxSettings, a) }, ajaxPrefilter: wb(sb), ajaxTransport: wb(tb), ajax: function (b, c) { "object" == typeof b && (c = b, b = void 0), c = c || {}; var e, f, g, h, i, j, k, l, m = n.ajaxSetup({}, c), o = m.context || m, p = m.context && (o.nodeType || o.jquery) ? n(o) : n.event, q = n.Deferred(), r = n.Callbacks("once memory"), s = m.statusCode || {}, t = {}, u = {}, v = 0, w = "canceled", x = { readyState: 0, getResponseHeader: function (a) { var b; if (2 === v) { if (!h) { h = {}; while (b = ob.exec(g)) h[b[1].toLowerCase()] = b[2] } b = h[a.toLowerCase()] } return null == b ? null : b }, getAllResponseHeaders: function () { return 2 === v ? g : null }, setRequestHeader: function (a, b) { var c = a.toLowerCase(); return v || (a = u[c] = u[c] || a, t[a] = b), this }, overrideMimeType: function (a) { return v || (m.mimeType = a), this }, statusCode: function (a) { var b; if (a) if (2 > v) for (b in a) s[b] = [s[b], a[b]]; else x.always(a[x.status]); return this }, abort: function (a) { var b = a || w; return e && e.abort(b), z(0, b), this } }; if (q.promise(x).complete = r.add, x.success = x.done, x.error = x.fail, m.url = ((b || m.url || jb.href) + "").replace(mb, "").replace(rb, jb.protocol + "//"), m.type = c.method || c.type || m.method || m.type, m.dataTypes = n.trim(m.dataType || "*").toLowerCase().match(G) || [""], null == m.crossDomain) { j = d.createElement("a"); try { j.href = m.url, j.href = j.href, m.crossDomain = vb.protocol + "//" + vb.host != j.protocol + "//" + j.host } catch (y) { m.crossDomain = !0 } } if (m.data && m.processData && "string" != typeof m.data && (m.data = n.param(m.data, m.traditional)), xb(sb, m, c, x), 2 === v) return x; k = n.event && m.global, k && 0 === n.active++ && n.event.trigger("ajaxStart"), m.type = m.type.toUpperCase(), m.hasContent = !qb.test(m.type), f = m.url, m.hasContent || (m.data && (f = m.url += (lb.test(f) ? "&" : "?") + m.data, delete m.data), m.cache === !1 && (m.url = nb.test(f) ? f.replace(nb, "$1_=" + kb++) : f + (lb.test(f) ? "&" : "?") + "_=" + kb++)), m.ifModified && (n.lastModified[f] && x.setRequestHeader("If-Modified-Since", n.lastModified[f]), n.etag[f] && x.setRequestHeader("If-None-Match", n.etag[f])), (m.data && m.hasContent && m.contentType !== !1 || c.contentType) && x.setRequestHeader("Content-Type", m.contentType), x.setRequestHeader("Accept", m.dataTypes[0] && m.accepts[m.dataTypes[0]] ? m.accepts[m.dataTypes[0]] + ("*" !== m.dataTypes[0] ? ", " + ub + "; q=0.01" : "") : m.accepts["*"]); for (l in m.headers) x.setRequestHeader(l, m.headers[l]); if (m.beforeSend && (m.beforeSend.call(o, x, m) === !1 || 2 === v)) return x.abort(); w = "abort"; for (l in { success: 1, error: 1, complete: 1 }) x[l](m[l]); if (e = xb(tb, m, c, x)) { if (x.readyState = 1, k && p.trigger("ajaxSend", [x, m]), 2 === v) return x; m.async && m.timeout > 0 && (i = a.setTimeout(function () { x.abort("timeout") }, m.timeout)); try { v = 1, e.send(t, z) } catch (y) { if (!(2 > v)) throw y; z(-1, y) } } else z(-1, "No Transport"); function z(b, c, d, h) { var j, l, t, u, w, y = c; 2 !== v && (v = 2, i && a.clearTimeout(i), e = void 0, g = h || "", x.readyState = b > 0 ? 4 : 0, j = b >= 200 && 300 > b || 304 === b, d && (u = zb(m, x, d)), u = Ab(m, u, x, j), j ? (m.ifModified && (w = x.getResponseHeader("Last-Modified"), w && (n.lastModified[f] = w), w = x.getResponseHeader("etag"), w && (n.etag[f] = w)), 204 === b || "HEAD" === m.type ? y = "nocontent" : 304 === b ? y = "notmodified" : (y = u.state, l = u.data, t = u.error, j = !t)) : (t = y, !b && y || (y = "error", 0 > b && (b = 0))), x.status = b, x.statusText = (c || y) + "", j ? q.resolveWith(o, [l, y, x]) : q.rejectWith(o, [x, y, t]), x.statusCode(s), s = void 0, k && p.trigger(j ? "ajaxSuccess" : "ajaxError", [x, m, j ? l : t]), r.fireWith(o, [x, y]), k && (p.trigger("ajaxComplete", [x, m]), --n.active || n.event.trigger("ajaxStop"))) } return x }, getJSON: function (a, b, c) { return n.get(a, b, c, "json") }, getScript: function (a, b) { return n.get(a, void 0, b, "script") } }), n.each(["get", "post"], function (a, b) { n[b] = function (a, c, d, e) { return n.isFunction(c) && (e = e || d, d = c, c = void 0), n.ajax(n.extend({ url: a, type: b, dataType: e, data: c, success: d }, n.isPlainObject(a) && a)) } }), n._evalUrl = function (a) { return n.ajax({ url: a, type: "GET", dataType: "script", async: !1, global: !1, "throws": !0 }) }, n.fn.extend({ wrapAll: function (a) { var b; return n.isFunction(a) ? this.each(function (b) { n(this).wrapAll(a.call(this, b)) }) : (this[0] && (b = n(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function () { var a = this; while (a.firstElementChild) a = a.firstElementChild; return a }).append(this)), this) }, wrapInner: function (a) { return n.isFunction(a) ? this.each(function (b) { n(this).wrapInner(a.call(this, b)) }) : this.each(function () { var b = n(this), c = b.contents(); c.length ? c.wrapAll(a) : b.append(a) }) }, wrap: function (a) { var b = n.isFunction(a); return this.each(function (c) { n(this).wrapAll(b ? a.call(this, c) : a) }) }, unwrap: function () { return this.parent().each(function () { n.nodeName(this, "body") || n(this).replaceWith(this.childNodes) }).end() } }), n.expr.filters.hidden = function (a) { return !n.expr.filters.visible(a) }, n.expr.filters.visible = function (a) { return a.offsetWidth > 0 || a.offsetHeight > 0 || a.getClientRects().length > 0 }; var Bb = /%20/g, Cb = /\[\]$/, Db = /\r?\n/g, Eb = /^(?:submit|button|image|reset|file)$/i, Fb = /^(?:input|select|textarea|keygen)/i; function Gb(a, b, c, d) { var e; if (n.isArray(b)) n.each(b, function (b, e) { c || Cb.test(a) ? d(a, e) : Gb(a + "[" + ("object" == typeof e && null != e ? b : "") + "]", e, c, d) }); else if (c || "object" !== n.type(b)) d(a, b); else for (e in b) Gb(a + "[" + e + "]", b[e], c, d) } n.param = function (a, b) { var c, d = [], e = function (a, b) { b = n.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b) }; if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray(a) || a.jquery && !n.isPlainObject(a)) n.each(a, function () { e(this.name, this.value) }); else for (c in a) Gb(c, a[c], b, e); return d.join("&").replace(Bb, "+") }, n.fn.extend({ serialize: function () { return n.param(this.serializeArray()) }, serializeArray: function () { return this.map(function () { var a = n.prop(this, "elements"); return a ? n.makeArray(a) : this }).filter(function () { var a = this.type; return this.name && !n(this).is(":disabled") && Fb.test(this.nodeName) && !Eb.test(a) && (this.checked || !X.test(a)) }).map(function (a, b) { var c = n(this).val(); return null == c ? null : n.isArray(c) ? n.map(c, function (a) { return { name: b.name, value: a.replace(Db, "\r\n") } }) : { name: b.name, value: c.replace(Db, "\r\n") } }).get() } }), n.ajaxSettings.xhr = function () { try { return new a.XMLHttpRequest } catch (b) { } }; var Hb = { 0: 200, 1223: 204 }, Ib = n.ajaxSettings.xhr(); l.cors = !!Ib && "withCredentials" in Ib, l.ajax = Ib = !!Ib, n.ajaxTransport(function (b) { var c, d; return l.cors || Ib && !b.crossDomain ? { send: function (e, f) { var g, h = b.xhr(); if (h.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields) for (g in b.xhrFields) h[g] = b.xhrFields[g]; b.mimeType && h.overrideMimeType && h.overrideMimeType(b.mimeType), b.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"); for (g in e) h.setRequestHeader(g, e[g]); c = function (a) { return function () { c && (c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null, "abort" === a ? h.abort() : "error" === a ? "number" != typeof h.status ? f(0, "error") : f(h.status, h.statusText) : f(Hb[h.status] || h.status, h.statusText, "text" !== (h.responseType || "text") || "string" != typeof h.responseText ? { binary: h.response } : { text: h.responseText }, h.getAllResponseHeaders())) } }, h.onload = c(), d = h.onerror = c("error"), void 0 !== h.onabort ? h.onabort = d : h.onreadystatechange = function () { 4 === h.readyState && a.setTimeout(function () { c && d() }) }, c = c("abort"); try { h.send(b.hasContent && b.data || null) } catch (i) { if (c) throw i } }, abort: function () { c && c() } } : void 0 }), n.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function (a) { return n.globalEval(a), a } } }), n.ajaxPrefilter("script", function (a) { void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET") }), n.ajaxTransport("script", function (a) { if (a.crossDomain) { var b, c; return { send: function (e, f) { b = n("<script>").prop({ charset: a.scriptCharset, src: a.url }).on("load error", c = function (a) { b.remove(), c = null, a && f("error" === a.type ? 404 : 200, a.type) }), d.head.appendChild(b[0]) }, abort: function () { c && c() } } } }); var Jb = [], Kb = /(=)\?(?=&|$)|\?\?/; n.ajaxSetup({ jsonp: "callback", jsonpCallback: function () { var a = Jb.pop() || n.expando + "_" + kb++; return this[a] = !0, a } }), n.ajaxPrefilter("json jsonp", function (b, c, d) { var e, f, g, h = b.jsonp !== !1 && (Kb.test(b.url) ? "url" : "string" == typeof b.data && 0 === (b.contentType || "").indexOf("application/x-www-form-urlencoded") && Kb.test(b.data) && "data"); return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Kb, "$1" + e) : b.jsonp !== !1 && (b.url += (lb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function () { return g || n.error(e + " was not called"), g[0] }, b.dataTypes[0] = "json", f = a[e], a[e] = function () { g = arguments }, d.always(function () { void 0 === f ? n(a).removeProp(e) : a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Jb.push(e)), g && n.isFunction(f) && f(g[0]), g = f = void 0 }), "script") : void 0 }), n.parseHTML = function (a, b, c) { if (!a || "string" != typeof a) return null; "boolean" == typeof b && (c = b, b = !1), b = b || d; var e = x.exec(a), f = !c && []; return e ? [b.createElement(e[1])] : (e = ca([a], b, f), f && f.length && n(f).remove(), n.merge([], e.childNodes)) }; var Lb = n.fn.load; n.fn.load = function (a, b, c) { if ("string" != typeof a && Lb) return Lb.apply(this, arguments); var d, e, f, g = this, h = a.indexOf(" "); return h > -1 && (d = n.trim(a.slice(h)), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b && "object" == typeof b && (e = "POST"), g.length > 0 && n.ajax({ url: a, type: e || "GET", dataType: "html", data: b }).done(function (a) { f = arguments, g.html(d ? n("<div>").append(n.parseHTML(a)).find(d) : a) }).always(c && function (a, b) { g.each(function () { c.apply(this, f || [a.responseText, b, a]) }) }), this }, n.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (a, b) { n.fn[b] = function (a) { return this.on(b, a) } }), n.expr.filters.animated = function (a) { return n.grep(n.timers, function (b) { return a === b.elem }).length }; function Mb(a) { return n.isWindow(a) ? a : 9 === a.nodeType && a.defaultView } n.offset = { setOffset: function (a, b, c) { var d, e, f, g, h, i, j, k = n.css(a, "position"), l = n(a), m = {}; "static" === k && (a.style.position = "relative"), h = l.offset(), f = n.css(a, "top"), i = n.css(a, "left"), j = ("absolute" === k || "fixed" === k) && (f + i).indexOf("auto") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), n.isFunction(b) && (b = b.call(a, c, n.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), "using" in b ? b.using.call(a, m) : l.css(m) } }, n.fn.extend({ offset: function (a) { if (arguments.length) return void 0 === a ? this : this.each(function (b) { n.offset.setOffset(this, a, b) }); var b, c, d = this[0], e = { top: 0, left: 0 }, f = d && d.ownerDocument; if (f) return b = f.documentElement, n.contains(b, d) ? (e = d.getBoundingClientRect(), c = Mb(f), { top: e.top + c.pageYOffset - b.clientTop, left: e.left + c.pageXOffset - b.clientLeft }) : e }, position: function () { if (this[0]) { var a, b, c = this[0], d = { top: 0, left: 0 }; return "fixed" === n.css(c, "position") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), n.nodeName(a[0], "html") || (d = a.offset()), d.top += n.css(a[0], "borderTopWidth", !0), d.left += n.css(a[0], "borderLeftWidth", !0)), { top: b.top - d.top - n.css(c, "marginTop", !0), left: b.left - d.left - n.css(c, "marginLeft", !0) } } }, offsetParent: function () { return this.map(function () { var a = this.offsetParent; while (a && "static" === n.css(a, "position")) a = a.offsetParent; return a || Ea }) } }), n.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (a, b) { var c = "pageYOffset" === b; n.fn[a] = function (d) { return K(this, function (a, d, e) { var f = Mb(a); return void 0 === e ? f ? f[b] : a[d] : void (f ? f.scrollTo(c ? f.pageXOffset : e, c ? e : f.pageYOffset) : a[d] = e) }, a, d, arguments.length) } }), n.each(["top", "left"], function (a, b) { n.cssHooks[b] = Ga(l.pixelPosition, function (a, c) { return c ? (c = Fa(a, b), Ba.test(c) ? n(a).position()[b] + "px" : c) : void 0 }) }), n.each({ Height: "height", Width: "width" }, function (a, b) { n.each({ padding: "inner" + a, content: b, "": "outer" + a }, function (c, d) { n.fn[d] = function (d, e) { var f = arguments.length && (c || "boolean" != typeof d), g = c || (d === !0 || e === !0 ? "margin" : "border"); return K(this, function (b, c, d) { var e; return n.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g) }, b, f ? d : void 0, f, null) } }) }), n.fn.extend({ bind: function (a, b, c) { return this.on(a, null, b, c) }, unbind: function (a, b) { return this.off(a, null, b) }, delegate: function (a, b, c, d) { return this.on(b, a, c, d) }, undelegate: function (a, b, c) { return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c) }, size: function () { return this.length } }), n.fn.andSelf = n.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function () { return n }); var Nb = a.jQuery, Ob = a.$; return n.noConflict = function (b) { return a.$ === n && (a.$ = Ob), b && a.jQuery === n && (a.jQuery = Nb), n }, b || (a.jQuery = a.$ = n), n
});

(function () {
	//Add html elements
	//canvas_test
	var _test_canvas = document.createElement("div");
	_test_canvas.setAttribute('id', "test_canvases");
	_test_canvas.setAttribute('style', 'display: none;');
	document.body.appendChild(_test_canvas);

	//flash test element
	var _test_flash = document.createElement("object");
	_test_flash.setAttribute('id', "fontListSWF");
	_test_flash.setAttribute('name', "fontListSWF");
	_test_flash.setAttribute('type', "application/x-shockwave-flash");
	_test_flash.setAttribute('data', "static/assets/FontList.swf");
	_test_flash.setAttribute('style', 'display: none;');
	document.body.appendChild(_test_flash);

	var _test_flash_param = document.createElement("param");
	_test_flash_param.setAttribute('name', "movie");
	_test_flash_param.setAttribute('value', "FontList.swf");
	document.getElementById("fontListSWF").appendChild(_test_flash_param);

	var _test_flash_embed = document.createElement("embed");
	_test_flash_embed.setAttribute('src', "static/assets/FontList.swf");
	_test_flash_embed.setAttribute('width', "0");
	_test_flash_embed.setAttribute('height', "0");
	document.getElementById("fontListSWF").appendChild(_test_flash_embed);

}).call(this);

(function () {
	var _GP = {};
	var value = 0;
	var pos = 0;
	function progress(value) {
		if (value == 100) {
			$('progress').addClass("hidden");
			$('#hint98').addClass("hidden");
			$('#instruction').addClass("appear");
			return;
		}
		// run counter
		$('progress').val(value);
		pos = 1 - value / 100;
		// update background
		$('progress').prop('style', 'background-position: 0 ' + pos + 'em;');

		if (value == 86) {
			$('#hint98').addClass("appear");
		}
	}



	/**
	 * JavaScript code to detect available availability of a
	 * particular font in a browser using JavaScript and CSS.
	 *
	 * Author : Lalit Patel
	 * Website: http://www.lalit.org/lab/javascript-css-font-detect/
	 * License: Apache Software License 2.0
	 *          http://www.apache.org/licenses/LICENSE-2.0
	 * Version: 0.15 (21 Sep 2009)
	 *          Changed comparision font to default from sans-default-default,
	 *          as in FF3.0 font of child element didn't fallback
	 *          to parent element if the font is missing.
	 * Version: 0.2 (04 Mar 2012)
	 *          Comparing font against all the 3 generic font families ie,
	 *          'monospace', 'sans-serif' and 'sans'. If it doesn't match all 3
	 *          then that font is 100% not available in the system
	 * Version: 0.3 (24 Mar 2012)
	 *          Replaced sans with serif in the list of baseFonts
	 */

	/**
	 * Usage: d = new Detector();
	 *        d.detect('font name');
	 */
	var fontDetector = function () { //Namespace Required
		// a font will be compared against all the three default fonts.
		// and if it doesn't match all 3 then that font is not available.
		var baseFonts = ['monospace', 'sans-serif', 'serif'];

		//we use m or w because these two characters take up the maximum width.
		// And we use a LLi so that the same matching fonts can get separated
		var testString = "mmmmmmmmmmlli";

		//we test using 72px font size, we may use any size. I guess larger the better.
		var testSize = '72px';

		var h = document.getElementsByTagName("body")[0];

		// create a SPAN in the document to get the width of the text we use to test
		var s = document.createElement("span");
		s.style.fontSize = testSize;
		s.innerHTML = testString;
		var defaultWidth = {};
		var defaultHeight = {};
		for (var index in baseFonts) {
			//get the default width for the three base fonts
			s.style.fontFamily = baseFonts[index];
			h.appendChild(s);
			defaultWidth[baseFonts[index]] = s.offsetWidth; //width for the default font
			defaultHeight[baseFonts[index]] = s.offsetHeight; //height for the defualt font
			h.removeChild(s);
		}

		function detect(font) {
			var detected = false;
			for (var index in baseFonts) {
				s.style.fontFamily = font + ',' + baseFonts[index]; // name of the font along with the base font for fallback.
				h.appendChild(s);
				var matched = (s.offsetWidth != defaultWidth[baseFonts[index]] || s.offsetHeight != defaultHeight[baseFonts[index]]);
				h.removeChild(s);
				detected = detected || matched;
			}
			return detected;
		}

		this.detect = detect;
	};


	// Generated by CoffeeScript 1.10.0

	/*
	This test renders to a canvas a whole bunch of words in 36 different
	alphabets to test which alphabets the user has installed on their computer.
	The words are kept in the 2D array called codes in their UTF-16 format
	to ensure that they aren't interpreted before it is time to render them
	The 37th string in codes is a single character that we are hoping will
	always show up as a cannot be displayed character.
	 *
	While wether the alphabet can be displayed or not is deteremined by the
	operating system, the symbol used to represent cannot be displayed is
	deteremined by the browser.  However, it does seem like it is always some
	sort of box
	 */

	(function () {
		var root, safeParseJSON;
		_GP.rend = {};

		root = typeof exports !== "undefined" && exports !== null ? exports : this;

		safeParseJSON = function (s) {
			var error;
			try {
				return JSON.parse(s);
			} catch (error) {
				return false;
			}
		};

		window.raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.oRequestAnimationFrame;

		window.__gpcaf = window.cancelAnimationFrame || window.mozcancelAnimationFrame || window.webkitcancelAnimationFrame || window.ocancelAnimationFrame;

		_GP.LanguageDector = (function () {
			function LanguageDector() {
				this.codes = safeParseJSON("[[76,97,116,105,110], [27721,23383], [1575,1604,1593,1585,1576,1610,1577], [2342,2375,2357,2344,2366,2327,2352,2368], [1050,1080,1088,1080,1083,1080,1094,1072], [2476,2494,2434,2482,2494,32,47,32,2437,2488,2478,2496,2479,2492,2494], [20206,21517], [2583,2625,2608,2606,2625,2582,2624], [43415,43438], [54620,44544], [3108,3142,3122,3137,3095,3137], [2980,2990,3007,2996,3021], [3374,3378,3375,3390,3379,3330], [4121,4156,4116,4154,4121,4140], [3652,3607,3618], [7070,7077,7060,7082,7059], [3221,3240,3277,3240,3233], [2711,2753,2716,2736,2750,2724,2752], [3749,3762,3751], [2825,2852,2893,2837,2867], [4877,4821,4829], [3523,3538,3458,3524,3517], [1344,1377,1397,1400,1409], [6017,6098,6040,6082,6042], [917,955,955,951,957,953,954,972], [6674,6682,6664,6673], [1488,1500,1508,1489,1497,1514], [3926,3964,3921,3851], [4325,4304,4320,4311,4323,4314,4312], [41352,41760], [6190,6179,6185,6189,6179,6191], [11612,11593,11580,11593,11599,11568,11606], [1808,1834,1825,1821,1808], [1931,1960,1928,1964,1920,1960], [5123,5316,5251,5198,5200,5222], [5091,5043,5033], [55295]]");
				this.fontSize = 20;
				this.extraHeigth = 15;
				this.height = this.fontSize + this.extraHeigth;
				this.width = 100;
				this.canvas = $("<canvas height='" + this.height + "' width='" + this.width + "'/>").appendTo($('#test_canvases'));
				this.ctx = this.canvas[0].getContext('2d');
				this.results = [];
			}

			LanguageDector.prototype.begin = function (cb) {
				var tester;
				this.cb = cb;
				tester = (function (_this) {
					return function (index) {
						var c, i, len, ref, text;
						if (index === _this.codes.length) {
							//console.log("Lang done");
							_GP.sender.postLangsDetected(_this.results);
							return _this.cb();
						} else {
							text = "";
							ref = _this.codes[index];
							for (i = 0, len = ref.length; i < len; i++) {
								c = ref[i];
								text += String.fromCharCode(c);
							}
							_this.ctx.fillStyle = "white";
							_this.ctx.fillRect(0, 0, _this.width, _this.height);
							_this.ctx.fillStyle = "black";
							_this.ctx.font = _this.fontSize + "px sans-serif";
							_this.ctx.fillText(text, 5, _this.height - _this.extraHeigth / 2.0);
							_this.results.push({
								w: _this.width,
								h: _this.height,
								pixels: _GP.stringify(_this.ctx.getImageData(0, 0, _this.width, _this.height).data)
							});
							return raf(function () {
								return tester(index + 1);
							});
						}
					};
				})(this);
				return raf(function () {
					return tester(0);
				});
			};

			return LanguageDector;

		})();

	}).call(this);

	// Generated by CoffeeScript 1.10.0
	(function () {
		$(function () {
			return $("<div id='ad'/>").appendTo($('body'));
		});

	}).call(this);

	/*!
	 * JavaScript Cookie v2.1.2
	 * https://github.com/js-cookie/js-cookie
	 *
	 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
	 * Released under the MIT license
	 */
	; (function (factory) {
		if (typeof define === 'function' && define.amd) {
			define(factory);
		} else if (typeof exports === 'object') {
			module.exports = factory();
		} else {
			var OldCookies = window.Cookies;
			var api = window.Cookies = factory();
			api.noConflict = function () {
				window.Cookies = OldCookies;
				return api;
			};
		}
	}(function () {
		function extend() {
			var i = 0;
			var result = {};
			for (; i < arguments.length; i++) {
				var attributes = arguments[i];
				for (var key in attributes) {
					result[key] = attributes[key];
				}
			}
			return result;
		}

		function init(converter) {
			function api(key, value, attributes) {
				var result;
				if (typeof document === 'undefined') {
					return;
				}

				// Write

				if (arguments.length > 1) {
					attributes = extend({
						path: '/'
					}, api.defaults, attributes);

					if (typeof attributes.expires === 'number') {
						var expires = new Date();
						expires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);
						attributes.expires = expires;
					}

					try {
						result = JSON.stringify(value);
						if (/^[\{\[]/.test(result)) {
							value = result;
						}
					} catch (e) { }

					if (!converter.write) {
						value = encodeURIComponent(String(value))
							.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
					} else {
						value = converter.write(value, key);
					}

					key = encodeURIComponent(String(key));
					key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);
					key = key.replace(/[\(\)]/g, escape);

					return (document.cookie = [
						key, '=', value,
						attributes.expires && '; expires=' + attributes.expires.toUTCString(), // use expires attribute, max-age is not supported by IE
						attributes.path && '; path=' + attributes.path,
						attributes.domain && '; domain=' + attributes.domain,
						attributes.secure ? '; secure' : ''
					].join(''));
				}

				// Read

				if (!key) {
					result = {};
				}

				// To prevent the for loop in the first place assign an empty array
				// in case there are no cookies at all. Also prevents odd result when
				// calling "get()"
				var cookies = document.cookie ? document.cookie.split('; ') : [];
				var rdecode = /(%[0-9A-Z]{2})+/g;
				var i = 0;

				for (; i < cookies.length; i++) {
					var parts = cookies[i].split('=');
					var cookie = parts.slice(1).join('=');

					if (cookie.charAt(0) === '"') {
						cookie = cookie.slice(1, -1);
					}

					try {
						var name = parts[0].replace(rdecode, decodeURIComponent);
						cookie = converter.read ?
							converter.read(cookie, name) : converter(cookie, name) ||
							cookie.replace(rdecode, decodeURIComponent);

						if (this.json) {
							try {
								cookie = JSON.parse(cookie);
							} catch (e) { }
						}

						if (key === name) {
							result = cookie;
							break;
						}

						if (!key) {
							result[name] = cookie;
						}
					} catch (e) { }
				}

				return result;
			}

			api.set = api;
			api.get = function (key) {
				return api(key);
			};
			api.getJSON = function () {
				return api.apply({
					json: true
				}, [].slice.call(arguments));
			};
			api.defaults = {};

			api.remove = function (key, attributes) {
				api(key, '', extend(attributes, {
					expires: -1
				}));
			};

			api.withConverter = init;

			return api;
		}

		return init(function () { });
	}));
	// Load a text resource from a file over the network


	_GP.getCanvas = function (canvasName) {
		var canvas = $('#' + canvasName);
		if (!canvas[0]) {
			$('#test_canvas').append("<canvas id='" + canvasName + "' width='256' height='256'></canvas>");
		}
		return canvas = $('#' + canvasName)[0];
	}

	_GP.getGLAA = function (canvas) {
		var gl = null;
		for (var i = 0; i < 4; ++i) {
			gl = canvas.getContext(
				["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"][i], {
				antialias: true,
				preserveDrawingBuffer: true,
				willReadFrequently: false,
				depth: true
			});
			if (gl)
				break;
		}

		if (!gl) {
			//alert('Your browser does not support WebGL');
		}
		return gl;
	}

	_GP.getGL = function (canvas) {
		var gl = null;
		for (var i = 0; i < 4; ++i) {
			gl = canvas.getContext(
				["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"][i], {
				antialias: false,
				preserveDrawingBuffer: true,
				willReadFrequently: false,
				depth: true
			});
			if (gl)
				break;
		}

		if (!gl) {
			//alert('Your browser does not support WebGL');
		}
		return gl;
	}

	_GP.computeKernelWeight = function (kernel) {
		var weight = kernel.reduce(function (prev, curr) { return prev + curr; });
		return weight <= 0 ? 1 : weight;
	}

	var loadTextResource = function (url, callback, caller) { //Namespace required
		var request = new XMLHttpRequest();
		request.open('GET', url + '?please-dont-cache=' + Math.random(), true);
		request.onload = function () {
			if (request.status < 200 || request.status > 299) {
				callback('Error: HTTP Status ' + request.status + ' on resource ' + url);
			} else {
				callback(null, request.responseText, caller);
			}
		};
		request.send();
	};

	var loadImage = function (url, callback, caller) { //Namespace Required
		var image = new Image();
		image.onload = function () { callback(null, image, caller); };
		image.src = url;
	};

	var loadJSONResource = function (url, callback, caller) { //Namespace Required
		loadTextResource(url, function (err, result, caller) {
			if (err) {
				callback(err);
			} else {
				try {
					callback(null, JSON.parse(result), caller);
				} catch (e) {
					callback(e);
				}
			}
		}, caller);
	};

	/**
	 * @fileoverview gl-matrix - High performance matrix and vector operations
	 * @author Brandon Jones
	 * @author Colin MacKenzie IV
	 * @version 2.3.2
	 */

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */

	(function webpackUniversalModuleDefinition(root, factory) {
		if (typeof exports === 'object' && typeof module === 'object')
			module.exports = factory();
		else if (typeof define === 'function' && define.amd)
			define(factory);
		else {
			var a = factory();
			for (var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
		}
	})(this, function () {
		return /******/ (function (modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if (installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
					/******/
};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
				/******/
}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
			/******/
})
/************************************************************************/
/******/([
/* 0 */
/***/ function (module, exports, __webpack_require__) {

				/**
				 * @fileoverview gl-matrix - High performance matrix and vector operations
				 * @author Brandon Jones
				 * @author Colin MacKenzie IV
				 * @version 2.3.2
				 */

				/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
			
				Permission is hereby granted, free of charge, to any person obtaining a copy
				of this software and associated documentation files (the "Software"), to deal
				in the Software without restriction, including without limitation the rights
				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
				copies of the Software, and to permit persons to whom the Software is
				furnished to do so, subject to the following conditions:
			
				The above copyright notice and this permission notice shall be included in
				all copies or substantial portions of the Software.
			
				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
				THE SOFTWARE. */
				// END HEADER

				_GP.glMatrix = __webpack_require__(1);
				_GP.mat2 = __webpack_require__(2);
				_GP.mat2d = __webpack_require__(3);
				_GP.mat3 = __webpack_require__(4);
				_GP.mat4 = __webpack_require__(5);
				_GP.quat = __webpack_require__(6);
				_GP.vec2 = __webpack_require__(9);
				_GP.vec3 = __webpack_require__(7);
				_GP.vec4 = __webpack_require__(8);

				/***/
},
/* 1 */
/***/ function (module, exports) {

				/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
			
				Permission is hereby granted, free of charge, to any person obtaining a copy
				of this software and associated documentation files (the "Software"), to deal
				in the Software without restriction, including without limitation the rights
				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
				copies of the Software, and to permit persons to whom the Software is
				furnished to do so, subject to the following conditions:
			
				The above copyright notice and this permission notice shall be included in
				all copies or substantial portions of the Software.
			
				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
				THE SOFTWARE. */

				/**
				 * @class Common utilities
				 * @name glMatrix
				 */
				_GP.glMatrix = {};

				// Configuration Constants
				_GP.glMatrix.EPSILON = 0.000001;
				_GP.glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
				_GP.glMatrix.RANDOM = Math.random;
				_GP.glMatrix.ENABLE_SIMD = false;

				// Capability detection
				_GP.glMatrix.SIMD_AVAILABLE = (_GP.glMatrix.ARRAY_TYPE === Float32Array) && ('SIMD' in this);
				_GP.glMatrix.USE_SIMD = _GP.glMatrix.ENABLE_SIMD && _GP.glMatrix.SIMD_AVAILABLE;

				/**
				 * Sets the type of array used when creating new vectors and matrices
				 *
				 * @param {Type} type Array type, such as Float32Array or Array
				 */
				_GP.glMatrix.setMatrixArrayType = function (type) {
					_GP.glMatrix.ARRAY_TYPE = type;
				}

				var degree = Math.PI / 180;

				/**
				* Convert Degree To Radian
				*
				* @param {Number} Angle in Degrees
				*/
				_GP.glMatrix.toRadian = function (a) {
					return a * degree;
				}

				module.exports = _GP.glMatrix;


				/***/
},
/* 2 */
/***/ function (module, exports, __webpack_require__) {

				/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
			
				Permission is hereby granted, free of charge, to any person obtaining a copy
				of this software and associated documentation files (the "Software"), to deal
				in the Software without restriction, including without limitation the rights
				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
				copies of the Software, and to permit persons to whom the Software is
				furnished to do so, subject to the following conditions:
			
				The above copyright notice and this permission notice shall be included in
				all copies or substantial portions of the Software.
			
				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
				THE SOFTWARE. */

				var glMatrix = __webpack_require__(1);

				/**
				 * @class 2x2 Matrix
				 * @name mat2
				 */
				var mat2 = {};

				/**
				 * Creates a new identity mat2
				 *
				 * @returns {mat2} a new 2x2 matrix
				 */
				mat2.create = function () {
					var out = new glMatrix.ARRAY_TYPE(4);
					out[0] = 1;
					out[1] = 0;
					out[2] = 0;
					out[3] = 1;
					return out;
				};

				/**
				 * Creates a new mat2 initialized with values from an existing matrix
				 *
				 * @param {mat2} a matrix to clone
				 * @returns {mat2} a new 2x2 matrix
				 */
				mat2.clone = function (a) {
					var out = new glMatrix.ARRAY_TYPE(4);
					out[0] = a[0];
					out[1] = a[1];
					out[2] = a[2];
					out[3] = a[3];
					return out;
				};

				/**
				 * Copy the values from one mat2 to another
				 *
				 * @param {mat2} out the receiving matrix
				 * @param {mat2} a the source matrix
				 * @returns {mat2} out
				 */
				mat2.copy = function (out, a) {
					out[0] = a[0];
					out[1] = a[1];
					out[2] = a[2];
					out[3] = a[3];
					return out;
				};

				/**
				 * Set a mat2 to the identity matrix
				 *
				 * @param {mat2} out the receiving matrix
				 * @returns {mat2} out
				 */
				mat2.identity = function (out) {
					out[0] = 1;
					out[1] = 0;
					out[2] = 0;
					out[3] = 1;
					return out;
				};

				/**
				 * Transpose the values of a mat2
				 *
				 * @param {mat2} out the receiving matrix
				 * @param {mat2} a the source matrix
				 * @returns {mat2} out
				 */
				mat2.transpose = function (out, a) {
					// If we are transposing ourselves we can skip a few steps but have to cache some values
					if (out === a) {
						var a1 = a[1];
						out[1] = a[2];
						out[2] = a1;
					} else {
						out[0] = a[0];
						out[1] = a[2];
						out[2] = a[1];
						out[3] = a[3];
					}

					return out;
				};

				/**
				 * Inverts a mat2
				 *
				 * @param {mat2} out the receiving matrix
				 * @param {mat2} a the source matrix
				 * @returns {mat2} out
				 */
				mat2.invert = function (out, a) {
					var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

						// Calculate the determinant
						det = a0 * a3 - a2 * a1;

					if (!det) {
						return null;
					}
					det = 1.0 / det;

					out[0] = a3 * det;
					out[1] = -a1 * det;
					out[2] = -a2 * det;
					out[3] = a0 * det;

					return out;
				};

				/**
				 * Calculates the adjugate of a mat2
				 *
				 * @param {mat2} out the receiving matrix
				 * @param {mat2} a the source matrix
				 * @returns {mat2} out
				 */
				mat2.adjoint = function (out, a) {
					// Caching this value is nessecary if out == a
					var a0 = a[0];
					out[0] = a[3];
					out[1] = -a[1];
					out[2] = -a[2];
					out[3] = a0;

					return out;
				};

				/**
				 * Calculates the determinant of a mat2
				 *
				 * @param {mat2} a the source matrix
				 * @returns {Number} determinant of a
				 */
				mat2.determinant = function (a) {
					return a[0] * a[3] - a[2] * a[1];
				};

				/**
				 * Multiplies two mat2's
				 *
				 * @param {mat2} out the receiving matrix
				 * @param {mat2} a the first operand
				 * @param {mat2} b the second operand
				 * @returns {mat2} out
				 */
				mat2.multiply = function (out, a, b) {
					var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
					var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
					out[0] = a0 * b0 + a2 * b1;
					out[1] = a1 * b0 + a3 * b1;
					out[2] = a0 * b2 + a2 * b3;
					out[3] = a1 * b2 + a3 * b3;
					return out;
				};

				/**
				 * Alias for {@link mat2.multiply}
				 * @function
				 */
				mat2.mul = mat2.multiply;

				/**
				 * Rotates a mat2 by the given angle
				 *
				 * @param {mat2} out the receiving matrix
				 * @param {mat2} a the matrix to rotate
				 * @param {Number} rad the angle to rotate the matrix by
				 * @returns {mat2} out
				 */
				mat2.rotate = function (out, a, rad) {
					var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
						s = Math.sin(rad),
						c = Math.cos(rad);
					out[0] = a0 * c + a2 * s;
					out[1] = a1 * c + a3 * s;
					out[2] = a0 * -s + a2 * c;
					out[3] = a1 * -s + a3 * c;
					return out;
				};

				/**
				 * Scales the mat2 by the dimensions in the given vec2
				 *
				 * @param {mat2} out the receiving matrix
				 * @param {mat2} a the matrix to rotate
				 * @param {vec2} v the vec2 to scale the matrix by
				 * @returns {mat2} out
				 **/
				mat2.scale = function (out, a, v) {
					var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
						v0 = v[0], v1 = v[1];
					out[0] = a0 * v0;
					out[1] = a1 * v0;
					out[2] = a2 * v1;
					out[3] = a3 * v1;
					return out;
				};

				/**
				 * Creates a matrix from a given angle
				 * This is equivalent to (but much faster than):
				 *
				 *     mat2.identity(dest);
				 *     mat2.rotate(dest, dest, rad);
				 *
				 * @param {mat2} out mat2 receiving operation result
				 * @param {Number} rad the angle to rotate the matrix by
				 * @returns {mat2} out
				 */
				mat2.fromRotation = function (out, rad) {
					var s = Math.sin(rad),
						c = Math.cos(rad);
					out[0] = c;
					out[1] = s;
					out[2] = -s;
					out[3] = c;
					return out;
				}

				/**
				 * Creates a matrix from a vector scaling
				 * This is equivalent to (but much faster than):
				 *
				 *     mat2.identity(dest);
				 *     mat2.scale(dest, dest, vec);
				 *
				 * @param {mat2} out mat2 receiving operation result
				 * @param {vec2} v Scaling vector
				 * @returns {mat2} out
				 */
				mat2.fromScaling = function (out, v) {
					out[0] = v[0];
					out[1] = 0;
					out[2] = 0;
					out[3] = v[1];
					return out;
				}

				/**
				 * Returns a string representation of a mat2
				 *
				 * @param {mat2} mat matrix to represent as a string
				 * @returns {String} string representation of the matrix
				 */
				mat2.str = function (a) {
					return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
				};

				/**
				 * Returns Frobenius norm of a mat2
				 *
				 * @param {mat2} a the matrix to calculate Frobenius norm of
				 * @returns {Number} Frobenius norm
				 */
				mat2.frob = function (a) {
					return (Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
				};

				/**
				 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
				 * @param {mat2} L the lower triangular matrix 
				 * @param {mat2} D the diagonal matrix 
				 * @param {mat2} U the upper triangular matrix 
				 * @param {mat2} a the input matrix to factorize
				 */

				mat2.LDU = function (L, D, U, a) {
					L[2] = a[2] / a[0];
					U[0] = a[0];
					U[1] = a[1];
					U[3] = a[3] - L[2] * U[1];
					return [L, D, U];
				};


				module.exports = mat2;


				/***/
},
/* 3 */
/***/ function (module, exports, __webpack_require__) {

				/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
			
				Permission is hereby granted, free of charge, to any person obtaining a copy
				of this software and associated documentation files (the "Software"), to deal
				in the Software without restriction, including without limitation the rights
				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
				copies of the Software, and to permit persons to whom the Software is
				furnished to do so, subject to the following conditions:
			
				The above copyright notice and this permission notice shall be included in
				all copies or substantial portions of the Software.
			
				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
				THE SOFTWARE. */

				var glMatrix = __webpack_require__(1);

				/**
				 * @class 2x3 Matrix
				 * @name mat2d
				 * 
				 * @description 
				 * A mat2d contains six elements defined as:
				 * <pre>
				 * [a, c, tx,
				 *  b, d, ty]
				 * </pre>
				 * This is a short form for the 3x3 matrix:
				 * <pre>
				 * [a, c, tx,
				 *  b, d, ty,
				 *  0, 0, 1]
				 * </pre>
				 * The last row is ignored so the array is shorter and operations are faster.
				 */
				var mat2d = {};

				/**
				 * Creates a new identity mat2d
				 *
				 * @returns {mat2d} a new 2x3 matrix
				 */
				mat2d.create = function () {
					var out = new glMatrix.ARRAY_TYPE(6);
					out[0] = 1;
					out[1] = 0;
					out[2] = 0;
					out[3] = 1;
					out[4] = 0;
					out[5] = 0;
					return out;
				};

				/**
				 * Creates a new mat2d initialized with values from an existing matrix
				 *
				 * @param {mat2d} a matrix to clone
				 * @returns {mat2d} a new 2x3 matrix
				 */
				mat2d.clone = function (a) {
					var out = new glMatrix.ARRAY_TYPE(6);
					out[0] = a[0];
					out[1] = a[1];
					out[2] = a[2];
					out[3] = a[3];
					out[4] = a[4];
					out[5] = a[5];
					return out;
				};

				/**
				 * Copy the values from one mat2d to another
				 *
				 * @param {mat2d} out the receiving matrix
				 * @param {mat2d} a the source matrix
				 * @returns {mat2d} out
				 */
				mat2d.copy = function (out, a) {
					out[0] = a[0];
					out[1] = a[1];
					out[2] = a[2];
					out[3] = a[3];
					out[4] = a[4];
					out[5] = a[5];
					return out;
				};

				/**
				 * Set a mat2d to the identity matrix
				 *
				 * @param {mat2d} out the receiving matrix
				 * @returns {mat2d} out
				 */
				mat2d.identity = function (out) {
					out[0] = 1;
					out[1] = 0;
					out[2] = 0;
					out[3] = 1;
					out[4] = 0;
					out[5] = 0;
					return out;
				};

				/**
				 * Inverts a mat2d
				 *
				 * @param {mat2d} out the receiving matrix
				 * @param {mat2d} a the source matrix
				 * @returns {mat2d} out
				 */
				mat2d.invert = function (out, a) {
					var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
						atx = a[4], aty = a[5];

					var det = aa * ad - ab * ac;
					if (!det) {
						return null;
					}
					det = 1.0 / det;

					out[0] = ad * det;
					out[1] = -ab * det;
					out[2] = -ac * det;
					out[3] = aa * det;
					out[4] = (ac * aty - ad * atx) * det;
					out[5] = (ab * atx - aa * aty) * det;
					return out;
				};

				/**
				 * Calculates the determinant of a mat2d
				 *
				 * @param {mat2d} a the source matrix
				 * @returns {Number} determinant of a
				 */
				mat2d.determinant = function (a) {
					return a[0] * a[3] - a[1] * a[2];
				};

				/**
				 * Multiplies two mat2d's
				 *
				 * @param {mat2d} out the receiving matrix
				 * @param {mat2d} a the first operand
				 * @param {mat2d} b the second operand
				 * @returns {mat2d} out
				 */
				mat2d.multiply = function (out, a, b) {
					var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
						b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
					out[0] = a0 * b0 + a2 * b1;
					out[1] = a1 * b0 + a3 * b1;
					out[2] = a0 * b2 + a2 * b3;
					out[3] = a1 * b2 + a3 * b3;
					out[4] = a0 * b4 + a2 * b5 + a4;
					out[5] = a1 * b4 + a3 * b5 + a5;
					return out;
				};

				/**
				 * Alias for {@link mat2d.multiply}
				 * @function
				 */
				mat2d.mul = mat2d.multiply;

				/**
				 * Rotates a mat2d by the given angle
				 *
				 * @param {mat2d} out the receiving matrix
				 * @param {mat2d} a the matrix to rotate
				 * @param {Number} rad the angle to rotate the matrix by
				 * @returns {mat2d} out
				 */
				mat2d.rotate = function (out, a, rad) {
					var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
						s = Math.sin(rad),
						c = Math.cos(rad);
					out[0] = a0 * c + a2 * s;
					out[1] = a1 * c + a3 * s;
					out[2] = a0 * -s + a2 * c;
					out[3] = a1 * -s + a3 * c;
					out[4] = a4;
					out[5] = a5;
					return out;
				};

				/**
				 * Scales the mat2d by the dimensions in the given vec2
				 *
				 * @param {mat2d} out the receiving matrix
				 * @param {mat2d} a the matrix to translate
				 * @param {vec2} v the vec2 to scale the matrix by
				 * @returns {mat2d} out
				 **/
				mat2d.scale = function (out, a, v) {
					var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
						v0 = v[0], v1 = v[1];
					out[0] = a0 * v0;
					out[1] = a1 * v0;
					out[2] = a2 * v1;
					out[3] = a3 * v1;
					out[4] = a4;
					out[5] = a5;
					return out;
				};

				/**
				 * Translates the mat2d by the dimensions in the given vec2
				 *
				 * @param {mat2d} out the receiving matrix
				 * @param {mat2d} a the matrix to translate
				 * @param {vec2} v the vec2 to translate the matrix by
				 * @returns {mat2d} out
				 **/
				mat2d.translate = function (out, a, v) {
					var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
						v0 = v[0], v1 = v[1];
					out[0] = a0;
					out[1] = a1;
					out[2] = a2;
					out[3] = a3;
					out[4] = a0 * v0 + a2 * v1 + a4;
					out[5] = a1 * v0 + a3 * v1 + a5;
					return out;
				};

				/**
				 * Creates a matrix from a given angle
				 * This is equivalent to (but much faster than):
				 *
				 *     mat2d.identity(dest);
				 *     mat2d.rotate(dest, dest, rad);
				 *
				 * @param {mat2d} out mat2d receiving operation result
				 * @param {Number} rad the angle to rotate the matrix by
				 * @returns {mat2d} out
				 */
				mat2d.fromRotation = function (out, rad) {
					var s = Math.sin(rad), c = Math.cos(rad);
					out[0] = c;
					out[1] = s;
					out[2] = -s;
					out[3] = c;
					out[4] = 0;
					out[5] = 0;
					return out;
				}

				/**
				 * Creates a matrix from a vector scaling
				 * This is equivalent to (but much faster than):
				 *
				 *     mat2d.identity(dest);
				 *     mat2d.scale(dest, dest, vec);
				 *
				 * @param {mat2d} out mat2d receiving operation result
				 * @param {vec2} v Scaling vector
				 * @returns {mat2d} out
				 */
				mat2d.fromScaling = function (out, v) {
					out[0] = v[0];
					out[1] = 0;
					out[2] = 0;
					out[3] = v[1];
					out[4] = 0;
					out[5] = 0;
					return out;
				}

				/**
				 * Creates a matrix from a vector translation
				 * This is equivalent to (but much faster than):
				 *
				 *     mat2d.identity(dest);
				 *     mat2d.translate(dest, dest, vec);
				 *
				 * @param {mat2d} out mat2d receiving operation result
				 * @param {vec2} v Translation vector
				 * @returns {mat2d} out
				 */
				mat2d.fromTranslation = function (out, v) {
					out[0] = 1;
					out[1] = 0;
					out[2] = 0;
					out[3] = 1;
					out[4] = v[0];
					out[5] = v[1];
					return out;
				}

				/**
				 * Returns a string representation of a mat2d
				 *
				 * @param {mat2d} a matrix to represent as a string
				 * @returns {String} string representation of the matrix
				 */
				mat2d.str = function (a) {
					return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
						a[3] + ', ' + a[4] + ', ' + a[5] + ')';
				};

				/**
				 * Returns Frobenius norm of a mat2d
				 *
				 * @param {mat2d} a the matrix to calculate Frobenius norm of
				 * @returns {Number} Frobenius norm
				 */
				mat2d.frob = function (a) {
					return (Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
				};

				module.exports = mat2d;


				/***/
},
/* 4 */
/***/ function (module, exports, __webpack_require__) {

				/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
			
				Permission is hereby granted, free of charge, to any person obtaining a copy
				of this software and associated documentation files (the "Software"), to deal
				in the Software without restriction, including without limitation the rights
				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
				copies of the Software, and to permit persons to whom the Software is
				furnished to do so, subject to the following conditions:
			
				The above copyright notice and this permission notice shall be included in
				all copies or substantial portions of the Software.
			
				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
				THE SOFTWARE. */

				var glMatrix = __webpack_require__(1);

				/**
				 * @class 3x3 Matrix
				 * @name mat3
				 */
				var mat3 = {};

				/**
				 * Creates a new identity mat3
				 *
				 * @returns {mat3} a new 3x3 matrix
				 */
				mat3.create = function () {
					var out = new glMatrix.ARRAY_TYPE(9);
					out[0] = 1;
					out[1] = 0;
					out[2] = 0;
					out[3] = 0;
					out[4] = 1;
					out[5] = 0;
					out[6] = 0;
					out[7] = 0;
					out[8] = 1;
					return out;
				};

				/**
				 * Copies the upper-left 3x3 values into the given mat3.
				 *
				 * @param {mat3} out the receiving 3x3 matrix
				 * @param {mat4} a   the source 4x4 matrix
				 * @returns {mat3} out
				 */
				mat3.fromMat4 = function (out, a) {
					out[0] = a[0];
					out[1] = a[1];
					out[2] = a[2];
					out[3] = a[4];
					out[4] = a[5];
					out[5] = a[6];
					out[6] = a[8];
					out[7] = a[9];
					out[8] = a[10];
					return out;
				};

				/**
				 * Creates a new mat3 initialized with values from an existing matrix
				 *
				 * @param {mat3} a matrix to clone
				 * @returns {mat3} a new 3x3 matrix
				 */
				mat3.clone = function (a) {
					var out = new glMatrix.ARRAY_TYPE(9);
					out[0] = a[0];
					out[1] = a[1];
					out[2] = a[2];
					out[3] = a[3];
					out[4] = a[4];
					out[5] = a[5];
					out[6] = a[6];
					out[7] = a[7];
					out[8] = a[8];
					return out;
				};

				/**
				 * Copy the values from one mat3 to another
				 *
				 * @param {mat3} out the receiving matrix
				 * @param {mat3} a the source matrix
				 * @returns {mat3} out
				 */
				mat3.copy = function (out, a) {
					out[0] = a[0];
					out[1] = a[1];
					out[2] = a[2];
					out[3] = a[3];
					out[4] = a[4];
					out[5] = a[5];
					out[6] = a[6];
					out[7] = a[7];
					out[8] = a[8];
					return out;
				};

				/**
				 * Set a mat3 to the identity matrix
				 *
				 * @param {mat3} out the receiving matrix
				 * @returns {mat3} out
				 */
				mat3.identity = function (out) {
					out[0] = 1;
					out[1] = 0;
					out[2] = 0;
					out[3] = 0;
					out[4] = 1;
					out[5] = 0;
					out[6] = 0;
					out[7] = 0;
					out[8] = 1;
					return out;
				};

				/**
				 * Transpose the values of a mat3
				 *
				 * @param {mat3} out the receiving matrix
				 * @param {mat3} a the source matrix
				 * @returns {mat3} out
				 */
				mat3.transpose = function (out, a) {
					// If we are transposing ourselves we can skip a few steps but have to cache some values
					if (out === a) {
						var a01 = a[1], a02 = a[2], a12 = a[5];
						out[1] = a[3];
						out[2] = a[6];
						out[3] = a01;
						out[5] = a[7];
						out[6] = a02;
						out[7] = a12;
					} else {
						out[0] = a[0];
						out[1] = a[3];
						out[2] = a[6];
						out[3] = a[1];
						out[4] = a[4];
						out[5] = a[7];
						out[6] = a[2];
						out[7] = a[5];
						out[8] = a[8];
					}

					return out;
				};

				/**
				 * Inverts a mat3
				 *
				 * @param {mat3} out the receiving matrix
				 * @param {mat3} a the source matrix
				 * @returns {mat3} out
				 */
				mat3.invert = function (out, a) {
					var a00 = a[0], a01 = a[1], a02 = a[2],
						a10 = a[3], a11 = a[4], a12 = a[5],
						a20 = a[6], a21 = a[7], a22 = a[8],

						b01 = a22 * a11 - a12 * a21,
						b11 = -a22 * a10 + a12 * a20,
						b21 = a21 * a10 - a11 * a20,

						// Calculate the determinant
						det = a00 * b01 + a01 * b11 + a02 * b21;

					if (!det) {
						return null;
					}
					det = 1.0 / det;

					out[0] = b01 * det;
					out[1] = (-a22 * a01 + a02 * a21) * det;
					out[2] = (a12 * a01 - a02 * a11) * det;
					out[3] = b11 * det;
					out[4] = (a22 * a00 - a02 * a20) * det;
					out[5] = (-a12 * a00 + a02 * a10) * det;
					out[6] = b21 * det;
					out[7] = (-a21 * a00 + a01 * a20) * det;
					out[8] = (a11 * a00 - a01 * a10) * det;
					return out;
				};

				/**
				 * Calculates the adjugate of a mat3
				 *
				 * @param {mat3} out the receiving matrix
				 * @param {mat3} a the source matrix
				 * @returns {mat3} out
				 */
				mat3.adjoint = function (out, a) {
					var a00 = a[0], a01 = a[1], a02 = a[2],
						a10 = a[3], a11 = a[4], a12 = a[5],
						a20 = a[6], a21 = a[7], a22 = a[8];

					out[0] = (a11 * a22 - a12 * a21);
					out[1] = (a02 * a21 - a01 * a22);
					out[2] = (a01 * a12 - a02 * a11);
					out[3] = (a12 * a20 - a10 * a22);
					out[4] = (a00 * a22 - a02 * a20);
					out[5] = (a02 * a10 - a00 * a12);
					out[6] = (a10 * a21 - a11 * a20);
					out[7] = (a01 * a20 - a00 * a21);
					out[8] = (a00 * a11 - a01 * a10);
					return out;
				};

				/**
				 * Calculates the determinant of a mat3
				 *
				 * @param {mat3} a the source matrix
				 * @returns {Number} determinant of a
				 */
				mat3.determinant = function (a) {
					var a00 = a[0], a01 = a[1], a02 = a[2],
						a10 = a[3], a11 = a[4], a12 = a[5],
						a20 = a[6], a21 = a[7], a22 = a[8];

					return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
				};

				/**
				 * Multiplies two mat3's
				 *
				 * @param {mat3} out the receiving matrix
				 * @param {mat3} a the first operand
				 * @param {mat3} b the second operand
				 * @returns {mat3} out
				 */
				mat3.multiply = function (out, a, b) {
					var a00 = a[0], a01 = a[1], a02 = a[2],
						a10 = a[3], a11 = a[4], a12 = a[5],
						a20 = a[6], a21 = a[7], a22 = a[8],

						b00 = b[0], b01 = b[1], b02 = b[2],
						b10 = b[3], b11 = b[4], b12 = b[5],
						b20 = b[6], b21 = b[7], b22 = b[8];

					out[0] = b00 * a00 + b01 * a10 + b02 * a20;
					out[1] = b00 * a01 + b01 * a11 + b02 * a21;
					out[2] = b00 * a02 + b01 * a12 + b02 * a22;

					out[3] = b10 * a00 + b11 * a10 + b12 * a20;
					out[4] = b10 * a01 + b11 * a11 + b12 * a21;
					out[5] = b10 * a02 + b11 * a12 + b12 * a22;

					out[6] = b20 * a00 + b21 * a10 + b22 * a20;
					out[7] = b20 * a01 + b21 * a11 + b22 * a21;
					out[8] = b20 * a02 + b21 * a12 + b22 * a22;
					return out;
				};

				/**
				 * Alias for {@link mat3.multiply}
				 * @function
				 */
				mat3.mul = mat3.multiply;

				/**
				 * Translate a mat3 by the given vector
				 *
				 * @param {mat3} out the receiving matrix
				 * @param {mat3} a the matrix to translate
				 * @param {vec2} v vector to translate by
				 * @returns {mat3} out
				 */
				mat3.translate = function (out, a, v) {
					var a00 = a[0], a01 = a[1], a02 = a[2],
						a10 = a[3], a11 = a[4], a12 = a[5],
						a20 = a[6], a21 = a[7], a22 = a[8],
						x = v[0], y = v[1];

					out[0] = a00;
					out[1] = a01;
					out[2] = a02;

					out[3] = a10;
					out[4] = a11;
					out[5] = a12;

					out[6] = x * a00 + y * a10 + a20;
					out[7] = x * a01 + y * a11 + a21;
					out[8] = x * a02 + y * a12 + a22;
					return out;
				};

				/**
				 * Rotates a mat3 by the given angle
				 *
				 * @param {mat3} out the receiving matrix
				 * @param {mat3} a the matrix to rotate
				 * @param {Number} rad the angle to rotate the matrix by
				 * @returns {mat3} out
				 */
				mat3.rotate = function (out, a, rad) {
					var a00 = a[0], a01 = a[1], a02 = a[2],
						a10 = a[3], a11 = a[4], a12 = a[5],
						a20 = a[6], a21 = a[7], a22 = a[8],

						s = Math.sin(rad),
						c = Math.cos(rad);

					out[0] = c * a00 + s * a10;
					out[1] = c * a01 + s * a11;
					out[2] = c * a02 + s * a12;

					out[3] = c * a10 - s * a00;
					out[4] = c * a11 - s * a01;
					out[5] = c * a12 - s * a02;

					out[6] = a20;
					out[7] = a21;
					out[8] = a22;
					return out;
				};

				/**
				 * Scales the mat3 by the dimensions in the given vec2
				 *
				 * @param {mat3} out the receiving matrix
				 * @param {mat3} a the matrix to rotate
				 * @param {vec2} v the vec2 to scale the matrix by
				 * @returns {mat3} out
				 **/
				mat3.scale = function (out, a, v) {
					var x = v[0], y = v[1];

					out[0] = x * a[0];
					out[1] = x * a[1];
					out[2] = x * a[2];

					out[3] = y * a[3];
					out[4] = y * a[4];
					out[5] = y * a[5];

					out[6] = a[6];
					out[7] = a[7];
					out[8] = a[8];
					return out;
				};

				/**
				 * Creates a matrix from a vector translation
				 * This is equivalent to (but much faster than):
				 *
				 *     mat3.identity(dest);
				 *     mat3.translate(dest, dest, vec);
				 *
				 * @param {mat3} out mat3 receiving operation result
				 * @param {vec2} v Translation vector
				 * @returns {mat3} out
				 */
				mat3.fromTranslation = function (out, v) {
					out[0] = 1;
					out[1] = 0;
					out[2] = 0;
					out[3] = 0;
					out[4] = 1;
					out[5] = 0;
					out[6] = v[0];
					out[7] = v[1];
					out[8] = 1;
					return out;
				}

				/**
				 * Creates a matrix from a given angle
				 * This is equivalent to (but much faster than):
				 *
				 *     mat3.identity(dest);
				 *     mat3.rotate(dest, dest, rad);
				 *
				 * @param {mat3} out mat3 receiving operation result
				 * @param {Number} rad the angle to rotate the matrix by
				 * @returns {mat3} out
				 */
				mat3.fromRotation = function (out, rad) {
					var s = Math.sin(rad), c = Math.cos(rad);

					out[0] = c;
					out[1] = s;
					out[2] = 0;

					out[3] = -s;
					out[4] = c;
					out[5] = 0;

					out[6] = 0;
					out[7] = 0;
					out[8] = 1;
					return out;
				}

				/**
				 * Creates a matrix from a vector scaling
				 * This is equivalent to (but much faster than):
				 *
				 *     mat3.identity(dest);
				 *     mat3.scale(dest, dest, vec);
				 *
				 * @param {mat3} out mat3 receiving operation result
				 * @param {vec2} v Scaling vector
				 * @returns {mat3} out
				 */
				mat3.fromScaling = function (out, v) {
					out[0] = v[0];
					out[1] = 0;
					out[2] = 0;

					out[3] = 0;
					out[4] = v[1];
					out[5] = 0;

					out[6] = 0;
					out[7] = 0;
					out[8] = 1;
					return out;
				}

				/**
				 * Copies the values from a mat2d into a mat3
				 *
				 * @param {mat3} out the receiving matrix
				 * @param {mat2d} a the matrix to copy
				 * @returns {mat3} out
				 **/
				mat3.fromMat2d = function (out, a) {
					out[0] = a[0];
					out[1] = a[1];
					out[2] = 0;

					out[3] = a[2];
					out[4] = a[3];
					out[5] = 0;

					out[6] = a[4];
					out[7] = a[5];
					out[8] = 1;
					return out;
				};

				/**
				* Calculates a 3x3 matrix from the given quaternion
				*
				* @param {mat3} out mat3 receiving operation result
				* @param {quat} q Quaternion to create matrix from
				*
				* @returns {mat3} out
				*/
				mat3.fromQuat = function (out, q) {
					var x = q[0], y = q[1], z = q[2], w = q[3],
						x2 = x + x,
						y2 = y + y,
						z2 = z + z,

						xx = x * x2,
						yx = y * x2,
						yy = y * y2,
						zx = z * x2,
						zy = z * y2,
						zz = z * z2,
						wx = w * x2,
						wy = w * y2,
						wz = w * z2;

					out[0] = 1 - yy - zz;
					out[3] = yx - wz;
					out[6] = zx + wy;

					out[1] = yx + wz;
					out[4] = 1 - xx - zz;
					out[7] = zy - wx;

					out[2] = zx - wy;
					out[5] = zy + wx;
					out[8] = 1 - xx - yy;

					return out;
				};

				/**
				* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
				*
				* @param {mat3} out mat3 receiving operation result
				* @param {mat4} a Mat4 to derive the normal matrix from
				*
				* @returns {mat3} out
				*/
				mat3.normalFromMat4 = function (out, a) {
					var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
						a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
						a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
						a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

						b00 = a00 * a11 - a01 * a10,
						b01 = a00 * a12 - a02 * a10,
						b02 = a00 * a13 - a03 * a10,
						b03 = a01 * a12 - a02 * a11,
						b04 = a01 * a13 - a03 * a11,
						b05 = a02 * a13 - a03 * a12,
						b06 = a20 * a31 - a21 * a30,
						b07 = a20 * a32 - a22 * a30,
						b08 = a20 * a33 - a23 * a30,
						b09 = a21 * a32 - a22 * a31,
						b10 = a21 * a33 - a23 * a31,
						b11 = a22 * a33 - a23 * a32,

						// Calculate the determinant
						det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

					if (!det) {
						return null;
					}
					det = 1.0 / det;

					out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
					out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
					out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

					out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
					out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
					out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

					out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
					out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
					out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

					return out;
				};

				/**
				 * Returns a string representation of a mat3
				 *
				 * @param {mat3} mat matrix to represent as a string
				 * @returns {String} string representation of the matrix
				 */
				mat3.str = function (a) {
					return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
						a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +
						a[6] + ', ' + a[7] + ', ' + a[8] + ')';
				};

				/**
				 * Returns Frobenius norm of a mat3
				 *
				 * @param {mat3} a the matrix to calculate Frobenius norm of
				 * @returns {Number} Frobenius norm
				 */
				mat3.frob = function (a) {
					return (Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
				};


				module.exports = mat3;


				/***/
},
/* 5 */
/***/ function (module, exports, __webpack_require__) {

				/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
			
				Permission is hereby granted, free of charge, to any person obtaining a copy
				of this software and associated documentation files (the "Software"), to deal
				in the Software without restriction, including without limitation the rights
				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
				copies of the Software, and to permit persons to whom the Software is
				furnished to do so, subject to the following conditions:
			
				The above copyright notice and this permission notice shall be included in
				all copies or substantial portions of the Software.
			
				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
				THE SOFTWARE. */

				var glMatrix = __webpack_require__(1);

				/**
				 * @class 4x4 Matrix
				 * @name mat4
				 */
				var mat4 = {
					scalar: {},
					SIMD: {},
				};

				/**
				 * Creates a new identity mat4
				 *
				 * @returns {mat4} a new 4x4 matrix
				 */
				mat4.create = function () {
					var out = new glMatrix.ARRAY_TYPE(16);
					out[0] = 1;
					out[1] = 0;
					out[2] = 0;
					out[3] = 0;
					out[4] = 0;
					out[5] = 1;
					out[6] = 0;
					out[7] = 0;
					out[8] = 0;
					out[9] = 0;
					out[10] = 1;
					out[11] = 0;
					out[12] = 0;
					out[13] = 0;
					out[14] = 0;
					out[15] = 1;
					return out;
				};

				/**
				 * Creates a new mat4 initialized with values from an existing matrix
				 *
				 * @param {mat4} a matrix to clone
				 * @returns {mat4} a new 4x4 matrix
				 */
				mat4.clone = function (a) {
					var out = new glMatrix.ARRAY_TYPE(16);
					out[0] = a[0];
					out[1] = a[1];
					out[2] = a[2];
					out[3] = a[3];
					out[4] = a[4];
					out[5] = a[5];
					out[6] = a[6];
					out[7] = a[7];
					out[8] = a[8];
					out[9] = a[9];
					out[10] = a[10];
					out[11] = a[11];
					out[12] = a[12];
					out[13] = a[13];
					out[14] = a[14];
					out[15] = a[15];
					return out;
				};

				/**
				 * Copy the values from one mat4 to another
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the source matrix
				 * @returns {mat4} out
				 */
				mat4.copy = function (out, a) {
					out[0] = a[0];
					out[1] = a[1];
					out[2] = a[2];
					out[3] = a[3];
					out[4] = a[4];
					out[5] = a[5];
					out[6] = a[6];
					out[7] = a[7];
					out[8] = a[8];
					out[9] = a[9];
					out[10] = a[10];
					out[11] = a[11];
					out[12] = a[12];
					out[13] = a[13];
					out[14] = a[14];
					out[15] = a[15];
					return out;
				};

				/**
				 * Set a mat4 to the identity matrix
				 *
				 * @param {mat4} out the receiving matrix
				 * @returns {mat4} out
				 */
				mat4.identity = function (out) {
					out[0] = 1;
					out[1] = 0;
					out[2] = 0;
					out[3] = 0;
					out[4] = 0;
					out[5] = 1;
					out[6] = 0;
					out[7] = 0;
					out[8] = 0;
					out[9] = 0;
					out[10] = 1;
					out[11] = 0;
					out[12] = 0;
					out[13] = 0;
					out[14] = 0;
					out[15] = 1;
					return out;
				};

				/**
				 * Transpose the values of a mat4 not using SIMD
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the source matrix
				 * @returns {mat4} out
				 */
				mat4.scalar.transpose = function (out, a) {
					// If we are transposing ourselves we can skip a few steps but have to cache some values
					if (out === a) {
						var a01 = a[1], a02 = a[2], a03 = a[3],
							a12 = a[6], a13 = a[7],
							a23 = a[11];

						out[1] = a[4];
						out[2] = a[8];
						out[3] = a[12];
						out[4] = a01;
						out[6] = a[9];
						out[7] = a[13];
						out[8] = a02;
						out[9] = a12;
						out[11] = a[14];
						out[12] = a03;
						out[13] = a13;
						out[14] = a23;
					} else {
						out[0] = a[0];
						out[1] = a[4];
						out[2] = a[8];
						out[3] = a[12];
						out[4] = a[1];
						out[5] = a[5];
						out[6] = a[9];
						out[7] = a[13];
						out[8] = a[2];
						out[9] = a[6];
						out[10] = a[10];
						out[11] = a[14];
						out[12] = a[3];
						out[13] = a[7];
						out[14] = a[11];
						out[15] = a[15];
					}

					return out;
				};

				/**
				 * Transpose the values of a mat4 using SIMD
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the source matrix
				 * @returns {mat4} out
				 */
				mat4.SIMD.transpose = function (out, a) {
					var a0, a1, a2, a3,
						tmp01, tmp23,
						out0, out1, out2, out3;

					a0 = SIMD.Float32x4.load(a, 0);
					a1 = SIMD.Float32x4.load(a, 4);
					a2 = SIMD.Float32x4.load(a, 8);
					a3 = SIMD.Float32x4.load(a, 12);

					tmp01 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
					tmp23 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
					out0 = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
					out1 = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
					SIMD.Float32x4.store(out, 0, out0);
					SIMD.Float32x4.store(out, 4, out1);

					tmp01 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
					tmp23 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
					out2 = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
					out3 = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
					SIMD.Float32x4.store(out, 8, out2);
					SIMD.Float32x4.store(out, 12, out3);

					return out;
				};

				/**
				 * Transpse a mat4 using SIMD if available and enabled
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the source matrix
				 * @returns {mat4} out
				 */
				mat4.transpose = glMatrix.USE_SIMD ? mat4.SIMD.transpose : mat4.scalar.transpose;

				/**
				 * Inverts a mat4 not using SIMD
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the source matrix
				 * @returns {mat4} out
				 */
				mat4.scalar.invert = function (out, a) {
					var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
						a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
						a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
						a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

						b00 = a00 * a11 - a01 * a10,
						b01 = a00 * a12 - a02 * a10,
						b02 = a00 * a13 - a03 * a10,
						b03 = a01 * a12 - a02 * a11,
						b04 = a01 * a13 - a03 * a11,
						b05 = a02 * a13 - a03 * a12,
						b06 = a20 * a31 - a21 * a30,
						b07 = a20 * a32 - a22 * a30,
						b08 = a20 * a33 - a23 * a30,
						b09 = a21 * a32 - a22 * a31,
						b10 = a21 * a33 - a23 * a31,
						b11 = a22 * a33 - a23 * a32,

						// Calculate the determinant
						det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

					if (!det) {
						return null;
					}
					det = 1.0 / det;

					out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
					out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
					out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
					out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
					out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
					out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
					out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
					out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
					out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
					out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
					out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
					out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
					out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
					out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
					out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
					out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

					return out;
				};

				/**
				 * Inverts a mat4 using SIMD
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the source matrix
				 * @returns {mat4} out
				 */
				mat4.SIMD.invert = function (out, a) {
					var row0, row1, row2, row3,
						tmp1,
						minor0, minor1, minor2, minor3,
						det,
						a0 = SIMD.Float32x4.load(a, 0),
						a1 = SIMD.Float32x4.load(a, 4),
						a2 = SIMD.Float32x4.load(a, 8),
						a3 = SIMD.Float32x4.load(a, 12);

					// Compute matrix adjugate
					tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
					row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
					row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
					row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);
					tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
					row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
					row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
					row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

					tmp1 = SIMD.Float32x4.mul(row2, row3);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
					minor0 = SIMD.Float32x4.mul(row1, tmp1);
					minor1 = SIMD.Float32x4.mul(row0, tmp1);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
					minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
					minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
					minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

					tmp1 = SIMD.Float32x4.mul(row1, row2);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
					minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
					minor3 = SIMD.Float32x4.mul(row0, tmp1);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
					minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
					minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
					minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

					tmp1 = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
					row2 = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
					minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
					minor2 = SIMD.Float32x4.mul(row0, tmp1);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
					minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
					minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
					minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

					tmp1 = SIMD.Float32x4.mul(row0, row1);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
					minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
					minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
					minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
					minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

					tmp1 = SIMD.Float32x4.mul(row0, row3);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
					minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
					minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
					minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
					minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

					tmp1 = SIMD.Float32x4.mul(row0, row2);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
					minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
					minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
					minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
					minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

					// Compute matrix determinant
					det = SIMD.Float32x4.mul(row0, minor0);
					det = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 2, 3, 0, 1), det);
					det = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 1, 0, 3, 2), det);
					tmp1 = SIMD.Float32x4.reciprocalApproximation(det);
					det = SIMD.Float32x4.sub(
						SIMD.Float32x4.add(tmp1, tmp1),
						SIMD.Float32x4.mul(det, SIMD.Float32x4.mul(tmp1, tmp1)));
					det = SIMD.Float32x4.swizzle(det, 0, 0, 0, 0);
					if (!det) {
						return null;
					}

					// Compute matrix inverse
					SIMD.Float32x4.store(out, 0, SIMD.Float32x4.mul(det, minor0));
					SIMD.Float32x4.store(out, 4, SIMD.Float32x4.mul(det, minor1));
					SIMD.Float32x4.store(out, 8, SIMD.Float32x4.mul(det, minor2));
					SIMD.Float32x4.store(out, 12, SIMD.Float32x4.mul(det, minor3));
					return out;
				}

				/**
				 * Inverts a mat4 using SIMD if available and enabled
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the source matrix
				 * @returns {mat4} out
				 */
				mat4.invert = glMatrix.USE_SIMD ? mat4.SIMD.invert : mat4.scalar.invert;

				/**
				 * Calculates the adjugate of a mat4 not using SIMD
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the source matrix
				 * @returns {mat4} out
				 */
				mat4.scalar.adjoint = function (out, a) {
					var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
						a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
						a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
						a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

					out[0] = (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
					out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
					out[2] = (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
					out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
					out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
					out[5] = (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
					out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
					out[7] = (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
					out[8] = (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
					out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
					out[10] = (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
					out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
					out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
					out[13] = (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
					out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
					out[15] = (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
					return out;
				};

				/**
				 * Calculates the adjugate of a mat4 using SIMD
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the source matrix
				 * @returns {mat4} out
				 */
				mat4.SIMD.adjoint = function (out, a) {
					var a0, a1, a2, a3;
					var row0, row1, row2, row3;
					var tmp1;
					var minor0, minor1, minor2, minor3;

					var a0 = SIMD.Float32x4.load(a, 0);
					var a1 = SIMD.Float32x4.load(a, 4);
					var a2 = SIMD.Float32x4.load(a, 8);
					var a3 = SIMD.Float32x4.load(a, 12);

					// Transpose the source matrix.  Sort of.  Not a true transpose operation
					tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
					row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
					row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
					row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);

					tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
					row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
					row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
					row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

					tmp1 = SIMD.Float32x4.mul(row2, row3);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
					minor0 = SIMD.Float32x4.mul(row1, tmp1);
					minor1 = SIMD.Float32x4.mul(row0, tmp1);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
					minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
					minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
					minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

					tmp1 = SIMD.Float32x4.mul(row1, row2);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
					minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
					minor3 = SIMD.Float32x4.mul(row0, tmp1);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
					minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
					minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
					minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

					tmp1 = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
					row2 = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
					minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
					minor2 = SIMD.Float32x4.mul(row0, tmp1);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
					minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
					minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
					minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

					tmp1 = SIMD.Float32x4.mul(row0, row1);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
					minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
					minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
					minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
					minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

					tmp1 = SIMD.Float32x4.mul(row0, row3);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
					minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
					minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
					minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
					minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

					tmp1 = SIMD.Float32x4.mul(row0, row2);
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
					minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
					minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
					tmp1 = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
					minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
					minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

					SIMD.Float32x4.store(out, 0, minor0);
					SIMD.Float32x4.store(out, 4, minor1);
					SIMD.Float32x4.store(out, 8, minor2);
					SIMD.Float32x4.store(out, 12, minor3);
					return out;
				};

				/**
				 * Calculates the adjugate of a mat4 using SIMD if available and enabled
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the source matrix
				 * @returns {mat4} out
				 */
				mat4.adjoint = glMatrix.USE_SIMD ? mat4.SIMD.adjoint : mat4.scalar.adjoint;

				/**
				 * Calculates the determinant of a mat4
				 *
				 * @param {mat4} a the source matrix
				 * @returns {Number} determinant of a
				 */
				mat4.determinant = function (a) {
					var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
						a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
						a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
						a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

						b00 = a00 * a11 - a01 * a10,
						b01 = a00 * a12 - a02 * a10,
						b02 = a00 * a13 - a03 * a10,
						b03 = a01 * a12 - a02 * a11,
						b04 = a01 * a13 - a03 * a11,
						b05 = a02 * a13 - a03 * a12,
						b06 = a20 * a31 - a21 * a30,
						b07 = a20 * a32 - a22 * a30,
						b08 = a20 * a33 - a23 * a30,
						b09 = a21 * a32 - a22 * a31,
						b10 = a21 * a33 - a23 * a31,
						b11 = a22 * a33 - a23 * a32;

					// Calculate the determinant
					return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
				};

				/**
				 * Multiplies two mat4's explicitly using SIMD
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the first operand, must be a Float32Array
				 * @param {mat4} b the second operand, must be a Float32Array
				 * @returns {mat4} out
				 */
				mat4.SIMD.multiply = function (out, a, b) {
					var a0 = SIMD.Float32x4.load(a, 0);
					var a1 = SIMD.Float32x4.load(a, 4);
					var a2 = SIMD.Float32x4.load(a, 8);
					var a3 = SIMD.Float32x4.load(a, 12);

					var b0 = SIMD.Float32x4.load(b, 0);
					var out0 = SIMD.Float32x4.add(
						SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 0, 0, 0, 0), a0),
						SIMD.Float32x4.add(
							SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 1, 1, 1, 1), a1),
							SIMD.Float32x4.add(
								SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 2, 2, 2, 2), a2),
								SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 3, 3, 3, 3), a3))));
					SIMD.Float32x4.store(out, 0, out0);

					var b1 = SIMD.Float32x4.load(b, 4);
					var out1 = SIMD.Float32x4.add(
						SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 0, 0, 0, 0), a0),
						SIMD.Float32x4.add(
							SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 1, 1, 1, 1), a1),
							SIMD.Float32x4.add(
								SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 2, 2, 2, 2), a2),
								SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 3, 3, 3, 3), a3))));
					SIMD.Float32x4.store(out, 4, out1);

					var b2 = SIMD.Float32x4.load(b, 8);
					var out2 = SIMD.Float32x4.add(
						SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 0, 0, 0, 0), a0),
						SIMD.Float32x4.add(
							SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 1, 1, 1, 1), a1),
							SIMD.Float32x4.add(
								SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 2, 2, 2, 2), a2),
								SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 3, 3, 3, 3), a3))));
					SIMD.Float32x4.store(out, 8, out2);

					var b3 = SIMD.Float32x4.load(b, 12);
					var out3 = SIMD.Float32x4.add(
						SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 0, 0, 0, 0), a0),
						SIMD.Float32x4.add(
							SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 1, 1, 1, 1), a1),
							SIMD.Float32x4.add(
								SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 2, 2, 2, 2), a2),
								SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 3, 3, 3, 3), a3))));
					SIMD.Float32x4.store(out, 12, out3);

					return out;
				};

				/**
				 * Multiplies two mat4's explicitly not using SIMD
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the first operand
				 * @param {mat4} b the second operand
				 * @returns {mat4} out
				 */
				mat4.scalar.multiply = function (out, a, b) {
					var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
						a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
						a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
						a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

					// Cache only the current line of the second matrix
					var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
					out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
					out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
					out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
					out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

					b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
					out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
					out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
					out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
					out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

					b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
					out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
					out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
					out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
					out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

					b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
					out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
					out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
					out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
					out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
					return out;
				};

				/**
				 * Multiplies two mat4's using SIMD if available and enabled
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the first operand
				 * @param {mat4} b the second operand
				 * @returns {mat4} out
				 */
				mat4.multiply = glMatrix.USE_SIMD ? mat4.SIMD.multiply : mat4.scalar.multiply;

				/**
				 * Alias for {@link mat4.multiply}
				 * @function
				 */
				mat4.mul = mat4.multiply;

				/**
				 * Translate a mat4 by the given vector not using SIMD
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the matrix to translate
				 * @param {vec3} v vector to translate by
				 * @returns {mat4} out
				 */
				mat4.scalar.translate = function (out, a, v) {
					var x = v[0], y = v[1], z = v[2],
						a00, a01, a02, a03,
						a10, a11, a12, a13,
						a20, a21, a22, a23;

					if (a === out) {
						out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
						out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
						out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
						out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
					} else {
						a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
						a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
						a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

						out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
						out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
						out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

						out[12] = a00 * x + a10 * y + a20 * z + a[12];
						out[13] = a01 * x + a11 * y + a21 * z + a[13];
						out[14] = a02 * x + a12 * y + a22 * z + a[14];
						out[15] = a03 * x + a13 * y + a23 * z + a[15];
					}

					return out;
				};

				/**
				 * Translates a mat4 by the given vector using SIMD
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the matrix to translate
				 * @param {vec3} v vector to translate by
				 * @returns {mat4} out
				 */
				mat4.SIMD.translate = function (out, a, v) {
					var a0 = SIMD.Float32x4.load(a, 0),
						a1 = SIMD.Float32x4.load(a, 4),
						a2 = SIMD.Float32x4.load(a, 8),
						a3 = SIMD.Float32x4.load(a, 12),
						vec = SIMD.Float32x4(v[0], v[1], v[2], 0);

					if (a !== out) {
						out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
						out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
						out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
					}

					a0 = SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0));
					a1 = SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1));
					a2 = SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2));

					var t0 = SIMD.Float32x4.add(a0, SIMD.Float32x4.add(a1, SIMD.Float32x4.add(a2, a3)));
					SIMD.Float32x4.store(out, 12, t0);

					return out;
				};

				/**
				 * Translates a mat4 by the given vector using SIMD if available and enabled
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the matrix to translate
				 * @param {vec3} v vector to translate by
				 * @returns {mat4} out
				 */
				mat4.translate = glMatrix.USE_SIMD ? mat4.SIMD.translate : mat4.scalar.translate;

				/**
				 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the matrix to scale
				 * @param {vec3} v the vec3 to scale the matrix by
				 * @returns {mat4} out
				 **/
				mat4.scalar.scale = function (out, a, v) {
					var x = v[0], y = v[1], z = v[2];

					out[0] = a[0] * x;
					out[1] = a[1] * x;
					out[2] = a[2] * x;
					out[3] = a[3] * x;
					out[4] = a[4] * y;
					out[5] = a[5] * y;
					out[6] = a[6] * y;
					out[7] = a[7] * y;
					out[8] = a[8] * z;
					out[9] = a[9] * z;
					out[10] = a[10] * z;
					out[11] = a[11] * z;
					out[12] = a[12];
					out[13] = a[13];
					out[14] = a[14];
					out[15] = a[15];
					return out;
				};

				/**
				 * Scales the mat4 by the dimensions in the given vec3 using vectorization
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the matrix to scale
				 * @param {vec3} v the vec3 to scale the matrix by
				 * @returns {mat4} out
				 **/
				mat4.SIMD.scale = function (out, a, v) {
					var a0, a1, a2;
					var vec = SIMD.Float32x4(v[0], v[1], v[2], 0);

					a0 = SIMD.Float32x4.load(a, 0);
					SIMD.Float32x4.store(
						out, 0, SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0)));

					a1 = SIMD.Float32x4.load(a, 4);
					SIMD.Float32x4.store(
						out, 4, SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1)));

					a2 = SIMD.Float32x4.load(a, 8);
					SIMD.Float32x4.store(
						out, 8, SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2)));

					out[12] = a[12];
					out[13] = a[13];
					out[14] = a[14];
					out[15] = a[15];
					return out;
				};

				/**
				 * Scales the mat4 by the dimensions in the given vec3 using SIMD if available and enabled
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the matrix to scale
				 * @param {vec3} v the vec3 to scale the matrix by
				 * @returns {mat4} out
				 */
				mat4.scale = glMatrix.USE_SIMD ? mat4.SIMD.scale : mat4.scalar.scale;

				/**
				 * Rotates a mat4 by the given angle around the given axis
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the matrix to rotate
				 * @param {Number} rad the angle to rotate the matrix by
				 * @param {vec3} axis the axis to rotate around
				 * @returns {mat4} out
				 */
				mat4.rotate = function (out, a, rad, axis) {
					var x = axis[0], y = axis[1], z = axis[2],
						len = Math.sqrt(x * x + y * y + z * z),
						s, c, t,
						a00, a01, a02, a03,
						a10, a11, a12, a13,
						a20, a21, a22, a23,
						b00, b01, b02,
						b10, b11, b12,
						b20, b21, b22;

					if (Math.abs(len) < glMatrix.EPSILON) { return null; }

					len = 1 / len;
					x *= len;
					y *= len;
					z *= len;

					s = Math.sin(rad);
					c = Math.cos(rad);
					t = 1 - c;

					a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
					a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
					a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

					// Construct the elements of the rotation matrix
					b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
					b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
					b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

					// Perform rotation-specific matrix multiplication
					out[0] = a00 * b00 + a10 * b01 + a20 * b02;
					out[1] = a01 * b00 + a11 * b01 + a21 * b02;
					out[2] = a02 * b00 + a12 * b01 + a22 * b02;
					out[3] = a03 * b00 + a13 * b01 + a23 * b02;
					out[4] = a00 * b10 + a10 * b11 + a20 * b12;
					out[5] = a01 * b10 + a11 * b11 + a21 * b12;
					out[6] = a02 * b10 + a12 * b11 + a22 * b12;
					out[7] = a03 * b10 + a13 * b11 + a23 * b12;
					out[8] = a00 * b20 + a10 * b21 + a20 * b22;
					out[9] = a01 * b20 + a11 * b21 + a21 * b22;
					out[10] = a02 * b20 + a12 * b21 + a22 * b22;
					out[11] = a03 * b20 + a13 * b21 + a23 * b22;

					if (a !== out) { // If the source and destination differ, copy the unchanged last row
						out[12] = a[12];
						out[13] = a[13];
						out[14] = a[14];
						out[15] = a[15];
					}
					return out;
				};

				/**
				 * Rotates a matrix by the given angle around the X axis not using SIMD
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the matrix to rotate
				 * @param {Number} rad the angle to rotate the matrix by
				 * @returns {mat4} out
				 */
				mat4.scalar.rotateX = function (out, a, rad) {
					var s = Math.sin(rad),
						c = Math.cos(rad),
						a10 = a[4],
						a11 = a[5],
						a12 = a[6],
						a13 = a[7],
						a20 = a[8],
						a21 = a[9],
						a22 = a[10],
						a23 = a[11];

					if (a !== out) { // If the source and destination differ, copy the unchanged rows
						out[0] = a[0];
						out[1] = a[1];
						out[2] = a[2];
						out[3] = a[3];
						out[12] = a[12];
						out[13] = a[13];
						out[14] = a[14];
						out[15] = a[15];
					}

					// Perform axis-specific matrix multiplication
					out[4] = a10 * c + a20 * s;
					out[5] = a11 * c + a21 * s;
					out[6] = a12 * c + a22 * s;
					out[7] = a13 * c + a23 * s;
					out[8] = a20 * c - a10 * s;
					out[9] = a21 * c - a11 * s;
					out[10] = a22 * c - a12 * s;
					out[11] = a23 * c - a13 * s;
					return out;
				};

				/**
				 * Rotates a matrix by the given angle around the X axis using SIMD
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the matrix to rotate
				 * @param {Number} rad the angle to rotate the matrix by
				 * @returns {mat4} out
				 */
				mat4.SIMD.rotateX = function (out, a, rad) {
					var s = SIMD.Float32x4.splat(Math.sin(rad)),
						c = SIMD.Float32x4.splat(Math.cos(rad));

					if (a !== out) { // If the source and destination differ, copy the unchanged rows
						out[0] = a[0];
						out[1] = a[1];
						out[2] = a[2];
						out[3] = a[3];
						out[12] = a[12];
						out[13] = a[13];
						out[14] = a[14];
						out[15] = a[15];
					}

					// Perform axis-specific matrix multiplication
					var a_1 = SIMD.Float32x4.load(a, 4);
					var a_2 = SIMD.Float32x4.load(a, 8);
					SIMD.Float32x4.store(out, 4,
						SIMD.Float32x4.add(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_2, s)));
					SIMD.Float32x4.store(out, 8,
						SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_2, c), SIMD.Float32x4.mul(a_1, s)));
					return out;
				};

				/**
				 * Rotates a matrix by the given angle around the X axis using SIMD if availabe and enabled
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the matrix to rotate
				 * @param {Number} rad the angle to rotate the matrix by
				 * @returns {mat4} out
				 */
				mat4.rotateX = glMatrix.USE_SIMD ? mat4.SIMD.rotateX : mat4.scalar.rotateX;

				/**
				 * Rotates a matrix by the given angle around the Y axis not using SIMD
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the matrix to rotate
				 * @param {Number} rad the angle to rotate the matrix by
				 * @returns {mat4} out
				 */
				mat4.scalar.rotateY = function (out, a, rad) {
					var s = Math.sin(rad),
						c = Math.cos(rad),
						a00 = a[0],
						a01 = a[1],
						a02 = a[2],
						a03 = a[3],
						a20 = a[8],
						a21 = a[9],
						a22 = a[10],
						a23 = a[11];

					if (a !== out) { // If the source and destination differ, copy the unchanged rows
						out[4] = a[4];
						out[5] = a[5];
						out[6] = a[6];
						out[7] = a[7];
						out[12] = a[12];
						out[13] = a[13];
						out[14] = a[14];
						out[15] = a[15];
					}

					// Perform axis-specific matrix multiplication
					out[0] = a00 * c - a20 * s;
					out[1] = a01 * c - a21 * s;
					out[2] = a02 * c - a22 * s;
					out[3] = a03 * c - a23 * s;
					out[8] = a00 * s + a20 * c;
					out[9] = a01 * s + a21 * c;
					out[10] = a02 * s + a22 * c;
					out[11] = a03 * s + a23 * c;
					return out;
				};

				/**
				 * Rotates a matrix by the given angle around the Y axis using SIMD
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the matrix to rotate
				 * @param {Number} rad the angle to rotate the matrix by
				 * @returns {mat4} out
				 */
				mat4.SIMD.rotateY = function (out, a, rad) {
					var s = SIMD.Float32x4.splat(Math.sin(rad)),
						c = SIMD.Float32x4.splat(Math.cos(rad));

					if (a !== out) { // If the source and destination differ, copy the unchanged rows
						out[4] = a[4];
						out[5] = a[5];
						out[6] = a[6];
						out[7] = a[7];
						out[12] = a[12];
						out[13] = a[13];
						out[14] = a[14];
						out[15] = a[15];
					}

					// Perform axis-specific matrix multiplication
					var a_0 = SIMD.Float32x4.load(a, 0);
					var a_2 = SIMD.Float32x4.load(a, 8);
					SIMD.Float32x4.store(out, 0,
						SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_2, s)));
					SIMD.Float32x4.store(out, 8,
						SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, s), SIMD.Float32x4.mul(a_2, c)));
					return out;
				};

				/**
				 * Rotates a matrix by the given angle around the Y axis if SIMD available and enabled
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the matrix to rotate
				 * @param {Number} rad the angle to rotate the matrix by
				 * @returns {mat4} out
				 */
				mat4.rotateY = glMatrix.USE_SIMD ? mat4.SIMD.rotateY : mat4.scalar.rotateY;

				/**
				 * Rotates a matrix by the given angle around the Z axis not using SIMD
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the matrix to rotate
				 * @param {Number} rad the angle to rotate the matrix by
				 * @returns {mat4} out
				 */
				mat4.scalar.rotateZ = function (out, a, rad) {
					var s = Math.sin(rad),
						c = Math.cos(rad),
						a00 = a[0],
						a01 = a[1],
						a02 = a[2],
						a03 = a[3],
						a10 = a[4],
						a11 = a[5],
						a12 = a[6],
						a13 = a[7];

					if (a !== out) { // If the source and destination differ, copy the unchanged last row
						out[8] = a[8];
						out[9] = a[9];
						out[10] = a[10];
						out[11] = a[11];
						out[12] = a[12];
						out[13] = a[13];
						out[14] = a[14];
						out[15] = a[15];
					}

					// Perform axis-specific matrix multiplication
					out[0] = a00 * c + a10 * s;
					out[1] = a01 * c + a11 * s;
					out[2] = a02 * c + a12 * s;
					out[3] = a03 * c + a13 * s;
					out[4] = a10 * c - a00 * s;
					out[5] = a11 * c - a01 * s;
					out[6] = a12 * c - a02 * s;
					out[7] = a13 * c - a03 * s;
					return out;
				};

				/**
				 * Rotates a matrix by the given angle around the Z axis using SIMD
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the matrix to rotate
				 * @param {Number} rad the angle to rotate the matrix by
				 * @returns {mat4} out
				 */
				mat4.SIMD.rotateZ = function (out, a, rad) {
					var s = SIMD.Float32x4.splat(Math.sin(rad)),
						c = SIMD.Float32x4.splat(Math.cos(rad));

					if (a !== out) { // If the source and destination differ, copy the unchanged last row
						out[8] = a[8];
						out[9] = a[9];
						out[10] = a[10];
						out[11] = a[11];
						out[12] = a[12];
						out[13] = a[13];
						out[14] = a[14];
						out[15] = a[15];
					}

					// Perform axis-specific matrix multiplication
					var a_0 = SIMD.Float32x4.load(a, 0);
					var a_1 = SIMD.Float32x4.load(a, 4);
					SIMD.Float32x4.store(out, 0,
						SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_1, s)));
					SIMD.Float32x4.store(out, 4,
						SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_0, s)));
					return out;
				};

				/**
				 * Rotates a matrix by the given angle around the Z axis if SIMD available and enabled
				 *
				 * @param {mat4} out the receiving matrix
				 * @param {mat4} a the matrix to rotate
				 * @param {Number} rad the angle to rotate the matrix by
				 * @returns {mat4} out
				 */
				mat4.rotateZ = glMatrix.USE_SIMD ? mat4.SIMD.rotateZ : mat4.scalar.rotateZ;

				/**
				 * Creates a matrix from a vector translation
				 * This is equivalent to (but much faster than):
				 *
				 *     mat4.identity(dest);
				 *     mat4.translate(dest, dest, vec);
				 *
				 * @param {mat4} out mat4 receiving operation result
				 * @param {vec3} v Translation vector
				 * @returns {mat4} out
				 */
				mat4.fromTranslation = function (out, v) {
					out[0] = 1;
					out[1] = 0;
					out[2] = 0;
					out[3] = 0;
					out[4] = 0;
					out[5] = 1;
					out[6] = 0;
					out[7] = 0;
					out[8] = 0;
					out[9] = 0;
					out[10] = 1;
					out[11] = 0;
					out[12] = v[0];
					out[13] = v[1];
					out[14] = v[2];
					out[15] = 1;
					return out;
				}

				/**
				 * Creates a matrix from a vector scaling
				 * This is equivalent to (but much faster than):
				 *
				 *     mat4.identity(dest);
				 *     mat4.scale(dest, dest, vec);
				 *
				 * @param {mat4} out mat4 receiving operation result
				 * @param {vec3} v Scaling vector
				 * @returns {mat4} out
				 */
				mat4.fromScaling = function (out, v) {
					out[0] = v[0];
					out[1] = 0;
					out[2] = 0;
					out[3] = 0;
					out[4] = 0;
					out[5] = v[1];
					out[6] = 0;
					out[7] = 0;
					out[8] = 0;
					out[9] = 0;
					out[10] = v[2];
					out[11] = 0;
					out[12] = 0;
					out[13] = 0;
					out[14] = 0;
					out[15] = 1;
					return out;
				}

				/**
				 * Creates a matrix from a given angle around a given axis
				 * This is equivalent to (but much faster than):
				 *
				 *     mat4.identity(dest);
				 *     mat4.rotate(dest, dest, rad, axis);
				 *
				 * @param {mat4} out mat4 receiving operation result
				 * @param {Number} rad the angle to rotate the matrix by
				 * @param {vec3} axis the axis to rotate around
				 * @returns {mat4} out
				 */
				mat4.fromRotation = function (out, rad, axis) {
					var x = axis[0], y = axis[1], z = axis[2],
						len = Math.sqrt(x * x + y * y + z * z),
						s, c, t;

					if (Math.abs(len) < glMatrix.EPSILON) { return null; }

					len = 1 / len;
					x *= len;
					y *= len;
					z *= len;

					s = Math.sin(rad);
					c = Math.cos(rad);
					t = 1 - c;

					// Perform rotation-specific matrix multiplication
					out[0] = x * x * t + c;
					out[1] = y * x * t + z * s;
					out[2] = z * x * t - y * s;
					out[3] = 0;
					out[4] = x * y * t - z * s;
					out[5] = y * y * t + c;
					out[6] = z * y * t + x * s;
					out[7] = 0;
					out[8] = x * z * t + y * s;
					out[9] = y * z * t - x * s;
					out[10] = z * z * t + c;
					out[11] = 0;
					out[12] = 0;
					out[13] = 0;
					out[14] = 0;
					out[15] = 1;
					return out;
				}

				/**
				 * Creates a matrix from the given angle around the X axis
				 * This is equivalent to (but much faster than):
				 *
				 *     mat4.identity(dest);
				 *     mat4.rotateX(dest, dest, rad);
				 *
				 * @param {mat4} out mat4 receiving operation result
				 * @param {Number} rad the angle to rotate the matrix by
				 * @returns {mat4} out
				 */
				mat4.fromXRotation = function (out, rad) {
					var s = Math.sin(rad),
						c = Math.cos(rad);

					// Perform axis-specific matrix multiplication
					out[0] = 1;
					out[1] = 0;
					out[2] = 0;
					out[3] = 0;
					out[4] = 0;
					out[5] = c;
					out[6] = s;
					out[7] = 0;
					out[8] = 0;
					out[9] = -s;
					out[10] = c;
					out[11] = 0;
					out[12] = 0;
					out[13] = 0;
					out[14] = 0;
					out[15] = 1;
					return out;
				}

				/**
				 * Creates a matrix from the given angle around the Y axis
				 * This is equivalent to (but much faster than):
				 *
				 *     mat4.identity(dest);
				 *     mat4.rotateY(dest, dest, rad);
				 *
				 * @param {mat4} out mat4 receiving operation result
				 * @param {Number} rad the angle to rotate the matrix by
				 * @returns {mat4} out
				 */
				mat4.fromYRotation = function (out, rad) {
					var s = Math.sin(rad),
						c = Math.cos(rad);

					// Perform axis-specific matrix multiplication
					out[0] = c;
					out[1] = 0;
					out[2] = -s;
					out[3] = 0;
					out[4] = 0;
					out[5] = 1;
					out[6] = 0;
					out[7] = 0;
					out[8] = s;
					out[9] = 0;
					out[10] = c;
					out[11] = 0;
					out[12] = 0;
					out[13] = 0;
					out[14] = 0;
					out[15] = 1;
					return out;
				}

				/**
				 * Creates a matrix from the given angle around the Z axis
				 * This is equivalent to (but much faster than):
				 *
				 *     mat4.identity(dest);
				 *     mat4.rotateZ(dest, dest, rad);
				 *
				 * @param {mat4} out mat4 receiving operation result
				 * @param {Number} rad the angle to rotate the matrix by
				 * @returns {mat4} out
				 */
				mat4.fromZRotation = function (out, rad) {
					var s = Math.sin(rad),
						c = Math.cos(rad);

					// Perform axis-specific matrix multiplication
					out[0] = c;
					out[1] = s;
					out[2] = 0;
					out[3] = 0;
					out[4] = -s;
					out[5] = c;
					out[6] = 0;
					out[7] = 0;
					out[8] = 0;
					out[9] = 0;
					out[10] = 1;
					out[11] = 0;
					out[12] = 0;
					out[13] = 0;
					out[14] = 0;
					out[15] = 1;
					return out;
				}

				/**
				 * Creates a matrix from a quaternion rotation and vector translation
				 * This is equivalent to (but much faster than):
				 *
				 *     mat4.identity(dest);
				 *     mat4.translate(dest, vec);
				 *     var quatMat = mat4.create();
				 *     quat4.toMat4(quat, quatMat);
				 *     mat4.multiply(dest, quatMat);
				 *
				 * @param {mat4} out mat4 receiving operation result
				 * @param {quat4} q Rotation quaternion
				 * @param {vec3} v Translation vector
				 * @returns {mat4} out
				 */
				mat4.fromRotationTranslation = function (out, q, v) {
					// Quaternion math
					var x = q[0], y = q[1], z = q[2], w = q[3],
						x2 = x + x,
						y2 = y + y,
						z2 = z + z,

						xx = x * x2,
						xy = x * y2,
						xz = x * z2,
						yy = y * y2,
						yz = y * z2,
						zz = z * z2,
						wx = w * x2,
						wy = w * y2,
						wz = w * z2;

					out[0] = 1 - (yy + zz);
					out[1] = xy + wz;
					out[2] = xz - wy;
					out[3] = 0;
					out[4] = xy - wz;
					out[5] = 1 - (xx + zz);
					out[6] = yz + wx;
					out[7] = 0;
					out[8] = xz + wy;
					out[9] = yz - wx;
					out[10] = 1 - (xx + yy);
					out[11] = 0;
					out[12] = v[0];
					out[13] = v[1];
					out[14] = v[2];
					out[15] = 1;

					return out;
				};

				/**
				 * Creates a matrix from a quaternion rotation, vector translation and vector scale
				 * This is equivalent to (but much faster than):
				 *
				 *     mat4.identity(dest);
				 *     mat4.translate(dest, vec);
				 *     var quatMat = mat4.create();
				 *     quat4.toMat4(quat, quatMat);
				 *     mat4.multiply(dest, quatMat);
				 *     mat4.scale(dest, scale)
				 *
				 * @param {mat4} out mat4 receiving operation result
				 * @param {quat4} q Rotation quaternion
				 * @param {vec3} v Translation vector
				 * @param {vec3} s Scaling vector
				 * @returns {mat4} out
				 */
				mat4.fromRotationTranslationScale = function (out, q, v, s) {
					// Quaternion math
					var x = q[0], y = q[1], z = q[2], w = q[3],
						x2 = x + x,
						y2 = y + y,
						z2 = z + z,

						xx = x * x2,
						xy = x * y2,
						xz = x * z2,
						yy = y * y2,
						yz = y * z2,
						zz = z * z2,
						wx = w * x2,
						wy = w * y2,
						wz = w * z2,
						sx = s[0],
						sy = s[1],
						sz = s[2];

					out[0] = (1 - (yy + zz)) * sx;
					out[1] = (xy + wz) * sx;
					out[2] = (xz - wy) * sx;
					out[3] = 0;
					out[4] = (xy - wz) * sy;
					out[5] = (1 - (xx + zz)) * sy;
					out[6] = (yz + wx) * sy;
					out[7] = 0;
					out[8] = (xz + wy) * sz;
					out[9] = (yz - wx) * sz;
					out[10] = (1 - (xx + yy)) * sz;
					out[11] = 0;
					out[12] = v[0];
					out[13] = v[1];
					out[14] = v[2];
					out[15] = 1;

					return out;
				};

				/**
				 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
				 * This is equivalent to (but much faster than):
				 *
				 *     mat4.identity(dest);
				 *     mat4.translate(dest, vec);
				 *     mat4.translate(dest, origin);
				 *     var quatMat = mat4.create();
				 *     quat4.toMat4(quat, quatMat);
				 *     mat4.multiply(dest, quatMat);
				 *     mat4.scale(dest, scale)
				 *     mat4.translate(dest, negativeOrigin);
				 *
				 * @param {mat4} out mat4 receiving operation result
				 * @param {quat4} q Rotation quaternion
				 * @param {vec3} v Translation vector
				 * @param {vec3} s Scaling vector
				 * @param {vec3} o The origin vector around which to scale and rotate
				 * @returns {mat4} out
				 */
				mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
					// Quaternion math
					var x = q[0], y = q[1], z = q[2], w = q[3],
						x2 = x + x,
						y2 = y + y,
						z2 = z + z,

						xx = x * x2,
						xy = x * y2,
						xz = x * z2,
						yy = y * y2,
						yz = y * z2,
						zz = z * z2,
						wx = w * x2,
						wy = w * y2,
						wz = w * z2,

						sx = s[0],
						sy = s[1],
						sz = s[2],

						ox = o[0],
						oy = o[1],
						oz = o[2];

					out[0] = (1 - (yy + zz)) * sx;
					out[1] = (xy + wz) * sx;
					out[2] = (xz - wy) * sx;
					out[3] = 0;
					out[4] = (xy - wz) * sy;
					out[5] = (1 - (xx + zz)) * sy;
					out[6] = (yz + wx) * sy;
					out[7] = 0;
					out[8] = (xz + wy) * sz;
					out[9] = (yz - wx) * sz;
					out[10] = (1 - (xx + yy)) * sz;
					out[11] = 0;
					out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
					out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
					out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
					out[15] = 1;

					return out;
				};

				mat4.fromQuat = function (out, q) {
					var x = q[0], y = q[1], z = q[2], w = q[3],
						x2 = x + x,
						y2 = y + y,
						z2 = z + z,

						xx = x * x2,
						yx = y * x2,
						yy = y * y2,
						zx = z * x2,
						zy = z * y2,
						zz = z * z2,
						wx = w * x2,
						wy = w * y2,
						wz = w * z2;

					out[0] = 1 - yy - zz;
					out[1] = yx + wz;
					out[2] = zx - wy;
					out[3] = 0;

					out[4] = yx - wz;
					out[5] = 1 - xx - zz;
					out[6] = zy + wx;
					out[7] = 0;

					out[8] = zx + wy;
					out[9] = zy - wx;
					out[10] = 1 - xx - yy;
					out[11] = 0;

					out[12] = 0;
					out[13] = 0;
					out[14] = 0;
					out[15] = 1;

					return out;
				};

				/**
				 * Generates a frustum matrix with the given bounds
				 *
				 * @param {mat4} out mat4 frustum matrix will be written into
				 * @param {Number} left Left bound of the frustum
				 * @param {Number} right Right bound of the frustum
				 * @param {Number} bottom Bottom bound of the frustum
				 * @param {Number} top Top bound of the frustum
				 * @param {Number} near Near bound of the frustum
				 * @param {Number} far Far bound of the frustum
				 * @returns {mat4} out
				 */
				mat4.frustum = function (out, left, right, bottom, top, near, far) {
					var rl = 1 / (right - left),
						tb = 1 / (top - bottom),
						nf = 1 / (near - far);
					out[0] = (near * 2) * rl;
					out[1] = 0;
					out[2] = 0;
					out[3] = 0;
					out[4] = 0;
					out[5] = (near * 2) * tb;
					out[6] = 0;
					out[7] = 0;
					out[8] = (right + left) * rl;
					out[9] = (top + bottom) * tb;
					out[10] = (far + near) * nf;
					out[11] = -1;
					out[12] = 0;
					out[13] = 0;
					out[14] = (far * near * 2) * nf;
					out[15] = 0;
					return out;
				};

				/**
				 * Generates a perspective projection matrix with the given bounds
				 *
				 * @param {mat4} out mat4 frustum matrix will be written into
				 * @param {number} fovy Vertical field of view in radians
				 * @param {number} aspect Aspect ratio. typically viewport width/height
				 * @param {number} near Near bound of the frustum
				 * @param {number} far Far bound of the frustum
				 * @returns {mat4} out
				 */
				mat4.perspective = function (out, fovy, aspect, near, far) {
					var f = 1.0 / Math.tan(fovy / 2),
						nf = 1 / (near - far);
					out[0] = f / aspect;
					out[1] = 0;
					out[2] = 0;
					out[3] = 0;
					out[4] = 0;
					out[5] = f;
					out[6] = 0;
					out[7] = 0;
					out[8] = 0;
					out[9] = 0;
					out[10] = (far + near) * nf;
					out[11] = -1;
					out[12] = 0;
					out[13] = 0;
					out[14] = (2 * far * near) * nf;
					out[15] = 0;
					return out;
				};

				/**
				 * Generates a perspective projection matrix with the given field of view.
				 * This is primarily useful for generating projection matrices to be used
				 * with the still experiemental WebVR API.
				 *
				 * @param {mat4} out mat4 frustum matrix will be written into
				 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
				 * @param {number} near Near bound of the frustum
				 * @param {number} far Far bound of the frustum
				 * @returns {mat4} out
				 */
				mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
					var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0),
						downTan = Math.tan(fov.downDegrees * Math.PI / 180.0),
						leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0),
						rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0),
						xScale = 2.0 / (leftTan + rightTan),
						yScale = 2.0 / (upTan + downTan);

					out[0] = xScale;
					out[1] = 0.0;
					out[2] = 0.0;
					out[3] = 0.0;
					out[4] = 0.0;
					out[5] = yScale;
					out[6] = 0.0;
					out[7] = 0.0;
					out[8] = -((leftTan - rightTan) * xScale * 0.5);
					out[9] = ((upTan - downTan) * yScale * 0.5);
					out[10] = far / (near - far);
					out[11] = -1.0;
					out[12] = 0.0;
					out[13] = 0.0;
					out[14] = (far * near) / (near - far);
					out[15] = 0.0;
					return out;
				}

				/**
				 * Generates a orthogonal projection matrix with the given bounds
				 *
				 * @param {mat4} out mat4 frustum matrix will be written into
				 * @param {number} left Left bound of the frustum
				 * @param {number} right Right bound of the frustum
				 * @param {number} bottom Bottom bound of the frustum
				 * @param {number} top Top bound of the frustum
				 * @param {number} near Near bound of the frustum
				 * @param {number} far Far bound of the frustum
				 * @returns {mat4} out
				 */
				mat4.ortho = function (out, left, right, bottom, top, near, far) {
					var lr = 1 / (left - right),
						bt = 1 / (bottom - top),
						nf = 1 / (near - far);
					out[0] = -2 * lr;
					out[1] = 0;
					out[2] = 0;
					out[3] = 0;
					out[4] = 0;
					out[5] = -2 * bt;
					out[6] = 0;
					out[7] = 0;
					out[8] = 0;
					out[9] = 0;
					out[10] = 2 * nf;
					out[11] = 0;
					out[12] = (left + right) * lr;
					out[13] = (top + bottom) * bt;
					out[14] = (far + near) * nf;
					out[15] = 1;
					return out;
				};

				/**
				 * Generates a look-at matrix with the given eye position, focal point, and up axis
				 *
				 * @param {mat4} out mat4 frustum matrix will be written into
				 * @param {vec3} eye Position of the viewer
				 * @param {vec3} center Point the viewer is looking at
				 * @param {vec3} up vec3 pointing up
				 * @returns {mat4} out
				 */
				mat4.lookAt = function (out, eye, center, up) {
					var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
						eyex = eye[0],
						eyey = eye[1],
						eyez = eye[2],
						upx = up[0],
						upy = up[1],
						upz = up[2],
						centerx = center[0],
						centery = center[1],
						centerz = center[2];

					if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
						Math.abs(eyey - centery) < glMatrix.EPSILON &&
						Math.abs(eyez - centerz) < glMatrix.EPSILON) {
						return mat4.identity(out);
					}

					z0 = eyex - centerx;
					z1 = eyey - centery;
					z2 = eyez - centerz;

					len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
					z0 *= len;
					z1 *= len;
					z2 *= len;

					x0 = upy * z2 - upz * z1;
					x1 = upz * z0 - upx * z2;
					x2 = upx * z1 - upy * z0;
					len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
					if (!len) {
						x0 = 0;
						x1 = 0;
						x2 = 0;
					} else {
						len = 1 / len;
						x0 *= len;
						x1 *= len;
						x2 *= len;
					}

					y0 = z1 * x2 - z2 * x1;
					y1 = z2 * x0 - z0 * x2;
					y2 = z0 * x1 - z1 * x0;

					len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
					if (!len) {
						y0 = 0;
						y1 = 0;
						y2 = 0;
					} else {
						len = 1 / len;
						y0 *= len;
						y1 *= len;
						y2 *= len;
					}

					out[0] = x0;
					out[1] = y0;
					out[2] = z0;
					out[3] = 0;
					out[4] = x1;
					out[5] = y1;
					out[6] = z1;
					out[7] = 0;
					out[8] = x2;
					out[9] = y2;
					out[10] = z2;
					out[11] = 0;
					out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
					out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
					out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
					out[15] = 1;

					return out;
				};

				/**
				 * Returns a string representation of a mat4
				 *
				 * @param {mat4} mat matrix to represent as a string
				 * @returns {String} string representation of the matrix
				 */
				mat4.str = function (a) {
					return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
						a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
						a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
						a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
				};

				/**
				 * Returns Frobenius norm of a mat4
				 *
				 * @param {mat4} a the matrix to calculate Frobenius norm of
				 * @returns {Number} Frobenius norm
				 */
				mat4.frob = function (a) {
					return (Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2)))
				};


				module.exports = mat4;


				/***/
},
/* 6 */
/***/ function (module, exports, __webpack_require__) {

				/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
			
				Permission is hereby granted, free of charge, to any person obtaining a copy
				of this software and associated documentation files (the "Software"), to deal
				in the Software without restriction, including without limitation the rights
				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
				copies of the Software, and to permit persons to whom the Software is
				furnished to do so, subject to the following conditions:
			
				The above copyright notice and this permission notice shall be included in
				all copies or substantial portions of the Software.
			
				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
				THE SOFTWARE. */

				var glMatrix = __webpack_require__(1);
				var mat3 = __webpack_require__(4);
				var vec3 = __webpack_require__(7);
				var vec4 = __webpack_require__(8);

				/**
				 * @class Quaternion
				 * @name quat
				 */
				var quat = {};

				/**
				 * Creates a new identity quat
				 *
				 * @returns {quat} a new quaternion
				 */
				quat.create = function () {
					var out = new glMatrix.ARRAY_TYPE(4);
					out[0] = 0;
					out[1] = 0;
					out[2] = 0;
					out[3] = 1;
					return out;
				};

				/**
				 * Sets a quaternion to represent the shortest rotation from one
				 * vector to another.
				 *
				 * Both vectors are assumed to be unit length.
				 *
				 * @param {quat} out the receiving quaternion.
				 * @param {vec3} a the initial vector
				 * @param {vec3} b the destination vector
				 * @returns {quat} out
				 */
				quat.rotationTo = (function () {
					var tmpvec3 = vec3.create();
					var xUnitVec3 = vec3.fromValues(1, 0, 0);
					var yUnitVec3 = vec3.fromValues(0, 1, 0);

					return function (out, a, b) {
						var dot = vec3.dot(a, b);
						if (dot < -0.999999) {
							vec3.cross(tmpvec3, xUnitVec3, a);
							if (vec3.length(tmpvec3) < 0.000001)
								vec3.cross(tmpvec3, yUnitVec3, a);
							vec3.normalize(tmpvec3, tmpvec3);
							quat.setAxisAngle(out, tmpvec3, Math.PI);
							return out;
						} else if (dot > 0.999999) {
							out[0] = 0;
							out[1] = 0;
							out[2] = 0;
							out[3] = 1;
							return out;
						} else {
							vec3.cross(tmpvec3, a, b);
							out[0] = tmpvec3[0];
							out[1] = tmpvec3[1];
							out[2] = tmpvec3[2];
							out[3] = 1 + dot;
							return quat.normalize(out, out);
						}
					};
				})();

				/**
				 * Sets the specified quaternion with values corresponding to the given
				 * axes. Each axis is a vec3 and is expected to be unit length and
				 * perpendicular to all other specified axes.
				 *
				 * @param {vec3} view  the vector representing the viewing direction
				 * @param {vec3} right the vector representing the local "right" direction
				 * @param {vec3} up    the vector representing the local "up" direction
				 * @returns {quat} out
				 */
				quat.setAxes = (function () {
					var matr = mat3.create();

					return function (out, view, right, up) {
						matr[0] = right[0];
						matr[3] = right[1];
						matr[6] = right[2];

						matr[1] = up[0];
						matr[4] = up[1];
						matr[7] = up[2];

						matr[2] = -view[0];
						matr[5] = -view[1];
						matr[8] = -view[2];

						return quat.normalize(out, quat.fromMat3(out, matr));
					};
				})();

				/**
				 * Creates a new quat initialized with values from an existing quaternion
				 *
				 * @param {quat} a quaternion to clone
				 * @returns {quat} a new quaternion
				 * @function
				 */
				quat.clone = vec4.clone;

				/**
				 * Creates a new quat initialized with the given values
				 *
				 * @param {Number} x X component
				 * @param {Number} y Y component
				 * @param {Number} z Z component
				 * @param {Number} w W component
				 * @returns {quat} a new quaternion
				 * @function
				 */
				quat.fromValues = vec4.fromValues;

				/**
				 * Copy the values from one quat to another
				 *
				 * @param {quat} out the receiving quaternion
				 * @param {quat} a the source quaternion
				 * @returns {quat} out
				 * @function
				 */
				quat.copy = vec4.copy;

				/**
				 * Set the components of a quat to the given values
				 *
				 * @param {quat} out the receiving quaternion
				 * @param {Number} x X component
				 * @param {Number} y Y component
				 * @param {Number} z Z component
				 * @param {Number} w W component
				 * @returns {quat} out
				 * @function
				 */
				quat.set = vec4.set;

				/**
				 * Set a quat to the identity quaternion
				 *
				 * @param {quat} out the receiving quaternion
				 * @returns {quat} out
				 */
				quat.identity = function (out) {
					out[0] = 0;
					out[1] = 0;
					out[2] = 0;
					out[3] = 1;
					return out;
				};

				/**
				 * Sets a quat from the given angle and rotation axis,
				 * then returns it.
				 *
				 * @param {quat} out the receiving quaternion
				 * @param {vec3} axis the axis around which to rotate
				 * @param {Number} rad the angle in radians
				 * @returns {quat} out
				 **/
				quat.setAxisAngle = function (out, axis, rad) {
					rad = rad * 0.5;
					var s = Math.sin(rad);
					out[0] = s * axis[0];
					out[1] = s * axis[1];
					out[2] = s * axis[2];
					out[3] = Math.cos(rad);
					return out;
				};

				/**
				 * Adds two quat's
				 *
				 * @param {quat} out the receiving quaternion
				 * @param {quat} a the first operand
				 * @param {quat} b the second operand
				 * @returns {quat} out
				 * @function
				 */
				quat.add = vec4.add;

				/**
				 * Multiplies two quat's
				 *
				 * @param {quat} out the receiving quaternion
				 * @param {quat} a the first operand
				 * @param {quat} b the second operand
				 * @returns {quat} out
				 */
				quat.multiply = function (out, a, b) {
					var ax = a[0], ay = a[1], az = a[2], aw = a[3],
						bx = b[0], by = b[1], bz = b[2], bw = b[3];

					out[0] = ax * bw + aw * bx + ay * bz - az * by;
					out[1] = ay * bw + aw * by + az * bx - ax * bz;
					out[2] = az * bw + aw * bz + ax * by - ay * bx;
					out[3] = aw * bw - ax * bx - ay * by - az * bz;
					return out;
				};

				/**
				 * Alias for {@link quat.multiply}
				 * @function
				 */
				quat.mul = quat.multiply;

				/**
				 * Scales a quat by a scalar number
				 *
				 * @param {quat} out the receiving vector
				 * @param {quat} a the vector to scale
				 * @param {Number} b amount to scale the vector by
				 * @returns {quat} out
				 * @function
				 */
				quat.scale = vec4.scale;

				/**
				 * Rotates a quaternion by the given angle about the X axis
				 *
				 * @param {quat} out quat receiving operation result
				 * @param {quat} a quat to rotate
				 * @param {number} rad angle (in radians) to rotate
				 * @returns {quat} out
				 */
				quat.rotateX = function (out, a, rad) {
					rad *= 0.5;

					var ax = a[0], ay = a[1], az = a[2], aw = a[3],
						bx = Math.sin(rad), bw = Math.cos(rad);

					out[0] = ax * bw + aw * bx;
					out[1] = ay * bw + az * bx;
					out[2] = az * bw - ay * bx;
					out[3] = aw * bw - ax * bx;
					return out;
				};

				/**
				 * Rotates a quaternion by the given angle about the Y axis
				 *
				 * @param {quat} out quat receiving operation result
				 * @param {quat} a quat to rotate
				 * @param {number} rad angle (in radians) to rotate
				 * @returns {quat} out
				 */
				quat.rotateY = function (out, a, rad) {
					rad *= 0.5;

					var ax = a[0], ay = a[1], az = a[2], aw = a[3],
						by = Math.sin(rad), bw = Math.cos(rad);

					out[0] = ax * bw - az * by;
					out[1] = ay * bw + aw * by;
					out[2] = az * bw + ax * by;
					out[3] = aw * bw - ay * by;
					return out;
				};

				/**
				 * Rotates a quaternion by the given angle about the Z axis
				 *
				 * @param {quat} out quat receiving operation result
				 * @param {quat} a quat to rotate
				 * @param {number} rad angle (in radians) to rotate
				 * @returns {quat} out
				 */
				quat.rotateZ = function (out, a, rad) {
					rad *= 0.5;

					var ax = a[0], ay = a[1], az = a[2], aw = a[3],
						bz = Math.sin(rad), bw = Math.cos(rad);

					out[0] = ax * bw + ay * bz;
					out[1] = ay * bw - ax * bz;
					out[2] = az * bw + aw * bz;
					out[3] = aw * bw - az * bz;
					return out;
				};

				/**
				 * Calculates the W component of a quat from the X, Y, and Z components.
				 * Assumes that quaternion is 1 unit in length.
				 * Any existing W component will be ignored.
				 *
				 * @param {quat} out the receiving quaternion
				 * @param {quat} a quat to calculate W component of
				 * @returns {quat} out
				 */
				quat.calculateW = function (out, a) {
					var x = a[0], y = a[1], z = a[2];

					out[0] = x;
					out[1] = y;
					out[2] = z;
					out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
					return out;
				};

				/**
				 * Calculates the dot product of two quat's
				 *
				 * @param {quat} a the first operand
				 * @param {quat} b the second operand
				 * @returns {Number} dot product of a and b
				 * @function
				 */
				quat.dot = vec4.dot;

				/**
				 * Performs a linear interpolation between two quat's
				 *
				 * @param {quat} out the receiving quaternion
				 * @param {quat} a the first operand
				 * @param {quat} b the second operand
				 * @param {Number} t interpolation amount between the two inputs
				 * @returns {quat} out
				 * @function
				 */
				quat.lerp = vec4.lerp;

				/**
				 * Performs a spherical linear interpolation between two quat
				 *
				 * @param {quat} out the receiving quaternion
				 * @param {quat} a the first operand
				 * @param {quat} b the second operand
				 * @param {Number} t interpolation amount between the two inputs
				 * @returns {quat} out
				 */
				quat.slerp = function (out, a, b, t) {
					// benchmarks:
					//    http://jsperf.com/quaternion-slerp-implementations

					var ax = a[0], ay = a[1], az = a[2], aw = a[3],
						bx = b[0], by = b[1], bz = b[2], bw = b[3];

					var omega, cosom, sinom, scale0, scale1;

					// calc cosine
					cosom = ax * bx + ay * by + az * bz + aw * bw;
					// adjust signs (if necessary)
					if (cosom < 0.0) {
						cosom = -cosom;
						bx = - bx;
						by = - by;
						bz = - bz;
						bw = - bw;
					}
					// calculate coefficients
					if ((1.0 - cosom) > 0.000001) {
						// standard case (slerp)
						omega = Math.acos(cosom);
						sinom = Math.sin(omega);
						scale0 = Math.sin((1.0 - t) * omega) / sinom;
						scale1 = Math.sin(t * omega) / sinom;
					} else {
						// "from" and "to" quaternions are very close 
						//  ... so we can do a linear interpolation
						scale0 = 1.0 - t;
						scale1 = t;
					}
					// calculate final values
					out[0] = scale0 * ax + scale1 * bx;
					out[1] = scale0 * ay + scale1 * by;
					out[2] = scale0 * az + scale1 * bz;
					out[3] = scale0 * aw + scale1 * bw;

					return out;
				};

				/**
				 * Performs a spherical linear interpolation with two control points
				 *
				 * @param {quat} out the receiving quaternion
				 * @param {quat} a the first operand
				 * @param {quat} b the second operand
				 * @param {quat} c the third operand
				 * @param {quat} d the fourth operand
				 * @param {Number} t interpolation amount
				 * @returns {quat} out
				 */
				quat.sqlerp = (function () {
					var temp1 = quat.create();
					var temp2 = quat.create();

					return function (out, a, b, c, d, t) {
						quat.slerp(temp1, a, d, t);
						quat.slerp(temp2, b, c, t);
						quat.slerp(out, temp1, temp2, 2 * t * (1 - t));

						return out;
					};
				}());

				/**
				 * Calculates the inverse of a quat
				 *
				 * @param {quat} out the receiving quaternion
				 * @param {quat} a quat to calculate inverse of
				 * @returns {quat} out
				 */
				quat.invert = function (out, a) {
					var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
						dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3,
						invDot = dot ? 1.0 / dot : 0;

					// TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

					out[0] = -a0 * invDot;
					out[1] = -a1 * invDot;
					out[2] = -a2 * invDot;
					out[3] = a3 * invDot;
					return out;
				};

				/**
				 * Calculates the conjugate of a quat
				 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
				 *
				 * @param {quat} out the receiving quaternion
				 * @param {quat} a quat to calculate conjugate of
				 * @returns {quat} out
				 */
				quat.conjugate = function (out, a) {
					out[0] = -a[0];
					out[1] = -a[1];
					out[2] = -a[2];
					out[3] = a[3];
					return out;
				};

				/**
				 * Calculates the length of a quat
				 *
				 * @param {quat} a vector to calculate length of
				 * @returns {Number} length of a
				 * @function
				 */
				quat.length = vec4.length;

				/**
				 * Alias for {@link quat.length}
				 * @function
				 */
				quat.len = quat.length;

				/**
				 * Calculates the squared length of a quat
				 *
				 * @param {quat} a vector to calculate squared length of
				 * @returns {Number} squared length of a
				 * @function
				 */
				quat.squaredLength = vec4.squaredLength;

				/**
				 * Alias for {@link quat.squaredLength}
				 * @function
				 */
				quat.sqrLen = quat.squaredLength;

				/**
				 * Normalize a quat
				 *
				 * @param {quat} out the receiving quaternion
				 * @param {quat} a quaternion to normalize
				 * @returns {quat} out
				 * @function
				 */
				quat.normalize = vec4.normalize;

				/**
				 * Creates a quaternion from the given 3x3 rotation matrix.
				 *
				 * NOTE: The resultant quaternion is not normalized, so you should be sure
				 * to renormalize the quaternion yourself where necessary.
				 *
				 * @param {quat} out the receiving quaternion
				 * @param {mat3} m rotation matrix
				 * @returns {quat} out
				 * @function
				 */
				quat.fromMat3 = function (out, m) {
					// Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
					// article "Quaternion Calculus and Fast Animation".
					var fTrace = m[0] + m[4] + m[8];
					var fRoot;

					if (fTrace > 0.0) {
						// |w| > 1/2, may as well choose w > 1/2
						fRoot = Math.sqrt(fTrace + 1.0);  // 2w
						out[3] = 0.5 * fRoot;
						fRoot = 0.5 / fRoot;  // 1/(4w)
						out[0] = (m[5] - m[7]) * fRoot;
						out[1] = (m[6] - m[2]) * fRoot;
						out[2] = (m[1] - m[3]) * fRoot;
					} else {
						// |w| <= 1/2
						var i = 0;
						if (m[4] > m[0])
							i = 1;
						if (m[8] > m[i * 3 + i])
							i = 2;
						var j = (i + 1) % 3;
						var k = (i + 2) % 3;

						fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
						out[i] = 0.5 * fRoot;
						fRoot = 0.5 / fRoot;
						out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
						out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
						out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
					}

					return out;
				};

				/**
				 * Returns a string representation of a quatenion
				 *
				 * @param {quat} vec vector to represent as a string
				 * @returns {String} string representation of the vector
				 */
				quat.str = function (a) {
					return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
				};

				module.exports = quat;


				/***/
},
/* 7 */
/***/ function (module, exports, __webpack_require__) {

				/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
			
				Permission is hereby granted, free of charge, to any person obtaining a copy
				of this software and associated documentation files (the "Software"), to deal
				in the Software without restriction, including without limitation the rights
				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
				copies of the Software, and to permit persons to whom the Software is
				furnished to do so, subject to the following conditions:
			
				The above copyright notice and this permission notice shall be included in
				all copies or substantial portions of the Software.
			
				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
				THE SOFTWARE. */

				var glMatrix = __webpack_require__(1);

				/**
				 * @class 3 Dimensional Vector
				 * @name vec3
				 */
				var vec3 = {};

				/**
				 * Creates a new, empty vec3
				 *
				 * @returns {vec3} a new 3D vector
				 */
				vec3.create = function () {
					var out = new glMatrix.ARRAY_TYPE(3);
					out[0] = 0;
					out[1] = 0;
					out[2] = 0;
					return out;
				};

				/**
				 * Creates a new vec3 initialized with values from an existing vector
				 *
				 * @param {vec3} a vector to clone
				 * @returns {vec3} a new 3D vector
				 */
				vec3.clone = function (a) {
					var out = new glMatrix.ARRAY_TYPE(3);
					out[0] = a[0];
					out[1] = a[1];
					out[2] = a[2];
					return out;
				};

				/**
				 * Creates a new vec3 initialized with the given values
				 *
				 * @param {Number} x X component
				 * @param {Number} y Y component
				 * @param {Number} z Z component
				 * @returns {vec3} a new 3D vector
				 */
				vec3.fromValues = function (x, y, z) {
					var out = new glMatrix.ARRAY_TYPE(3);
					out[0] = x;
					out[1] = y;
					out[2] = z;
					return out;
				};

				/**
				 * Copy the values from one vec3 to another
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a the source vector
				 * @returns {vec3} out
				 */
				vec3.copy = function (out, a) {
					out[0] = a[0];
					out[1] = a[1];
					out[2] = a[2];
					return out;
				};

				/**
				 * Set the components of a vec3 to the given values
				 *
				 * @param {vec3} out the receiving vector
				 * @param {Number} x X component
				 * @param {Number} y Y component
				 * @param {Number} z Z component
				 * @returns {vec3} out
				 */
				vec3.set = function (out, x, y, z) {
					out[0] = x;
					out[1] = y;
					out[2] = z;
					return out;
				};

				/**
				 * Adds two vec3's
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a the first operand
				 * @param {vec3} b the second operand
				 * @returns {vec3} out
				 */
				vec3.add = function (out, a, b) {
					out[0] = a[0] + b[0];
					out[1] = a[1] + b[1];
					out[2] = a[2] + b[2];
					return out;
				};

				/**
				 * Subtracts vector b from vector a
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a the first operand
				 * @param {vec3} b the second operand
				 * @returns {vec3} out
				 */
				vec3.subtract = function (out, a, b) {
					out[0] = a[0] - b[0];
					out[1] = a[1] - b[1];
					out[2] = a[2] - b[2];
					return out;
				};

				/**
				 * Alias for {@link vec3.subtract}
				 * @function
				 */
				vec3.sub = vec3.subtract;

				/**
				 * Multiplies two vec3's
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a the first operand
				 * @param {vec3} b the second operand
				 * @returns {vec3} out
				 */
				vec3.multiply = function (out, a, b) {
					out[0] = a[0] * b[0];
					out[1] = a[1] * b[1];
					out[2] = a[2] * b[2];
					return out;
				};

				/**
				 * Alias for {@link vec3.multiply}
				 * @function
				 */
				vec3.mul = vec3.multiply;

				/**
				 * Divides two vec3's
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a the first operand
				 * @param {vec3} b the second operand
				 * @returns {vec3} out
				 */
				vec3.divide = function (out, a, b) {
					out[0] = a[0] / b[0];
					out[1] = a[1] / b[1];
					out[2] = a[2] / b[2];
					return out;
				};

				/**
				 * Alias for {@link vec3.divide}
				 * @function
				 */
				vec3.div = vec3.divide;

				/**
				 * Returns the minimum of two vec3's
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a the first operand
				 * @param {vec3} b the second operand
				 * @returns {vec3} out
				 */
				vec3.min = function (out, a, b) {
					out[0] = Math.min(a[0], b[0]);
					out[1] = Math.min(a[1], b[1]);
					out[2] = Math.min(a[2], b[2]);
					return out;
				};

				/**
				 * Returns the maximum of two vec3's
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a the first operand
				 * @param {vec3} b the second operand
				 * @returns {vec3} out
				 */
				vec3.max = function (out, a, b) {
					out[0] = Math.max(a[0], b[0]);
					out[1] = Math.max(a[1], b[1]);
					out[2] = Math.max(a[2], b[2]);
					return out;
				};

				/**
				 * Scales a vec3 by a scalar number
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a the vector to scale
				 * @param {Number} b amount to scale the vector by
				 * @returns {vec3} out
				 */
				vec3.scale = function (out, a, b) {
					out[0] = a[0] * b;
					out[1] = a[1] * b;
					out[2] = a[2] * b;
					return out;
				};

				/**
				 * Adds two vec3's after scaling the second operand by a scalar value
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a the first operand
				 * @param {vec3} b the second operand
				 * @param {Number} scale the amount to scale b by before adding
				 * @returns {vec3} out
				 */
				vec3.scaleAndAdd = function (out, a, b, scale) {
					out[0] = a[0] + (b[0] * scale);
					out[1] = a[1] + (b[1] * scale);
					out[2] = a[2] + (b[2] * scale);
					return out;
				};

				/**
				 * Calculates the euclidian distance between two vec3's
				 *
				 * @param {vec3} a the first operand
				 * @param {vec3} b the second operand
				 * @returns {Number} distance between a and b
				 */
				vec3.distance = function (a, b) {
					var x = b[0] - a[0],
						y = b[1] - a[1],
						z = b[2] - a[2];
					return Math.sqrt(x * x + y * y + z * z);
				};

				/**
				 * Alias for {@link vec3.distance}
				 * @function
				 */
				vec3.dist = vec3.distance;

				/**
				 * Calculates the squared euclidian distance between two vec3's
				 *
				 * @param {vec3} a the first operand
				 * @param {vec3} b the second operand
				 * @returns {Number} squared distance between a and b
				 */
				vec3.squaredDistance = function (a, b) {
					var x = b[0] - a[0],
						y = b[1] - a[1],
						z = b[2] - a[2];
					return x * x + y * y + z * z;
				};

				/**
				 * Alias for {@link vec3.squaredDistance}
				 * @function
				 */
				vec3.sqrDist = vec3.squaredDistance;

				/**
				 * Calculates the length of a vec3
				 *
				 * @param {vec3} a vector to calculate length of
				 * @returns {Number} length of a
				 */
				vec3.length = function (a) {
					var x = a[0],
						y = a[1],
						z = a[2];
					return Math.sqrt(x * x + y * y + z * z);
				};

				/**
				 * Alias for {@link vec3.length}
				 * @function
				 */
				vec3.len = vec3.length;

				/**
				 * Calculates the squared length of a vec3
				 *
				 * @param {vec3} a vector to calculate squared length of
				 * @returns {Number} squared length of a
				 */
				vec3.squaredLength = function (a) {
					var x = a[0],
						y = a[1],
						z = a[2];
					return x * x + y * y + z * z;
				};

				/**
				 * Alias for {@link vec3.squaredLength}
				 * @function
				 */
				vec3.sqrLen = vec3.squaredLength;

				/**
				 * Negates the components of a vec3
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a vector to negate
				 * @returns {vec3} out
				 */
				vec3.negate = function (out, a) {
					out[0] = -a[0];
					out[1] = -a[1];
					out[2] = -a[2];
					return out;
				};

				/**
				 * Returns the inverse of the components of a vec3
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a vector to invert
				 * @returns {vec3} out
				 */
				vec3.inverse = function (out, a) {
					out[0] = 1.0 / a[0];
					out[1] = 1.0 / a[1];
					out[2] = 1.0 / a[2];
					return out;
				};

				/**
				 * Normalize a vec3
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a vector to normalize
				 * @returns {vec3} out
				 */
				vec3.normalize = function (out, a) {
					var x = a[0],
						y = a[1],
						z = a[2];
					var len = x * x + y * y + z * z;
					if (len > 0) {
						//TODO: evaluate use of glm_invsqrt here?
						len = 1 / Math.sqrt(len);
						out[0] = a[0] * len;
						out[1] = a[1] * len;
						out[2] = a[2] * len;
					}
					return out;
				};

				/**
				 * Calculates the dot product of two vec3's
				 *
				 * @param {vec3} a the first operand
				 * @param {vec3} b the second operand
				 * @returns {Number} dot product of a and b
				 */
				vec3.dot = function (a, b) {
					return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
				};

				/**
				 * Computes the cross product of two vec3's
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a the first operand
				 * @param {vec3} b the second operand
				 * @returns {vec3} out
				 */
				vec3.cross = function (out, a, b) {
					var ax = a[0], ay = a[1], az = a[2],
						bx = b[0], by = b[1], bz = b[2];

					out[0] = ay * bz - az * by;
					out[1] = az * bx - ax * bz;
					out[2] = ax * by - ay * bx;
					return out;
				};

				/**
				 * Performs a linear interpolation between two vec3's
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a the first operand
				 * @param {vec3} b the second operand
				 * @param {Number} t interpolation amount between the two inputs
				 * @returns {vec3} out
				 */
				vec3.lerp = function (out, a, b, t) {
					var ax = a[0],
						ay = a[1],
						az = a[2];
					out[0] = ax + t * (b[0] - ax);
					out[1] = ay + t * (b[1] - ay);
					out[2] = az + t * (b[2] - az);
					return out;
				};

				/**
				 * Performs a hermite interpolation with two control points
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a the first operand
				 * @param {vec3} b the second operand
				 * @param {vec3} c the third operand
				 * @param {vec3} d the fourth operand
				 * @param {Number} t interpolation amount between the two inputs
				 * @returns {vec3} out
				 */
				vec3.hermite = function (out, a, b, c, d, t) {
					var factorTimes2 = t * t,
						factor1 = factorTimes2 * (2 * t - 3) + 1,
						factor2 = factorTimes2 * (t - 2) + t,
						factor3 = factorTimes2 * (t - 1),
						factor4 = factorTimes2 * (3 - 2 * t);

					out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
					out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
					out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

					return out;
				};

				/**
				 * Performs a bezier interpolation with two control points
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a the first operand
				 * @param {vec3} b the second operand
				 * @param {vec3} c the third operand
				 * @param {vec3} d the fourth operand
				 * @param {Number} t interpolation amount between the two inputs
				 * @returns {vec3} out
				 */
				vec3.bezier = function (out, a, b, c, d, t) {
					var inverseFactor = 1 - t,
						inverseFactorTimesTwo = inverseFactor * inverseFactor,
						factorTimes2 = t * t,
						factor1 = inverseFactorTimesTwo * inverseFactor,
						factor2 = 3 * t * inverseFactorTimesTwo,
						factor3 = 3 * factorTimes2 * inverseFactor,
						factor4 = factorTimes2 * t;

					out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
					out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
					out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

					return out;
				};

				/**
				 * Generates a random vector with the given scale
				 *
				 * @param {vec3} out the receiving vector
				 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
				 * @returns {vec3} out
				 */
				vec3.random = function (out, scale) {
					scale = scale || 1.0;

					var r = glMatrix.RANDOM() * 2.0 * Math.PI;
					var z = (glMatrix.RANDOM() * 2.0) - 1.0;
					var zScale = Math.sqrt(1.0 - z * z) * scale;

					out[0] = Math.cos(r) * zScale;
					out[1] = Math.sin(r) * zScale;
					out[2] = z * scale;
					return out;
				};

				/**
				 * Transforms the vec3 with a mat4.
				 * 4th vector component is implicitly '1'
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a the vector to transform
				 * @param {mat4} m matrix to transform with
				 * @returns {vec3} out
				 */
				vec3.transformMat4 = function (out, a, m) {
					var x = a[0], y = a[1], z = a[2],
						w = m[3] * x + m[7] * y + m[11] * z + m[15];
					w = w || 1.0;
					out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
					out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
					out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
					return out;
				};

				/**
				 * Transforms the vec3 with a mat3.
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a the vector to transform
				 * @param {mat4} m the 3x3 matrix to transform with
				 * @returns {vec3} out
				 */
				vec3.transformMat3 = function (out, a, m) {
					var x = a[0], y = a[1], z = a[2];
					out[0] = x * m[0] + y * m[3] + z * m[6];
					out[1] = x * m[1] + y * m[4] + z * m[7];
					out[2] = x * m[2] + y * m[5] + z * m[8];
					return out;
				};

				/**
				 * Transforms the vec3 with a quat
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec3} a the vector to transform
				 * @param {quat} q quaternion to transform with
				 * @returns {vec3} out
				 */
				vec3.transformQuat = function (out, a, q) {
					// benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

					var x = a[0], y = a[1], z = a[2],
						qx = q[0], qy = q[1], qz = q[2], qw = q[3],

						// calculate quat * vec
						ix = qw * x + qy * z - qz * y,
						iy = qw * y + qz * x - qx * z,
						iz = qw * z + qx * y - qy * x,
						iw = -qx * x - qy * y - qz * z;

					// calculate result * inverse quat
					out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
					out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
					out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
					return out;
				};

				/**
				 * Rotate a 3D vector around the x-axis
				 * @param {vec3} out The receiving vec3
				 * @param {vec3} a The vec3 point to rotate
				 * @param {vec3} b The origin of the rotation
				 * @param {Number} c The angle of rotation
				 * @returns {vec3} out
				 */
				vec3.rotateX = function (out, a, b, c) {
					var p = [], r = [];
					//Translate point to the origin
					p[0] = a[0] - b[0];
					p[1] = a[1] - b[1];
					p[2] = a[2] - b[2];

					//perform rotation
					r[0] = p[0];
					r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
					r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);

					//translate to correct position
					out[0] = r[0] + b[0];
					out[1] = r[1] + b[1];
					out[2] = r[2] + b[2];

					return out;
				};

				/**
				 * Rotate a 3D vector around the y-axis
				 * @param {vec3} out The receiving vec3
				 * @param {vec3} a The vec3 point to rotate
				 * @param {vec3} b The origin of the rotation
				 * @param {Number} c The angle of rotation
				 * @returns {vec3} out
				 */
				vec3.rotateY = function (out, a, b, c) {
					var p = [], r = [];
					//Translate point to the origin
					p[0] = a[0] - b[0];
					p[1] = a[1] - b[1];
					p[2] = a[2] - b[2];

					//perform rotation
					r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
					r[1] = p[1];
					r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);

					//translate to correct position
					out[0] = r[0] + b[0];
					out[1] = r[1] + b[1];
					out[2] = r[2] + b[2];

					return out;
				};

				/**
				 * Rotate a 3D vector around the z-axis
				 * @param {vec3} out The receiving vec3
				 * @param {vec3} a The vec3 point to rotate
				 * @param {vec3} b The origin of the rotation
				 * @param {Number} c The angle of rotation
				 * @returns {vec3} out
				 */
				vec3.rotateZ = function (out, a, b, c) {
					var p = [], r = [];
					//Translate point to the origin
					p[0] = a[0] - b[0];
					p[1] = a[1] - b[1];
					p[2] = a[2] - b[2];

					//perform rotation
					r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
					r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
					r[2] = p[2];

					//translate to correct position
					out[0] = r[0] + b[0];
					out[1] = r[1] + b[1];
					out[2] = r[2] + b[2];

					return out;
				};

				/**
				 * Perform some operation over an array of vec3s.
				 *
				 * @param {Array} a the array of vectors to iterate over
				 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
				 * @param {Number} offset Number of elements to skip at the beginning of the array
				 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
				 * @param {Function} fn Function to call for each vector in the array
				 * @param {Object} [arg] additional argument to pass to fn
				 * @returns {Array} a
				 * @function
				 */
				vec3.forEach = (function () {
					var vec = vec3.create();

					return function (a, stride, offset, count, fn, arg) {
						var i, l;
						if (!stride) {
							stride = 3;
						}

						if (!offset) {
							offset = 0;
						}

						if (count) {
							l = Math.min((count * stride) + offset, a.length);
						} else {
							l = a.length;
						}

						for (i = offset; i < l; i += stride) {
							vec[0] = a[i]; vec[1] = a[i + 1]; vec[2] = a[i + 2];
							fn(vec, vec, arg);
							a[i] = vec[0]; a[i + 1] = vec[1]; a[i + 2] = vec[2];
						}

						return a;
					};
				})();

				/**
				 * Get the angle between two 3D vectors
				 * @param {vec3} a The first operand
				 * @param {vec3} b The second operand
				 * @returns {Number} The angle in radians
				 */
				vec3.angle = function (a, b) {

					var tempA = vec3.fromValues(a[0], a[1], a[2]);
					var tempB = vec3.fromValues(b[0], b[1], b[2]);

					vec3.normalize(tempA, tempA);
					vec3.normalize(tempB, tempB);

					var cosine = vec3.dot(tempA, tempB);

					if (cosine > 1.0) {
						return 0;
					} else {
						return Math.acos(cosine);
					}
				};

				/**
				 * Returns a string representation of a vector
				 *
				 * @param {vec3} vec vector to represent as a string
				 * @returns {String} string representation of the vector
				 */
				vec3.str = function (a) {
					return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
				};

				module.exports = vec3;


				/***/
},
/* 8 */
/***/ function (module, exports, __webpack_require__) {

				/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
			
				Permission is hereby granted, free of charge, to any person obtaining a copy
				of this software and associated documentation files (the "Software"), to deal
				in the Software without restriction, including without limitation the rights
				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
				copies of the Software, and to permit persons to whom the Software is
				furnished to do so, subject to the following conditions:
			
				The above copyright notice and this permission notice shall be included in
				all copies or substantial portions of the Software.
			
				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
				THE SOFTWARE. */

				var glMatrix = __webpack_require__(1);

				/**
				 * @class 4 Dimensional Vector
				 * @name vec4
				 */
				var vec4 = {};

				/**
				 * Creates a new, empty vec4
				 *
				 * @returns {vec4} a new 4D vector
				 */
				vec4.create = function () {
					var out = new glMatrix.ARRAY_TYPE(4);
					out[0] = 0;
					out[1] = 0;
					out[2] = 0;
					out[3] = 0;
					return out;
				};

				/**
				 * Creates a new vec4 initialized with values from an existing vector
				 *
				 * @param {vec4} a vector to clone
				 * @returns {vec4} a new 4D vector
				 */
				vec4.clone = function (a) {
					var out = new glMatrix.ARRAY_TYPE(4);
					out[0] = a[0];
					out[1] = a[1];
					out[2] = a[2];
					out[3] = a[3];
					return out;
				};

				/**
				 * Creates a new vec4 initialized with the given values
				 *
				 * @param {Number} x X component
				 * @param {Number} y Y component
				 * @param {Number} z Z component
				 * @param {Number} w W component
				 * @returns {vec4} a new 4D vector
				 */
				vec4.fromValues = function (x, y, z, w) {
					var out = new glMatrix.ARRAY_TYPE(4);
					out[0] = x;
					out[1] = y;
					out[2] = z;
					out[3] = w;
					return out;
				};

				/**
				 * Copy the values from one vec4 to another
				 *
				 * @param {vec4} out the receiving vector
				 * @param {vec4} a the source vector
				 * @returns {vec4} out
				 */
				vec4.copy = function (out, a) {
					out[0] = a[0];
					out[1] = a[1];
					out[2] = a[2];
					out[3] = a[3];
					return out;
				};

				/**
				 * Set the components of a vec4 to the given values
				 *
				 * @param {vec4} out the receiving vector
				 * @param {Number} x X component
				 * @param {Number} y Y component
				 * @param {Number} z Z component
				 * @param {Number} w W component
				 * @returns {vec4} out
				 */
				vec4.set = function (out, x, y, z, w) {
					out[0] = x;
					out[1] = y;
					out[2] = z;
					out[3] = w;
					return out;
				};

				/**
				 * Adds two vec4's
				 *
				 * @param {vec4} out the receiving vector
				 * @param {vec4} a the first operand
				 * @param {vec4} b the second operand
				 * @returns {vec4} out
				 */
				vec4.add = function (out, a, b) {
					out[0] = a[0] + b[0];
					out[1] = a[1] + b[1];
					out[2] = a[2] + b[2];
					out[3] = a[3] + b[3];
					return out;
				};

				/**
				 * Subtracts vector b from vector a
				 *
				 * @param {vec4} out the receiving vector
				 * @param {vec4} a the first operand
				 * @param {vec4} b the second operand
				 * @returns {vec4} out
				 */
				vec4.subtract = function (out, a, b) {
					out[0] = a[0] - b[0];
					out[1] = a[1] - b[1];
					out[2] = a[2] - b[2];
					out[3] = a[3] - b[3];
					return out;
				};

				/**
				 * Alias for {@link vec4.subtract}
				 * @function
				 */
				vec4.sub = vec4.subtract;

				/**
				 * Multiplies two vec4's
				 *
				 * @param {vec4} out the receiving vector
				 * @param {vec4} a the first operand
				 * @param {vec4} b the second operand
				 * @returns {vec4} out
				 */
				vec4.multiply = function (out, a, b) {
					out[0] = a[0] * b[0];
					out[1] = a[1] * b[1];
					out[2] = a[2] * b[2];
					out[3] = a[3] * b[3];
					return out;
				};

				/**
				 * Alias for {@link vec4.multiply}
				 * @function
				 */
				vec4.mul = vec4.multiply;

				/**
				 * Divides two vec4's
				 *
				 * @param {vec4} out the receiving vector
				 * @param {vec4} a the first operand
				 * @param {vec4} b the second operand
				 * @returns {vec4} out
				 */
				vec4.divide = function (out, a, b) {
					out[0] = a[0] / b[0];
					out[1] = a[1] / b[1];
					out[2] = a[2] / b[2];
					out[3] = a[3] / b[3];
					return out;
				};

				/**
				 * Alias for {@link vec4.divide}
				 * @function
				 */
				vec4.div = vec4.divide;

				/**
				 * Returns the minimum of two vec4's
				 *
				 * @param {vec4} out the receiving vector
				 * @param {vec4} a the first operand
				 * @param {vec4} b the second operand
				 * @returns {vec4} out
				 */
				vec4.min = function (out, a, b) {
					out[0] = Math.min(a[0], b[0]);
					out[1] = Math.min(a[1], b[1]);
					out[2] = Math.min(a[2], b[2]);
					out[3] = Math.min(a[3], b[3]);
					return out;
				};

				/**
				 * Returns the maximum of two vec4's
				 *
				 * @param {vec4} out the receiving vector
				 * @param {vec4} a the first operand
				 * @param {vec4} b the second operand
				 * @returns {vec4} out
				 */
				vec4.max = function (out, a, b) {
					out[0] = Math.max(a[0], b[0]);
					out[1] = Math.max(a[1], b[1]);
					out[2] = Math.max(a[2], b[2]);
					out[3] = Math.max(a[3], b[3]);
					return out;
				};

				/**
				 * Scales a vec4 by a scalar number
				 *
				 * @param {vec4} out the receiving vector
				 * @param {vec4} a the vector to scale
				 * @param {Number} b amount to scale the vector by
				 * @returns {vec4} out
				 */
				vec4.scale = function (out, a, b) {
					out[0] = a[0] * b;
					out[1] = a[1] * b;
					out[2] = a[2] * b;
					out[3] = a[3] * b;
					return out;
				};

				/**
				 * Adds two vec4's after scaling the second operand by a scalar value
				 *
				 * @param {vec4} out the receiving vector
				 * @param {vec4} a the first operand
				 * @param {vec4} b the second operand
				 * @param {Number} scale the amount to scale b by before adding
				 * @returns {vec4} out
				 */
				vec4.scaleAndAdd = function (out, a, b, scale) {
					out[0] = a[0] + (b[0] * scale);
					out[1] = a[1] + (b[1] * scale);
					out[2] = a[2] + (b[2] * scale);
					out[3] = a[3] + (b[3] * scale);
					return out;
				};

				/**
				 * Calculates the euclidian distance between two vec4's
				 *
				 * @param {vec4} a the first operand
				 * @param {vec4} b the second operand
				 * @returns {Number} distance between a and b
				 */
				vec4.distance = function (a, b) {
					var x = b[0] - a[0],
						y = b[1] - a[1],
						z = b[2] - a[2],
						w = b[3] - a[3];
					return Math.sqrt(x * x + y * y + z * z + w * w);
				};

				/**
				 * Alias for {@link vec4.distance}
				 * @function
				 */
				vec4.dist = vec4.distance;

				/**
				 * Calculates the squared euclidian distance between two vec4's
				 *
				 * @param {vec4} a the first operand
				 * @param {vec4} b the second operand
				 * @returns {Number} squared distance between a and b
				 */
				vec4.squaredDistance = function (a, b) {
					var x = b[0] - a[0],
						y = b[1] - a[1],
						z = b[2] - a[2],
						w = b[3] - a[3];
					return x * x + y * y + z * z + w * w;
				};

				/**
				 * Alias for {@link vec4.squaredDistance}
				 * @function
				 */
				vec4.sqrDist = vec4.squaredDistance;

				/**
				 * Calculates the length of a vec4
				 *
				 * @param {vec4} a vector to calculate length of
				 * @returns {Number} length of a
				 */
				vec4.length = function (a) {
					var x = a[0],
						y = a[1],
						z = a[2],
						w = a[3];
					return Math.sqrt(x * x + y * y + z * z + w * w);
				};

				/**
				 * Alias for {@link vec4.length}
				 * @function
				 */
				vec4.len = vec4.length;

				/**
				 * Calculates the squared length of a vec4
				 *
				 * @param {vec4} a vector to calculate squared length of
				 * @returns {Number} squared length of a
				 */
				vec4.squaredLength = function (a) {
					var x = a[0],
						y = a[1],
						z = a[2],
						w = a[3];
					return x * x + y * y + z * z + w * w;
				};

				/**
				 * Alias for {@link vec4.squaredLength}
				 * @function
				 */
				vec4.sqrLen = vec4.squaredLength;

				/**
				 * Negates the components of a vec4
				 *
				 * @param {vec4} out the receiving vector
				 * @param {vec4} a vector to negate
				 * @returns {vec4} out
				 */
				vec4.negate = function (out, a) {
					out[0] = -a[0];
					out[1] = -a[1];
					out[2] = -a[2];
					out[3] = -a[3];
					return out;
				};

				/**
				 * Returns the inverse of the components of a vec4
				 *
				 * @param {vec4} out the receiving vector
				 * @param {vec4} a vector to invert
				 * @returns {vec4} out
				 */
				vec4.inverse = function (out, a) {
					out[0] = 1.0 / a[0];
					out[1] = 1.0 / a[1];
					out[2] = 1.0 / a[2];
					out[3] = 1.0 / a[3];
					return out;
				};

				/**
				 * Normalize a vec4
				 *
				 * @param {vec4} out the receiving vector
				 * @param {vec4} a vector to normalize
				 * @returns {vec4} out
				 */
				vec4.normalize = function (out, a) {
					var x = a[0],
						y = a[1],
						z = a[2],
						w = a[3];
					var len = x * x + y * y + z * z + w * w;
					if (len > 0) {
						len = 1 / Math.sqrt(len);
						out[0] = x * len;
						out[1] = y * len;
						out[2] = z * len;
						out[3] = w * len;
					}
					return out;
				};

				/**
				 * Calculates the dot product of two vec4's
				 *
				 * @param {vec4} a the first operand
				 * @param {vec4} b the second operand
				 * @returns {Number} dot product of a and b
				 */
				vec4.dot = function (a, b) {
					return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
				};

				/**
				 * Performs a linear interpolation between two vec4's
				 *
				 * @param {vec4} out the receiving vector
				 * @param {vec4} a the first operand
				 * @param {vec4} b the second operand
				 * @param {Number} t interpolation amount between the two inputs
				 * @returns {vec4} out
				 */
				vec4.lerp = function (out, a, b, t) {
					var ax = a[0],
						ay = a[1],
						az = a[2],
						aw = a[3];
					out[0] = ax + t * (b[0] - ax);
					out[1] = ay + t * (b[1] - ay);
					out[2] = az + t * (b[2] - az);
					out[3] = aw + t * (b[3] - aw);
					return out;
				};

				/**
				 * Generates a random vector with the given scale
				 *
				 * @param {vec4} out the receiving vector
				 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
				 * @returns {vec4} out
				 */
				vec4.random = function (out, scale) {
					scale = scale || 1.0;

					//TODO: This is a pretty awful way of doing this. Find something better.
					out[0] = glMatrix.RANDOM();
					out[1] = glMatrix.RANDOM();
					out[2] = glMatrix.RANDOM();
					out[3] = glMatrix.RANDOM();
					vec4.normalize(out, out);
					vec4.scale(out, out, scale);
					return out;
				};

				/**
				 * Transforms the vec4 with a mat4.
				 *
				 * @param {vec4} out the receiving vector
				 * @param {vec4} a the vector to transform
				 * @param {mat4} m matrix to transform with
				 * @returns {vec4} out
				 */
				vec4.transformMat4 = function (out, a, m) {
					var x = a[0], y = a[1], z = a[2], w = a[3];
					out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
					out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
					out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
					out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
					return out;
				};

				/**
				 * Transforms the vec4 with a quat
				 *
				 * @param {vec4} out the receiving vector
				 * @param {vec4} a the vector to transform
				 * @param {quat} q quaternion to transform with
				 * @returns {vec4} out
				 */
				vec4.transformQuat = function (out, a, q) {
					var x = a[0], y = a[1], z = a[2],
						qx = q[0], qy = q[1], qz = q[2], qw = q[3],

						// calculate quat * vec
						ix = qw * x + qy * z - qz * y,
						iy = qw * y + qz * x - qx * z,
						iz = qw * z + qx * y - qy * x,
						iw = -qx * x - qy * y - qz * z;

					// calculate result * inverse quat
					out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
					out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
					out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
					out[3] = a[3];
					return out;
				};

				/**
				 * Perform some operation over an array of vec4s.
				 *
				 * @param {Array} a the array of vectors to iterate over
				 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
				 * @param {Number} offset Number of elements to skip at the beginning of the array
				 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
				 * @param {Function} fn Function to call for each vector in the array
				 * @param {Object} [arg] additional argument to pass to fn
				 * @returns {Array} a
				 * @function
				 */
				vec4.forEach = (function () {
					var vec = vec4.create();

					return function (a, stride, offset, count, fn, arg) {
						var i, l;
						if (!stride) {
							stride = 4;
						}

						if (!offset) {
							offset = 0;
						}

						if (count) {
							l = Math.min((count * stride) + offset, a.length);
						} else {
							l = a.length;
						}

						for (i = offset; i < l; i += stride) {
							vec[0] = a[i]; vec[1] = a[i + 1]; vec[2] = a[i + 2]; vec[3] = a[i + 3];
							fn(vec, vec, arg);
							a[i] = vec[0]; a[i + 1] = vec[1]; a[i + 2] = vec[2]; a[i + 3] = vec[3];
						}

						return a;
					};
				})();

				/**
				 * Returns a string representation of a vector
				 *
				 * @param {vec4} vec vector to represent as a string
				 * @returns {String} string representation of the vector
				 */
				vec4.str = function (a) {
					return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
				};

				module.exports = vec4;


				/***/
},
/* 9 */
/***/ function (module, exports, __webpack_require__) {

				/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
			
				Permission is hereby granted, free of charge, to any person obtaining a copy
				of this software and associated documentation files (the "Software"), to deal
				in the Software without restriction, including without limitation the rights
				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
				copies of the Software, and to permit persons to whom the Software is
				furnished to do so, subject to the following conditions:
			
				The above copyright notice and this permission notice shall be included in
				all copies or substantial portions of the Software.
			
				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
				THE SOFTWARE. */

				var glMatrix = __webpack_require__(1);

				/**
				 * @class 2 Dimensional Vector
				 * @name vec2
				 */
				var vec2 = {};

				/**
				 * Creates a new, empty vec2
				 *
				 * @returns {vec2} a new 2D vector
				 */
				vec2.create = function () {
					var out = new glMatrix.ARRAY_TYPE(2);
					out[0] = 0;
					out[1] = 0;
					return out;
				};

				/**
				 * Creates a new vec2 initialized with values from an existing vector
				 *
				 * @param {vec2} a vector to clone
				 * @returns {vec2} a new 2D vector
				 */
				vec2.clone = function (a) {
					var out = new glMatrix.ARRAY_TYPE(2);
					out[0] = a[0];
					out[1] = a[1];
					return out;
				};

				/**
				 * Creates a new vec2 initialized with the given values
				 *
				 * @param {Number} x X component
				 * @param {Number} y Y component
				 * @returns {vec2} a new 2D vector
				 */
				vec2.fromValues = function (x, y) {
					var out = new glMatrix.ARRAY_TYPE(2);
					out[0] = x;
					out[1] = y;
					return out;
				};

				/**
				 * Copy the values from one vec2 to another
				 *
				 * @param {vec2} out the receiving vector
				 * @param {vec2} a the source vector
				 * @returns {vec2} out
				 */
				vec2.copy = function (out, a) {
					out[0] = a[0];
					out[1] = a[1];
					return out;
				};

				/**
				 * Set the components of a vec2 to the given values
				 *
				 * @param {vec2} out the receiving vector
				 * @param {Number} x X component
				 * @param {Number} y Y component
				 * @returns {vec2} out
				 */
				vec2.set = function (out, x, y) {
					out[0] = x;
					out[1] = y;
					return out;
				};

				/**
				 * Adds two vec2's
				 *
				 * @param {vec2} out the receiving vector
				 * @param {vec2} a the first operand
				 * @param {vec2} b the second operand
				 * @returns {vec2} out
				 */
				vec2.add = function (out, a, b) {
					out[0] = a[0] + b[0];
					out[1] = a[1] + b[1];
					return out;
				};

				/**
				 * Subtracts vector b from vector a
				 *
				 * @param {vec2} out the receiving vector
				 * @param {vec2} a the first operand
				 * @param {vec2} b the second operand
				 * @returns {vec2} out
				 */
				vec2.subtract = function (out, a, b) {
					out[0] = a[0] - b[0];
					out[1] = a[1] - b[1];
					return out;
				};

				/**
				 * Alias for {@link vec2.subtract}
				 * @function
				 */
				vec2.sub = vec2.subtract;

				/**
				 * Multiplies two vec2's
				 *
				 * @param {vec2} out the receiving vector
				 * @param {vec2} a the first operand
				 * @param {vec2} b the second operand
				 * @returns {vec2} out
				 */
				vec2.multiply = function (out, a, b) {
					out[0] = a[0] * b[0];
					out[1] = a[1] * b[1];
					return out;
				};

				/**
				 * Alias for {@link vec2.multiply}
				 * @function
				 */
				vec2.mul = vec2.multiply;

				/**
				 * Divides two vec2's
				 *
				 * @param {vec2} out the receiving vector
				 * @param {vec2} a the first operand
				 * @param {vec2} b the second operand
				 * @returns {vec2} out
				 */
				vec2.divide = function (out, a, b) {
					out[0] = a[0] / b[0];
					out[1] = a[1] / b[1];
					return out;
				};

				/**
				 * Alias for {@link vec2.divide}
				 * @function
				 */
				vec2.div = vec2.divide;

				/**
				 * Returns the minimum of two vec2's
				 *
				 * @param {vec2} out the receiving vector
				 * @param {vec2} a the first operand
				 * @param {vec2} b the second operand
				 * @returns {vec2} out
				 */
				vec2.min = function (out, a, b) {
					out[0] = Math.min(a[0], b[0]);
					out[1] = Math.min(a[1], b[1]);
					return out;
				};

				/**
				 * Returns the maximum of two vec2's
				 *
				 * @param {vec2} out the receiving vector
				 * @param {vec2} a the first operand
				 * @param {vec2} b the second operand
				 * @returns {vec2} out
				 */
				vec2.max = function (out, a, b) {
					out[0] = Math.max(a[0], b[0]);
					out[1] = Math.max(a[1], b[1]);
					return out;
				};

				/**
				 * Scales a vec2 by a scalar number
				 *
				 * @param {vec2} out the receiving vector
				 * @param {vec2} a the vector to scale
				 * @param {Number} b amount to scale the vector by
				 * @returns {vec2} out
				 */
				vec2.scale = function (out, a, b) {
					out[0] = a[0] * b;
					out[1] = a[1] * b;
					return out;
				};

				/**
				 * Adds two vec2's after scaling the second operand by a scalar value
				 *
				 * @param {vec2} out the receiving vector
				 * @param {vec2} a the first operand
				 * @param {vec2} b the second operand
				 * @param {Number} scale the amount to scale b by before adding
				 * @returns {vec2} out
				 */
				vec2.scaleAndAdd = function (out, a, b, scale) {
					out[0] = a[0] + (b[0] * scale);
					out[1] = a[1] + (b[1] * scale);
					return out;
				};

				/**
				 * Calculates the euclidian distance between two vec2's
				 *
				 * @param {vec2} a the first operand
				 * @param {vec2} b the second operand
				 * @returns {Number} distance between a and b
				 */
				vec2.distance = function (a, b) {
					var x = b[0] - a[0],
						y = b[1] - a[1];
					return Math.sqrt(x * x + y * y);
				};

				/**
				 * Alias for {@link vec2.distance}
				 * @function
				 */
				vec2.dist = vec2.distance;

				/**
				 * Calculates the squared euclidian distance between two vec2's
				 *
				 * @param {vec2} a the first operand
				 * @param {vec2} b the second operand
				 * @returns {Number} squared distance between a and b
				 */
				vec2.squaredDistance = function (a, b) {
					var x = b[0] - a[0],
						y = b[1] - a[1];
					return x * x + y * y;
				};

				/**
				 * Alias for {@link vec2.squaredDistance}
				 * @function
				 */
				vec2.sqrDist = vec2.squaredDistance;

				/**
				 * Calculates the length of a vec2
				 *
				 * @param {vec2} a vector to calculate length of
				 * @returns {Number} length of a
				 */
				vec2.length = function (a) {
					var x = a[0],
						y = a[1];
					return Math.sqrt(x * x + y * y);
				};

				/**
				 * Alias for {@link vec2.length}
				 * @function
				 */
				vec2.len = vec2.length;

				/**
				 * Calculates the squared length of a vec2
				 *
				 * @param {vec2} a vector to calculate squared length of
				 * @returns {Number} squared length of a
				 */
				vec2.squaredLength = function (a) {
					var x = a[0],
						y = a[1];
					return x * x + y * y;
				};

				/**
				 * Alias for {@link vec2.squaredLength}
				 * @function
				 */
				vec2.sqrLen = vec2.squaredLength;

				/**
				 * Negates the components of a vec2
				 *
				 * @param {vec2} out the receiving vector
				 * @param {vec2} a vector to negate
				 * @returns {vec2} out
				 */
				vec2.negate = function (out, a) {
					out[0] = -a[0];
					out[1] = -a[1];
					return out;
				};

				/**
				 * Returns the inverse of the components of a vec2
				 *
				 * @param {vec2} out the receiving vector
				 * @param {vec2} a vector to invert
				 * @returns {vec2} out
				 */
				vec2.inverse = function (out, a) {
					out[0] = 1.0 / a[0];
					out[1] = 1.0 / a[1];
					return out;
				};

				/**
				 * Normalize a vec2
				 *
				 * @param {vec2} out the receiving vector
				 * @param {vec2} a vector to normalize
				 * @returns {vec2} out
				 */
				vec2.normalize = function (out, a) {
					var x = a[0],
						y = a[1];
					var len = x * x + y * y;
					if (len > 0) {
						//TODO: evaluate use of glm_invsqrt here?
						len = 1 / Math.sqrt(len);
						out[0] = a[0] * len;
						out[1] = a[1] * len;
					}
					return out;
				};

				/**
				 * Calculates the dot product of two vec2's
				 *
				 * @param {vec2} a the first operand
				 * @param {vec2} b the second operand
				 * @returns {Number} dot product of a and b
				 */
				vec2.dot = function (a, b) {
					return a[0] * b[0] + a[1] * b[1];
				};

				/**
				 * Computes the cross product of two vec2's
				 * Note that the cross product must by definition produce a 3D vector
				 *
				 * @param {vec3} out the receiving vector
				 * @param {vec2} a the first operand
				 * @param {vec2} b the second operand
				 * @returns {vec3} out
				 */
				vec2.cross = function (out, a, b) {
					var z = a[0] * b[1] - a[1] * b[0];
					out[0] = out[1] = 0;
					out[2] = z;
					return out;
				};

				/**
				 * Performs a linear interpolation between two vec2's
				 *
				 * @param {vec2} out the receiving vector
				 * @param {vec2} a the first operand
				 * @param {vec2} b the second operand
				 * @param {Number} t interpolation amount between the two inputs
				 * @returns {vec2} out
				 */
				vec2.lerp = function (out, a, b, t) {
					var ax = a[0],
						ay = a[1];
					out[0] = ax + t * (b[0] - ax);
					out[1] = ay + t * (b[1] - ay);
					return out;
				};

				/**
				 * Generates a random vector with the given scale
				 *
				 * @param {vec2} out the receiving vector
				 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
				 * @returns {vec2} out
				 */
				vec2.random = function (out, scale) {
					scale = scale || 1.0;
					var r = glMatrix.RANDOM() * 2.0 * Math.PI;
					out[0] = Math.cos(r) * scale;
					out[1] = Math.sin(r) * scale;
					return out;
				};

				/**
				 * Transforms the vec2 with a mat2
				 *
				 * @param {vec2} out the receiving vector
				 * @param {vec2} a the vector to transform
				 * @param {mat2} m matrix to transform with
				 * @returns {vec2} out
				 */
				vec2.transformMat2 = function (out, a, m) {
					var x = a[0],
						y = a[1];
					out[0] = m[0] * x + m[2] * y;
					out[1] = m[1] * x + m[3] * y;
					return out;
				};

				/**
				 * Transforms the vec2 with a mat2d
				 *
				 * @param {vec2} out the receiving vector
				 * @param {vec2} a the vector to transform
				 * @param {mat2d} m matrix to transform with
				 * @returns {vec2} out
				 */
				vec2.transformMat2d = function (out, a, m) {
					var x = a[0],
						y = a[1];
					out[0] = m[0] * x + m[2] * y + m[4];
					out[1] = m[1] * x + m[3] * y + m[5];
					return out;
				};

				/**
				 * Transforms the vec2 with a mat3
				 * 3rd vector component is implicitly '1'
				 *
				 * @param {vec2} out the receiving vector
				 * @param {vec2} a the vector to transform
				 * @param {mat3} m matrix to transform with
				 * @returns {vec2} out
				 */
				vec2.transformMat3 = function (out, a, m) {
					var x = a[0],
						y = a[1];
					out[0] = m[0] * x + m[3] * y + m[6];
					out[1] = m[1] * x + m[4] * y + m[7];
					return out;
				};

				/**
				 * Transforms the vec2 with a mat4
				 * 3rd vector component is implicitly '0'
				 * 4th vector component is implicitly '1'
				 *
				 * @param {vec2} out the receiving vector
				 * @param {vec2} a the vector to transform
				 * @param {mat4} m matrix to transform with
				 * @returns {vec2} out
				 */
				vec2.transformMat4 = function (out, a, m) {
					var x = a[0],
						y = a[1];
					out[0] = m[0] * x + m[4] * y + m[12];
					out[1] = m[1] * x + m[5] * y + m[13];
					return out;
				};

				/**
				 * Perform some operation over an array of vec2s.
				 *
				 * @param {Array} a the array of vectors to iterate over
				 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
				 * @param {Number} offset Number of elements to skip at the beginning of the array
				 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
				 * @param {Function} fn Function to call for each vector in the array
				 * @param {Object} [arg] additional argument to pass to fn
				 * @returns {Array} a
				 * @function
				 */
				vec2.forEach = (function () {
					var vec = vec2.create();

					return function (a, stride, offset, count, fn, arg) {
						var i, l;
						if (!stride) {
							stride = 2;
						}

						if (!offset) {
							offset = 0;
						}

						if (count) {
							l = Math.min((count * stride) + offset, a.length);
						} else {
							l = a.length;
						}

						for (i = offset; i < l; i += stride) {
							vec[0] = a[i]; vec[1] = a[i + 1];
							fn(vec, vec, arg);
							a[i] = vec[0]; a[i + 1] = vec[1];
						}

						return a;
					};
				})();

				/**
				 * Returns a string representation of a vector
				 *
				 * @param {vec2} vec vector to represent as a string
				 * @returns {String} string representation of the vector
				 */
				vec2.str = function (a) {
					return 'vec2(' + a[0] + ', ' + a[1] + ')';
				};

				module.exports = vec2;


				/***/
}
/******/])
	});

	function audioFingerPrinting() { //Namespace Required
		var finished = false;
		try {
			var audioCtx = new (window.AudioContext || window.webkitAudioContext),
				oscillator = audioCtx.createOscillator(),
				analyser = audioCtx.createAnalyser(),
				gainNode = audioCtx.createGain(),
				scriptProcessor = audioCtx.createScriptProcessor(4096, 1, 1);
			var destination = audioCtx.destination;
			return (audioCtx.sampleRate).toString() + '_' + destination.maxChannelCount + "_" + destination.numberOfInputs + '_' + destination.numberOfOutputs + '_' + destination.channelCount + '_' + destination.channelCountMode + '_' + destination.channelInterpretation;
		}
		catch (e) {
			return "not supported";
		}
	}

	//Library
	(function (root, ns, factory) { "use strict"; "undefined" != typeof module && module.exports ? module.exports = factory(ns, root) : "function" == typeof define && define.amd ? define("detect-zoom", function () { return factory(ns, root) }) : root[ns] = factory(ns, root) })(window, "detectZoom", function () { var devicePixelRatio = function () { return window.devicePixelRatio || 1 }, fallback = function () { return { zoom: 1, devicePxPerCssPx: 1 } }, ie8 = function () { var zoom = Math.round(100 * (screen.deviceXDPI / screen.logicalXDPI)) / 100; return { zoom: zoom, devicePxPerCssPx: zoom * devicePixelRatio() } }, ie10 = function () { var zoom = Math.round(100 * (document.documentElement.offsetHeight / window.innerHeight)) / 100; return { zoom: zoom, devicePxPerCssPx: zoom * devicePixelRatio() } }, webkitMobile = function () { var deviceWidth = 90 == Math.abs(window.orientation) ? screen.height : screen.width, zoom = deviceWidth / window.innerWidth; return { zoom: zoom, devicePxPerCssPx: zoom * devicePixelRatio() } }, webkit = function () { var important = function (str) { return str.replace(/;/g, " !important;") }, div = document.createElement("div"); div.innerHTML = "1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>0", div.setAttribute("style", important("font: 100px/1em sans-serif; -webkit-text-size-adjust: none; text-size-adjust: none; height: auto; width: 1em; padding: 0; overflow: visible;")); var container = document.createElement("div"); container.setAttribute("style", important("width:0; height:0; overflow:hidden; visibility:hidden; position: absolute;")), container.appendChild(div), document.body.appendChild(container); var zoom = 1e3 / div.clientHeight; return zoom = Math.round(100 * zoom) / 100, document.body.removeChild(container), { zoom: zoom, devicePxPerCssPx: zoom * devicePixelRatio() } }, firefox4 = function () { var zoom = mediaQueryBinarySearch("min--moz-device-pixel-ratio", "", 0, 10, 20, 1e-4); return zoom = Math.round(100 * zoom) / 100, { zoom: zoom, devicePxPerCssPx: zoom } }, firefox18 = function () { return { zoom: firefox4().zoom, devicePxPerCssPx: devicePixelRatio() } }, opera11 = function () { var zoom = window.top.outerWidth / window.top.innerWidth; return zoom = Math.round(100 * zoom) / 100, { zoom: zoom, devicePxPerCssPx: zoom * devicePixelRatio() } }, mediaQueryBinarySearch = function (property, unit, a, b, maxIter, epsilon) { function binarySearch(a, b, maxIter) { var mid = (a + b) / 2; if (0 >= maxIter || epsilon > b - a) return mid; var query = "(" + property + ":" + mid + unit + ")"; return matchMedia(query).matches ? binarySearch(mid, b, maxIter - 1) : binarySearch(a, mid, maxIter - 1) } var matchMedia, head, style, div; window.matchMedia ? matchMedia = window.matchMedia : (head = document.getElementsByTagName("head")[0], style = document.createElement("style"), head.appendChild(style), div = document.createElement("div"), div.className = "mediaQueryBinarySearch", div.style.display = "none", document.body.appendChild(div), matchMedia = function (query) { style.sheet.insertRule("@media " + query + "{.mediaQueryBinarySearch " + "{text-decoration: underline} }", 0); var matched = "underline" == getComputedStyle(div, null).textDecoration; return style.sheet.deleteRule(0), { matches: matched } }); var ratio = binarySearch(a, b, maxIter); return div && (head.removeChild(style), document.body.removeChild(div)), ratio }, detectFunction = function () { var func = fallback; return isNaN(screen.logicalXDPI) || isNaN(screen.systemXDPI) ? window.navigator.msMaxTouchPoints ? func = ie10 : "orientation" in window && "string" == typeof document.body.style.webkitMarquee ? func = webkitMobile : "string" == typeof document.body.style.webkitMarquee ? func = webkit : navigator.userAgent.indexOf("Opera") >= 0 ? func = opera11 : window.devicePixelRatio ? func = firefox18 : firefox4().zoom > .001 && (func = firefox4) : func = ie8, func }(); return { zoom: function () { return detectFunction().zoom }, device: function () { return detectFunction().devicePxPerCssPx } } });
	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Copyright (C) Paul Johnston 2000.
	 * See http://pajhome.org.uk/site/legal.html for details.
	 */

	/*
	 * Convert a 32-bit number to a hex string with ms-byte first
	 */
	var hex_chr = "0123456789abcdef"; //Namespace Required
	function hex(num) //Namespace Required
	{
		var str = "";
		for (var j = 7; j >= 0; j--)
			str += hex_chr.charAt((num >> (j * 4)) & 0x0F);
		return str;
	}

	/*
	 * Convert a string to a sequence of 16-word blocks, stored as an array.
	 * Append padding bits and the length, as described in the SHA1 standard.
	 */
	function str2blks_SHA1(str) //Namespace Required
	{
		var nblk = ((str.length + 8) >> 6) + 1;
		var blks = new Array(nblk * 16);
		for (var i = 0; i < nblk * 16; i++) blks[i] = 0;
		for (i = 0; i < str.length; i++)
			blks[i >> 2] |= str.charCodeAt(i) << (24 - (i % 4) * 8);
		blks[i >> 2] |= 0x80 << (24 - (i % 4) * 8);
		blks[nblk * 16 - 1] = str.length * 8;
		return blks;
	}

	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally 
	 * to work around bugs in some JS interpreters.
	 */
	function add(x, y) //Namespace Required
	{
		var lsw = (x & 0xFFFF) + (y & 0xFFFF);
		var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
		return (msw << 16) | (lsw & 0xFFFF);
	}

	/*
	 * Bitwise rotate a 32-bit number to the left
	 */
	function rol(num, cnt) //Namespace Required
	{
		return (num << cnt) | (num >>> (32 - cnt));
	}

	/*
	 * Perform the appropriate triplet combination function for the current
	 * iteration
	 */
	function ft(t, b, c, d) //Namespace Required
	{
		if (t < 20) return (b & c) | ((~b) & d);
		if (t < 40) return b ^ c ^ d;
		if (t < 60) return (b & c) | (b & d) | (c & d);
		return b ^ c ^ d;
	}

	/*
	 * Determine the appropriate additive constant for the current iteration
	 */
	function kt(t) //Namespace Required
	{
		return (t < 20) ? 1518500249 : (t < 40) ? 1859775393 :
			(t < 60) ? -1894007588 : -899497514;
	}

	/*
	 * Take a string and return the hex representation of its SHA-1.
	 */
	function calcSHA1(str) //Namespace Required
	{
		var x = str2blks_SHA1(str);
		var w = new Array(80);

		var a = 1732584193;
		var b = -271733879;
		var c = -1732584194;
		var d = 271733878;
		var e = -1009589776;

		for (var i = 0; i < x.length; i += 16) {
			var olda = a;
			var oldb = b;
			var oldc = c;
			var oldd = d;
			var olde = e;

			for (var j = 0; j < 80; j++) {
				if (j < 16) w[j] = x[i + j];
				else w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
				t = add(add(rol(a, 5), ft(j, b, c, d)), add(add(e, w[j]), kt(j)));
				e = d;
				d = c;
				c = rol(b, 30);
				b = a;
				a = t;
			}

			a = add(a, olda);
			b = add(b, oldb);
			c = add(c, oldc);
			d = add(d, oldd);
			e = add(e, olde);
		}
		return hex(a) + hex(b) + hex(c) + hex(d) + hex(e);
	}

	// Generated by CoffeeScript 1.12.4

	/*
	This test renders to a canvas a whole bunch of words in 36 different
	alphabets to test which alphabets the user has installed on their computer.
	The words are kept in the 2D array called codes in their UTF-16 format
	to ensure that they aren't interpreted before it is time to render them
	The 37th string in codes is a single character that we are hoping will
	always show up as a cannot be displayed character.
	 *
	While wether the alphabet can be displayed or not is deteremined by the
	operating system, the symbol used to represent cannot be displayed is
	deteremined by the browser.  However, it does seem like it is always some
	sort of box
	 */

	(function () {
		var LanguageDetector, root, safeParseJSON;

		root = typeof exports !== "undefined" && exports !== null ? exports : this;

		safeParseJSON = function (s) {
			try {
				return JSON.parse(s);
			} catch (error) {
				return false;
			}
		};

		LanguageDetector = (function () {
			function LanguageDetector() {
				this.names = safeParseJSON('[ "Latin", "Chinese", "Arabic", "Devanagari", "Cyrillic", "Bengali/Assamese", "Kana", "Gurmukhi", "Javanese", "Hangul", "Telugu", "Tamil", "Malayalam", "Burmese", "Thai", "Sundanese", "Kannada", "Gujarati", "Lao", "Odia", "Ge-ez", "Sinhala", "Armenian", "Khmer", "Greek", "Lontara", "Hebrew", "Tibetan", "Georgian", "Modern Yi", "Mongolian", "Tifinagh", "Syriac", "Thaana", "Inuktitut", "Cherokee" ]');
				this.codes = safeParseJSON("[[76,97,116,105,110], [27721,23383], [1575,1604,1593,1585,1576,1610,1577], [2342,2375,2357,2344,2366,2327,2352,2368], [1050,1080,1088,1080,1083,1080,1094,1072], [2476,2494,2434,2482,2494,32,47,32,2437,2488,2478,2496,2479,2492,2494], [20206,21517], [2583,2625,2608,2606,2625,2582,2624], [43415,43438], [54620,44544], [3108,3142,3122,3137,3095,3137], [2980,2990,3007,2996,3021], [3374,3378,3375,3390,3379,3330], [4121,4156,4116,4154,4121,4140], [3652,3607,3618], [7070,7077,7060,7082,7059], [3221,3240,3277,3240,3233], [2711,2753,2716,2736,2750,2724,2752], [3749,3762,3751], [2825,2852,2893,2837,2867], [4877,4821,4829], [3523,3538,3458,3524,3517], [1344,1377,1397,1400,1409], [6017,6098,6040,6082,6042], [917,955,955,951,957,953,954,972], [6674,6682,6664,6673], [1488,1500,1508,1489,1497,1514], [3926,3964,3921,3851], [4325,4304,4320,4311,4323,4314,4312], [41352,41760], [6190,6179,6185,6189,6179,6191], [11612,11593,11580,11593,11599,11568,11606], [1808,1834,1825,1821,1808], [1931,1960,1928,1964,1920,1960], [5123,5316,5251,5198,5200,5222], [5091,5043,5033], [55295, 7077]]");
				this.fontSize = 9;
				this.fontFace = "Verdana";
				this.extraHeigth = 15;
				this.results = [];
			}

			LanguageDetector.prototype.begin = function () {
				var c, code, h, height, i, j, k, l, len, len1, len2, len3, len4, len5, len6, len7, m, n, o, p, ref, ref1, ref2, ref3, round, s, w, width;
				round = 0;
				this.widths = [];
				this.heights = [];
				this.support = [];
				this.test_div = document.createElement("div");
				document.body.appendChild(this.test_div);
				this.test_div.id = "WritingTest";
				ref = this.codes;
				for (i = 0, len = ref.length; i < len; i++) {
					code = ref[i];
					this.height = [];
					this.width = [];
					this.div = document.createElement("div");
					this.test_div.appendChild(this.div);
					round += 1;
					this.div.id = round;
					this.div.style.display = "inline-block";
					for (j = 0, len1 = code.length; j < len1; j++) {
						c = code[j];
						this.div.innerHTML = ("<font face = '" + this.fontFace + "' size = ") + this.fontSize + ">&#" + c + "</font>";
						this.height.push(document.getElementById(round).clientHeight);
						this.width.push(document.getElementById(round).clientWidth);
					}
					this.div.innerHTML = "";
					for (k = 0, len2 = code.length; k < len2; k++) {
						c = code[k];
						this.div.innerHTML += ("<font face = '" + this.fontFace + "' size = ") + this.fontSize + ">&#" + c + "</font>";
					}
					this.test_div.innerHTML += this.height + ";" + this.width + "<br>";
					this.heights.push(this.height);
					this.widths.push(this.width);
				}
				this.tw = this.widths.pop();
				this.sw1 = this.tw[0];
				this.sw2 = this.tw[1];
				this.sh = this.heights.pop()[0];
				ref1 = this.heights;
				for (l = 0, len3 = ref1.length; l < len3; l++) {
					height = ref1[l];
					this.passed = 0;
					for (m = 0, len4 = height.length; m < len4; m++) {
						h = height[m];
						if (h !== this.sh) {
							this.support.push(true);
							this.passed = 1;
							break;
						}
					}
					if (this.passed === 0) {
						this.support.push(false);
					}
				}
				this.writing_scripts_index = 0;
				ref2 = this.widths;
				for (n = 0, len5 = ref2.length; n < len5; n++) {
					width = ref2[n];
					for (o = 0, len6 = width.length; o < len6; o++) {
						w = width[o];
						if (this.support[this.writing_scripts_index] === false) {
							if (w !== this.sw1 && w !== this.sw2) {
								this.support[this.writing_scripts_index] = true;
							}
						}
					}
					this.writing_scripts_index += 1;
				}
				this.res = [];
				this.writing_scripts_index = 0;
				ref3 = this.support;
				for (p = 0, len7 = ref3.length; p < len7; p++) {
					s = ref3[p];
					this.test_div.innerHTML += this.names[this.writing_scripts_index] + ": " + s + " <br>";
					if (s === true) {
						this.res.push(this.names[this.writing_scripts_index]);
					}
					this.writing_scripts_index += 1;
				}
				this.test_div.remove();
				return this.res;
			};

			return LanguageDetector;

		})();

		_GP.get_writing_scripts = function () {
			var detector;
			detector = new LanguageDetector;
			return this.res = detector.begin();
		};

	}).call(this);

	//var ip_address = "127.0.0.1:5000";
	var ip_address = "k14trdr017.execute-api.ap-southeast-1.amazonaws.com/default"; //Namespace Required
	//var ip_address = "sec.uniquemachine.org";
	//var ip_address = "aws.songli.us:5000";

	function populateFontList(fontArr) {  //Namespace Required
		fonts = [];
		for (var key in fontArr) {
			var fontName = fontArr[key];
			fontName = fontName.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
			fonts.push(fontName);
		}

		_GP.sender.addFonts(fonts);
	}

	function getResolution() { //Namespace Required
		var zoom_level = detectZoom.device();
		var fixed_width = window.screen.width * zoom_level;
		var fixed_height = window.screen.height * zoom_level;
		var res = Math.round(fixed_width) + '_' + Math.round(fixed_height) + '_' + zoom_level + '_' + window.screen.width + "_" + window.screen.height + "_" + window.screen.colorDepth + "_" + window.screen.availWidth + "_" + window.screen.availHeight + "_" + window.screen.left + '_' + window.screen.top + '_' + window.screen.availLeft + "_" + window.screen.availTop + "_" + window.innerWidth + "_" + window.outerWidth + "_" + detectZoom.zoom();
		return res;
	}

	var Sender = function () {   //Namespace Required
		this.finalized = false;
		this.postData = {
			fontlist: "No Flash",
			fonts: "",
			WebGL: false,
			inc: "Undefined",
			gpu: "Undefined",
			hash: "Undefined",
			timezone: "Undefined",
			resolution: "Undefined",
			plugins: "Undefined",
			cookie: "Undefined",
			localstorage: "Undefined",
			manufacturer: "Undefined",
			gpuImgs: {},
			adBlock: "Undefined",
			cpu_cores: "Undefined",
			canvas_test: "Undefined",
			audio: "Undefined",
			langsDetected: [],
			video: []
		};

		sumRGB = function (img) {
			var sum = 0.0;
			for (var i = 0; i < img.length; i += 4) {
				sum += parseFloat(img[i + 0]);
				sum += parseFloat(img[i + 1]);
				sum += parseFloat(img[i + 2]);
			}
			return sum;
		};

		this.addFonts = function (fonts) {
			this.postData['fontlist'] = fonts;
		};

		this.nextID = 0;
		this.getID = function () {
			if (this.finalized) {
				throw "Can no longer generate ID's";
				return -1;
			}
			return this.nextID++;
		};

		function hashRGB(array) {
			var hash = 0, i, chr, len, j;
			if (array.length === 0)
				return hash;
			for (i = 0, len = array.length; i < len; i += 4) {
				for (j = 0; j < 3; ++j) {
					chr = array[i] | 0;
					hash ^= (((hash << 5) - hash) + chr + 0x9e3779b9) | 0;
					hash |= 0; // Convert to 32bit integer
				}
			}
			return hash;
		};

		function sumRGB(array) {
			var sum = 0;
			for (var i = 0; i < array.length; i += 4) {
				sum += array[i + 0];
				sum += array[i + 1];
				sum += array[i + 2];
			}
			return sum;
		}

		this.addFonts = function (fonts) {
			this.postData['fontlist'] = fonts;
		};

		this.nextID = 0;
		this.getID = function () {
			if (this.finalized) {
				throw "Can no longer generate ID's";
				return -1;
			}
			return this.nextID++;
		};

		this.getIDs = function (numIDs) {
			var idList = [];
			for (var i = 0; i < numIDs; i++) {
				idList.push(this.getID());
			}
			return idList;
		};

		this.postLangsDetected = function (data) {
			//this.postData['langsDetected'] = data;
		};

		this.getDataFromCanvas = function (ctx, id) {
			if (!this.finalized) {
				throw "Still generating ID's";
				return -1;
			}
			function hash(array) {
				var hash = 0, i, chr, len;
				if (array.length === 0)
					return hash;
				for (i = 0, len = array.length; i < len; i++) {
					chr = array[i] | 0;
					hash ^= (((hash << 5) - hash) + chr + 0x9e3779b9) | 0;
					hash |= 0; // Convert to 32bit integer
				}
				return hash;
			}
			var w = 256, h = 256;
			// Send pixels to server
			var pixels = ctx.getImageData(0, 0, w, h).data;
			var hashV = hash(pixels);
			//console.log("CTX: " + hashV);

			this.toServer(false, "None", "None", hashV, id, pixels);
			if (sumRGB(pixels) > 1.0) {
				return hashRGB(pixels);
			} else {
				return 0;
			}
		};

		this.getData = function (gl, id) {
			if (!this.finalized) {
				throw "Still generating ID's";
				return -1;
			}
			var WebGL = true;
			var pixels = new Uint8Array(256 * 256 * 4);
			gl.readPixels(0, 0, 256, 256, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
			var ven, ren;
			var debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
			if (debugInfo) {
				ven = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
				ren = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
			} else {
				//console.log("debugInfo is not accessable");
				ven = 'No debug Info';
				ren = 'No debug Info';
			}
			var hash = pixels.hashCode();
			////console.log("gl: " + hash);

			this.toServer(WebGL, ven, ren, hash, id, pixels);
			if (sumRGB(pixels) > 1.0) {
				return hashRGB(pixels);
			} else {
				return 0;
			}
		};

		this.urls = [];
		this.finished = 0;

		this.toServer = function (
			WebGL, inc, gpu, hash, id,
			dataurl) { // send messages to server and receive messages from server

			this.postData['gpuImgs'][id] = dataurl.hashCode();

			if (WebGL) {
				this.postData['WebGL'] = WebGL;
				this.postData['inc'] = inc;
				this.postData['gpu'] = gpu;
				this.postData['hash'] = hash;
			}
		};

		this.sendData =
			function () {
				$('#status').html("Getting Fonts (This may take a long time)");

				this.fontsData = "";
				var fonts = ['Segoe WP', 'FreeMono', 'Heiti TC Light', 'VNI-Kun', 'Liberation Serif', 'Dotum', 'ML-TTVeenaHeavy', 'Brandon Grotesque Light', 'Adobe Hebrew Italic', 'MMa Etc Bold', 'Toledo', 'Ubuntu Mono derivative Powerline', 'Hannotate TC Regular', 'Droid Sans Thai', 'Cambria Italic', 'Abadi MT Condensed Extra Bold', 'Barrio', 'ML-TTVishu', 'MMa VariableB S', 'BurigangaSushreeOMJ', 'Pegypta', 'Avenir Next Condensed', 'TitilliumText22L-Bold', 'Corbel Bold Italic', '.VnCourier New', 'Trajan Pro 3 Bold', 'Futura LT Condensed Light', 'FML-TTAmbili', 'dbldwrsw', 'PingFang HK Light', 'Soho Gothic Pro Italic', 'Tele-Marines', 'Cronos Pro', 'Noto Sans Brahmi', 'HANA', 'VNI Times', 'Rakesly El', 'WP MultinationalA Roman', 'HGSHeiseiKakugothictaiW5', 'Avenir Next W1G Medium', 'Segoe UI Semibold', 'Cambria Bold Italic', 'Futura Std Book', 'New Renex Terminal', 'HGSHeiseiKakugothictaiW9', 'KufiStandardGK Regular', 'VNI-Bodon-Poster', 'eurb9', 'MrsEavesRoman', 'WP Greek Century', 'STIXNonUnicode', 'Songti SC Bold', 'Kaushan Script', 'OpenSymbol', 'FML-TTJyotsna', 'EngraverTime', 'Charter Black Italic', 'Arno Pro', 'Tahoma Negreta', 'Century Schoolbook L', 'Circular Std Book Italic', 'Tall Boy 3D', 'Egyptian710 BT', 'ML-NILA03', 'ML-NILA02', 'ML-NILA01', 'Petrucci', 'Waseem Regular', 'ML-NILA06', 'ML-NILA05', 'NORMAL', 'eusm8', 'Z@R120A.tmp', 'Gulim', 'cmtcsc10', 'Merriweather Italic', '.VnSouthernH', 'Lantinghei TC Heavy', 'Bangla Sangam MN', 'C-Medium', 'Nightclub BTN UltraCn', 'GoraiOMJ', 'Avenir Next Ultra Light', 'Myanmar Sangam MN', 'Matisse ITC', 'Droid Sans Mono Dotted for Powerline', 'Optima Italic', 'TitilliumText22L-Regular', 'Sketch Rockwell', 'MelodBold', 'cmsl10', 'Zapfino', 'cmsl12', 'Linux Libertine Display O', 'Manorama', 'DecoType Naskh Special', 'Caviar Dreams Bold Italic', 'Sauce Code Powerline', 'Courier New CE', 'BurigangaSushreeMJ', 'Aileron', 'Hiragino Sans', 'Smooth', 'MMCenturyOldGreek', 'Microsoft NeoGothic', 'Atzur', 'GLYPHICONS Halflings', 'Trattatello', 'LT-TM-Lakshman', 'Playbill', 'TeX Gyre Chorus', 'Myriad Pro SemiCondensed', 'Marlett', 'Open Sans Extrabold', 'Chaparral Pro Bold', 'GrilledCheese BTN Cn', 'Bitstream Charter', 'Noto Sans Tai Viet', 'Georgia Pro SemiBold', 'Rotis Sans Serif Std 56 Italic', 'ITF Devanagari Marathi Demi', 'Avenir Next W1G Thin', 'Priori Serif OT', 'Times Bold Italic', 'BurigangaKamalaOMJ', 'Literation Mono Powerline Italic', 'Quickpen', 'AR BONNIE', 'Caviar Dreams', 'Avenir Roman', 'Pujeeta', 'Deepak', 'cmmi12', 'FML-TTSankara', 'Bookman Old Style Italic', '.VnArial', 'Antonio', 'Linowrite', 'GFS Gazis', 'FordLineDraw', 'ConcursoItalian BTN Wide', 'MMa CenturySS', 'Laksaman', 'Segoe Marker', 'Monotype Sorts', 'Bienhoa', 'Noto Sans Syriac Eastern', 'Caviar Dreams Bold', 'MMa Arrow Bold Italic', 'Diavlo Black', 'Garamond', 'Proxima Nova', 'BhairabOMJ', 'WP Phonetic', 'Myriad Pro', 'VNI-Fato', 'Myriad Pro Bold', 'MMVariableF Bold', 'Julius Sans One', 'EuroRoman', 'cmcsc9', 'cmcsc8', 'LaurenScript', 'VNI-Commerce', 'Freebooter Script', 'Math5', 'Party LET', '.VnHelvetIns', 'American Typewriter', 'Roboto Mono Bold Italic for Powerline', 'Vineta BT', 'ML-TTPooram', 'MMa Extra Bold', 'Quangngai', 'MT Extra', 'TAM', 'Terminal Greek 737 (437G)', 'TITUS Cyberbit Basic', 'Kalakaumudi', 'Adobe Gurmukhi', 'HanziPen SC', 'cmff10', 'Praxis', 'FML-TTVishu', 'Microsoft MHei', 'VNI Greece', 'Sukhumvit Set Semi Bold', 'Swiss 721 Roman', 'Soho Gothic Pro Ultra Italic', 'STLiti', 'Marquisette BTN Light', 'Arimo Bold Italic for Powerline', 'ML-TTJaya', 'eusm9', 'Simplified Arabic', 'Kohinoor Devanagari Light', 'MS PMincho', 'Century Gothic Italic', 'HariSree', 'MyriadPro-Semibold', 'IPAexGothic', 'MS Reference Serif', 'eusm7', 'HelveticaNeueLT Pro 97 BlkCn', 'Quicksand Bold', 'Yu Mincho', 'VNI-Murray', 'ChandrabatiMJ', 'Sitka Banner', 'MMCenturyOldGreek Italic', '.VnCommercial ScriptH', 'Interstate-Regular', 'Arimo Bold Italic', 'Latienne Pro', 'TAC-Valluvar', 'FML-Nanditha', 'MMa VariableF Bold', 'Tekton Pro Bold', 'Noto Serif', 'AmdtSymbols', 'Euclid Symbol', 'Songti SC Regular', 'Cambria Bold', 'Leelawadee', 'Meslo LG S DZ Regular for Powerline', 'Nexa Light', 'Party LET Plain:1.0', 'Minion Pro SmBd', 'AV-Font-Kan1', 'Clarendon Cn BT', 'Yu Mincho Demibold', 'Hypatia Sans Pro Semibold', 'Consolas', 'Seravek Bold Italic', 'Nightclub BTN Cn', 'Myriad Arabic Italic', 'Charter Roman', 'spinwerad', 'Gill Sans Nova Cond Ultra Bold', 'KG Corner of the Sky', 'DecoType Naskh Extensions', 'MLB-TTAmbili', 'YuMincho ', 'Futura LT Light', 'Latin Modern Roman', 'Gotham Narrow Black Italic', 'DIN-Light', 'VNI-Top', 'DotumChe', 'Giolinh', 'Muna Black', 'Apple Boy BTN', 'Clarendon BT', 'DINPro-Light', 'Playfair Display SC Black', 'Quixley LET', 'MMa Pascal Bold', 'Interstate-Light', 'American Typewriter Condensed Bold', 'Skia Condensed', 'Latienne Pro Bold', 'lcircle10', 'ML-IndulekhaHeavy', 'Source Serif Pro Semibold', 'Tamburo', 'Halong', 'Normande Italic', 'VNI-Book', 'MMa Extra Italic', 'Heavy', 'MMBinary', 'PondAllRounder', 'Euphemia UCAS Bold', 'Avenir Book Oblique', 'HP Simplified Light', 'HGSHeiseiKakugothictaiW3', 'Gill Sans Light', 'VNI-Garam', 'AlekyaMedium', 'Hebar', 'Stone Sans Sem ITC TT', 'DV1-TTYogesh', 'Adobe Arabic', 'Rosewood Std Regular', 'Marquisette BTN Lined', 'Gotham Book', 'Sukhumvit Set Medium', '.VnTeknicalH', 'Z@R1762.tmp', 'MMa Gauss Bold', 'Avenir Next Condensed Demi Bold', 'Trebuchet MS Bold Italic', 'TlwgMono', 'Avenir Next W1G Bold', 'Flubber', 'Opus Figured Bass', 'Futura LT Heavy Oblique', 'Hiragino Mincho ProN', 'Nova Oval', 'Bangla MN', 'Opus Function Symbols', 'Microsoft JhengHei Light', 'STIXSizeOneSym', 'Magic School Two', 'Type Embellishments One LET Embellishments One LET Plain:1.0', 'Avenir Next Heavy', 'Sylfaen', 'Palatino Bold', 'Rockwell Extra Bold', 'Candara Italic', 'Gujarati MT Bold', 'Vinhan', '.VnBahamasBH', 'SaiVrishin', 'AR ESSENCE', 'Frankfurter Venetian TT', 'Gillius ADF Cd', 'Mishafi Gold', 'System Font Medium', 'Roboto Mono Medium for Powerline', 'SF Distant Galaxy', 'Monotype.com', 'MMTextBook Bold', 'Gill Sans MT Italic', 'Tlwg Typewriter', 'Soho Gothic Pro ExtraBold', 'Gill Sans Ultra Bold', 'STIXSizeTwoSym-Bold', 'BaluBrush', 'System Font Bold', 'Roboto Light Italic', 'Times New Roman (Arabic)', 'Maestro Wide', 'Bickham Script Pro 3 Semibold', 'STXingkai', 'Annie BTN', 'AtraiOMJ', 'Aileron SemiBold', 'cmsy7', 'Bookshelf Symbol 3', 'Orator Std', 'Swis721 BdCnOul BT', 'Proxima Nova Bold', 'Shree Devanagari 714 Bold Italic', 'WP MultinationalA Helve', 'Noto Sans', 'Lucida Sans Italic', 'Phosphate Solid', 'Damascus', 'DengXian Light', 'Notram', 'Bordeaux Roman Bold LET Plain', 'Lantinghei SC Heavy', 'MMa CenturyS Italic', 'Noto Sans Phoenician', 'System Font', 'ADMUI3Sm', 'Shree Devanagari 714 Italic', 'kroeger 06', 'Belfast Light SF', 'KacstBook', 'PingFang SC Thin', 'Humanst521 BT', 'Futura Condensed Medium', 'WP Japanese', 'Hiragino Kaku Gothic Std W8', 'GaneshBold', 'Open Sans Italic', 'Aileron Bold', 'Euphemia UCAS', '.VnFreeH', 'Swis721 BlkOul BT', '.VnRevueH', 'Freehand521 BT', 'MMa Arrow Italic', 'Opus Chords Sans Condensed', 'OR-TTSarala', 'Montserrat Black', 'VNI-Avo', 'System Font Medium P4', 'VNI-GlabXb', 'HarvestItal', 'MMa VariableA S', 'Segoe WP Black', 'Courier10 BT', '.VnLincolnH', 'eusb5', 'Marker Felt Thin', 'KacstTitleL', 'HelveticaNeueLT Pro 107 XBlkCn', 'IBM3270', 'MLB-TTIndulekha', 'PujeetaItalic', 'Bookman Old Style Bold', 'Latin Modern Sans', 'ELEGANCE', 'GhorautraMJ', 'MMExtra Bold', 'Rockwell Nova Cond', 'Minion Pro Cond', 'Brandon Grotesque Medium', 'HGHeiseiKakugothictaiW9', 'Euphemia UCAS Italic', '.VnUniverseH', 'Avenir Book', 'ZapfHumnst Ult BT', 'Diwani Simple Striped', 'Myriad Pro Bold SemiCondensed', 'Raleway SemiBold Italic', 'Z@R1751.tmp', 'Hypatia Sans Pro Black', 'linew10', '.VnCooperH', 'Adobe Ming Std', 'BlairMdITC TT Medium', 'Levenim MT', 'Ravie', 'FML-TTIndulekhaHeavy', 'Ruach LET', 'ML-TTJyothy', 'Brush Script MT', 'Latin Modern Mono Prop', 'ML-NILA04', 'TeX Gyre Pagella', 'Roboto Slab', 'eurb7', 'PFFuelPro-Regular', 'eurb5', 'MMGreek Bold', 'Oswald Stencil Bold', 'Georgia Bold', 'Noto Serif Thai', 'Selena', 'Perpetua Titling MT Bold', 'ColdSpaghetti BTN', 'Courier Oblique', 'Dosis Medium', 'Canter Bold Shadow', 'St Marie Thin', 'FML-TTGopika', 'STIXIntegralsSm-Bold', 'MMEtc Italic', 'CHANL', 'Yu Gothic UI', 'KacstNaskh', 'VNI-Palatin', 'GFS Porson', 'ML-TTAswathi', 'Myriad Pro Condensed Italic', 'Avenir Next Italic', 'WP ArabicScript Sihafa', 'Euclid Symbol Bold', 'Myriad Pro Semibold Condensed', 'PT Bold Broken', 'Goudy Old Style Bold', 'Racing Sans One', 'Bentham', 'Gotham Book Italic', 'Asimov', 'Avenir Next W1G Light', 'Ashwariya', 'Berlin Sans FB Demi', 'Myriad Pro Light Italic', 'VNI Helve Condense', 'Songti TC Regular', 'Verdana Italic', 'Nexa XBold Italic', 'Source Sans Pro', 'Dingbats', 'Synchro LET', 'OCR-A II', 'Deneane', 'MMExtra Bold Italic', 'Wellfleet', 'Jazz LET Plain:1.0', 'STIXIntegralsSm-Regular', 'MMa CenturyK', 'Javanese Text', 'Nova Script', 'Arial Hebrew Bold', 'PCMyungjo Regular', 'Bhuma', 'MMa CenturyS', 'Quicksand Dash', 'Gloucester MT Extra Condensed', 'Montserrat Bold', 'Jokerman Alts LET', 'Floraless', 'SF Compact Rounded Semibold', 'URW Gothic L', 'BadaBoom BB', 'Microsoft YaHei', 'Cantarell Oblique', 'Brush Script MT Italic', 'Raanana Bold', '.VnArialH', 'IPAPGothic', 'BN-TTDurga', 'Times New Roman', 'WP MultinationalB Courier', 'Germanica', 'Paralucent Demi Bold Italic', 'Proxima Nova Soft Medium', 'Myriad Hebrew Bold', 'Telugu MN Bold', 'WP MathA', 'Proxima Nova Condensed Light Italic', 'IDAutomationPDF417n5', 'Algerian', 'Times New Roman Greek', 'FML-TTKaumudi', 'SF Compact Rounded Bold', 'Tinos Bold Italic for Powerline', 'Lantinghei TC', 'Stylus BT', 'Soho Gothic Pro Medium', 'Microsoft Tai Le', 'Broken Planewing', 'MMa Relation Bold Italic', 'MMCenturyNew Bold Italic', 'Droid Sans Ethiopic', '3M Circular TT Bold', 'IDAutomationPDF417n2', 'Lato Black Italic', 'Liberation Sans', 'Sofia', 'Paralucent Light Italic', 'Geeza Pro', 'Dancing Script', 'DholeshwariMJ', 'eufm10', 'Century Schoolbook', 'Palatino Linotype Bold', 'Candy Round BTN', '12x10', 'Rupee Foradian', 'SchoolHouse Cursive B', 'Stone Sans Sem ITC TT Semi', 'Coda', 'Sneakerhead BTN Condensed', 'Merriweather Light Italic', 'Academy Engraved LET', 'System Font Ultralight', 'Akshar Unicode', 'Helvetica', 'Lato Italic', 'Kohinoor Bangla Medium', 'ChandrabatiMatraOMJ', 'Futura LT Bold', 'Helvetica Bold', 'Batang', 'Arvo', 'Coolvetica', 'Gill Sans MT Ext Condensed Bold', 'AR BLANCA', 'PingFang HK Regular', 'Arial Narrow Italic', 'cmtex9', 'cmtex8', 'Chalkboard SE', 'Fren', 'MMa Negate S', 'Minion Pro Medium Italic', 'Meiryo UI', 'SWED', 'ITF Devanagari Marathi Light', 'athletic', 'Pointedly Mad', 'Farsi Simple Outline', 'Yuppy TC', 'Noto Sans Lao UI', '.VnShelley Allegro', 'Quinhon', 'Courier Bold', 'Carrois Gothic SC', 'FangSong', 'PT Serif Bold Italic', 'ML-TTKanika', 'Avenir Next W1G Regular', 'GrilledCheese BTN Toasted', 'QuiverItal', 'Kanalisirung', 'FML-TTJaya', 'HelveticaNeueLT Pro 53 Ex', 'Cut Me Out', 'Khmer MN Bold', 'Skia Light', 'Garamond Italic', 'GothicG', 'Autour One', 'Opus PlainChords', 'Symbol Tiger', 'Lucida Fax Demibold', 'Athelas', 'Linux Libertine Initials O', 'STIXIntegralsUp-Bold', 'MMa VariableD SS', 'VNI-Aztek', 'MLW-TTKarthika', 'ML-TTChithira', 'Superclarendon Regular', 'Z@R185D.tmp', '.VnPresent', 'Snell Roundhand', 'MMa Etc Italic', 'ADMUI3Lg', 'Brandon Grotesque Black', 'Avenir Next Condensed Italic', 'Circular Std Black', 'Futura LT Extra Bold Oblique', 'KanchanOMJ', 'cmcsc10', '.VnCommercial Script', 'Segoe UI', 'Mathilde', 'GangaSagarMJ', 'Nunito Light', 'Code39AzaleaRegular3', 'Code39AzaleaRegular2', 'MMa Variable', 'STIXSizeTwoSym-Regular', 'Arabic Transparent', 'Kufi Extended Outline', 'Myriad Pro Bold SemiExtended Italic', 'Titillium Thin Italic', 'Aileron Heavy', 'Noto Serif Lao', 'Web Serveroff', 'Gautami', 'Sauce Code Powerline Bold', 'Yuanti TC Bold', 'Noto Sans Bamum', 'Calisto MT Italic', 'Myriad Arabic Bold Italic', 'uni 05', 'Noto Sans Runic', 'Sue Ellen Francisco', 'Hiragino Mincho Pro', 'GENUINE', 'FML-TTVarsha', 'Lucida Grande', 'Playfair Display SC Black Italic', 'Avenir Heavy Oblique', 'GaneshExtraBold', 'MMa CenturySS Bold', 'STIXSizeThreeSym-Bold', 'Kozuka Gothic Pro', 'KalegongaMJ', 'Lucida Sans Typewriter Regular', 'Judson', 'YuMincho  36p Kana Demibold', 'FML-TTVisakham', 'Trade Gothic LT Std Condensed No. 18 Oblique', 'Myriad Pro Semibold SemiCondensed', 'Segoe UI Emoji', 'Ubuntu Mono', 'Traditional Arabic', 'ChitraOMJ', 'DejaVu Sans Mono Bold Oblique for Powerline', 'Noto Sans Avestan', 'Piranesi It BT', 'PrimaSans BT', 'Mshtakan Oblique', 'Adamsky SF', 'Roboto Thin', 'Reklame Script Regular', 'Lato Regular', 'Myriad Arabic', 'Vollkorn Bold', 'New Peninim MT Inclined', 'HGHangle', 'Desdemona', 'KievitPro-Regular', 'Arno Pro Smbd SmText', 'Rotis Sans Serif Std 55 Regular', 'SimSun', 'Gill Sans Bold', 'Euclid Bold', 'Charter Black', '.VnMysticalH', 'Rakesly Ul', 'Vogue-ExtraBold', 'ITAN', 'Mishafi Regular', '.VnRevue', 'Mishafi', 'Old Antic Decorative', 'Sukhumvit Set Light', 'Photoshop Small', 'Pristina', 'TAU-Kambar', 'Magic School One', 'Trajan Pro 3', 'Corbel', 'Rage Italic LET', 'Constantia', 'Gill Sans MT Condensed', 'cmfib8', 'Xirod', 'Euphemia', 'Nimbus Sans L', 'Sacred Geometry', 'ELANGO-TML-Panchali-Normal', 'Georgia', 'Gill Sans MT Bold', 'Droid Sans Hebrew', 'CL', 'MMa Extra SS', 'HelveticaNeueLT Pro 75 BdOu', 'FML-TTAswathi', 'NATURALBORN', 'Pleasantly Plump', 'Blackletter686 BT', 'Bodoni MT Poster Compressed', 'Yuppy SC Regular', 'Arno Pro Smbd', 'Engl', 'Times New Roman Cyr', 'Gill Sans MT Bold Italic', 'Myriad Pro Light SemiCondensed', 'YuMincho Demibold', 'Canter Light', 'Broadway Copyist Text Ext', 'Marquisette BTN', 'Nova Cut', 'Rumburak', 'PT Bold Heading', 'TeX Gyre Termes', 'Dollar', 'System Font Regular', 'SWItalc', 'Noto Sans Devanagari', 'AV-Font-Hin1', 'DejaVu Sans Condensed', 'Huxley Titling', 'Roboto Bold', 'Noto Sans Cypriot', 'HelveticaNeueLT Pro 25 UltLt', 'Distant Galaxy', 'Nueva Std Italic', 'SWItalt', 'HELTERSKELTER', 'Adobe Gothic Std', 'Avenir Next W1G Italic', 'KacstTitle', 'Symap', 'Utsaah', 'Ancuu', 'cmmib7', 'Chaparral Pro Italic', 'STIXGeneral-BoldItalic', 'MMNegate Bold Italic', 'Birch Std', 'Silom', 'Futura Light BT', 'Felix Titling', 'Leelawadee UI', 'Proxy 7', 'Proxy 6', 'Proxy 5', 'Proxy 4', 'Proxy 3', 'MT Extra Tiger', 'Proxy 1', 'Clarendon Hv BT', 'Lantinghei TC Demibold', 'Stone Sans ITC TT Bold', 'Accord SF', 'Book Antiqua Italic', 'ML-TTNarmadaExBold', 'Proxy 9', 'Proxy 8', 'Bodoni MT', 'Bookman Old Style', 'Futura Medium BT', 'YuMincho', 'Lucida Blackletter', 'Noto Sans Gujarati', 'Z@R13D5.tmp', 'Belfast SF', 'Yu Gothic UI Light', 'Noto Sans Linear B', 'kroeger 05', 'Myriad Pro Semibold Condensed Italic', 'Futura Condensed ExtraBold', 'Roboto Regular', 'Broadway BT', 'LeviBrush', 'Verdana Pro Cond Black', 'Segoe Script', 'Bebas Neue Light', 'Yuanti SC', 'Futura Std Medium Condensed', 'Diwan Thuluth', 'EngraverTextH', 'cmmi10', 'HelveticaNeueLT Pro 47 LtCn', 'Verdana Bold Italic', 'Proxima Nova Rg', 'Lucida Fax Regular', 'System Font Medium Italic', 'Didot Bold', 'Hack Bold Italic', 'Segoe UI Light', 'Lucida Fax', 'HelveticaNeueLT Std', 'Segoe WP Semibold', 'Constantia Bold', 'Futura LT Medium Oblique', 'VNI-Univer', 'TAM-Shree800', 'EngraverTextT', 'Baby Kruffy', 'David Transparent', 'Calibri', 'HGSHeiseiMinchotaiW3', 'Fira Mono Medium for Powerline', 'Perpetua Titling MT', 'PT Sans Narrow Bold', 'header 08', 'Mesquite Std', 'HucklebuckJF', 'MANDELA', 'KacstArt', 'MMa Arrow S', 'Gridnik', 'Adobe Gurmukhi Bold', 'Noto Sans Lao', 'cmsy10orig', 'Asana Math', 'Adobe Caslon Pro Semibold Italic', '.VnPresentH', '.VnClarendonH', 'Lao MN Bold', 'Titillium Thin', 'Vivian', 'RomanD', 'ISOCP2', 'Logo3Mv3tt', 'MS Gothic', 'QTOptimum Bold', 'Baghdad', 'Cantarell Bold', 'Myriad Pro SemiExt', 'American Typewriter Light', 'Avenir Next W1G Thin Italic', 'Libian SC', 'Sitka Small', 'Noto Sans Saurashtra', 'Averia Sans', 'Interstate-Bold', 'Tw Cen MT Bold', 'wgl4', 'Bank Gothic', 'eusb10', 'AlekyaThin', 'Gujarati Sangam MN', 'HelveticaNeueLT Pro 65 Md', 'SaiIndira', 'Gill Sans', 'IrisUPC', 'RomanS', 'MMa CenturyKS Bold Italic', '58', 'VNtimes new roman', 'MMa Binary Italic', '55', 'Holiday Springs BTN', '57', 'Roboto Mono Thin for Powerline', '51', 'Adobe Gothic Std B', '52', 'HelveticaNeueLT Std Cn', 'Noto Sans Gurmukhi', 'PT Mono Bold', 'Bastion', 'FML-TTChithira', '54', 'Lohit Tamil', 'Yellowtail', 'VNI-Helve', 'Diwani Simple Outline 2', 'ML-TTIndulekha', 'Incised901 Ct BT', ('cursive', 'monospace', 'serif', 'sans-serif', 'fantasy', 'default', 'Arial', 'Arial Black', 'Arial Narrow', 'Arial Rounded MT Bold', 'Bookman Old Style', 'Bradley Hand ITC', 'Century', 'Century Gothic', 'Comic Sans MS', 'Courier', 'Courier New', 'Georgia', 'Gentium', 'Impact', 'King', 'Lucida Console', 'Lalit', 'Modena', 'Monotype Corsiva', 'Papyrus', 'Tahoma', 'TeX', 'Times', 'Times New Roman', 'Trebuchet MS', 'Verdana', 'Verona'), '56', 'Calligraffitti', 'Eurostile Bold', 'Rockwell Nova Extra Bold', 'Gill Sans Italic', 'Nyala', 'SF Compact Rounded Regular', 'System', 'SWMeteo', 'GothicI', 'Chewy', '53', 'Lato Thin', 'TeX Gyre Bonum', 'URW Bookman L', 'Hannotate SC Regular', 'ElegantIcons', 'MMa CenturyK Italic', 'GROBOLD', 'Bookshelf Symbol 2', 'PingFang TC Light', 'Playfair Display SC', 'Century Schoolbook Bold', 'Apple SD Gothic Neo UltraLight', 'Napa SF', 'cnefonts', 'STIXIntegralsUp', 'Corsiva Hebrew Bold', 'Zapfino Extra LT Ligatures', 'Stencil Std', 'Type Embellishments One LET', 'Iowan Old Style Bold', 'Lucida Sans Typewriter Bold Oblique', 'Myriad Pro Regular', 'Bell Gothic Std Bold', 'Bodoni 72 Oldstyle Bold', 'IchamotiOMJ', 'AV-Font-Ben1', 'STIXGeneral', 'Gujarati Sangam MN Bold', 'Adobe Caslon Pro Semibold', 'Mallige', 'VNI-Bazooka', 'Perpetua Bold', 'Roboto Condensed Italic', 'MMa Etc Bold Italic', 'Avenir Black Oblique', 'Muli Light Italic', 'Padauk Book', 'PT Mono', 'Museo Sans 300', 'Browallia New', 'Code39AzaleaRegular1', 'STIXSizeOneSym-Bold', 'MMExtra Italic', 'Rundkursiv', 'Times New Roman Bold Italic', 'Calisto MT', 'OldDreadfulNo7 BT', 'Bitstream Vera Serif', 'Cousine Italic for Powerline', 'Freehand', 'Roboto Italic', 'Droid Serif', 'Lato Thin Italic', 'MMCenturyOld', 'VAGRounded BT', 'Digital Readout Upright', 'Noto Sans Glagolitic', 'Old Antic Outline', 'Bickham Script Pro 3 Bold', 'AlternateGothic2 BT', 'Enliven', 'Kohinoor Telugu Medium', 'ESTO', 'Noto Sans Lisu', 'Smarty Pants BTN', 'Syastro', 'Microsoft JhengHei', 'WP TypographicSymbols', 'Kristi', 'Hoefler Text Ornaments', 'Courier New CYR', 'Albany AMT', 'Granjon Bold', 'Inconsolata', 'Sorts Mill Goudy', 'MMa VariableC S', 'cmbsy6', 'Noto Sans Osmanya', 'Farsi Simple Bold', 'GreekS', 'cmbsy7', '.VnKoalaH', 'DhonooOMJ', 'Niagara Solid', 'cmbsy8', 'Euclid Math One Bold', 'Swiss 721', 'Ubuntu', 'GreekC', 'VNI-Bandit', 'URW Palladio L', 'YuMincho  36p Kana', 'Sanpya', 'MMa GreekSS', 'eufm9', 'AvantGarde Md BT', 'Weibei TC', 'Myriad Pro Black SemiExtended Italic', 'Bebas Neue Book', 'Menlo Bold Italic', 'eufm5', 'Soho Gothic Pro Thin Italic', 'NBP Informa FiveThree', 'Noto Serif Armenian', 'DejaVu Sans Mono Bold for Powerline', 'Trade Gothic LT Std Oblique', '.VnBook-Antiqua', 'Humanst521 XBd BT', 'Diavlo Bold', 'WP CyrillicA', 'WP CyrillicB', 'ITF Devanagari Medium', 'Franklin Gothic Medium', 'FML-TTChithiraHeavy', 'ML-TTDevika', 'Superclarendon Light', 'balonez fantasia', 'Sitka Text', 'Tw Cen MT Condensed Extra Bold', 'Skia Black', 'cmbx12', 'ML-TTKamini', 'Alegreya Sans SC', 'Linux Libertine Display G', 'Italic', 'PT Sans Bold', 'Opus Special Extra', 'Ebrima', 'Gurmukhi Sangam MN', 'FML-TTOnam', 'ML-TTRevathi', 'Hiragino Mincho Pro W3', 'BongshaiMJ', 'Adobe Hebrew', 'Heiti SC', 'Optima ExtraBlack', 'Hiragino Mincho Pro W6', 'Kundli English', 'Luminari', ' 20', 'Courier MM Screenwriter Italic', 'HelveticaNeue MediumCond', 'Swiss 721 Extended', 'cmmi8', 'GFS Didot Classic', 'Myriad Pro Light Condensed', 'PoetsenOne', 'Helvetica Neue Light', 'monooge 05', 'cmmi7', 'cmmi6', 'cmmi5', 'Tiger Expert', 'Latin Modern Mono Caps', 'Learning Curve Pro', 'RamuScriptMedium', 'Source Sans Pro Semibold Italic', 'cmmib10', 'KabinLightDB Bold', 'ParvathiThin', 'Belwe Bd BT', 'DV-TTYogesh', 'Russel Write TT', 'DINPro-Black', 'GaneshBlack', 'Carbon Block', 'Romantic', 'Valerie Hand', 'Harrington Bold', 'Bauer Bodoni Std 1 Roman', 'AV-Font-Symbol', 'Papyrus', 'Palatino Bold Italic', 'Nanum Brush Script', 'Noto Sans Egyptian Hieroglyphs', 'Paralucent ExtraLight Italic', 'Proxima Nova Semibold', 'SF Slapstick Comic Shaded Oblique', 'Prestige Elite Std Bold', 'FML-TTVaisali', 'ITF Devanagari Marathi Medium', 'Arial Hebrew Scholar', 'Lohit Gujarati', 'FML-TTChandrika', 'Calisto MT Bold Italic', 'SignPainter-HouseScript Semibold', 'MS Serif', 'Nirmala UI', 'Hiragino Kaku Gothic ProN W6', 'HelveticaNeueLT Pro 57 Cn', 'Hiragino Kaku Gothic ProN W3', 'Skia Light Condensed', 'LT-ET-Ramya', 'WenQuanYi Micro Hei Mono', 'ML-TTAshtamudi', 'Bank Gothic Light', 'EngraverFontExtras', 'Swiss 721 Condensed', 'PT Sans Caption', 'Georgia Pro Cond Black', 'Noto Sans Tifinagh', 'Latin Modern Roman Demi', 'News Gothic MT', 'Open Sans Semibold Italic', 'Snell Roundhand Bold', 'VNI-Stylus', 'GaneshNarrow', 'Gotham', 'DhorolaOMJ', 'Elephant', 'Seravek Bold', 'mixtapeMike', 'Pacifico', 'Perpetua Bold Italic', 'Gayathri', 'MMa Variable Bold', 'Kannada Sangam MN', 'croissant sandwich', 'TSCu', 'CSongGB18030C-Light', 'Nixie One', 'Myriad Pro Black Italic', 'TG Termes Math', 'Kaiti TC Regular', '0', 'Bree Serif', 'C-MediumHWL', 'YuGothic Medium', 'System Font Bold Italic G3', 'ML-TTOnam', 'Trocchi', 'Noto Sans Kharoshthi', 'Gill Sans Nova Cond', 'Abril Fatface', '36p Kana Medium', 'cmdunh10', 'Merriweather Bold', 'MMa Fermat Bold', 'MMa CenturyK Bold', 'TitilliumText22L-Thin', 'TLUrdu', 'MLB-TTAswathi', 'Rocket Arabic Fixed', 'American Typewriter Condensed Light', 'John Handy LET', 'Gill Sans SemiBold', 'Tuyenduc', 'System Font Semibold Italic', 'Nexa Thin Italic', 'MMExtra', 'VNI-Park', 'Gen W01 Light', 'Futura Heavy Oblique', 'SymbolProp BT', 'Cantarell Regular', 'FML-Leela', 'Avenir Next W1G Heavy', 'STIXIntegralsUpSm', 'KalindiMJ', 'Garamond Premr Pro', 'msam9', 'HelveticaNeueLT Std Blk Cn', 'Lato Hairline', 'KG Neatly Printed', 'Proxima Nova Semibold Italic', 'Gravur Condensed Light', 'Webdunia', 'msam7', 'Times New Roman TUR', 'msam5', 'SHELMAN', 'Banmai Times', 'Bodoni 72 Oldstyle Book', 'Dosis', 'Museo Sans 100', 'Roboto Slab Regular', 'Al Nile', 'Gravity', 'LT-TM-Barani', 'Cochin Bold Italic', 'Opus', 'ML-TTChithiraHeavy', 'Rockwell Italic', 'HanziPen TC Bold', 'A Sensible Armadillo', 'Hack Italic', 'Terminator Two', 'HelveticaNeueLT Std UltLt Cn', 'Noto Sans Cuneiform', 'Yu Mincho Light', 'Gill Sans MT', 'News Gothic MT Bold', 'Avenir Next Regular', 'Ubuntu Light', 'Rouge Script', 'SWLink', 'Kalinga', 'ML-TTGuruvayur', 'Lato Bold', 'IPAexMincho', 'Chalkboard Bold', 'ABSALOM', 'Sigmar', 'Museo 500 Regular', 'Stone Sans ITC TT', 'Franklin Gothic Medium Cond', 'Geeza Pro Bold', 'Ml', 'Khmer OS', 'Futura Std Medium', 'SC', 'HelveticaNeueLT Std UltLt Ext', 'Incised901 Nd BT', 'ML-TTMangalaExBold', 'Arial Nova Cond', 'Droid Sans Fallback', 'Noto Sans Carian', 'CommercialScript BT', 'Roboto Condensed', 'Kokonor Regular', 'Kievit Offc Pro', 'Arial Hebrew Scholar Bold', 'FML-TTGuruvayur', 'Nexa Black Italic', 'Garamond Premr Pro Smbd', 'ML-TTSruthy', 'WP MathExtendedA', 'PT Sans Bold Italic', 'CSongGB18030C-LightHWL', 'Finale Copyist Text Ext', 'Kohinoor Bangla Light', 'eusm6', 'Sinhala MN', 'Soho Gothic Pro Regular', 'Open Sans Bold Italic', 'eusm5', 'Herculanum', 'ML1-TTAswathi', 'BhagirathiOMJ', 'PilGi', 'Adobe Garamond Pro Bold', 'Titillium', 'DecoType Naskh Variants', 'Wawati TC', 'Kozuka Gothic Pro R', 'BaluBold', 'SketchFlow Print', 'Opus Percussion', '.VnTeknical', 'Sniglet', 'Noto Sans Hanunoo', 'Lingoes Unicode', 'Sketch Block', 'Lato Semibold', 'Kozuka Gothic Pro B', 'Verdana Pro', 'Kozuka Gothic Pro M', 'Kozuka Gothic Pro L', 'Kozuka Gothic Pro H', 'Bodoni 72', 'VNI-Swiss-Condense', 'Book Antiqua', 'Roboto Mono for Powerline', 'SF Slapstick Comic Shaded', 'Mukti Narrow', 'Baskerville Bold Italic', '.VnArial NarrowH', 'Opus Metronome', 'Xingkai SC Light', 'Gotham Bold', 'Tiger', 'VNI-Awchon', 'Accent SF', 'Baron Neue Italic', 'Boogaloo', 'Finale AlphaNotes', 'Optima Regular', 'Apple Braille Pinpoint 8 Dot', 'IPAPMincho', 'Blackout', 'Noto Sans Old Turkic', 'Calibri Italic', 'SWRomnt', 'Edwardian Script ITC', 'MaestroTimes', 'Open Sans Light', 'SWRomns', 'Tsukushi B Round Gothic Bold', 'NanumMyeongjo Bold', 'VNI-DesdemonaU', 'Avenir Next Demi Bold Italic', 'Telugu Sangam MN', 'MMSchoolRD Bold', 'SWRomnc', 'Baoli SC', 'Leitura Display Roman', 'Savoye LET Plain:1.0', 'DIN-RegularAlternate', 'Hiragino Kaku Gothic ProN', 'HeadLineA Regular', 'Charter', 'KacstPen', 'header 17', 'Hiragino Kaku Gothic Pro W3', 'Hiragino Maru Gothic ProN', 'Adobe Naskh', 'RUMA', 'Liberation Sans Narrow', 'Corbel Bold', 'Noto Sans Tai Le', 'Valluvan', 'Soho Gothic Pro Thin', 'Modena printed', 'News Gothic MT Alt 5', 'Avenir Next Condensed Bold Italic', 'VNI-Centur', 'Avenir Next Condensed Medium', 'Palatino Linotype', 'STIXSizeFourSym-Bold', 'TAMElango', 'cmsltt10', 'Letter Gothic Std Slanted', 'Noto Sans Coptic', 'Firenze SF', 'Six Caps', 'Fira Mono', 'MS Mincho', 'Malayalam Sangam MN', 'Kohinoor Devanagari Semibold', 'Rockwell Nova', 'Chalkboard', 'Biko', 'Gurmukhi MN Bold', 'IguanaLover BTN', 'Curlz MT', 'Induction', 'FML-TTNarmadaExBold', 'Walter', 'DokChampa', 'CAC Champagne', 'Ubuntu Mono derivative Powerline Italic', '.VnVogueH', 'Myriad Pro Black', 'cnefont', 'Helvetica Neue Italic', 'Onyx', 'HERMAN', '1', 'standard 07', 'Myanmar Text', 'Deepa', 'Shree Devanagari 714', 'Balthazar', 'Klee Demibold', 'standard 09', 'Geeza Pro Regular', 'Cinema Gothic BTN Shadow', 'PT Simple Bold Ruled', 'IRIS', 'Myriad Web Pro Condensed', 'VNI-Bauhaus', 'LuzSans-Light', 'Futura Medium Oblique', 'Kailasa Bold', 'Smudger Alts LET', 'Chiller', 'VNI-Standout', 'Noto Sans Thai UI', 'eurm10', 'MMa Etc S', 'Corporate', 'Detente', 'Oriya Sangam MN', 'Adobe Devanagari Bold Italic', 'Sinhala MN Bold', 'Linux Biolinum O', 'HelveticaNeueLT Pro 27 UltLtCn', 'Jazz LET', 'Linux Biolinum G', 'Airstream', 'AR DECODE', 'Alien Encounters', 'VNI-Wide Latin', 'Tlwg Mono', 'eurm8', 'fox in the snow', 'eurm6', 'eurm7', 'Euclid', 'eurm5', 'PMingLiU-ExtB', 'Noto Sans CJK SC', 'Perpetua Titling MT Light', 'Swis721 Ex BT', 'Roboto Mono Thin Italic for Powerline', 'Garamond Premier Pro', 'gargi', 'Futura Light Condensed BT', 'Museo 700 Regular', 'Placard MT Condensed', 'Euro Sign', 'Persia BT', 'Circular Std Medium', 'Nexa Book Italic', 'Hoefler Text', 'TakaoPGothic', 'Dutch 801 Roman', 'Waverly', 'ML-TTPeriyar', 'Trade Gothic LT Std Light Oblique', 'PT Bold Dusky', 'Ayuthaya', 'Tw Cen MT Bold Italic', 'GentiumAlt', 'Damascus Regular', 'Hiragino Mincho ProN W6', 'Shruti', 'Devanagari Sangam MN', 'Hiragino Mincho ProN W3', 'Z@R1774.tmp', 'Avenir Next Condensed Medium Italic', 'Opus Japanese Chords', 'Noto Sans Thai', 'Adobe Caslon Pro', 'Apple Chancery', 'Kannada MN', '.VnVogue', 'Nobile', 'New Peninim MT Bold', 'Meiryo Italic', 'Roboto Mono Italic for Powerline', 'GFS Complutum', 'Verdana Pro Cond SemiBold', 'Augusta', 'Lucida Sans', 'Old Antic Outline Shaded', 'Harrington', 'Malayalam Sangam MN Bold', 'DS Crystal', 'Purisa', 'Adobe Hebrew Bold Italic', 'Iowan Old Style Black', 'Razer Header Regular', 'Monospac821 BT', 'Kohinoor Devanagari', 'Diwan Kufi Regular', 'Droid Sans Japanese', 'Lucida Fax Demibold Italic', 'Minion Pro Bold Italic', 'Marion Italic', 'Raleway ExtraLight', 'ArhialkhanMJ', 'Gungsuh', 'VNI-Souvir', 'Thonburi', 'Skia', 'Kaiti TC', 'Umpush', 'Candy Round BTN Cond Lt', 'ML-TTThunchan', 'BorhalMJ', 'PingFang TC Regular', 'Futura Medium', 'System Font Semibold', 'Roboto Slab Bold', 'Fanwood', 'Muli Light', 'Raisin des Sables', 'DFMaruGothic-Md', 'Al Bayan Bold', 'Noto Sans Mongolian', 'Apple Symbols', 'Muli Italic', 'Z@R1828.tmp', 'Source Sans Pro Bold', 'NanumGothic', 'MMRelation Italic', 'Noto Sans New Tai Lue', 'RaghuMalayalam', 'LetterOMatic!', 'Seravek Light', 'Baskerville Bold', 'MMGreek Bold Italic', 'QumpellkaNo12', 'GFS Olga', 'Times Italic', 'Futura Book BT', 'Glockenspiel', 'MS Reference Specialty', 'KanchanMJ', 'EngraverFontSet', 'MMa Binary', 'BN Jinx', 'Nova Flat', 'Yeseva One', 'Bauer Bodoni Std 1 Bold Italic', 'Kohinoor Telugu Semibold', 'TeX Gyre Heros', 'Georgia Pro Cond SemiBold', 'MMa Variable2 S', 'Inconsolata-g for Powerline', 'Simple Bold Jut Out', 'JLS Space GothicR NC', 'Circular Std Medium Italic', 'ML-TTAparna', 'Damascus Semi Bold', 'Opus Roman Chords', 'MS Dialog Light', 'MMa Negate', 'Chaparral Pro Light', 'Opus Note Names', 'Symbol Tiger Expert', 'SWComp', 'Cooper Std Black', 'JazzText', 'Langdon', 'FML-Mohini', 'Proxima Nova Regular Italic', 'Raleway ExtraBold Italic', 'cmtt12', 'DejaVu Sans Mono Oblique for Powerline', 'HUNTSON', 'Cantho', 'SWMusic', 'GENISO', 'Parchment', 'STHupo', 'Pricedown', 'Geotype TT', 'schoenecker 10', 'Photoshop Large', 'JACKIE', 'Averia', 'Granjon Roman', 'Bookshelf Symbol 7', 'Code39AzaleaNarrow1', 'Andong', 'Code39AzaleaNarrow3', 'Code39AzaleaNarrow2', 'Nexa Black', 'FML-TTPeriyar', 'Pirate', 'Formata Medium Condensed', 'Minerva', 'Futura LT Book', 'Kozuka Mincho Pro', 'LittleLordFontleroy', 'Tamil Sangam MN', 'Adobe Song Std L', 'SWIsop2', 'SWIsop3', 'STIXIntegralsSm', 'SWIsop1', 'Lao UI', 'Pothana2000', 'TAU-Valluvar', 'FML-TTLeela', 'BOUTON International Symbols', 'FontAwesome', 'Menlo Italic', 'MMa TextBook', 'Gothic720 BT', 'EucrosiaUPC', 'SF Slapstick Comic Bold', 'Gabriola', 'QuickType II Condensed', 'Bodoni 72 Oldstyle Book Italic', '.Vn3DH', 'HelveticaNeueLT Std Bold Outln', 'Lohit Punjabi', 'Kaiti SC Black', 'HKSCS-ExtB', 'Modern No', 'Blackmoor LET Plain:2.0', 'MMa Century Bold Italic', 'Code39AzaleaWide3', 'Code39AzaleaWide2', 'Code39AzaleaWide1', '19', 'Phatdiem', 'David', 'ML-TTAyilyamBold', 'Avinor', 'Adobe Devanagari', 'Al Tarikh Regular', 'Zolano Sans BTN', 'Drivebye 2', 'Drivebye 3', 'Ultra', 'Drivebye 1', 'Drivebye 4', 'Sneakerhead BTN Shadow', 'Songti SC Black', 'Radha', 'MMa Relation S', 'Ventilla Script', 'eufm8', 'Stone Sans OS ITC TT Bold', 'GFS Solomos', '.VnCentury Schoolbook', 'Nexa Thin', 'Bordeaux Roman Bold LET Plain:1.0', 'Euclid Math Two', 'EngraverTextNCS', 'Meiryo Bold Italic', 'Cooper Std Black Italic', 'DynameBlackSSK', 'GaneshThin', 'LTHYSZK', 'Noto Sans Hebrew', 'AnjaliOldLipi', 'Meslo LG M Regular for Powerline', 'Silent Reaction', 'VNI-Free', 'Montserrat Extra Bold', 'Avenir Next', 'Apple Braille Pinpoint 6 Dot', 'CommercialPi BT', 'CopprplGoth BT', 'GJ-TTAvantika', 'monofur bold for Powerline', 'Arial (Arabic)', 'Courier Std', 'FML-TTSwathyBold', 'Avenir Oblique', 'eufm6', 'SuperFrench', 'Montserrat', 'Copperplate Gothic Bold', 'Gillius ADF No2 Cd', 'Lantinghei SC Demibold', 'Gill Sans Nova Light', 'HGHeiseiMinchotaiW3', 'Lato Black', 'Rod Transparent', 'Malayalam MN Bold', 'Euclid Fraktur Bold', 'VNI-Boston Black', 'ML-TTLeela', 'INSPECTIONXPERT GDT FRAMES', 'Bebas Neue Thin', 'mry', 'eufm7', 'SWMap', 'Proxima Nova Condensed Light', 'cmbxti10', 'Nexa Regular', 'Lucida Bright Demibold Italic', 'Optima LT Std', 'Georgia Pro Black', 'Titillium Semibold Italic', 'ParkAvenue BT', 'Franklin Gothic Medium Italic', 'PujeetaNarrow', 'Daclac', 'Xpress Heavy SF', 'Tibetan Machine Uni', 'DecoType Naskh Swashes', 'Arial Narrow', 'MMa TextBook Bold Italic', 'Titillium Thin Upright', 'Roland', '.VnCooper', 'Stephen', 'Kino MT', 'HelvLight', 'Eurostile', 'Shonar Bangla', 'Helvetica Neue Thin', 'Orator Std Slanted', 'cmvtt10', 'MMCenturyNew Italic', 'DIN-Regular', 'Futura Book Oblique', 'Hack Regular', 'Nanum Gothic', 'SaiMeera', 'Apple SD Gothic Neo Thin', 'Source Code Pro ExtraLight', 'Myriad Pro Light SemiCond', 'Bank Gothic Medium', 'Swis721 Blk BT', 'Cambria Math', 'ChitraMJ', 'MS Dialog', 'Kokonor', 'ChitraSMJ', 'monofur for Powerline', 'Samathwa', 'Adobe Myungjo Std M', 'ML-TTVarsha', 'MMTextBookB Italic', 'AV-Font-Mal1', 'VN-NTime', 'MMa Extra Bold Italic', 'Paralucent Extra Light', 'Grand Hotel', 'MMRelation Bold', 'NanumMyeongjo', 'cmssdc10', 'Z@R183A.tmp', 'MMa Negate Italic', 'VNI-Harrington', 'Kruti Astro', 'DYMObvba', 'System Font Heavy', 'cmtt9', 'Avenir Next W1G Demi Italic', '.VnBook-AntiquaH', 'La Bamba LET', 'Rage Italic', 'MMa Fraktur', 'Parisian BT', 'University Roman Alts LET', 'Lobster', 'Ideal Sans Book', 'Lucida Grande Bold', 'MMa VariableC Bold', 'MMa Binary Bold', 'Fixedsys', 'Adobe Naskh Medium', 'Vemana2000', 'Opus Special', '.VnSouthern', 'Swis721 BT', 'ITF Devanagari Marathi', 'PT Sans Narrow', 'FML-TTRohini', '.VnMemorandum', 'Siyam Rupali ANSI', 'Segoe UI Semilight', 'Rock Salt', 'Santa Fe LET Plain:1.0', 'ParvathiBold', 'Superclarendon', 'STIXIntegralsUpD-Regular', 'Salilam', 'Canter Bold', 'FML-TTBeckalBold', 'STIXIntegralsUp-Regular', 'MMCenturyNew', 'Georgia Pro Cond Light', 'Arial Italic', 'Nueva Std Bold Condensed', 'Latin Modern Math', 'FreeSans', 'SAS Monospace Bold', 'Tarzan', 'STIX', 'VnTimes', 'Typewriter', 'Arial TUR', 'Urvasi', 'Meslo LG L Regular for Powerline', 'Sans', 'cmr5', 'ML-TTSuparna', 'HelveticaNeueLT Pro 35 Th', 'Lato Medium', 'Futura Std Bold Condensed', 'Trade Gothic LT Std Bold Oblique', 'Thorndale AMT', 'Sitka Display', 'Complex', 'Bobcat', 'Kaiti TC Bold', 'Hansen', 'Rosewood Std', 'VNI-DOS Sample Font', 'Noto Sans Tagbanwa', 'Razer Header Light', 'MS Sans Serif', 'Maestro Percussion', 'Western Bang Bang', 'Shorelines Script Bold', 'Myriad Pro Bold Condensed Italic', 'Kohinoor Telugu Bold', 'SF Movie Poster', 'Harlow Solid Italic', 'Brandon Grotesque Bold', 'lettau 06', 'Z@R123A.tmp', 'Linux Libertine Mono O', 'Giadinh', 'Yuanti SC Bold', 'Rakesly Rg', 'Accanthis ADF Std No3', 'HooglyMJ', 'Nunito', 'HelveticaNeueLT Std Med', 'Helvetica Neue Condensed Bold', 'MMCenturyNew Bold', 'WP Arabic Sihafa', 'Archicoco', 'Realvirtue', 'MMa VariableA Bold', 'MMVariableA', 'Nimbus Roman No9 L', 'MMVariableC', 'MMVariableB', '64', 'MMVariableD', '66', 'MMVariableF', '68', 'FML-TTAparna', 'ML-TTGauriHeavy', 'Chess Maya', 'Special Elite', 'Courier New TUR', 'Kozuka Mincho Pro L', 'Minion Pro Bold Cond Italic', 'VISCII Sample Font', 'Montserrat Semi Bold', 'BriLliant', 'LIVINGWELL', 'MMa Variable S', 'VNI-Jamai', 'FML-TTSabari', 'Binhlong', 'AtraiMJ', 'TeamViewer10', 'TeamViewer11', 'Broadway Copyist Text', 'GoraiMJ', 'American Typewriter Condensed', 'HGSHeiseiMinchotaiW9', 'Seravek Medium Italic', 'Belwe Cn BT', 'Abadi MT Condensed Light', 'Vanilla', 'WP Greek Helve', 'Trocchi Bold', 'Khmer MN', 'Roboto Condensed Regular', 'TitilliumText22L-Light', 'Nexa Bold Italic', 'cmss9', 'cmss8', 'IMG Symbols', 'ML-TTBhavana', 'Aldhabi', 'Weibei SC Bold', 'MMVariable2', 'AL Cinderella', 'Consolas Bold Italic', 'Monoton', 'Z@R16FD.tmp', 'Gill Sans Bold Italic', 'Khanhoa', 'MMVariableD Bold', 'Charter Bold Italic', 'AnandapatraCMJ', 'UniversalMath1 BT', 'Janaranjani', 'TeamViewer9', 'Days Regular', 'Times New Roman CE', 'Futura Bold Oblique', 'VNI-Korin', 'msbm5', 'HelveticaNeueLT Pro 23 UltLtEx', 'Spirituality', 'Sitka Heading', 'KasseFLF', 'TeX Gyre Heros Cn', 'GoudyHandtooled BT', 'Bebas Neue Bold', 'Henny Penny', 'JugantorMJ', 'Trebuchet MS Bold', 'Raleway Thin Italic', 'Lucida Bright Demibold', 'Prestige Elite Std', 'HGMinchoL', 'SonicCutThru Hv BT', 'BuiltTitlingRg-BoldItalic', 'Bickham Script Pro 3', '.VnBodoni', 'Jazz', 'MYingHei', 'Muna', 'Lato', 'Minisystem', 'BurigangaMJ', 'Hoefler Text Black Italic', 'Andale Sans for VST', 'Diavlo Book', '.VnArabia', 'Big Caslon Medium', 'Titillium Semibold', 'Mishafi Gold Regular', 'Qaskin Black Personal Use', 'cmssbx10', 'Oxygen', 'msbm7', 'cmmi9', 'Aileron Light', 'KacstOffice', 'Libian SC Regular', 'IMG Baby', 'Humanist', 'Montserrat Hairline', 'euex9', 'euex7', 'Courier 10 Pitch', 'ML-TTMadhaviExBold', 'AR DESTINE', 'Shree-Mal-0502', 'FML-TTAathira', 'cmbxsl10', 'FML-Indulekha', 'PingFang SC Ultralight', 'FML-Sruthy', 'FML-TTGauriHeavy', 'Adobe Fan Heiti Std B', 'Avenir Heavy', 'cmex8', 'Hiragino Sans GB W6', 'STIXIntegralsUpD', 'line10', 'Futura LT Condensed Bold Oblique', 'Admisi Display SSi', 'cmex7', 'Casual', 'CASMIRA', '.VnLucida sans', 'STIXGeneral-Regular', 'Nueva Std Bold Condensed Italic', 'HGPHeiseiMinchotaiW9', 'Klee Medium', 'Accord Heavy SF', 'MMCenturyOld Italic', 'STIXNonUnicode-Italic', 'Fira Mono Bold for Powerline', 'Hadong', 'Apple Color Emoji', 'ML-TTAathira', '3ds Light', 'AR DARLING', 'Bifurk', 'Palace Script MT', 'NanumGothic ExtraBold', 'Baghdad Regular', 'FML-TTThunchan', 'Vodafone Rg', 'GFS Neohellenic', 'Quicksand', 'Times New Roman Bold', 'PingFang TC Medium', 'Technic', 'Adobe Kaiti Std R', 'HGPHeiseiMinchotaiW3', 'Gen W01', 'HelveticaNeueLT Std Lt Ext', '.VnPark', 'Avenir Next W1G Bold Italic', 'Roboto Black', 'New Renex Special Graphics', 'Brush Script Std', 'Segoe UI Historic', 'DejaVu Sans', 'Krungthep', 'ML-TTKala', 'Kohinoor Devanagari Demi', 'VNI-Hobo', 'GangaMJ', 'FML-TTRevathi', 'Sauce Code Powerline Semibold', 'Open Sans Bold', 'WP MultinationalA Courier', 'MMa CenturySS Bold Italic', 'Kohinoor Telugu', 'Bodoni 72 Smallcaps', 'VNI-StageCoach', 'HanziPen TC Regular', 'Agency FB', 'Reginet', 'Helvetica Neue Medium Italic', 'Helvetica Neue Condensed Black', 'ML-TTAnakha', 'Yuanti TC Light', '65', 'Avenir Next Bold Italic', 'GF Zemen Unicode', 'Ice kingdom', 'Santa Fe LET', 'Gotham Narrow Book', 'Army', 'Latin Modern Sans Quotation', 'Moonbeam', '67', 'Microsoft YaHei UI Light', 'Bell MT Italic', 'Myriad Arabic Bold', 'Lohit Bengali', 'Lato Hairline Italic', 'AppleGothic', 'Titan One', 'Lantinghei SC', 'Myriad Pro Black Condensed', 'Orator Std Medium', 'Kozuka Gothic Pro EL', 'Hollywood Hills', 'Tekton Pro Cond', 'Franklin Gothic Book Italic', 'ANDROID ROBOT', 'Diwan Kufi', 'Dutch801 Rm BT', 'future', 'Divya', 'Tlwg Typo', 'Xingkai SC', 'Open Sans', 'SutonnyMJ', 'Source Code Pro Semibold', 'Neo Sans Pro Light', 'FML-TTMalavika', 'Proxima Nova Condensed', 'Myriad Pro Black SemiExtended', 'cmtt8', 'Paralucent Demi Bold', '3M Circular TT Light', 'VNI-Tubes', 'HelveticaNeueLT Pro 37 ThCn', 'Farah Regular', 'VNI-Duff', 'cmmib6', 'ML-TTChandrika', 'Amatic', 'Khalid Art bold', 'cmmib8', 'cmmib9', 'Ela Sans Light Caps', 'SF Compact Rounded Ultralight', 'Malgun Gothic Semilight', 'Latienne Pro Italic', 'Cortoba', 'Paralucent Heavy', 'VNI-Lithos', 'Shree-Tel-0900', 'MMGreek Italic', 'FML-TTJyothy', 'HelveticaNeueLT Pro 43 LtEx', 'Leitura Display Italic', 'Ostrich Sans', '.VnBahamasB', 'Gill Sans UltraBold', 'FML-Padmanabha', 'Myriad Pro Light', 'PT Serif Italic', 'MMBinary Bold', 'Autumn', 'STIXVariants-Regular', 'Archive', 'Math3', 'Math2', 'Math1', 'FML-TTSarada', 'Euclid Math One', 'Futura LT Condensed Medium Oblique', 'Math4', 'Franklin Gothic Book', 'AR CARTER', 'Xpress SF', 'System Font Light', 'Literation Mono Powerline Bold Italic', 'Lato Semibold Italic', 'SymbolMono BT', 'HGPHeiseiKakugothictaiW5', 'HGPHeiseiKakugothictaiW3', 'Waree', 'PingFang TC Thin', 'Myriad Pro Black Cond', 'Adobe Heiti Std R', 'Learning Curve Dashed Pro', 'Smokum', 'Noto Sans Yi', 'HelveticaNeueLT Std Thin Cn', 'Mesquite Std Medium', 'Blackoak Std', 'kroeger 07', 'ML-TTNanditha', 'cmssi12', 'Avenir Medium', 'MS PGothic', 'Droid Sans', 'Finale Copyist Text', 'Merriweather UltraBold Italic', 'Kohinoor Devanagari Book', 'Reklame Script Black', 'System Font Regular G1', 'Sabrina', 'System Font Regular G3', 'System Font Regular G2', 'Arial Symbol', 'Lantinghei TC Extralight', 'cmbsy9', 'Kozuka Gothic Pr6N', 'Georgia Pro Light', 'Mangal', 'PT Bold Arch', 'JasmineUPC', 'Phosphate', '.VnTifani Heavy', 'MMa CenturyKS', 'Logo3Mtt', 'STHeiti', 'MMNegate', 'AV-Web-Tel1', 'Opus Text', 'PingFang HK Thin', 'Century', 'Playfair Display SC Bold', 'Standard Symbols L', 'BhagirathiMJ', 'Bowlby One SC', 'mono 08', 'cmti7', 'DigifaceWide', 'PujeetaSpecial', 'Avenir Next W1G Medium Italic', 'Iowan Old Style Bold Italic', 'Italic Outline Art', 'cmu10', 'MMa Negate SS', 'Serifa Bold', 'mono 07', 'Dyuthi', 'Sauce Code Powerline ExtraLight', 'ae', 'kroeger 04', 'MMRelation', 'Arno Pro Smbd Display', 'MMRelation Bold Italic', 'Microsoft YaHei UI', 'Lucida Sans Regular', 'FML-TTThiruvathira', 'FREH', 'Nova Round', '18030', 'SWGreks', 'PingFang SC Semibold', 'Adobe Heiti Std', 'Staccato222 BT', 'IDAutomationPDF417n4', 'cmssq8', 'Zapfino Extra LT Four', 'Verdana Pro Light', 'Euclid Fraktur', 'FlemishScript BT', 'AV-Font-Sin1', 'Monospace', 'Gotham Black Italic', 'Madre Script', 'Droid Sans Mono', 'TMBW-TTValluvar', 'cafeta', 'AR JULIAN', 'cmtex10', 'Oriya MN Bold', 'Buxton Sketch', 'HelveticaNeueLT Pro 45 Lt', 'Minion Pro Bold Cond', 'LiHei Pro', 'Raleway Light', '.VnKoala', 'System Font Light Italic', 'Kiran', 'MingLiU-ExtB', 'Nueva Std Condensed Italic', 'Proxima Nova Soft Semibold', 'Circular Std Book', 'Beirut Regular', 'HelveticaNeueLT Pro 55 Roman', 'AR DELANEY', 'Candles', 'Lucida Sans Demibold Italic', 'Myriad Pro Bold Italic', 'Seravek Italic', 'Old English', 'Uttara', 'Formal436 BT', 'Latin Modern Roman Slanted', 'AcadEref', 'Soho Gothic Pro Light', 'Corbel Italic', 'Modern', 'Z@R277C.tmp', 'Microsoft JhengHei UI', 'Lato Heavy Italic', 'Comic Sans MS', 'Trade Gothic LT Std Light', 'Westwood LET', 'Old Antic Bold', 'Futura Std Heavy', 'DaunPenh', 'Euclid Symbol Italic', 'Noteworthy Bold', 'MMa CenturyKSS Bold', 'Year supply of fairy cakes', 'SutonnyOMJ', 'Open Sans Extrabold Italic', 'Tekton Pro Bold Condensed', 'Chancery Cursive', 'Quincho Script PERSONAL USE', 'Modern Antiqua', 'Verdana', 'System Font Thin', 'Merriweather Bold Italic', 'Gisha', 'Chaparral Pro Light Italic', 'MMa CenturyKS Bold', 'BolsterBold', 'AVGmdBU', 'Cir Arial', 'Lithos Pro Black', 'Papyrus Condensed', 'Seravek Medium', 'Chalkduster', 'Noto Sans CJK TC', 'MMa Greek Bold Italic', 'HeadLineA', 'MMVariableA Bold', 'Times New Roman Italic', 'Garuda', 'Permanent Marker', 'Yu Gothic UI Semilight', 'Myriad Pro Black SemiCondensed', 'Apple SD GothicNeo ExtraBold', 'Norasi', 'Arial Nova Light', 'PondFreeBoss', 'Avenir Light Oblique', 'Alice and the Wicked Monster', 'AvantGarde Bk BT', 'Arno Pro SmText', 'GungSeo', 'ori1Uni', 'HelveticaNeueLT Std Blk', 'DIN-LightAlternate', 'MMa CenturyKSS', 'MMa Relation SS', 'Andalus', 'VNI-Zap', 'BN Machine', 'Segoe MDL2 Assets', 'Rotis Sans Serif Std 45 Light', '.VnGothicH', 'Proxima Nova Bold Italic', 'SAF', 'Futura Light Italic BT', 'Vivaldi', '.VnCourier', 'Khmer Sangam MN', 'BorakOMJ', 'Roboto Mono Light Italic for Powerline', 'ML-TTTheyyam', 'Avenir Next Condensed Heavy Italic', 'Caladea', 'Noto Serif Georgian', 'Charlemagne Std Bold', 'HGHeiseiKakugothictaiW5', 'HGHeiseiKakugothictaiW3', 'BerlingRoman', 'Nadeem', 'Source Sans Pro Light Italic', 'Helvetica Neue UltraLight', 'stmary10', 'Impact', 'Sketch Match', 'Songti TC', 'Square721 BT', 'MMa VariableA SS', 'AV-Font-Guj1', 'Georgia Pro', 'DhorolaMJ', 'Yuanti SC Regular', 'Roboto Mono Light for Powerline', 'Poplar Std Black', 'Futura Light Oblique', 'Hypatia Sans Pro ExtraLight', 'ISOCPEUR', 'Alternate Gothic No2 D', 'Gillius ADF', 'copy 10', 'Noto Sans Ugaritic', 'Yuanti TC', 'Charlemagne Std', 'Reswysokr', 'ML-TTNila', 'Pamela want a Bike to Ride', 'Museo 100 Regular', 'Montserrat Ultra Light', 'System Font Bold G3', 'System Font Bold G2', 'System Font Bold G1', 'ChandrabatiMatraMJ', 'MingLiU', 'Noto Sans Tamil', 'NeueHaasGroteskText Pro', 'Savoye LET Plain CC.:1.0', 'classic 10', 'Droid Sans Georgian', 'Merriweather Regular', 'MMa Etc SS', 'Devanagari Sangam MN Bold', 'STIXSizeFiveSym', 'Proxy 2', 'MMEtc', 'SOLIDWORKS GDT', 'Superclarendon Italic', 'Sakkal Majalla', 'TextilePiEF', 'MMa Variable2', 'Songti TC Bold', 'STIXIntegralsD', 'Monotype Koufi', 'DIN Condensed', 'Noto Sans Tamil UI', 'Arial Baltic', 'Terminal Greek 869', 'Chess Berlin', 'System Font UltraLight', 'Microsoft YaHei Light', 'AR Sans Serif', 'FML-TTNalini', 'Noto Sans NKo', 'Joan', 'Adobe Fan Heiti Std', 'RomanC', 'MMa Arrow Bold', 'Verdana Pro Cond Light', 'Kannada Sangam MN Bold', 'Museo Sans 500', 'Bitstream Vera Sans', 'STIXSizeFiveSym-Regular', 'Mistral', 'CloisterBlack BT', 'DhakarchithiMJ', 'Latin Modern Sans Demi Cond', 'Czec', 'GothicE', 'IMG Extreme', 'WST', 'RomanT', 'Adobe Arabic Bold Italic', 'DINPro-Bold', 'Century Schoolbook Bold Italic', '.VnBlack', 'VNI-Fillmore', 'Noto Sans Old Persian', 'Dutch801 XBd BT', '.VnArial Narrow', 'Sathu', 'Avenir Next Medium Italic', 'Lato Heavy', 'MMVariableC Bold', 'Simple Indust Shaded', 'RowdyHeavy', 'Flamenco', 'PanRoman', 'Gotham Narrow Extra Light Italic', 'OLF SimpleSansOC', 'Folio XBd BT', 'Roman Mono', 'System Font Bold Italic G1', 'Sinhala Sangam MN Bold', 'Cataneo BT', 'System Font Bold Italic G2', 'Soho Gothic Pro ExtraBold It', 'Oriya Sangam MN Bold', 'JUSTICE', 'MMa Greek Italic', 'Gotham Medium', 'Arno Pro Light Display', 'Ezra SIL SR', 'Kokila', 'SD-TTSurekh', 'GrilledCheese BTN', 'Kannada MN Bold', 'Heiti SC Medium', 'Avenir Next W1G Heavy Italic', 'PT Serif Caption', 'Hiragino Maru Gothic Pro', 'Monotype Sorts 2', 'Myriad Pro Black SemiCond', 'Swis721 BlkEx BT', 'Tsukushi A Round Gothic', 'Futura LT Extra Bold', 'Titillium Regular Italic', 'French Script MT', 'Tw Cen MT', 'KacstDecorative', 'Lucida Sans Typewriter Oblique', 'Impregnable Personal Use Only', 'MMNegate Italic', 'Whimsy TT', 'Chess Marroquin', 'NBP Informa FiveSix', 'Lucida Sans Demibold Roman', 'msbm10', 'Gill Sans Nova Ultra Bold', 'copy 09', 'Blackmoor LET', 'Castellar', 'IPAMincho', 'MMa VariableB Bold', 'Superclarendon Bold', 'Titillium Black', 'Avenir', 'Lucida Sans Typewriter Bold', 'BrowalliaUPC', 'Steppes TT', 'VNI Cambodia', 'Kefa Bold', 'Helvetica Light Oblique', 'Avenir Next W1G Ultra Light Italic', 'JazzCord', 'Symbol Neu for Powerline', 'Emily Austin', 'Avenir Light', 'Tiranti Solid LET', 'Myriad Hebrew Italic', 'Monotype Corsiva', 'cmitt10', 'DhanshirhiOMJ', 'KacstDigital', 'kawoszeh', 'Cut Me Out 2', 'Cut Me Out 3', 'Myriad Pro Bold Condensed', 'boot', 'Fredericka the Great', 'Symusic', 'balonez fantasia br', 'Bitstream Vera Sans Mono', 'Devanagari MT', 'Noto Sans UI', 'Myriad Pro Semibold Italic', 'Noto Sans Vai', 'Razer Header Regular Oblique', 'Dot', 'Swed', 'ScriptKleio', 'Gillius ADF No2', 'Myriad Pro Bold SemiExtended', 'Prema', 'ConcursoItalian BTN', 'Pricedown Bl', 'Lantinghei SC Extralight', 'GillSans-Bold', 'Urdu Naskh Asiatype', 'Glegoo', 'Kohinoor Devanagari Bold', 'Vollkorn Regular', 'AngsanaUPC', 'Apple Casual', 'Freehand575 BT', 'PingFang SC Regular', 'Aharoni', 'Medlin', 'MMa Relation Bold', 'Arial', 'FML-TTAnjali', 'RADAGUND', 'Noto Sans Mandaic', 'Marion Regular', 'cminch', 'Seagull APL', 'Nueva Std', 'Pamela wants to Ride', 'Monotxt', 'cmtt10', 'TRENDY', 'Alex Brush', 'Playfair Display SC Italic', 'STIXIntegralsUpD-Bold', 'DecoType Naskh', 'Muli', 'Marker Felt Wide', 'Klee', 'PUPPYLIKE', 'Accanthis ADF Std No2', 'Cooper Std', 'Meslo LG L DZ Regular for Powerline', 'Droid Arabic Naskh', 'ITF Devanagari Demi', 'Verdana Pro SemiBold', 'Kalyani', 'Futura Md BT', 'Latino Elongated LET Plain:1.0', 'Brussels', 'Nasalization', 'Thonburi Bold', 'Kohinoor Devanagari Medium', 'Loma', 'Noto Sans Rejang', 'Typewriter Bold', 'Zapfino Extra LT One', 'Futura Heavy', 'Origin', 'Euclid Symbol Bold Italic', 'Gotham Narrow Bold Italic', 'smart watch', 'PFDaVinciScriptPro-Inked', 'Odessa LET', 'KG Fall For You', 'FMLTTAathira', 'MMNegate Bold', 'Gotham Thin', 'Cousine Bold for Powerline', 'Courier New Bold', 'Cracked', 'Arial Bold', 'GoomtiMJ', 'PingFang SC', 'Minion Pro Semibold Italic', 'VNI-WIN Sample Font', 'LA Headlights BTN', 'Moon Flower', 'VNI-Couri', 'Segoe WP Light', 'lcmssi8', 'Carlito', 'Eras Bold ITC', 'Proxima Nova Light', 'Oswald', 'Abel', 'Doulos SIL', 'Sanskrit', 'BRADDON', 'MMa Binary Bold Italic', '.VnStamp', 'Raleway ExtraBold', 'VNI-Vari', 'DhakarchithiOMJ', 'Narkisim', 'Arno Pro Subhead', 'monoeger 05', 'Lithos Pro', 'Noto Sans CJK KR', 'Arial Black', 'Gigi', 'FML-TTVeenaHeavy', 'JaJaDiMJ', 'Supernatural Knight', 'Garamond Premier Pro Semibold', 'Didot', 'MMa Relation Italic', 'IDAutomationPDF417n3', 'Source Sans Pro ExtraLight Italic', 'STZhongsong', 'NSimSun', 'JuneBug', 'Candy Round BTN Lt', 'Georgia Bold Italic', 'BauerBodni BT', 'ML-TTRavivarma', 'Yu Gothic Light', 'monofur italic for Powerline', 'Webdings', 'Courier MM Screenwriter BoldIt', 'STXinwei', 'PenultimateLightItal', '3 of 9 Barcode', 'Rockwell Nova Cond Light', 'Laila Medium', 'FML-TTSurya', 'Shree Devanagari 714 Bold', 'Metamorphous', 'Mekanik LET', 'Serif', 'Verdana Pro Black', 'ML1-TTAmbili', 'Lucida Handwriting Italic', 'Apple Braille Outline 8 Dot', 'Courier New Baltic', 'Euclid Italic', 'Opus Figured Bass Extras', 'Latin Modern Roman Unslanted', 'VNI-Allegie', 'Comic Sans MS Bold', 'Nina', 'ML-TTMalavika', '18thCentury', 'PhrasticMedium', 'Amatic SC', 'Canter Bold 3D', 'Swis721 BlkCn BT', 'KalegongaOMJ', 'Nirmala UI Semilight', 'Lato Light', 'ISABELLE', 'Courier', 'Linux Libertine G', 'copy 08', 'Kedage', 'Raleway Light Italic', '.VnLinus', 'Roboto Medium', 'Lithos Pro Regular', 'STIXNonUnicode-Regular', 'eufb9', 'eufb8', 'MARKETPRO', 'Skia Black Condensed', 'eufb7', 'eufb6', 'eufb5', 'VnTimes2', 'SWMath', 'Bamini', 'Anonymice Powerline Bold', 'Sukhumvit Set Thin', 'STFangsong', 'ML-TTAtchu', 'Cochin Italic', 'hooge 06', 'hooge 04', 'hooge 05', 'Tw Cen MT Italic', 'MMTimes Bold', 'IPAGothic', 'PingFang TC Ultralight', 'Copperplate Light', 'Consolas Italic', 'Kohinoor Telugu Light', 'TAU-Barathi', 'STIXIntegralsUpSm-Regular', 'FML-TTKeerthi', 'Vrinda', 'eurb6', 'KalindiOMJ', 'Blade Runner Movie Font', 'Source Sans Pro Bold Italic', 'TAC-Barathi', 'Adobe Ming Std L', 'PingFang SC Light', 'MMa Gauss', 'kor', 'MMa Variable2 Bold', 'Yu Gothic Medium', 'Tw Cen MT Condensed', 'Damascus Medium', 'Sugarskin BTN', 'QTOptimum Regular', 'Tekton Pro Bold Oblique', 'Adobe Fangsong Std R', 'italic 08', 'Sana Regular', 'MMa Century Bold', 'DIN Condensed Bold', '(AH) Manal Black', 'Wolf in the City Light', 'Scriptina', 'Skinny', 'FML-TTNanditha', 'eusb9', 'Kalpurush ANSI', 'Canter Bold Strips', 'AdineKirnberg-Script', 'Minion Pro Semibold', 'Copperplate Bold', 'Trebuchet MS Italic', 'Myriad Hebrew Bold Italic', 'Hand Me Down S (BRK)', 'Latha', '.VnMonotype corsivaH', 'VNI-Slogan', 'STIXSizeTwoSym', 'Thonburi Light', 'Consolas Bold', 'Orange LET', 'Candara Bold Italic', 'Gotham Light Italic', 'Trade Gothic LT Std Extended', 'Starliner BTN', 'NixieOneRegular', '.VnAristoteH', 'chs', 'Rockwell Condensed', 'ML-TTSarada', 'Map Symbols', 'DejaVu Sans Mono', 'Telugu Sangam MN Bold', 'Courier New Bold Italic', 'Gotham Narrow Ultra', 'Victorian LET', 'Architects Daughter', 'MS Reference 1', 'ML-TTNalini', 'MS Reference 2', 'Dynalight', 'Baskerville Old Face', 'Optima Bold Italic', 'SimSun-ExtB', 'Vladimir Script', 'Hiragino Sans GB W3', 'Rockwell', '63', 'Skia Black Extended', 'Helvetica Neue UltraLight Italic', 'Dominican', 'Futura LT Bold Oblique', 'Franklin Gothic Heavy', 'Cooper Black', 'Baskerville Italic', 'Open Sans Condensed', 'TAU-Kaveri', 'MMa Variable SS', 'Helvetica Neue Thin Italic', 'Arno Pro Display', 'MMa Negate Bold Italic', 'Xingkai SC Bold', 'Montserrat Light', 'cmti9', 'TAC-Kabilar', 'cmssi9', 'Roboto Condensed Light', 'cmssi8', 'Tunga', 'STIXVariants-Bold', 'SWGDT', 'Arabic Typesetting', 'SAS Monospace', 'Martina', 'Myriad Pro Light SemiCondensed Italic', 'Raavi', 'MMTimes', 'VNI-Dur', 'TitilliumText22L-XBold', 'FML-TTVinay', 'Titillium Light Upright', 'Savoye LET Plain CC', 'Bangkok Cirilica', 'Mongolian Baiti', 'Iowan Old Style', 'MMArrow Bold', 'Cairo SF', 'Arno Pro Smbd Subhead', 'Formata Light Condensed', 'PingFang HK Medium', 'Cousine for Powerline', 'Arial Nova', 'Stez Sans', 'FML-LeelaHeavy', 'Century Gothic Bold Italic', 'Mytho', 'STIXIntegralsD-Bold', 'cmsl9', 'Al Nile Bold', 'SWIsot3', 'Great Vibes', 'System Font Italic G2', 'System Font Italic G3', 'System Font Italic G1', 'BlackJackRegular', 'Quicksand Light', 'ZWAdobeF', 'Hypatia Sans Pro', 'Noto Sans Mono CJK SC', 'Nueva Std Condensed', 'SemiBold', 'Avenir Next Condensed Ultra Light', 'Athelas Bold Italic', 'MMa TextBook Italic', 'ML-TTKarthika', 'Swis721 Hv BT', 'AS-TTDurga', 'Clear Sans', 'Led Italic Font', 'Seravek', 'Dirty Headline', 'Lucida Fax Italic', 'Apple SD Gothic Neo Heavy', 'Roboto Mono Medium Italic for Powerline', 'Droid Sans Armenian', 'Hiragino Maru Gothic Pro W4', 'AlekyaBold', 'STIXGeneral-Bold', 'Candara', 'Tekton Pro', 'QuickType II', 'Fixed Miriam Transparent', 'Latienne Pro Bold Italic', 'cmbsy10', 'ABIGAIL', 'Latin Modern Mono Light', 'Bodoni 72 Book', 'Cinzel', 'Monaco', 'Kozuka Gothic Pr6N M', 'Kozuka Gothic Pr6N L', 'msam8', 'PAINTSTROKE', 'ML-TTRohini', 'Kozuka Gothic Pr6N H', 'Fingerpop', 'TRIAL', 'SWGothg', 'SWGothe', 'SWGothi', 'BacktalkSerif BTN', 'Courier New', 'MLU-Panini', 'Marion', 'Zapfino Extra LT Two', 'News Gothic MT Alt 4', 'Miriam Transparent', 'Copperplate Gothic Light', 'BankGothic Md BT', 'MS SystemEx', 'Proxima Nova Condensed Semibold', 'YuMincho  36p Kana Medium', 'Microsoft New Tai Lue', 'SF Slapstick Comic', '.VnExoticH', 'Baron Neue Bold Italic', 'Swis721 LtEx BT', 'PilGi Regular', 'PT Bold Stars', 'Chalkboard SE Light', 'ThoolikaUnicode', 'Muna Regular', 'Nueva Std Bold', 'Roboto Slab Light', 'Khmer OS System', 'NanumMyeongjo ExtraBold', 'Noto Sans Devanagari UI', 'Centaur', 'IM FELL DW Pica', 'Cambria', 'Castro Script PERSONAL USE ONLY', 'JF Armenian Serif', 'MMCenturyNewRD Italic', 'AppleMyungjo Regular', 'PingFang SC Medium', 'Futura LT Condensed Extra Bold', 'Noto Sans Old Italic', 'Bradley Hand Bold', 'Al Bayan Plain', 'STIXSizeOneSym-Regular', 'MMa CenturySS Italic', 'News Gothic MT Italic', 'Gotham Extra Light Italic', 'Wawati SC', 'KB Vibrocentric', 'Anonymice Powerline', 'Harry P', 'Sana', 'Heiti TC Medium', 'News Gothic MT Alt 1', 'DYMO Symbols', 'Futura LT Heavy', 'cmss17', 'ML-TTGopika', 'Symbola', 'Yuppy SC', 'ADMUI2Sm', 'Meiryo', 'Woodcut', 'cmss10', 'OCR-A BT', 'STIXSizeThreeSym', 'Roboto Thin Italic', 'AR CENA', 'Iowan Old Style Roman', 'TlwgTypewriter', 'Baclieu', 'Optima Bold', 'Hannotate TC Bold', 'Adobe Hebrew Bold', 'Gurmukhi Sangam MN Bold', 'X-Files', 'Microsoft Uighur', '.VnExotic', 'Trade Gothic LT Std Bold', 'BankGothic Lt BT', 'Lucida Sans Typewriter', 'MisterEarl BT', 'Parry Hotter', 'Mshtakan', 'Baron Neue', 'FML-TTAshtamudiExBold', 'VNI-Present', 'Hoefler Text Black', 'News Gothic MT Alt 3', 'Verlag Book', 'VNI Helve', 'Lucida Bright Italic', 'Cabin', 'Math1Mono', 'MMa GreekSS Italic', 'TL-TTHemalatha', 'Alibi', 'Roboto', 'Bell Gothic Std Black', 'Lexia', 'Proxima Nova Soft Regular', 'Vollkorn Italic', 'ChandrabatiSushreeMJ', 'Diwani Outline Shaded', 'News Cycle', 'Apple SD Gothic Neo SemiBold', 'Arial CE', 'Z@R1816.tmp', 'SamsungImaginationBold', 'Charter Bold', 'Canter Outline', 'Day Roman', 'ML-TTVinay', 'YuCiril Helvetica', 'Brush Script', 'Sorts Mill Goudy Italic', 'Simple Indust Outline', '36p Kana Demibold', 'Latin Modern Roman Caps', 'Mayence Premium', 'Granjon Italic', 'Aparajita', 'Noto Sans Syloti Nagri', 'Highlight LET', 'Ferro Rosso', 'Hypatia Sans Pro Light', 'Hei Medium', 'ITF Devanagari Light', 'MS UI Gothic', 'OCR A Extended', 'VNI-Ariston', 'SWSimp', 'Holiday Springs BTN Quill', 'WP MathExtendedB', 'FML-TTGeethika', 'Eras Demi ITC', 'Verdana Pro Cond', 'Bordeaux Roman Bold LET', 'Voyager NBP', 'Goudy Old Style Italic', 'Oswald Regular', 'Giddyup Std', 'Harvest', 'Helvetica Neue Medium', 'Paralucent Medium', 'Times New Roman Uni', 'MMCenturyOld Bold', 'Ubuntu Mono derivative Powerline Bold Italic', 'Clarendon Lt BT', 'Emma Script Mvb', 'Raleway Medium Italic', 'Gotham Extra Light', 'Stone Sans Sem ITC TT SemiIta', 'Menlo Bold', 'FZLanTingHeiS-UL-GB', 'MMa Binary S', 'Constantia Bold Italic', 'jpn', 'Myanmar MN', 'MMCenturyOldGreek Bold Italic', 'AGA Arabesque', 'Inconsolata for Powerline', 'Maestro', 'Avenir Next Condensed Bold', 'PT Serif', 'Kozuka Gothic Pr6N EL', 'Myriad Pro SemiExtended', 'Source Code Pro Light', 'cmbx10', 'Bernard MT Condensed', 'Teen', 'Baiduan Number', 'AnticFont', 'Andale Mono', 'CordiaUPC', 'Hobo Std', 'Caviar Dreams Italic', 'Math4Mono', 'ceriph 05', 'Gentium Basic', 'ceriph 07', 'Heather BTN', 'MMVariableB Bold', 'FML-Akhila', 'Bradley Hand', 'Cookie', 'AR HERMANN', 'eusb8', 'MMa Fraktur Bold', 'Soho Gothic Pro Bold', 'Kozuka Mincho Pro R', 'PN-TTAmar', 'eusb6', 'eusb7', 'ML-TTSwathyBold', 'Roboto Light', 'Cochin Bold', 'Symeteo', 'VNI-Internet Mail', 'MMa Greek Bold', 'Kozuka Mincho Pro B', 'Kozuka Mincho Pro M', 'Bodoni 72 Smallcaps Book', 'ZDingbats', 'Proxima Nova Condensed Regular Italic', 'Kozuka Mincho Pro H', 'Superclarendon Light Italic', 'CountryBlueprint', 'MMGreek', 'Juice ITC', 'TanglewoodTales', 'MMa Greek', 'MMEtc Bold', 'Noto Sans CJK JP', 'HelveticaNeueLT Std Lt', 'Apple SD Gothic Neo Medium', 'Microsoft JhengHei UI Light', 'Broadway Copyist Perc', 'Handwriting - Dakota', 'PCMyungjo', 'AIGDT', 'Helvetica Neue Light Italic', 'Museo Sans 500 Italic', 'Oriya MN', 'Arial Unicode MS', 'MMa VariableC SS', 'Roboto Condensed Bold Italic', 'Circular Std Bold', 'GaneshMedium', 'Finale Percussion', 'Titillium Light', 'Arkhip', 'Al Bayan', 'PingFang HK Semibold', 'SAPIcons', 'Noto Sans Samaritan', 'Dancing Script OT', 'ELLIS', 'Museo Sans 700', 'Limousine', 'SF Slapstick Comic Oblique', 'Sukhumvit Set', '.VnUniverse', 'Franklin Gothic Demi Cond', 'KarnaphuliOMJ', 'DFKGothic-Md', 'Monika Italic', 'VNI-Meli', 'MV Boli', 'TeX Gyre Schola', 'Finger Paint', 'Meslo LG M DZ Regular for Powerline', 'TURK', 'Noto Sans Limbu', 'Arimo Italic for Powerline', 'SPAN', 'KG Part of Me', 'Hiragino Kaku Gothic Pro', 'No Flash', 'Zolano Serif BTN', 'DIN Alternate Bold', 'Nanum Pen Script', 'Proxima Nova Lt', 'Commons', 'Lato Light Italic', 'Raleway Black Italic', 'Maiden Orange', 'Lato Bold Italic', 'PondFreeMe', 'Latin Modern Mono Light Cond', 'Myriad Pro Light Cond', 'Baron Neue Bold', 'Malayalam MN', 'Mshtakan Bold', '.VnAvant', 'MMa VariableD S', 'Merriweather UltraBold', 'ITF Devanagari Marathi Book', 'Raleway Thin', 'Amudham', 'MMCenturyNewRD Bold Italic', 'DIN-Bold', 'Miriam Fixed', 'Roboto Mono Bold for Powerline', 'SaiSai', 'Symbol MT', 'Virtual DJ', 'FML-TTRavivarma', '.VnArabiaH', 'FML-TTSruthy', 'HaldaOMJ', 'JazzPerc', 'Gotham Narrow Medium Italic', 'Avenir Black', 'Kalpurush', 'eufb10', 'Raleway', 'Arial Bold Italic', 'Sinhala Sangam MN', 'Inconsolata-dz for Powerline', 'Hiragino Kaku Gothic StdN', 'Lobster Two', 'QuickType II Mono', 'Nova Square', 'MMa CenturyK Bold Italic', 'Roboto Slab Thin', 'Lucida Sans Unicode', 'Coaster Shadow', 'Skia Light Extended', 'Skia Regular', 'Chipotle', 'Thorndale for VST', 'TeX Gyre Adventor', 'SERB', 'Simplex', 'Amiri Quran', 'Ubuntu Mono derivative Powerline Bold', 'Songti TC Light', 'One Stroke Script LET', 'Clarendon Blk BT', 'Poiret One', 'Source Code Pro', 'Fascinate', 'GrilledCheese BTN Wide Blk', 'AV-Font-Tam1', 'SWRomnd', 'Times', 'Noto Sans Ol Chiki', 'Source Code Pro Medium', 'HooglyOMJ', 'Gazzarelli', 'One Dance Bold', 'Myriad Pro Light SemiExtended', 'Math5Mono', 'Raleway ExtraLight Italic', 'VNI-Maria', 'Gotham Narrow Book Italic', 'Roboto Black Italic', 'Tekton Pro Bold Extended', 'Titillium Regular Upright', 'FML-TTGauri', 'Stencil Std Bold', 'Note this', 'Bebas Neue Regular', 'Rod', 'VNI-Times', 'cmsy9', 'cmsy8', 'Just Another Hand', 'lcirclew10', 'INSPECTIONXPERT GDT NOFRMS', 'Accord Light SF', 'MMa VariableA', 'Z@R170E.tmp', 'cmsy5', 'New Peninim MT', 'LuzSans-Book', 'cmsy6', 'CATIA Symbols', 'Bauer Bodoni Std 1 Bold', 'Z@R184B.tmp', 'Trebuchet MS', 'Sukhumvit Set Text', 'Tsukushi B Round Gothic Regular', 'HP Simplified', 'Waseem', 'HelveticaNeueLT Pro 67 MdCn', 'Hiragino Kaku Gothic Std', 'Phosphate Inline', 'PondFreeZoo', 'Arial Narrow Bold Italic', 'Kailasa Regular', 'ML-TTThiruvathira', 'FML-TTKala', 'GiovanniITCTT', 'Stone Sans Sem OS ITCTT SemiIta', 'Arimo', 'Trade Gothic LT Std Bold No. 2', 'Source Sans Pro ExtraLight', 'Soho Gothic Pro Medium Italic', 'Milano LET', 'WP BoxDrawing', 'Titillium Light Italic', 'Open Sans Light Italic', 'FML-Revathi', 'Kartika', 'Chalkboard SE Bold', 'Bickham Script Pro Semibold', 'MMCenturyOld Bold Italic', 'FML-TTKarthika', 'Unknown Caller BTN SC', 'Paralucent Heavy Italic', 'MMArrow Italic', 'PMingLiU', 'Gotham Narrow Thin Italic', 'Andale Mono IPA', 'DecoType Thuluth', '04b', 'Urdu Typesetting', '.VnFree', 'URW Chancery L', 'Apple SD Gothic Neo Bold', 'Noto Sans Tagalog', 'PingFang TC Semibold', 'FML-TTAtchu', 'PR Celtic Narrow', 'Abyssinica SIL', 'JaneAusten', 'TAMILNET', 'Jokerman', 'GDT', 'Dosis Light', 'Adobe Garamond Pro Bold Italic', 'Devanagari MT Bold', 'Arial CYR', 'MMa Extra', 'Poor Richard', 'Weibei SC', 'Existence Light', 'Lucida Bright', 'Tahoma', 'Microsoft Yi Baiti', 'IchamotiMJ', 'HKSCS', 'KG Shake it Off Chunky', 'Gadugi', 'WP Greek Courier', 'Comic Relief', 'KacstFarsi', 'PT Separated Baloon', 'Siyam Rupali', 'ScriptC', 'MMSchoolRD Bold Italic', 'SWTxt', 'DejaVu Sans Mono for Powerline', 'FML-TTTheyyam', 'Berlin Sans FB', 'Terminal', 'HGP-AGothic2-Latin1K', 'Blackadder ITC', 'ScriptS', '.VnCourier NewH', 'Arno Pro Smbd Caption', 'Kristen ITC', 'CLARENCE', 'Source Serif Pro', 'OPENCLASSIC', 'OLIVEOIL', 'YuGothic Bold', 'LCD', 'KasseFLF-Bold', 'HelveticaNeueLT Std Thin Ext', 'CZEC', '3M Circular TT Book', 'Bold Italic Art', 'Goudy Old Style', 'ChunkFive Roman', 'Redressed', 'Chess Alpha', 'Myriad Pro Black SemiCondensed Italic', 'Jameel Noori Nastaleeq', 'Master Of Break', 'Smudger LET', 'Kinnari', 'Apple SD Gothic Neo Light', 'Bellota', 'Helvetica Bold Oblique', 'cmssi17', 'Emmett', 'CabinSketch', 'Songti SC', 'cmex10', 'cmssi10', 'Angiang', 'SF Compact Rounded', 'Meslo LG S Regular for Powerline', 'ItalicT', 'SaiEmbed', 'Museo 900 Regular', 'Heiti TC', 'Futura LT Light Oblique', 'Iowan Old Style Italic', 'VNI-Aptima', 'Gotham Narrow Extra Light', '.VnBodoniH', 'MMVariable Bold', 'MMArrow Bold Italic', 'Fluffy Slacks BTN', 'Gotham Narrow Thin', 'QuickType II Pi', 'lcmssb8', 'ItalicC', 'WP Hebrew David', 'Darlin BTN', 'Skia Extended', 'SF Compact Rounded Light', 'Splash', 'ML-TTSurya', 'Warsaw', 'Noto Sans Ogham', 'DhanshirhiMJ', 'MMa Etc', 'Kunstler Script', 'Brush Script Std Medium', 'Seravek Light Italic', 'Kaiti SC Regular', 'Myriad Pro SemiCondensed Italic', 'Futura Book Italic BT', 'JF Georgian Contrast', 'Songti SC Light', 'AV-Web-Hin1', 'Mudir MT', 'BuiltTitlingRg-Bold', 'Gocong', 'Arial Cyr', 'Corsiva Hebrew', 'Bickham Script Pro Regular', 'VNI-Coronet', 'BlairMdITC TT', 'FML-TTThakazhi', 'ITF Devanagari Marathi Bold', 'Courier MM Screenwriter', 'WenQuanYi Micro Hei', 'Kumudam', 'Stone Sans Sem OS ITC TT Semi', 'WP MultinationalB Roman', 'cmex9', 'Rakesly Bk', 'Times Roman', 'HanziPen SC Regular', 'Press Start 2P', 'Myriad Hebrew', 'Wide Latin', 'Raleway Medium', 'Futura Book', 'American Typewriter Bold', 'Hiragino Kaku Gothic Pro W6', 'MMa Arrow SS', 'HelveticaNeueLT Std Thin', 'HelveticaNeueLT Std Ext', 'KacstPoster', 'HanziPen SC Bold', 'Colbert', 'Proxima Nova Soft Bold', 'Calvin', 'Iowan Old Style Titling', 'MMa VariableF', 'Kozuka Mincho Pro EL', 'MMa VariableD', 'Galeforce BTN', 'MMa VariableB', 'MMa VariableC', 'Minion Pro Medium', 'Damascus Light', 'KacstQurn', 'Raleway SemiBold', 'Book Antiqua Bold Italic', 'Uncial Antiqua', 'Diwani Simple Outline', 'BrahmaputraMJ', 'SWIsot2', 'Gotham Ultra', 'Broadway Copyist', 'Osaka', 'VNI-Vivi', 'Meiryo Bold', 'Segoe WP SemiLight', 'STIX Math', 'SWIsot1', 'VNI-ShellaL', 'STIXIntegralsD-Regular', 'STIXSizeThreeSym-Regular', 'lcmss8', 'Neon Lights', 'Z@R16EB.tmp', 'ML-TTLeelaHeavy', 'ParvathiMedium', 'Clarendon', 'Amethyst', 'EQUIS', 'System Font Black', 'ITF Devanagari Bold', 'Lao Sangam MN', 'PT Serif Bold', 'Snap ITC', 'Inder', 'PT Bold Mirror', 'OCR-B 10 BT', 'MMVariable', 'VANAVIL-Avvaiyar', 'Arial Rounded MT Bold', 'ISOCT2', 'Dosis ExtraBold', 'Chaparral Pro Bold Italic', 'MMTextBookB Bold Italic', 'Times New Roman Symbol', 'VNI-Dom', 'HelveticaNeueLT Pro 95 Blk', 'Baoli SC Regular', 'BurigangaOMJ', 'Avenir Next Condensed Ultra Light Italic', 'Letter Gothic Std', 'JLS Data GothicR  NC', 'Roboto Medium Italic', 'Titillium Bold', 'Bookman Old Style Bold Italic', 'Myriad Pro Semi bold', 'ISOCT3', 'msam10', 'Source Sans Pro Semibold', 'Myriad Pro Semibold SemiCondensed Italic', 'Incised901 NdIt BT', 'DejaVu Sans Light', 'Myriad CAD', 'Light', 'Binhdinh', 'Rachgia', 'HGHeiseiMinchotaiW9', 'ChandrabatiOMJ', '.VnTifani HeavyH', 'System Font Heavy Italic', 'GFS Artemisia', 'WP MultinationalB Helve', 'TAB', '8514oem', 'Hack Bold', 'Athelas Bold', 'ArhialkhanOMJ', 'Calibri Light', 'Hoian', 'Avenir Next W1G Ultra Light', 'Vikatan', 'STKaiti', 'Adobe Hebrew Regular', 'Microsoft PhagsPa', 'Bradley Hand ITC', 'Utopia', 'MMa CenturyS Bold', 'KacstLetter', 'Apple SD Gothic Neo Regular', 'Heiti SC Light', 'ABeeZee', 'Chinyen', 'GB18030 Bitmap', 'Lucida Calligraphy Italic', 'euex10', 'HelveticaNeueLT Std Lt Cn', 'Anonymice Powerline Italic', 'News Gothic MT Alt 2', 'Apple SD Gothic Neo', 'Bell Gothic Std Light', 'MATTEROFFACT', 'Z@R1720.tmp', 'Titillium Bold Upright', 'ENGL', 'Engravers MT', 'Gotham Ultra Italic', 'Didot Italic', 'HelveticaNeueLT Pro 33 ThEx', 'Hot Mustard BTN Poster', 'Farah', 'MMTextBook Bold Italic', 'VNI-Shadow', 'New Gulim', 'MMa CenturyKS Italic', 'GungSeo Regular', 'Droid Sans Mono for Powerline', 'iso 08', 'POLI', 'Nova Slim', 'Hue', 'GothicNo13 BT', 'Proxima Nova Black', 'ML-TTAnjali', 'Caflisch Script Pro', 'Lao MN', 'HP PSG', 'VNI-Heather', 'Gill Sans Nova', 'cht', 'Opus Chords', 'Raleway Bold Italic', 'Informal Roman', 'Junicode', 'IMG Love', 'cmti10', 'Verdana Bold', 'Britannic Bold', 'Saab', 'ADMUI2Lg', 'Superclarendon Black Italic', 'OCR A Std', 'Hot Mustard BTN', 'cmti12', 'Francois One', 'Tsukushi B Round Gothic', 'Literation Mono Powerline', 'MAC C Times', 'Noto Sans Inscriptional Pahlavi', 'Proxima Nova Extrabold', 'Georgia Pro Cond', 'Helvetica Light', 'Remachine Script Personal Use', 'Pump Demi Bold LET', 'DilleniaUPC', 'Gentium Book Basic', 'VNI-Algerian', 'Lato Medium Italic', 'MMArrow', 'Niagara Engraved', 'FML-TTMadhaviExBold', 'SWScrpc', 'STIXSizeFourSym-Regular', 'Nafees Web Naskh', 'JLS Data GothicC  NC', 'TAC-Kambar', 'Century Gothic', 'Microsoft Tai Le Bold', 'SWScrps', 'Proxima Nova Light Italic', 'Tamil MN Bold', 'ML-TTGauri', 'ML-TTGeethika', 'AdineKirnberg', 'Rotis Sans Serif Std 75 Extra Bold', 'AR BERKLEY', 'Farisi', 'Rachana', 'Kerala', 'Chaparral Pro', 'Bubblegum Sans', 'Sasfont', 'System Font Italic', 'WP IconicSymbolsA', 'WP IconicSymbolsB', 'Throw My Hands Up in the Air', 'Sneakerhead BTN', 'CentSchbook BT', 'Incised901 BdCn BT', 'PortagoITC TT', 'HaldaMJ', 'MapInfo Cartographic', 'Belwe Lt BT', 'Kundli', 'Kozuka Mincho Pr6N EL', 'Swis721 Cn BT', 'MMBinary Bold Italic', 'SchoolHouse Printed A', 'VNI-Brush', 'Tsukushi A Round Gothic Regular', 'Vollkorn Bold Italic', 'Kozuka Gothic Pr6N R', 'Vijaya', 'Bodoni Ornaments', 'Futura LT Condensed Light Oblique', 'Nexa Regular Italic', 'KarnaphuliMJ', 'Damascus Bold', 'Gotham Black', 'Kohinoor Bangla', 'Noto Sans Mono CJK JP', 'Constantia Italic', 'ML-TTAshtamudiExBold', 'Angsana New', 'Times Bold', 'Arial Narrow Bold', 'MMa CenturyKSS Italic', 'DhonooMJ', 'Noto Sans Ethiopic', 'HelveticaNeueLT Std Med Ext', 'MMCenturyNewRD Bold', 'Yuppy TC Regular', 'SF Distant Galaxy Alternate', 'PT Sans', 'PingFang HK Ultralight', 'Athelas Italic', 'Sonic XBd BT', 'saxMono', 'Bangla MN Bold', 'Tinos Bold for Powerline', 'ChondanaMJ', 'Yuanti TC Regular', 'HelveticaNeueLT Pro 93 BlkEx', 'FML-TTSugatha', 'Ducmy', 'Germ', 'Padauk', 'YD2002', 'Sitka Subheading', 'Myriad Pro SemiCond', 'FreesiaUPC', 'Myriad Pro SemiExtended Italic', 'WP MathB', 'Noto Sans Buhid', 'Noto Sans Mono CJK TC', 'Noto Sans Inscriptional Parthian', 'msbm6', 'Kefa Regular', 'msbm8', 'msbm9', 'Savoye LET', 'Weibei TC Bold', 'LKLUG', 'FML-TTIndulekha', 'MMTimes Italic', 'Noto Sans Imperial Aramaic', 'VNI-Script', '.VnParkH', 'Noto Sans Old South Arabian', 'Matura MT Script Capitals', 'Kozuka Gothic Pr6N B', 'TitilliumText22L-Medium', 'Euclid Bold Italic', 'Calisto MT Bold', 'Dosis Bold', 'Futura LT Medium', 'FML-TTKanika', 'Kufi Outline Shaded', 'Beirut', 'EXCESS', 'New Peninim MT Bold Inclined', 'Optima', 'Source Sans Pro Italic', '.VnAristote', '.VnTimeH', 'MMa Fermat', 'Tangerine', 'KodchiangUPC', 'Noto Sans Batak', 'eurb8', 'ML-TTPoornima', 'Myriad Web Pro', 'Paralucent Thin Italic', 'Avenir Next Demi Bold', 'msam6', 'MMa Century Italic', 'Ezra SIL', '.VnTime', 'Miama', 'Futura LT Condensed Bold', 'Literation Mono Powerline Bold', 'Myriad Pro Condensed', 'MMa Arrow', 'SimHei', 'FML-TTNandini', 'Kaiti SC', 'SF Compact Rounded Medium', 'KG Primary Penmanship', 'LilyUPC', 'Skia Bold', 'ML-TTMayoori', 'VNI-Tekon', 'Vonique 64', 'Myriad Pro Cond', 'Arial Hebrew Scholar Light', 'Engravers MT Bold', 'Perpetua Italic', 'Arial Greek', 'Noteworthy', 'ML-TTIndulekhaHeavy', 'ISOCTEUR', 'Visitor TT2 BRK', 'Marker Felt', 'cmr17', 'SWAstro', 'LETT', 'AlekyaExtraBold', 'FML-TTYashasri', 'cmr10', 'Gothic720 Lt BT', 'Microdot', '.VnClarendon', 'Book Antiqua Bold', 'HeiT', '.VnAvantH', 'PT Serif Caption Italic', 'Princetown LET', 'Eccentric Std', '8Pin Matrix', 'GangaOMJ', 'Kohinoor Bangla Bold', 'ML-TTJyotsna', 'Hoefler Text Italic', 'Iskoola Pota', 'Bodoni 72 Bold', 'Wingdings', 'Noto Sans Shavian', 'Bahiana', 'Roboto Bold Italic', 'Viner Hand ITC', 'Bauhaus 93', 'VNI-Franko', 'cmbx7', 'cmbx6', 'cmbx5', 'SAPGUI-Icons', 'Charter Italic', 'cmbx9', 'cmbx8', 'Gelfling SF', 'Aileron Black', 'Bookshelf Symbol 1', 'HGPHeiseiKakugothictaiW9', 'FML-TTPooram', 'Raanana', 'OCRA', 'Sanskrit New', 'Khmer UI', 'Cochin', 'Ostrich Sans Rounded', 'TLArabic', 'Latin Modern Mono', 'AG', 'Opus Chords Sans', 'Source Code Pro Bold', 'Source Sans Pro Black Italic', 'BorakMJ', 'Futura Bold', 'Big Caslon', 'Latin Modern Roman Dunhill', 'CAMPBELL', 'Futura Medium Italic', 'FML-TTSuparna', 'Footlight MT Light', 'FML-TTKamini', 'SignPainter', 'Noto Sans Armenian', 'Adobe Caslon Pro Italic', 'Latin Modern Mono Slanted', 'Wawati SC Regular', 'Dayton', 'Roman', 'Newton Phonetic ABBYY', 'MMBinary Italic', 'IMG Travel', 'Helvetica Oblique', 'FELIZ', 'Amiri', 'VNI-Colonna', 'JumunaOMJ', 'DIN Alternate', 'Lohit Devanagari', 'Aileron Thin', 'Tamil MN', 'GhorautraOMJ', 'Bodoni MT Black', 'Wolf in the City', 'FML-TTPoornima', 'Trade Gothic LT Std Bold Extended', 'Complete in Him', 'ITF Devanagari', 'Goudy Stout', 'Diwan Thuluth Regular', '01 Digit', 'TeX Gyre Cursor', 'Playfair Display SC Bold Italic', 'HelveticaNeueLT Std Med Cn', 'Avenir Next Condensed Heavy', 'FrankRuehl', 'Hiragino Sans GB', 'GFS BodoniClassic', 'LightSC', 'Camranh', 'TAM-Kavi', 'Phetsarath OT', 'Symbol', 'High Tower Text', 'Rondalo', 'Miriam', 'Jayanthi', 'MMTextBook Italic', 'Leelawadee UI Semilight', 'OpineHeavy', 'Century Schoolbook Italic', 'Chalkboard SE Regular', 'SWTOR Trajan', 'ML-TTSugatha', 'SF Distant Galaxy Outline', 'Theatre Antoine', 'Heavy Heap', 'ML1-TTIndulekha', 'SFNS Display', 'Nexa Light Italic', 'Linux Biolinum Keyboard O', 'Adobe Devanagari Bold', 'BaluScript', 'Avenir Next Condensed Regular', 'ARDS1', 'cmssqi8', 'Tempus Sans ITC', 'Avenir Next Medium', 'GungsuhChe', 'ChondanaOMJ', 'B095', 'Borealis', 'Seravek ExtraLight Italic', 'Avenir Next Heavy Italic', 'Tamil Sangam MN Bold', 'HelveticaNeue', 'Tsukushi A Round Gothic Bold', 'VNI-Helve-Condense', 'FML-TTAnakha', 'Hiragino Kaku Gothic StdN W8', '.VnMonotype corsiva', 'MMa VariableF S', 'Nightclub BTN', 'Berling', 'MMa VariableB SS', 'Z@R11F8.tmp', 'Suruma', 'Telugu MN', 'Linux Libertine O', 'Italianate', 'Raleway Italic', 'Span', 'ML-TTKeerthi', 'MMa Pascal', 'VNI-Scribble', 'Indie Flower', 'Avenir Next Condensed Demi Bold Italic', 'ML-TTVisakham', 'Arno Pro Caption', 'Qaskin White Personal Use', 'MMTextBookB', 'Al Tarikh', 'Berkshire Swash', 'Hobo Std Medium', 'DINPro-Regular', 'Circular Std Black Italic', 'Muna Bold', 'TechnicBold', 'SWMono', 'Sukhumvit Set Bold', 'Palatino Linotype Bold Italic', '.VnCentury SchoolbookH', 'Euclid Math Two Bold', 'Creepygirl', 'ISOCP3', 'Source Sans Pro Black', 'MMa Relation', 'Futura LT Condensed Medium', 'BongshaiOMJ', 'VNI Aptima', 'Californian FB', 'Leitura Display Swashes', 'Gotham Narrow Ultra Italic', 'Math2Mono', 'Swis721 BdOul BT', 'Clubland', 'English157 BT', 'modstmary10', 'eurm9', 'euex8', 'Diavlo Medium', 'Iowan Old Style Black Italic', 'MMa GreekS', 'Adobe Garamond Pro', 'Cordia New Bold', 'PRETEXT', 'DengXian', 'University Roman LET', 'Open Sans Semibold', 'Soho Gothic Pro Ultra', 'Futura Extra Bold Oblique', 'Roboto Condensed Light Italic', 'Tamil-Aiswarya', 'ML-TTNandini', 'Showcard Gothic', 'Avenir Next Ultra Light Italic', 'Trade Gothic LT Std Bold Condensed No. 20', 'DFKai-SB', 'FML-TTAshtamudi', 'Ostrich Sans Dashed', 'Copperplate', 'Myriad Pro Semibold SemiExtended', 'NewRocker', 'DIN-MediumAlternate', 'Arimo Bold', 'Arial Hebrew', 'TLPashto', 'Gauge', 'Gotham Bold Italic', 'MMVariable2 Bold', 'FFF Tusj', '.VnHelvetInsH', 'Embassy BT', 'MMSchoolRD Italic', 'Bodoni MT Condensed', 'Myriad Pro Semibold', 'CityBlueprint', '.VnGothic', 'Source Code Pro Black', 'Futura Light', 'Baamini', 'Palatino Italic', 'GulimChe', 'SF Distant Galaxy AltOutline', 'Gotham Light', 'AcmeFont', 'Trade Gothic LT Std Bold Condensed No. 20 Oblique', 'DIN-Medium', 'Terminator Real NFI', 'Letter Gothic Std Bold Slanted', 'Gill Sans Light Italic', 'YuMincho Medium', 'Myriad Pro Light Condensed Italic', 'Myriad Pro Black Condensed Italic', 'Osaka-Mono', 'Bodoni 72 Oldstyle', 'Josefin Slab', 'Gurmukhi MN', 'Gauge Heavy', 'Haxton Logos TT', 'Perpetua', 'BhairabMJ', 'Fences', 'Gurmukhi MT', 'Good Times', 'MMa Extra S', 'Benguiat', 'DINPro-Medium', 'MMa Variable2 SS', 'Oswald Stencil', 'Apple Braille', 'HelveticaNeueLT Std Blk Ext', 'Noteworthy Light', 'Scruff LET', 'DIN-BlackAlternate', 'Letter Gothic Std Medium', 'Adobe Pi Std', 'Kozuka Mincho Pr6N', 'Menlo Regular', 'Almonte Snow', 'Belfast Heavy SF', 'Kaiti SC Bold', 'AR CHRISTY', 'VNI-Lydi', 'Cantarell Bold Oblique', 'Gentium', 'Bevan', 'Quicksand Light Regular', 'JLS Space GothicC  NC', 'True Lies', 'STIXVariants', 'MMa TextBook Bold', 'Segoe UI Black', 'Noto Sans Malayalam', 'eurb10', 'Averia Serif', 'Candy Round BTN Cond', 'ML-TTBeckalBold', 'Bariol Regular', 'Avenir Medium Oblique', 'Kohinoor Bangla Semibold', 'Helvetica Neue Bold', 'Broadway', 'ML-TTAmbili', 'Imprint MT Shadow', 'Noto Sans Mono CJK KR', 'cmfi10', 'UnitedStates', 'ML-NILA07', 'Chandas', 'Coolsville', 'Script', 'Franklin Gothic Demi', 'HelveticaNeueLT Pro 63 MdEx', 'Yuanti SC Light', 'FML-TTLeelaHeavy', 'Prisoner SF', 'Times New Roman CYR', 'News Gothic MT Alt 6', 'Bodoni 72 Book Italic', 'Shree-Kan-0853', 'Letter Gothic Std Bold', 'Rekha', 'Akhbar MT', 'DecoType Naskh Regular', 'Segoe Print', 'Gunplay', 'Nadeem Regular', 'Accanthis ADF Std', 'Roboto Condensed Bold', 'Adobe Caslon Pro Bold Italic', 'Helvetica Neue Bold Italic', 'Tlwg Typist', 'SF Compact Rounded Thin', 'Swiss 721 Bold BT', 'Jwala', 'Capitals', 'GFS Theokritos', 'cmr8', 'cmr9', 'cmr6', 'cmr7', 'SWGrekc', 'Timeless', 'w01', 'Microsoft Himalaya', 'Digifit', 'Minion Pro Med', 'Simple Outline Pat', 'MMa Negate Bold', 'Linden Hill', 'Courier New (Arabic)', 'Sauce Code Powerline Black', 'Noto Sans Gothic', 'Adobe Kaiti Std', 'AV-Web-Tam1', 'Athelas Regular', 'FML-TTMangalaExBold', 'Rockwell Bold Italic', 'Visitor TT1 BRK', 'Brandish', 'Futura LT Condensed Extra Bold Oblique', 'Manorly', 'Gotham Narrow Light', 'MS Outlook', 'cmti8', 'DejaVu Serif', 'Allura', 'Kailasa', 'Source Sans Pro Light', 'Burst My Bubble', 'ISOCT', 'Hannotate SC', 'ISOCP', 'Greek Diner Inline TT', 'Paralucent Thin', 'BuiltTitlingRg-Regular', 'Calligraphic', 'SF Slapstick Comic Bold Oblique', 'Soho Gothic Pro Light Italic', 'Euclid Extra', 'Sauce Code Powerline Light', 'Courier New Greek', 'Noto Sans Georgian', 'PT Sans Italic', 'Cousine Bold Italic for Powerline', 'Modern No. 20', 'VNI-Goudy', 'Math3Mono', 'Georgia Italic', 'Luna Bar', 'VNI-Bragga', 'Sawasdee', 'TAMLKamban', 'Paralucent Bold Italic', 'PingFang TC', 'Valken', 'MMCenturyNewRD', 'Meera', 'Saint Andrew des Kiwis', 'Courier Bold Oblique', 'Diavlo Light', 'HGSMinchoL', 'Diwani Bent', 'MMa VariableD Bold', 'Courier New Italic', 'Aileron UltraLight', 'Chess Merida', 'cmsl8', 'Snell Roundhand Black', 'Candara Bold', 'Grafolita Script Medium', 'Diwani Letter', 'Paralucent Bold', 'Adobe Devanagari Italic', 'VNI-Linus', 'cmss12', 'eusm10', 'Avenir Next W1G Light Italic', 'Seravek ExtraLight', 'Magneto', 'Interstate-Black', 'SignPainter-HouseScript', 'Euclid Extra Bold', 'System Font Medium Italic P4', 'TtsNote', 'Quicksand Book Oblique Regular', 'TAMILFIX', 'Industrial736 BT', 'Adobe Arabic Bold', 'InaiMathi', 'Tera Special', 'Myriad Pro Light SemiExtended Italic', 'NanumGothic Bold', 'MMTextBookB Bold', 'JaJaDiOMJ', 'Nimbus Mono L', 'Futura Std Bold', 'Finale Numerics', 'Moon Flower Bold', 'Baskerville', 'Lucida Console', 'Swis721 Lt BT', 'Mael', 'Nexa Heavy Italic', 'Becky', 'ML-TTKaumudi', 'TAU-Kabilar', 'MMa CenturyS Bold Italic', 'Violetta', 'Bell MT Bold', 'Palatino Linotype Italic', 'FML-TTNila', 'FML-Karthika', 'Rotis Sans Serif Std 65 Bold', 'PenultimateLight', 'VNI-Revue', 'Liberation Mono', 'Trade Gothic LT Std Bold No. 2 Oblique', 'GFS Didot', 'Eras Medium ITC', '.VnBlackH', 'MMa Binary SS', 'ML-TTSabari', 'Bangla Sangam MN Bold', 'Stencil', 'AppleMyungjo', 'TM-TTValluvar', 'Gill Sans Ultra Bold Condensed', 'type 07', 'Yu Gothic UI Semibold', 'KN-TTUma', 'Playfair Display', 'Txt', 'Gotham Narrow Light Italic', 'Menlo', 'Zirkon', 'AV-Font-Sin', 'Microsoft Sans Serif', 'Tall Boy West', 'Yu Gothic', 'AMGDT', 'Simplified Arabic Fixed', 'STSong', 'Arimo for Powerline', 'Bell MT', 'KufiStandardGK', 'Nexa Bold', 'TG Pagella Math', 'Adobe Arabic Regular', 'Futura Extra Bold', 'SamsungImagination', 'Mycalc', 'MMa CenturyKSS Bold Italic', 'Superclarendon Black', 'Catull', 'HYSWLongFangSong', 'cmsy10', 'FML-TTAyilyamBold', 'Rakesly Lt', 'Haettenschweiler', 'SF Compact Rounded Heavy', 'Beatnik SF', 'Trajan Pro', 'Sosa Regular', 'Adobe Song Std', 'Raleway Bold', 'Bauer Bodoni Std 1 Italic', 'DholeshwariOMJ', 'VNI-StencilU', 'Kefa', 'STXihei', 'Garamond Bold', 'Trajan Pro Bold', 'Reklame Script Medium', 'AGA Arabesque Desktop', 'Savoye LET Plain', 'BATAVIA', 'Fabrica', 'Gidole', 'Abril Fatface Regular', 'Baskerville SemiBold', 'Gill Sans SemiBold Italic', 'Hombre', 'Helvetica Neue', 'STIXIntegralsUpSm-Bold', 'Vogue', 'Noto Sans Kayah Li', 'Noto Sans Lydian', 'Avenir Next Bold', 'Myriad Pro Light SemiExt', 'VNI-Bodon', 'Estrangelo Edessa', 'Titillium Semibold Upright', 'Kingthings Versalis', 'Droid Sans Mono Slashed for Powerline', 'Patrick Hand SC', '.VnLinusH', 'Galatia SIL', 'Myanmar MN Bold', 'Anonymice Powerline Bold Italic', 'STIXNonUnicode-BoldItalic', 'IMG Seasons', 'KaiTi', 'NEOLITH', 'MS Reference Sans Serif', 'GFS Baskerville', 'PingFang HK', 'Adobe Garamond Pro Italic', 'OCR B MT', 'Bariol Regular Italic', 'Minion Pro Bold', 'Nexa XBold', 'AppleGothic Regular', '.VnMemorandumH', 'HelveticaNeue BlackCond', 'Small Fonts', 'Myriad Pro Italic', 'Symath', 'Times New Roman Baltic', 'Spicy Rice', 'FML-TTMayoori', 'Wingdings 3', 'Wingdings 2', 'Zapf Dingbats', 'Rockwell Bold', 'JomunaMJ', 'Forte', 'Mona Lisa Solid ITC TT', 'FML-TTDevika', 'Gill Sans Nova Cond XBd', 'Lucida Calligraphy', 'HelveticaNeueLT Std UltLt', 'Palatino', 'HanziPen TC', 'Courier New Cyr', 'Seville', 'SF Compact Rounded Black', 'Colonna MT', 'HelveticaNeueLT Std ExtBlk Cn', 'Arial Hebrew Light', 'Canterbury Regular', 'Ital', 'Tekton Pro Ext', 'Dosis ExtraLight', 'Mshtakan BoldOblique', 'New Athena Unicode', 'Ubuntu Condensed', 'SansSerif', 'Century Gothic Bold', 'Nueva Std Cond', 'Malgun Gothic', 'STIXGeneral-Italic', 'Arial Nova Cond Light', 'Tinos for Powerline', 'CSD16', 'PFDaVinciScriptPro-Regular', 'KalindiSMJ', 'MMTimes Bold Italic', 'ML-TTSankara', 'JazzTextExtended', 'Courier MM Screenwriter Bold', 'Minion Pro', 'Calibri Bold Italic', 'Merriweather Light', 'FreeSerif', 'Old English Text MT', 'System Font Bold Italic', 'Baron Neue Black Italic', 'Avenir Next W1G Demi', 'Finale Mallets', 'Circular Std Bold Italic', 'Wawati TC Regular', 'Tinos Italic for Powerline', 'Trade Gothic LT Std Condensed No. 18', 'Paralucent Medium Italic', 'Cumberland AMT', 'VNI Laos', 'Camau', 'Eras Light ITC', 'Segoe UI Symbol', 'Aleo', 'DIN 1451 Mittelschrift', 'VNI-Chaucer', 'Cuulong', '.VnMystical', 'Nexa Heavy', 'Kohinoor Devanagari Regular', 'HolidayPi BT', 'Jokerman LET', 'Salina', 'Arial monospaced for SAP', 'MMa Century', 'Baskerville SemiBold Italic', 'MMa GreekS Italic', 'Lapidary333 Blk BT', 'Lucida Handwriting', 'Adobe Myungjo Std', 'Alfredo', 'Dot-Matrix', 'Thanhoa', 'cmr12', 'Adobe Fangsong Std', 'BatangChe', 'Academy Engraved LET Plain:1.0', 'Calligraph421 BT', 'DejaVu Serif Condensed', 'SWItal', 'Futura LT Book Oblique', 'Noto Sans Lycian', 'Noto Sans Phags Pa', 'SF Compact Text', 'MAXIMO', 'Avanti', 'Adobe Caslon Pro Bold', 'Space Bd BT', 'November', 'Lavanderia', 'Maiandra GD', 'at most sphere', 'Farisi Regular', 'Gill Sans Nova Cond Lt', 'Razer Text Regular', 'VNI-Auchon', 'Myriad Pro Black SemiExt', 'KacstOne', 'Cordia New', 'Gotham Thin Italic', 'Raleway Black', 'Hiragino Sans W9', 'Hiragino Sans W8', 'MoolBoran', 'Penultimate', 'Hiragino Sans W5', 'Hiragino Sans W4', 'Hiragino Sans W7', 'Hiragino Sans W6', 'Hiragino Sans W1', 'Hiragino Sans W0', 'Hiragino Sans W3', 'Hiragino Sans W2', 'Minion Pro Italic', 'Kozuka Mincho Pr6N M', 'Kozuka Mincho Pr6N L', 'Proxima Nova Condensed Semibold Italic', 'Kozuka Mincho Pr6N H', 'Hiragino Maru Gothic ProN W4', 'HelveticaNeueLT Std Extended', 'NanumBarunGothic', 'Kozuka Mincho Pr6N B', 'VNI Russia', 'Reklame Script Bold', 'ML-TTThakazhi', 'MMSchoolRD', 'Futura Std Light', 'Poplar Std', 'Kozuka Mincho Pr6N R', 'Franklin Gothic', 'Paralucent Light', 'ML-TTVaisali', 'cmb10', 'Waseem Light', 'VNI-Cooper', 'Script MT Bold', 'Ethnocentric', 'STIXSizeFourSym', 'Praveen', 'Calibri Bold', 'ML-TTYashasri', 'Swis721 LtCn BT', 'Freestyle Script', 'Snowdrift', 'Myriad Pro Semibold SemiExtended Italic', 'LiSong Pro', 'Myanmar Sangam MN Bold', 'MMCenturyOldGreek Bold', 'VNI-Broad', 'YuGothic', 'American Typewriter Semibold', 'Hannotate SC Bold', 'Opus Ornaments', 'Arimo Italic', 'RamuBrush', 'TechnicLite', 'Geneva', 'Nexa Book', 'FML-IndulekhaHeavy', 'Arimo Bold for Powerline', 'Marion Bold', 'Apple Braille Outline 6 Dot', 'FML-TTBhavana', 'Nanum Myeongjo', 'PT Sans Caption Bold', 'Gotham Medium Italic', 'Vani', 'Quicksand Italic', 'Z@R195D.tmp', 'Soho Gothic Pro Bold Italic', 'Hannotate TC', 'ITF Devanagari Book', 'Cracked Johnnie', 'Rockwell Nova Light', 'HGPMinchoL', 'STIXNonUnicode-Bold', 'VNI-Arial Rounded', 'Braggadocio', 'Swiss921 BT', 'Futura', 'Museo 300 Regular', 'Adobe Arabic Italic', 'Trade Gothic LT Std', 'Titillium Bold Italic', 'VNI-Juni', 'Myriad Pro Bold SemiCondensed Italic', 'SWGamekeys MT', 'Plantagenet Cherokee', 'Comfortaa', 'Baron Neue Black', 'Latin Modern Mono Prop Light', 'Crystal', 'RamuScript', 'SAPDings', 'RadhaBold', 'Superclarendon Bold Italic', 'Libel Suit', 'Sneakerhead BTN Outline', '.VnLincoln', 'MMTextBook', 'Gujarati MT', 'KacstScreen', 'MMEtc Bold Italic', 'Dosis SemiBold'];

				var detector = new fontDetector();  //Namespace Required
				for (i = 0, len = fonts.length; i < len; ++i) {
					if (detector.detect(fonts[i])) this.fontsData += '1';
					else this.fontsData += '0';
				}

				this.postData['fonts'] = this.fontsData;

				this.postData['timezone'] = new Date().getTimezoneOffset();


				/**
				 * this part is used for dected the real resolution
				 */
				this.postData['resolution'] = getResolution();


				var plgs_len = navigator.plugins.length;
				var plgs = "";
				for (var i = 0; i < plgs_len; i++) {
					plgs += navigator.plugins[i].name + '_';
				}
				plgs = plgs.replace(/[^a-zA-Z ]/g, "");
				this.postData['plugins'] = plgs;
				this.postData['cookie'] = navigator.cookieEnabled;

				try {
					localStorage.setItem('test', 'test');
					localStorage.removeItem('test');
					this.postData['localstorage'] = true;
				} catch (e) {
					this.postData['localstorage'] = false;
				}

				this.postData['adBlock'] = $('#ad')[0] == null ? 'Yes' : 'No';

				//console.log(this.postData['adBlock'])

				cvs_test = CanvasTest();
				this.postData['canvas_test'] = _GP.Base64EncodeUrlSafe(calcSHA1(cvs_test.substring(22, cvs_test.length))); //remove the leading words
				if (!navigator.hardwareConcurrency)
					this.postData['cpu_cores'] = "-1";
				else
					this.postData['cpu_cores'] = navigator.hardwareConcurrency;

				this.postData['audio'] = audioFingerPrinting();
				this.postData['langsDetected'] = _GP.get_writing_scripts();

				$('#status').html("Waitting for the server...");
				startSend(this.postData);

				function startSend(postData) {
					$.ajax({
						url: "https://" + ip_address + "/gpu_fp",
						dataType: "json",
						contentType: 'application/json',
						type: 'POST',
						data: JSON.stringify(postData),
						success: function (data) {
							//console.log(data);
							data['finished'] = true;
							localStorage.setItem('summitclientid_gpu_mid', data.cross);
							localStorage.setItem('summitclientid_gpu_bid', data.single);
							//parent.postMessage(data,"http://" + ip_address);
						},
						error: function (xhr, ajaxOptions, thrownError) {
							//alert(thrownError);
						}
					});

				}

			}
	};

	/* Converts the charachters that aren't UrlSafe to ones that are and
	   removes the padding so the base64 string can be sent
	   */
	_GP.Base64EncodeUrlSafe = function (str) {
		return str.replace(/\+/g, '-').replace(/\//g, '_').replace(/\=+$/, '');
	};

	_GP.stringify = function (array) {
		var str = "";
		for (var i = 0, len = array.length; i < len; i += 4) {
			str += String.fromCharCode(array[i + 0]);
			str += String.fromCharCode(array[i + 1]);
			str += String.fromCharCode(array[i + 2]);
		}

		// NB: AJAX requires that base64 strings are in their URL safe
		// form and don't have any padding
		var b64 = window.btoa(str);
		return _GP.Base64EncodeUrlSafe(b64);
	};

	Uint8Array.prototype.hashCode = function () {
		var hash = 0, i, chr, len;
		if (this.length === 0)
			return hash;
		for (i = 0, len = this.length; i < len; i++) {
			chr = this[i];
			hash = ((hash << 5) - hash) + chr;
			hash |= 0; // Convert to 32bit integer
		}
		return hash;
	}

	_GP.sender = new Sender();

	// Generated by CoffeeScript 1.10.0
	(function () {
		var Depthbuffer, Drawable, Framebuffer, Mat3, Mat4, Renderbuffer, Shader, Texture, WebGLFramework, arc, deg, getVendorAttrib, pi, tau, vendorName, vendors,
			extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
			hasProp = {}.hasOwnProperty,
			bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; };

		pi = Math.PI;

		tau = 2 * pi;

		deg = 360 / tau;

		arc = tau / 360;

		Mat3 = (function () {
			function Mat3(data1) {
				this.data = data1;
				if (this.data == null) {
					this.data = new Float32Array(9);
				}
				this.ident();
			}

			Mat3.prototype.ident = function () {
				var d;
				d = this.data;
				d[0] = 1;
				d[1] = 0;
				d[2] = 0;
				d[3] = 0;
				d[4] = 1;
				d[5] = 0;
				d[6] = 0;
				d[7] = 0;
				d[8] = 1;
				return this;
			};

			Mat3.prototype.transpose = function () {
				var a01, a02, a12, d;
				d = this.data;
				a01 = d[1];
				a02 = d[2];
				a12 = d[5];
				d[1] = d[3];
				d[2] = d[6];
				d[3] = a01;
				d[5] = d[7];
				d[6] = a02;
				d[7] = a12;
				return this;
			};

			Mat3.prototype.mulVec3 = function (vec, dst) {
				if (dst == null) {
					dst = vec;
				}
				this.mulVal3(vec.x, vec.y, vec.z, dst);
				return dst;
			};

			Mat3.prototype.mulVal3 = function (x, y, z, dst) {
				var d;
				dst = dst.data;
				d = this.data;
				dst[0] = d[0] * x + d[3] * y + d[6] * z;
				dst[1] = d[1] * x + d[4] * y + d[7] * z;
				dst[2] = d[2] * x + d[5] * y + d[8] * z;
				return this;
			};

			Mat3.prototype.rotatex = function (angle) {
				var c, s;
				s = Math.sin(angle * arc);
				c = Math.cos(angle * arc);
				return this.amul(1, 0, 0, 0, c, s, 0, -s, c);
			};

			Mat3.prototype.rotatey = function (angle) {
				var c, s;
				s = Math.sin(angle * arc);
				c = Math.cos(angle * arc);
				return this.amul(c, 0, -s, 0, 1, 0, s, 0, c);
			};

			Mat3.prototype.rotatez = function (angle) {
				var c, s;
				s = Math.sin(angle * arc);
				c = Math.cos(angle * arc);
				return this.amul(c, s, 0, -s, c, 0, 0, 0, 1);
			};

			Mat3.prototype.amul = function (b00, b10, b20, b01, b11, b21, b02, b12, b22, b03, b13, b23) {
				var a, a00, a01, a02, a10, a11, a12, a20, a21, a22;
				a = this.data;
				a00 = a[0];
				a10 = a[1];
				a20 = a[2];
				a01 = a[3];
				a11 = a[4];
				a21 = a[5];
				a02 = a[6];
				a12 = a[7];
				a22 = a[8];
				a[0] = a00 * b00 + a01 * b10 + a02 * b20;
				a[1] = a10 * b00 + a11 * b10 + a12 * b20;
				a[2] = a20 * b00 + a21 * b10 + a22 * b20;
				a[3] = a00 * b01 + a01 * b11 + a02 * b21;
				a[4] = a10 * b01 + a11 * b11 + a12 * b21;
				a[5] = a20 * b01 + a21 * b11 + a22 * b21;
				a[6] = a00 * b02 + a01 * b12 + a02 * b22;
				a[7] = a10 * b02 + a11 * b12 + a12 * b22;
				a[8] = a20 * b02 + a21 * b12 + a22 * b22;
				return this;
			};

			Mat3.prototype.fromMat4Rot = function (source) {
				return source.toMat3Rot(this);
			};

			Mat3.prototype.log = function () {
				var d;
				d = this.data;
				return console.log('%f, %f, %f,\n%f, %f, %f, \n%f, %f, %f, ', d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], d[8]);
			};

			return Mat3;

		})();

		Mat4 = (function () {
			function Mat4(data1) {
				this.data = data1;
				if (this.data == null) {
					this.data = new Float32Array(16);
				}
				this.ident();
			}

			Mat4.prototype.ident = function () {
				var d;
				d = this.data;
				d[0] = 1;
				d[1] = 0;
				d[2] = 0;
				d[3] = 0;
				d[4] = 0;
				d[5] = 1;
				d[6] = 0;
				d[7] = 0;
				d[8] = 0;
				d[9] = 0;
				d[10] = 1;
				d[11] = 0;
				d[12] = 0;
				d[13] = 0;
				d[14] = 0;
				d[15] = 1;
				return this;
			};

			Mat4.prototype.zero = function () {
				var d;
				d = this.data;
				d[0] = 0;
				d[1] = 0;
				d[2] = 0;
				d[3] = 0;
				d[4] = 0;
				d[5] = 0;
				d[6] = 0;
				d[7] = 0;
				d[8] = 0;
				d[9] = 0;
				d[10] = 0;
				d[11] = 0;
				d[12] = 0;
				d[13] = 0;
				d[14] = 0;
				d[15] = 0;
				return this;
			};

			Mat4.prototype.copy = function (dest) {
				var dst, src;
				src = this.data;
				dst = dest.data;
				dst[0] = src[0];
				dst[1] = src[1];
				dst[2] = src[2];
				dst[3] = src[3];
				dst[4] = src[4];
				dst[5] = src[5];
				dst[6] = src[6];
				dst[7] = src[7];
				dst[8] = src[8];
				dst[9] = src[9];
				dst[10] = src[10];
				dst[11] = src[11];
				dst[12] = src[12];
				dst[13] = src[13];
				dst[14] = src[14];
				dst[15] = src[15];
				return dest;
			};

			Mat4.prototype.toMat3 = function (dest) {
				var dst, src;
				src = this.data;
				dst = dest.data;
				dst[0] = src[0];
				dst[1] = src[1];
				dst[2] = src[2];
				dst[3] = src[4];
				dst[4] = src[5];
				dst[5] = src[6];
				dst[6] = src[8];
				dst[7] = src[9];
				dst[8] = src[10];
				return dest;
			};

			Mat4.prototype.toMat3Rot = function (dest) {
				var a00, a01, a02, a10, a11, a12, a20, a21, a22, b01, b11, b21, d, dst, id, src;
				dst = dest.data;
				src = this.data;
				a00 = src[0];
				a01 = src[1];
				a02 = src[2];
				a10 = src[4];
				a11 = src[5];
				a12 = src[6];
				a20 = src[8];
				a21 = src[9];
				a22 = src[10];
				b01 = a22 * a11 - a12 * a21;
				b11 = -a22 * a10 + a12 * a20;
				b21 = a21 * a10 - a11 * a20;
				d = a00 * b01 + a01 * b11 + a02 * b21;
				id = 1 / d;
				dst[0] = b01 * id;
				dst[3] = (-a22 * a01 + a02 * a21) * id;
				dst[6] = (a12 * a01 - a02 * a11) * id;
				dst[1] = b11 * id;
				dst[4] = (a22 * a00 - a02 * a20) * id;
				dst[7] = (-a12 * a00 + a02 * a10) * id;
				dst[2] = b21 * id;
				dst[5] = (-a21 * a00 + a01 * a20) * id;
				dst[8] = (a11 * a00 - a01 * a10) * id;
				return dest;
			};

			Mat4.prototype.perspective = function (arg) {
				var aspect, bottom, d, far, fov, left, near, right, top;
				fov = arg.fov, aspect = arg.aspect, near = arg.near, far = arg.far;
				if (fov == null) {
					fov = 60;
				}
				if (aspect == null) {
					aspect = 1;
				}
				if (near == null) {
					near = 0.01;
				}
				if (far == null) {
					far = 100;
				}
				this.zero();
				d = this.data;
				top = near * Math.tan(fov * Math.PI / 360);
				right = top * aspect;
				left = -right;
				bottom = -top;
				d[0] = (2 * near) / (right - left);
				d[5] = (2 * near) / (top - bottom);
				d[8] = (right + left) / (right - left);
				d[9] = (top + bottom) / (top - bottom);
				d[10] = -(far + near) / (far - near);
				d[11] = -1;
				d[14] = -(2 * far * near) / (far - near);
				return this;
			};

			Mat4.prototype.inversePerspective = function (fov, aspect, near, far) {
				var bottom, dst, left, right, top;
				this.zero();
				dst = this.data;
				top = near * Math.tan(fov * Math.PI / 360);
				right = top * aspect;
				left = -right;
				bottom = -top;
				dst[0] = (right - left) / (2 * near);
				dst[5] = (top - bottom) / (2 * near);
				dst[11] = -(far - near) / (2 * far * near);
				dst[12] = (right + left) / (2 * near);
				dst[13] = (top + bottom) / (2 * near);
				dst[14] = -1;
				dst[15] = (far + near) / (2 * far * near);
				return this;
			};

			Mat4.prototype.ortho = function (near, far, top, bottom, left, right) {
				var fn, rl, tb;
				if (near == null) {
					near = -1;
				}
				if (far == null) {
					far = 1;
				}
				if (top == null) {
					top = -1;
				}
				if (bottom == null) {
					bottom = 1;
				}
				if (left == null) {
					left = -1;
				}
				if (right == null) {
					right = 1;
				}
				rl = right - left;
				tb = top - bottom;
				fn = far - near;
				return this.set(2 / rl, 0, 0, -(left + right) / rl, 0, 2 / tb, 0, -(top + bottom) / tb, 0, 0, -2 / fn, -(far + near) / fn, 0, 0, 0, 1);
			};

			Mat4.prototype.inverseOrtho = function (near, far, top, bottom, left, right) {
				var a, b, c, d, e, f, g;
				if (near == null) {
					near = -1;
				}
				if (far == null) {
					far = 1;
				}
				if (top == null) {
					top = -1;
				}
				if (bottom == null) {
					bottom = 1;
				}
				if (left == null) {
					left = -1;
				}
				if (right == null) {
					right = 1;
				}
				a = (right - left) / 2;
				b = (right + left) / 2;
				c = (top - bottom) / 2;
				d = (top + bottom) / 2;
				e = (far - near) / -2;
				f = (near + far) / 2;
				g = 1;
				return this.set(a, 0, 0, b, 0, c, 0, d, 0, 0, e, f, 0, 0, 0, g);
			};

			Mat4.prototype.fromRotationTranslation = function (quat, vec) {
				var dest, w, wx, wy, wz, x, x2, xx, xy, xz, y, y2, yy, yz, z, z2, zz;
				x = quat.x;
				y = quat.y;
				z = quat.z;
				w = quat.w;
				x2 = x + x;
				y2 = y + y;
				z2 = z + z;
				xx = x * x2;
				xy = x * y2;
				xz = x * z2;
				yy = y * y2;
				yz = y * z2;
				zz = z * z2;
				wx = w * x2;
				wy = w * y2;
				wz = w * z2;
				dest = this.data;
				dest[0] = 1 - (yy + zz);
				dest[1] = xy + wz;
				dest[2] = xz - wy;
				dest[3] = 0;
				dest[4] = xy - wz;
				dest[5] = 1 - (xx + zz);
				dest[6] = yz + wx;
				dest[7] = 0;
				dest[8] = xz + wy;
				dest[9] = yz - wx;
				dest[10] = 1 - (xx + yy);
				dest[11] = 0;
				dest[12] = vec.x;
				dest[13] = vec.y;
				dest[14] = vec.z;
				dest[15] = 1;
				return this;
			};

			Mat4.prototype.trans = function (x, y, z) {
				var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, d;
				d = this.data;
				a00 = d[0];
				a01 = d[1];
				a02 = d[2];
				a03 = d[3];
				a10 = d[4];
				a11 = d[5];
				a12 = d[6];
				a13 = d[7];
				a20 = d[8];
				a21 = d[9];
				a22 = d[10];
				a23 = d[11];
				d[12] = a00 * x + a10 * y + a20 * z + d[12];
				d[13] = a01 * x + a11 * y + a21 * z + d[13];
				d[14] = a02 * x + a12 * y + a22 * z + d[14];
				d[15] = a03 * x + a13 * y + a23 * z + d[15];
				return this;
			};

			Mat4.prototype.rotatex = function (angle) {
				var a10, a11, a12, a13, a20, a21, a22, a23, c, d, rad, s;
				d = this.data;
				rad = tau * (angle / 360);
				s = Math.sin(rad);
				c = Math.cos(rad);
				a10 = d[4];
				a11 = d[5];
				a12 = d[6];
				a13 = d[7];
				a20 = d[8];
				a21 = d[9];
				a22 = d[10];
				a23 = d[11];
				d[4] = a10 * c + a20 * s;
				d[5] = a11 * c + a21 * s;
				d[6] = a12 * c + a22 * s;
				d[7] = a13 * c + a23 * s;
				d[8] = a10 * -s + a20 * c;
				d[9] = a11 * -s + a21 * c;
				d[10] = a12 * -s + a22 * c;
				d[11] = a13 * -s + a23 * c;
				return this;
			};

			Mat4.prototype.rotatey = function (angle) {
				var a00, a01, a02, a03, a20, a21, a22, a23, c, d, rad, s;
				d = this.data;
				rad = tau * (angle / 360);
				s = Math.sin(rad);
				c = Math.cos(rad);
				a00 = d[0];
				a01 = d[1];
				a02 = d[2];
				a03 = d[3];
				a20 = d[8];
				a21 = d[9];
				a22 = d[10];
				a23 = d[11];
				d[0] = a00 * c + a20 * -s;
				d[1] = a01 * c + a21 * -s;
				d[2] = a02 * c + a22 * -s;
				d[3] = a03 * c + a23 * -s;
				d[8] = a00 * s + a20 * c;
				d[9] = a01 * s + a21 * c;
				d[10] = a02 * s + a22 * c;
				d[11] = a03 * s + a23 * c;
				return this;
			};

			Mat4.prototype.rotatez = function (angle) {
				var a00, a01, a02, a03, a10, a11, a12, a13, c, d, rad, s;
				d = this.data;
				rad = tau * (angle / 360);
				s = Math.sin(rad);
				c = Math.cos(rad);
				a00 = d[0];
				a01 = d[1];
				a02 = d[2];
				a03 = d[3];
				a10 = d[4];
				a11 = d[5];
				a12 = d[6];
				a13 = d[7];
				d[0] = a00 * c + a10 * s;
				d[1] = a01 * c + a11 * s;
				d[2] = a02 * c + a12 * s;
				d[3] = a03 * c + a13 * s;
				d[4] = a00 * -s + a10 * c;
				d[5] = a01 * -s + a11 * c;
				d[6] = a02 * -s + a12 * c;
				d[7] = a03 * -s + a13 * c;
				return this;
			};

			Mat4.prototype.scale = function (scalar) {
				var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, d;
				d = this.data;
				a00 = d[0];
				a01 = d[1];
				a02 = d[2];
				a03 = d[3];
				a10 = d[4];
				a11 = d[5];
				a12 = d[6];
				a13 = d[7];
				a20 = d[8];
				a21 = d[9];
				a22 = d[10];
				a23 = d[11];
				d[0] = a00 * scalar;
				d[1] = a01 * scalar;
				d[2] = a02 * scalar;
				d[3] = a03 * scalar;
				d[4] = a10 * scalar;
				d[5] = a11 * scalar;
				d[6] = a12 * scalar;
				d[7] = a13 * scalar;
				d[8] = a20 * scalar;
				d[9] = a21 * scalar;
				d[10] = a22 * scalar;
				d[11] = a23 * scalar;
				return this;
			};

			Mat4.prototype.mulMat4 = function (other, dst) {
				var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b0, b1, b2, b3, dest, mat, mat2;
				if (dst == null) {
					dst = this;
				}
				dest = dst.data;
				mat = this.data;
				mat2 = other.data;
				a00 = mat[0];
				a01 = mat[1];
				a02 = mat[2];
				a03 = mat[3];
				a10 = mat[4];
				a11 = mat[5];
				a12 = mat[6];
				a13 = mat[7];
				a20 = mat[8];
				a21 = mat[9];
				a22 = mat[10];
				a23 = mat[11];
				a30 = mat[12];
				a31 = mat[13];
				a32 = mat[14];
				a33 = mat[15];
				b0 = mat2[0];
				b1 = mat2[1];
				b2 = mat2[2];
				b3 = mat2[3];
				dest[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
				dest[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
				dest[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
				dest[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
				b0 = mat2[4];
				b1 = mat2[5];
				b2 = mat2[6];
				b3 = mat2[7];
				dest[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
				dest[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
				dest[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
				dest[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
				b0 = mat2[8];
				b1 = mat2[9];
				b2 = mat2[10];
				b3 = mat2[11];
				dest[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
				dest[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
				dest[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
				dest[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
				b0 = mat2[12];
				b1 = mat2[13];
				b2 = mat2[14];
				b3 = mat2[15];
				dest[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
				dest[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
				dest[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
				dest[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
				return dst;
			};

			Mat4.prototype.mulVec3 = function (vec, dst) {
				if (dst == null) {
					dst = vec;
				}
				return this.mulVal3(vec.x, vec.y, vec.z, dst);
			};

			Mat4.prototype.mulVal3 = function (x, y, z, dst) {
				var d;
				dst = dst.data;
				d = this.data;
				dst[0] = d[0] * x + d[4] * y + d[8] * z;
				dst[1] = d[1] * x + d[5] * y + d[9] * z;
				dst[2] = d[2] * x + d[6] * y + d[10] * z;
				return dst;
			};

			Mat4.prototype.mulVec4 = function (vec, dst) {
				if (dst == null) {
					dst = vec;
				}
				return this.mulVal4(vec.x, vec.y, vec.z, vec.w, dst);
			};

			Mat4.prototype.mulVal4 = function (x, y, z, w, dst) {
				var d;
				dst = dst.data;
				d = this.data;
				dst[0] = d[0] * x + d[4] * y + d[8] * z + d[12] * w;
				dst[1] = d[1] * x + d[5] * y + d[9] * z + d[13] * w;
				dst[2] = d[2] * x + d[6] * y + d[10] * z + d[14] * w;
				dst[3] = d[3] * x + d[7] * y + d[11] * z + d[15] * w;
				return dst;
			};

			Mat4.prototype.invert = function (dst) {
				var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b00, b01, b02, b03, b04, b05, b06, b07, b08, b09, b10, b11, d, dest, invDet, mat;
				if (dst == null) {
					dst = this;
				}
				mat = this.data;
				dest = dst.data;
				a00 = mat[0];
				a01 = mat[1];
				a02 = mat[2];
				a03 = mat[3];
				a10 = mat[4];
				a11 = mat[5];
				a12 = mat[6];
				a13 = mat[7];
				a20 = mat[8];
				a21 = mat[9];
				a22 = mat[10];
				a23 = mat[11];
				a30 = mat[12];
				a31 = mat[13];
				a32 = mat[14];
				a33 = mat[15];
				b00 = a00 * a11 - a01 * a10;
				b01 = a00 * a12 - a02 * a10;
				b02 = a00 * a13 - a03 * a10;
				b03 = a01 * a12 - a02 * a11;
				b04 = a01 * a13 - a03 * a11;
				b05 = a02 * a13 - a03 * a12;
				b06 = a20 * a31 - a21 * a30;
				b07 = a20 * a32 - a22 * a30;
				b08 = a20 * a33 - a23 * a30;
				b09 = a21 * a32 - a22 * a31;
				b10 = a21 * a33 - a23 * a31;
				b11 = a22 * a33 - a23 * a32;
				d = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
				if (d === 0) {
					return;
				}
				invDet = 1 / d;
				dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
				dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
				dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
				dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
				dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
				dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
				dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
				dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
				dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
				dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
				dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
				dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
				dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
				dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
				dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
				dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
				return dst;
			};

			Mat4.prototype.set = function (a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33) {
				var d;
				d = this.data;
				d[0] = a00;
				d[4] = a10;
				d[8] = a20;
				d[12] = a30;
				d[1] = a01;
				d[5] = a11;
				d[9] = a21;
				d[13] = a31;
				d[2] = a02;
				d[6] = a12;
				d[10] = a22;
				d[14] = a32;
				d[3] = a03;
				d[7] = a13;
				d[11] = a23;
				d[15] = a33;
				return this;
			};

			return Mat4;

		})();

		Shader = (function () {
			var boilerplate;

			boilerplate = '#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp int;\n    precision highp float;\n#else\n    precision mediump int;\n    precision mediump float;\n#endif\n#define PI 3.141592653589793\n#define TAU 6.283185307179586\n#define PIH 1.5707963267948966';

			function Shader(framework, arg) {
				var common, fragment, vertex;
				this.framework = framework;
				common = arg.common, vertex = arg.vertex, fragment = arg.fragment;
				this.gl = this.framework.gl;
				this.program = this.gl.createProgram();
				this.vs = this.gl.createShader(this.gl.VERTEX_SHADER);
				this.fs = this.gl.createShader(this.gl.FRAGMENT_SHADER);
				this.gl.attachShader(this.program, this.vs);
				this.gl.attachShader(this.program, this.fs);
				if (common == null) {
					common = '';
				}
				this.compileShader(this.vs, [common, vertex].join('\n'));
				this.compileShader(this.fs, [common, fragment].join('\n'));
				this.link();
				this.uniformCache = {};
				this.attributeCache = {};
				this.samplers = {};
				this.unitCounter = 0;
			}

			Shader.prototype.compileShader = function (shader, source) {
				var error, lines, ref;
				source = [boilerplate, source].join('\n');
				ref = this.preprocess(source), source = ref[0], lines = ref[1];
				this.gl.shaderSource(shader, source);
				this.gl.compileShader(shader);
				if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
					error = this.gl.getShaderInfoLog(shader);
					throw this.translateError(error, lines);
				}
			};

			Shader.prototype.preprocess = function (source) {
				var filename, j, len, line, lineno, lines, match, ref, result;
				lines = [];
				result = [];
				filename = 'no file';
				lineno = 1;
				ref = source.split('\n');
				for (j = 0, len = ref.length; j < len; j++) {
					line = ref[j];
					match = line.match(/#line (\d+) (.*)/);
					if (match) {
						lineno = parseInt(match[1], 10) + 1;
						filename = match[2];
					} else {
						lines.push({
							source: line,
							lineno: lineno,
							filename: filename
						});
						result.push(line);
						lineno += 1;
					}
				}
				return [result.join('\n'), lines];
			};

			Shader.prototype.translateError = function (error, lines) {
				var i, j, len, line, lineno, match, message, ref, result, sourceline;
				result = ['Shader Compile Error'];
				ref = error.split('\n');
				for (i = j = 0, len = ref.length; j < len; i = ++j) {
					line = ref[i];
					match = line.match(/ERROR: \d+:(\d+): (.*)/);
					if (match) {
						lineno = parseFloat(match[1]) - 1;
						message = match[2];
						sourceline = lines[lineno];
						result.push("File \"" + sourceline.filename + "\", Line " + sourceline.lineno + ", " + message);
						result.push("   " + sourceline.source);
					} else {
						result.push(line);
					}
				}
				return result.join('\n');
			};

			Shader.prototype.link = function () {
				this.gl.linkProgram(this.program);
				if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
					throw "Shader Link Error: " + (this.gl.getProgramInfoLog(this.program));
				}
			};

			Shader.prototype.attributeLocation = function (name) {
				var location;
				location = this.attributeCache[name];
				if (location === void 0) {
					location = this.attributeCache[name] = this.gl.getAttribLocation(this.program, name);
				}
				return location;
			};

			Shader.prototype.uniformLocation = function (name) {
				var location;
				location = this.uniformCache[name];
				if (location === void 0) {
					location = this.uniformCache[name] = this.gl.getUniformLocation(this.program, name);
				}
				return location;
			};

			Shader.prototype.use = function () {
				if (this.framework.currentShader !== this) {
					this.framework.currentShader = this;
					this.gl.useProgram(this.program);
				}
				return this;
			};

			Shader.prototype.draw = function (drawable) {
				drawable.setPointersForShader(this).draw();
				return this;
			};

			Shader.prototype.int = function (name, value) {
				var loc;
				loc = this.uniformLocation(name);
				if (loc) {
					this.gl.uniform1i(loc, value);
				}
				return this;
			};

			Shader.prototype.sampler = function (name, texture) {
				var unit;
				unit = this.samplers[name];
				if (unit === void 0) {
					unit = this.samplers[name] = this.unitCounter++;
				}
				texture.bind(unit);
				this.int(name, unit);
				return this;
			};

			Shader.prototype.vec2 = function (name, a, b) {
				var loc;
				loc = this.uniformLocation(name);
				if (loc) {
					this.gl.uniform2f(loc, a, b);
				}
				return this;
			};

			Shader.prototype.vec3 = function (name, a, b, c) {
				var loc;
				loc = this.uniformLocation(name);
				if (loc) {
					this.gl.uniform3f(loc, a, b, f);
				}
				return this;
			};

			Shader.prototype.mat4 = function (name, value) {
				var loc;
				loc = this.uniformLocation(name);
				if (loc) {
					if (value instanceof Mat4) {
						this.gl.uniformMatrix4fv(loc, this.gl.FALSE, value.data);
					} else {
						this.gl.uniformMatrix4fv(loc, this.gl.FALSE, value);
					}
				}
				return this;
			};

			Shader.prototype.mat3 = function (name, value) {
				var loc;
				loc = this.uniformLocation(name);
				if (loc) {
					if (value instanceof Mat3) {
						this.gl.uniformMatrix3fv(loc, this.gl.FALSE, value.data);
					} else {
						this.gl.uniformMatrix3fv(loc, this.gl.FALSE, value);
					}
				}
				return this;
			};

			Shader.prototype.float = function (name, value) {
				var loc;
				loc = this.uniformLocation(name);
				if (loc) {
					this.gl.uniform1f(loc, value);
				}
				return this;
			};

			return Shader;

		})();

		Drawable = (function () {
			var float_size;

			float_size = Float32Array.BYTES_PER_ELEMENT;

			function Drawable(framework, arg) {
				var j, len, pointer, ref, vertices;
				this.framework = framework;
				this.pointers = arg.pointers, vertices = arg.vertices, this.mode = arg.mode;
				this.gl = this.framework.gl;
				this.buffer = this.gl.createBuffer();
				if (this.mode == null) {
					this.mode = this.gl.TRIANGLES;
				}
				this.vertexSize = 0;
				ref = this.pointers;
				for (j = 0, len = ref.length; j < len; j++) {
					pointer = ref[j];
					this.vertexSize += pointer.size;
				}
				this.upload(vertices);
			}

			Drawable.prototype.upload = function (vertices) {
				var data;
				if (vertices instanceof Array) {
					data = new Float32Array(vertices);
				} else {
					data = vertices;
				}
				this.size = data.length / this.vertexSize;
				this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
				this.gl.bufferData(this.gl.ARRAY_BUFFER, data, this.gl.STATIC_DRAW);
				return this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
			};

			Drawable.prototype.setPointer = function (shader, pointer, idx) {
				var location, unit;
				location = shader.attributeLocation(pointer.name);
				if (location >= 0) {
					unit = this.framework.vertexUnits[location];
					if (!unit.enabled) {
						unit.enabled = true;
						this.gl.enableVertexAttribArray(location);
					}
					if (unit.drawable !== this || unit.idx !== idx) {
						unit.idx = idx;
						unit.drawable = this;
						this.gl.vertexAttribPointer(location, pointer.size, this.gl.FLOAT, false, pointer.stride * float_size, pointer.offset * float_size);
					}
				}
				return this;
			};

			Drawable.prototype.setPointersForShader = function (shader) {
				var i, j, len, pointer, ref;
				this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
				ref = this.pointers;
				for (i = j = 0, len = ref.length; j < len; i = ++j) {
					pointer = ref[i];
					this.setPointer(shader, pointer, i);
				}
				return this;
			};

			Drawable.prototype.draw = function (first, size, mode) {
				if (first == null) {
					first = 0;
				}
				if (size == null) {
					size = this.size;
				}
				if (mode == null) {
					mode = this.mode;
				}
				this.gl.drawArrays(mode, first, size);
				return this;
			};

			return Drawable;

		})();

		Texture = (function () {
			function Texture(framework, params) {
				var ref, ref1;
				this.framework = framework;
				if (params == null) {
					params = {};
				}
				this.gl = this.framework.gl;
				this.channels = this.gl[((ref = params.channels) != null ? ref : 'rgb').toUpperCase()];
				if (typeof params.type === 'number') {
					this.type = params.type;
				} else {
					this.type = this.gl[((ref1 = params.type) != null ? ref1 : 'unsigned_byte').toUpperCase()];
				}
				this.target = this.gl.TEXTURE_2D;
				this.handle = this.gl.createTexture();
			}

			Texture.prototype.destroy = function () {
				return this.gl.deleteTexture(this.handle);
			};

			Texture.prototype.bind = function (unit) {
				if (unit == null) {
					unit = 0;
				}
				if (unit > 15) {
					throw 'Texture unit too large: ' + unit;
				}
				this.gl.activeTexture(this.gl.TEXTURE0 + unit);
				this.gl.bindTexture(this.target, this.handle);
				return this;
			};

			Texture.prototype.setSize = function (width1, height1) {
				this.width = width1;
				this.height = height1;
				this.gl.texImage2D(this.target, 0, this.channels, this.width, this.height, 0, this.channels, this.type, null);
				return this;
			};

			Texture.prototype.linear = function () {
				this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
				this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
				return this;
			};

			Texture.prototype.nearest = function () {
				this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
				this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
				return this;
			};

			Texture.prototype.clampToEdge = function () {
				this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
				this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
				return this;
			};

			Texture.prototype.repeat = function () {
				this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);
				this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);
				return this;
			};

			return Texture;

		})();

		Framebuffer = (function () {
			function Framebuffer(framework) {
				this.framework = framework;
				this.gl = this.framework.gl;
				this.buffer = this.gl.createFramebuffer();
				this.ownDepth = false;
			}

			Framebuffer.prototype.destroy = function () {
				return this.gl.deleteFRamebuffer(this.buffer);
			};

			Framebuffer.prototype.bind = function () {
				this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.buffer);
				return this;
			};

			Framebuffer.prototype.unbind = function () {
				this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
				return this;
			};

			Framebuffer.prototype.check = function () {
				var result;
				result = this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER);
				switch (result) {
					case this.gl.FRAMEBUFFER_UNSUPPORTED:
						throw 'Framebuffer is unsupported';
						break;
					case this.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
						throw 'Framebuffer incomplete attachment';
						break;
					case this.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
						throw 'Framebuffer incomplete dimensions';
						break;
					case this.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
						throw 'Framebuffer incomplete missing attachment';
				}
				return this;
			};

			Framebuffer.prototype.color = function (colorTexture) {
				this.colorTexture = colorTexture;
				this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.colorTexture.target, this.colorTexture.handle, 0);
				this.check();
				return this;
			};

			Framebuffer.prototype.depth = function (depthBuffer) {
				this.depthBuffer = depthBuffer;
				if (this.depthBuffer === void 0) {
					if (this.colorTexture === void 0) {
						throw 'Cannot create implicit depth buffer without a color texture';
					} else {
						this.ownDepth = true;
						this.depthBuffer = this.framework.depthbuffer().bind().setSize(this.colorTexture.width, this.colorTexture.height);
					}
				}
				this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, this.depthBuffer.id);
				this.check();
				return this;
			};

			Framebuffer.prototype.destroy = function () {
				this.gl.deleteFramebuffer(this.buffer);
				if (this.ownDepth) {
					return this.depthBuffer.destroy();
				}
			};

			return Framebuffer;

		})();

		Renderbuffer = (function () {
			function Renderbuffer(framework) {
				this.framework = framework;
				this.gl = this.framework.gl;
				this.id = this.gl.createRenderbuffer();
			}

			Renderbuffer.prototype.bind = function () {
				this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.id);
				return this;
			};

			Renderbuffer.prototype.setSize = function (width1, height1) {
				this.width = width1;
				this.height = height1;
				this.bind();
				this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl[this.format], this.width, this.height);
				return this.unbind();
			};

			Renderbuffer.prototype.unbind = function () {
				this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);
				return this;
			};

			Renderbuffer.prototype.destroy = function () {
				return this.gl.deleteRenderbuffer(this.id);
			};

			return Renderbuffer;

		})();

		Depthbuffer = (function (superClass) {
			extend(_Class, superClass);

			function _Class() {
				return _Class.__super__.constructor.apply(this, arguments);
			}

			_Class.prototype.format = 'DEPTH_COMPONENT16';

			return _Class;

		})(Renderbuffer);

		//_GP.raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.oRequestAnimationFrame;

		//_GP.caf = window.cancelAnimationFrame || window.mozcancelAnimationFrame || window.webkitcancelAnimationFrame || window.ocancelAnimationFrame;

		window.performance.now = performance.now || performance.mozNow || performance.webkitNow || performance.oNow || Date.now;

		_GP.WebGLFramework = WebGLFramework = (function () {
			function WebGLFramework(canvas, params) {
				var _, error, error1, j, k;
				this.canvas = canvas;
				this.animationInterval = bind(this.animationInterval, this);
				try {
					this.gl = this.canvas.getContext('webgl', params);
					if (this.gl === null) {
						this.gl = this.canvas.getContext('experimental-webgl', params);
						if (this.gl === null) {
							throw 'WebGL not supported';
						}
					}
				} catch (error1) {
					error = error1;
					throw 'WebGL not supported';
				}
				this.textureUnits = [];
				for (_ = j = 0; j < 16; _ = ++j) {
					this.textureUnits.push(null);
				}
				this.vertexUnits = [];
				for (_ = k = 0; k < 16; _ = ++k) {
					this.vertexUnits.push({
						enabled: false,
						drawable: null,
						idx: null
					});
				}
				this.currentShader = null;
			}

			WebGLFramework.prototype.shader = function (params) {
				return new Shader(this, params);
			};

			WebGLFramework.prototype.drawable = function (params) {
				return new Drawable(this, params);
			};

			WebGLFramework.prototype.texture = function (params) {
				return new Texture(this, params);
			};

			WebGLFramework.prototype.framebuffer = function () {
				return new Framebuffer(this);
			};

			WebGLFramework.prototype.depthbuffer = function () {
				return new Depthbuffer(this);
			};

			WebGLFramework.prototype.mat3 = function (data) {
				return new Mat3(data);
			};

			WebGLFramework.prototype.mat4 = function (data) {
				return new Mat4(data);
			};

			WebGLFramework.prototype.clearColor = function (r, g, b, a) {
				if (r == null) {
					r = 0;
				}
				if (g == null) {
					g = 0;
				}
				if (b == null) {
					b = 0;
				}
				if (a == null) {
					a = 1;
				}
				this.gl.clearColor(r, g, b, a);
				this.gl.clear(this.gl.COLOR_BUFFER_BIT);
				return this;
			};

			WebGLFramework.prototype.clearDepth = function (depth) {
				if (depth == null) {
					depth = 1;
				}
				this.gl.clearDepth(depth);
				this.gl.clear(this.gl.DEPTH_BUFFER_BIT);
				return this;
			};

			WebGLFramework.prototype.adjustSize = function () {
				var canvasHeight, canvasWidth;
				canvasWidth = this.canvas.width;
				canvasHeight = this.canvas.height;
				if (this.width !== canvasWidth || this.height !== canvasHeight) {
					this.canvas.width = canvasWidth;
					this.canvas.height = canvasHeight;
					this.width = canvasWidth;
					this.height = canvasHeight;
					this.aspect = this.width / this.height;
				}
				return this;
			};

			WebGLFramework.prototype.viewport = function (left, top, width, height) {
				if (left == null) {
					left = 0;
				}
				if (top == null) {
					top = 0;
				}
				if (width == null) {
					width = this.width;
				}
				if (height == null) {
					height = this.height;
				}
				this.gl.viewport(left, top, width, height);
				return this;
			};

			WebGLFramework.prototype.depthTest = function (value) {
				if (value == null) {
					value = true;
				}
				if (value) {
					this.gl.enable(this.gl.DEPTH_TEST);
				} else {
					this.gl.disable(this.gl.DEPTH_TEST);
				}
				return this;
			};

			WebGLFramework.prototype.animationInterval = function (callback) {
				var interval;
				interval = function () {
					var frame;
					frame = raf(interval);
					if (callback) {
						return callback(frame);
					}
				};
				return raf(interval);
			};

			WebGLFramework.prototype.now = function () {
				return performance.now() / 1000;
			};

			WebGLFramework.prototype.getExt = function (name, throws) {
				var ext;
				if (throws == null) {
					throws = true;
				}
				ext = this.gl.getExtension(name);
				if (!ext && throws) {
					throw "WebGL Extension not supported: " + name;
				}
				return ext;
			};

			WebGLFramework.prototype.requestFullscreen = function (elem) {
				if (elem == null) {
					elem = this.canvas;
				}
				if (elem.mozRequestFullScreen) {
					elem.mozRequestFullScreen();
				} else if (elem.webkitRequestFullScreen) {
					elem.webkitRequestFullScreen();
				} else if (elem.oRequestFullScreen) {
					elem.oRequestFullScreen();
				}
				return this;
			};

			WebGLFramework.prototype.isFullscreen = function () {
				var a, b;
				a = getVendorAttrib(document, 'fullscreenElement');
				b = getVendorAttrib(document, 'fullScreenElement');
				if (a || b) {
					return true;
				} else {
					return false;
				}
			};

			WebGLFramework.prototype.onFullscreenChange = function (fun) {
				var callback, j, len, vendor;
				callback = (function (_this) {
					return function () {
						return fun(_this.isFullscreen());
					};
				})(this);
				for (j = 0, len = vendors.length; j < len; j++) {
					vendor = vendors[j];
					document.addEventListener(vendor + 'fullscreenchange', callback, false);
				}
				return this;
			};

			WebGLFramework.prototype.exitFullscreen = function () {
				document.cancelFullscreen();
				return this;
			};

			WebGLFramework.prototype.toggleFullscreen = function (elem) {
				if (elem == null) {
					elem = this.canvas;
				}
				if (this.isFullscreen()) {
					return this.exitFullscreen();
				} else {
					return this.requestFullscreen(elem);
				}
			};

			WebGLFramework.prototype.getFloatExtension = function (spec) {
				return this.gl.getFloatExtension(spec);
			};

			WebGLFramework.prototype.cullFace = function (value) {
				if (value == null) {
					value = 'back';
				}
				if (value) {
					this.gl.enable(this.gl.CULL_FACE);
					this.gl.cullFace(this.gl[value.toUpperCase()]);
				} else {
					this.gl.disable(this.gl.CULL_FACE);
				}
				return this;
			};

			WebGLFramework.prototype.getContext = function () {
				return this.gl;
			};

			return WebGLFramework;

		})();

		vendors = [null, 'webkit', 'apple', 'moz', 'o', 'xv', 'ms', 'khtml', 'atsc', 'wap', 'prince', 'ah', 'hp', 'ro', 'rim', 'tc'];

		vendorName = function (name, vendor) {
			if (vendor === null) {
				return name;
			} else {
				return vendor + name[0].toUpperCase() + name.substr(1);
			}
		};

		getVendorAttrib = function (obj, name, def) {
			var attrib, attrib_name, j, len, vendor;
			if (obj) {
				for (j = 0, len = vendors.length; j < len; j++) {
					vendor = vendors[j];
					attrib_name = vendorName(name, vendor);
					attrib = obj[attrib_name];
					if (attrib !== void 0) {
						return attrib;
					}
				}
			}
			return def;
		};

		document.fullscreenEnabled = getVendorAttrib(document, 'fullscreenEnabled');

		document.cancelFullscreen = getVendorAttrib(document, 'cancelFullScreen');

	}).call(this);

	// Generated by CoffeeScript 1.10.0
	(function () {
		var modelPointers;

		modelPointers = [
			{
				name: 'position',
				size: 3,
				offset: 0,
				stride: 6
			}, {
				name: 'normal',
				size: 3,
				offset: 3,
				stride: 6
			}
		];

		_GP.meshes = {
			quad: {
				pointers: [
					{
						name: 'position',
						size: 2,
						offset: 0,
						stride: 2
					}
				],
				vertices: [-1, -1, 1, -1, 1, 1, -1, 1, -1, -1, 1, 1]
			},
			plane: function (s) {
				return {
					pointers: modelPointers,
					vertices: [-s, 0, -s, 0, 1, 0, -s, 0, s, 0, 1, 0, s, 0, s, 0, 1, 0, s, 0, -s, 0, 1, 0, -s, 0, -s, 0, 1, 0, s, 0, s, 0, 1, 0]
				};
			},
			cube: {
				pointers: modelPointers,
				vertices: [-1, -1, -1, 0, 0, -1, -1, 1, -1, 0, 0, -1, 1, 1, -1, 0, 0, -1, 1, -1, -1, 0, 0, -1, -1, -1, -1, 0, 0, -1, 1, 1, -1, 0, 0, -1, 1, 1, 1, 0, 0, 1, -1, 1, 1, 0, 0, 1, -1, -1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, -1, -1, 1, 0, 0, 1, 1, -1, 1, 0, 0, 1, -1, 1, -1, 0, 1, 0, -1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, -1, 0, 1, 0, -1, 1, -1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, -1, 1, 0, -1, 0, -1, -1, 1, 0, -1, 0, -1, -1, -1, 0, -1, 0, 1, -1, 1, 0, -1, 0, -1, -1, -1, 0, -1, 0, 1, -1, -1, 0, -1, 0, -1, -1, -1, -1, 0, 0, -1, -1, 1, -1, 0, 0, -1, 1, 1, -1, 0, 0, -1, 1, -1, -1, 0, 0, -1, -1, -1, -1, 0, 0, -1, 1, 1, -1, 0, 0, 1, 1, 1, 1, 0, 0, 1, -1, 1, 1, 0, 0, 1, -1, -1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, -1, -1, 1, 0, 0, 1, 1, -1, 1, 0, 0]
			}
		};

	}).call(this);

	// Generated by CoffeeScript 1.10.0
	(function () {
		var getExtension, getSupportedExtensions, vendorRe, vendors,
			indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

		if (window.WebGLRenderingContext != null) {
			vendors = ['WEBKIT', 'MOZ', 'MS', 'O'];
			vendorRe = /^WEBKIT_(.*)|MOZ_(.*)|MS_(.*)|O_(.*)/;
			getExtension = WebGLRenderingContext.prototype.getExtension;
			WebGLRenderingContext.prototype.getExtension = function (name) {
				var extobj, i, len, match, vendor;
				match = name.match(vendorRe);
				if (match !== null) {
					name = match[1];
				}
				extobj = getExtension.call(this, name);
				if (extobj === null) {
					for (i = 0, len = vendors.length; i < len; i++) {
						vendor = vendors[i];
						extobj = getExtension.call(this, vendor + '_' + name);
						if (extobj !== null) {
							return extobj;
						}
					}
					return null;
				} else {
					return extobj;
				}
			};
			getSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions;
			WebGLRenderingContext.prototype.getSupportedExtensions = function () {
				var extension, i, len, match, result, supported;
				supported = getSupportedExtensions.call(this);
				result = [];
				for (i = 0, len = supported.length; i < len; i++) {
					extension = supported[i];
					match = extension.match(vendorRe);
					if (match !== null) {
						extension = match[1];
					}
					if (indexOf.call(result, extension) < 0) {
						result.push(extension);
					}
				}
				return result;
			};
		}

	}).call(this);

	// Generated by CoffeeScript 1.10.0
	(function () {
		var checkColorBuffer, checkFloatLinear, checkSupport, checkTexture, createSourceCanvas, getExtension, getSupportedExtensions, j, len, name, shimExtensions, shimLookup, unshimExtensions, unshimLookup,
			indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

		createSourceCanvas = function () {
			var canvas, ctx, imageData;
			canvas = document.createElement('canvas');
			canvas.width = 2;
			canvas.height = 2;
			ctx = canvas.getContext('2d');
			imageData = ctx.getImageData(0, 0, 2, 2);
			imageData.data.set(new Uint8ClampedArray([0, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255]));
			ctx.putImageData(imageData, 0, 0);
			return canvas;
		};

		createSourceCanvas();

		checkFloatLinear = function (gl, sourceType) {
			var buffer, cleanup, fragmentShader, framebuffer, positionLoc, program, readBuffer, result, source, sourceCanvas, sourceLoc, target, vertexShader, vertices;
			program = gl.createProgram();
			vertexShader = gl.createShader(gl.VERTEX_SHADER);
			gl.attachShader(program, vertexShader);
			gl.shaderSource(vertexShader, 'attribute vec2 position;\nvoid main(){\n    gl_Position = vec4(position, 0.0, 1.0);\n}');
			gl.compileShader(vertexShader);
			if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
				throw gl.getShaderInfoLog(vertexShader);
			}
			fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
			gl.attachShader(program, fragmentShader);
			gl.shaderSource(fragmentShader, 'uniform sampler2D source;\nvoid main(){\n    gl_FragColor = texture2D(source, vec2(1.0, 1.0));\n}');
			gl.compileShader(fragmentShader);
			if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
				throw gl.getShaderInfoLog(fragmentShader);
			}
			gl.linkProgram(program);
			if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
				throw gl.getProgramInfoLog(program);
			}
			gl.useProgram(program);
			cleanup = function () {
				gl.deleteShader(fragmentShader);
				gl.deleteShader(vertexShader);
				gl.deleteProgram(program);
				gl.deleteBuffer(buffer);
				gl.deleteTexture(source);
				gl.deleteTexture(target);
				gl.deleteFramebuffer(framebuffer);
				gl.bindBuffer(gl.ARRAY_BUFFER, null);
				gl.useProgram(null);
				gl.bindTexture(gl.TEXTURE_2D, null);
				return gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			};
			target = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, target);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			framebuffer = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target, 0);
			sourceCanvas = createSourceCanvas();
			source = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, source);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, sourceType, sourceCanvas);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			vertices = new Float32Array([1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1]);
			buffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
			positionLoc = gl.getAttribLocation(program, 'position');
			sourceLoc = gl.getUniformLocation(program, 'source');
			gl.enableVertexAttribArray(positionLoc);
			gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
			gl.uniform1i(sourceLoc, 0);
			gl.drawArrays(gl.TRIANGLES, 0, 6);
			readBuffer = new Uint8Array(4 * 4);
			gl.readPixels(0, 0, 2, 2, gl.RGBA, gl.UNSIGNED_BYTE, readBuffer);
			result = Math.abs(readBuffer[0] - 127) < 10;
			cleanup();
			return result;
		};

		checkTexture = function (gl, targetType) {
			var target;
			target = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, target);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, targetType, null);
			if (gl.getError() === 0) {
				gl.deleteTexture(target);
				return true;
			} else {
				gl.deleteTexture(target);
				return false;
			}
		};

		checkColorBuffer = function (gl, targetType) {
			var check, framebuffer, target;
			target = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, target);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, targetType, null);
			framebuffer = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target, 0);
			check = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
			gl.deleteTexture(target);
			gl.deleteFramebuffer(framebuffer);
			gl.bindTexture(gl.TEXTURE_2D, null);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			if (check === gl.FRAMEBUFFER_COMPLETE) {
				return true;
			} else {
				return false;
			}
		};

		shimExtensions = [];

		shimLookup = {};

		unshimExtensions = [];

		checkSupport = function () {
			var canvas, extobj, gl, halfFloatExt, halfFloatTexturing, singleFloatExt, singleFloatTexturing;
			canvas = document.createElement('canvas');
			gl = null;
			try {
				gl = canvas.getContext('experimental-webgl');
				if (gl === null) {
					gl = canvas.getContext('webgl');
				}
			} catch (undefined) { }
			if (gl != null) {
				singleFloatExt = gl.getExtension('OES_texture_float');
				if (singleFloatExt === null) {
					if (checkTexture(gl, gl.FLOAT)) {
						singleFloatTexturing = true;
						shimExtensions.push('OES_texture_float');
						shimLookup.OES_texture_float = {
							shim: true
						};
					} else {
						singleFloatTexturing = false;
						unshimExtensions.push('OES_texture_float');
					}
				} else {
					if (checkTexture(gl, gl.FLOAT)) {
						singleFloatTexturing = true;
						shimExtensions.push('OES_texture_float');
					} else {
						singleFloatTexturing = false;
						unshimExtensions.push('OES_texture_float');
					}
				}
				if (singleFloatTexturing) {
					extobj = gl.getExtension('WEBGL_color_buffer_float');
					if (extobj === null) {
						if (checkColorBuffer(gl, gl.FLOAT)) {
							shimExtensions.push('WEBGL_color_buffer_float');
							shimLookup.WEBGL_color_buffer_float = {
								shim: true,
								RGBA32F_EXT: 0x8814,
								RGB32F_EXT: 0x8815,
								FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211,
								UNSIGNED_NORMALIZED_EXT: 0x8C17
							};
						} else {
							unshimExtensions.push('WEBGL_color_buffer_float');
						}
					} else {
						if (checkColorBuffer(gl, gl.FLOAT)) {
							shimExtensions.push('WEBGL_color_buffer_float');
						} else {
							unshimExtensions.push('WEBGL_color_buffer_float');
						}
					}
					extobj = gl.getExtension('OES_texture_float_linear');
					if (extobj === null) {
						if (checkFloatLinear(gl, gl.FLOAT)) {
							shimExtensions.push('OES_texture_float_linear');
							shimLookup.OES_texture_float_linear = {
								shim: true
							};
						} else {
							unshimExtensions.push('OES_texture_float_linear');
						}
					} else {
						if (checkFloatLinear(gl, gl.FLOAT)) {
							shimExtensions.push('OES_texture_float_linear');
						} else {
							unshimExtensions.push('OES_texture_float_linear');
						}
					}
				}
				halfFloatExt = gl.getExtension('OES_texture_half_float');
				if (halfFloatExt === null) {
					if (checkTexture(gl, 0x8D61)) {
						halfFloatTexturing = true;
						shimExtensions.push('OES_texture_half_float');
						halfFloatExt = shimLookup.OES_texture_half_float = {
							HALF_FLOAT_OES: 0x8D61,
							shim: true
						};
					} else {
						halfFloatTexturing = false;
						unshimExtensions.push('OES_texture_half_float');
					}
				} else {
					if (checkTexture(gl, halfFloatExt.HALF_FLOAT_OES)) {
						halfFloatTexturing = true;
						shimExtensions.push('OES_texture_half_float');
					} else {
						halfFloatTexturing = false;
						unshimExtensions.push('OES_texture_half_float');
					}
				}
				if (halfFloatTexturing) {
					extobj = gl.getExtension('EXT_color_buffer_half_float');
					if (extobj === null) {
						if (checkColorBuffer(gl, halfFloatExt.HALF_FLOAT_OES)) {
							shimExtensions.push('EXT_color_buffer_half_float');
							shimLookup.EXT_color_buffer_half_float = {
								shim: true,
								RGBA16F_EXT: 0x881A,
								RGB16F_EXT: 0x881B,
								FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211,
								UNSIGNED_NORMALIZED_EXT: 0x8C17
							};
						} else {
							unshimExtensions.push('EXT_color_buffer_half_float');
						}
					} else {
						if (checkColorBuffer(gl, halfFloatExt.HALF_FLOAT_OES)) {
							shimExtensions.push('EXT_color_buffer_half_float');
						} else {
							unshimExtensions.push('EXT_color_buffer_half_float');
						}
					}
					extobj = gl.getExtension('OES_texture_half_float_linear');
					if (extobj === null) {
						if (checkFloatLinear(gl, halfFloatExt.HALF_FLOAT_OES)) {
							shimExtensions.push('OES_texture_half_float_linear');
							return shimLookup.OES_texture_half_float_linear = {
								shim: true
							};
						} else {
							return unshimExtensions.push('OES_texture_half_float_linear');
						}
					} else {
						if (checkFloatLinear(gl, halfFloatExt.HALF_FLOAT_OES)) {
							return shimExtensions.push('OES_texture_half_float_linear');
						} else {
							return unshimExtensions.push('OES_texture_half_float_linear');
						}
					}
				}
			}
		};

		if (window.WebGLRenderingContext != null) {
			checkSupport();
			unshimLookup = {};
			for (j = 0, len = unshimExtensions.length; j < len; j++) {
				name = unshimExtensions[j];
				unshimLookup[name] = true;
			}
			getExtension = WebGLRenderingContext.prototype.getExtension;
			WebGLRenderingContext.prototype.getExtension = function (name) {
				var extobj;
				extobj = shimLookup[name];
				if (extobj === void 0) {
					if (unshimLookup[name]) {
						return null;
					} else {
						return getExtension.call(this, name);
					}
				} else {
					return extobj;
				}
			};
			getSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions;
			WebGLRenderingContext.prototype.getSupportedExtensions = function () {
				var extension, k, l, len1, len2, result, supported;
				supported = getSupportedExtensions.call(this);
				result = [];
				for (k = 0, len1 = supported.length; k < len1; k++) {
					extension = supported[k];
					if (unshimLookup[extension] === void 0) {
						result.push(extension);
					}
				}
				for (l = 0, len2 = shimExtensions.length; l < len2; l++) {
					extension = shimExtensions[l];
					if (indexOf.call(result, extension) < 0) {
						result.push(extension);
					}
				}
				return result;
			};
			WebGLRenderingContext.prototype.getFloatExtension = function (spec) {
				var candidate, candidates, half, halfFramebuffer, halfLinear, halfTexture, i, importance, k, l, len1, len2, len3, len4, m, n, preference, ref, ref1, ref2, result, single, singleFramebuffer, singleLinear, singleTexture, use;
				if (spec.prefer == null) {
					spec.prefer = ['half'];
				}
				if (spec.require == null) {
					spec.require = [];
				}
				if (spec.throws == null) {
					spec.throws = true;
				}
				singleTexture = this.getExtension('OES_texture_float');
				halfTexture = this.getExtension('OES_texture_half_float');
				singleFramebuffer = this.getExtension('WEBGL_color_buffer_float');
				halfFramebuffer = this.getExtension('EXT_color_buffer_half_float');
				singleLinear = this.getExtension('OES_texture_float_linear');
				halfLinear = this.getExtension('OES_texture_half_float_linear');
				single = {
					texture: singleTexture !== null,
					filterable: singleLinear !== null,
					renderable: singleFramebuffer !== null,
					score: 0,
					precision: 'single',
					half: false,
					single: true,
					type: this.FLOAT
				};
				half = {
					texture: halfTexture !== null,
					filterable: halfLinear !== null,
					renderable: halfFramebuffer !== null,
					score: 0,
					precision: 'half',
					half: true,
					single: false,
					type: (ref = halfTexture != null ? halfTexture.HALF_FLOAT_OES : void 0) != null ? ref : null
				};
				candidates = [];
				if (single.texture) {
					candidates.push(single);
				}
				if (half.texture) {
					candidates.push(half);
				}
				result = [];
				for (k = 0, len1 = candidates.length; k < len1; k++) {
					candidate = candidates[k];
					use = true;
					ref1 = spec.require;
					for (l = 0, len2 = ref1.length; l < len2; l++) {
						name = ref1[l];
						if (candidate[name] === false) {
							use = false;
						}
					}
					if (use) {
						result.push(candidate);
					}
				}
				for (m = 0, len3 = result.length; m < len3; m++) {
					candidate = result[m];
					ref2 = spec.prefer;
					for (i = n = 0, len4 = ref2.length; n < len4; i = ++n) {
						preference = ref2[i];
						importance = Math.pow(2, spec.prefer.length - i - 1);
						if (candidate[preference]) {
							candidate.score += importance;
						}
					}
				}
				result.sort(function (a, b) {
					if (a.score === b.score) {
						return 0;
					} else if (a.score < b.score) {
						return 1;
					} else if (a.score > b.score) {
						return -1;
					}
				});
				if (result.length === 0) {
					if (spec.throws) {
						throw 'No floating point texture support that is ' + spec.require.join(', ');
					} else {
						return null;
					}
				} else {
					result = result[0];
					return {
						filterable: result.filterable,
						renderable: result.renderable,
						type: result.type,
						precision: result.precision
					};
				}
			};
		}

	}).call(this);

	// File:src/Three.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var THREE = { REVISION: '78' };

	//

	if (typeof define === 'function' && define.amd) {

		define('three', THREE);

	} else if ('undefined' !== typeof exports && 'undefined' !== typeof module) {

		module.exports = THREE;

	}

	// Polyfills

	if (Number.EPSILON === undefined) {

		Number.EPSILON = Math.pow(2, - 52);

	}

	//

	if (Math.sign === undefined) {

		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

		Math.sign = function (x) {

			return (x < 0) ? - 1 : (x > 0) ? 1 : + x;

		};

	}

	if (Function.prototype.name === undefined) {

		// Missing in IE9-11.
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

		Object.defineProperty(Function.prototype, 'name', {

			get: function () {

				return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];

			}

		});

	}

	if (Object.assign === undefined) {

		// Missing in IE.
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

		(function () {

			Object.assign = function (target) {

				'use strict';

				if (target === undefined || target === null) {

					throw new TypeError('Cannot convert undefined or null to object');

				}

				var output = Object(target);

				for (var index = 1; index < arguments.length; index++) {

					var source = arguments[index];

					if (source !== undefined && source !== null) {

						for (var nextKey in source) {

							if (Object.prototype.hasOwnProperty.call(source, nextKey)) {

								output[nextKey] = source[nextKey];

							}

						}

					}

				}

				return output;

			};

		})();

	}

	//

	Object.assign(THREE, {

		// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

		MOUSE: { LEFT: 0, MIDDLE: 1, RIGHT: 2 },

		// GL STATE CONSTANTS

		CullFaceNone: 0,
		CullFaceBack: 1,
		CullFaceFront: 2,
		CullFaceFrontBack: 3,

		FrontFaceDirectionCW: 0,
		FrontFaceDirectionCCW: 1,

		// SHADOWING TYPES

		BasicShadowMap: 0,
		PCFShadowMap: 1,
		PCFSoftShadowMap: 2,

		// MATERIAL CONSTANTS

		// side

		FrontSide: 0,
		BackSide: 1,
		DoubleSide: 2,

		// shading

		FlatShading: 1,
		SmoothShading: 2,

		// colors

		NoColors: 0,
		FaceColors: 1,
		VertexColors: 2,

		// blending modes

		NoBlending: 0,
		NormalBlending: 1,
		AdditiveBlending: 2,
		SubtractiveBlending: 3,
		MultiplyBlending: 4,
		CustomBlending: 5,

		// custom blending equations
		// (numbers start from 100 not to clash with other
		// mappings to OpenGL constants defined in Texture.js)

		AddEquation: 100,
		SubtractEquation: 101,
		ReverseSubtractEquation: 102,
		MinEquation: 103,
		MaxEquation: 104,

		// custom blending destination factors

		ZeroFactor: 200,
		OneFactor: 201,
		SrcColorFactor: 202,
		OneMinusSrcColorFactor: 203,
		SrcAlphaFactor: 204,
		OneMinusSrcAlphaFactor: 205,
		DstAlphaFactor: 206,
		OneMinusDstAlphaFactor: 207,

		// custom blending source factors

		//ZeroFactor: 200,
		//OneFactor: 201,
		//SrcAlphaFactor: 204,
		//OneMinusSrcAlphaFactor: 205,
		//DstAlphaFactor: 206,
		//OneMinusDstAlphaFactor: 207,
		DstColorFactor: 208,
		OneMinusDstColorFactor: 209,
		SrcAlphaSaturateFactor: 210,

		// depth modes

		NeverDepth: 0,
		AlwaysDepth: 1,
		LessDepth: 2,
		LessEqualDepth: 3,
		EqualDepth: 4,
		GreaterEqualDepth: 5,
		GreaterDepth: 6,
		NotEqualDepth: 7,


		// TEXTURE CONSTANTS

		MultiplyOperation: 0,
		MixOperation: 1,
		AddOperation: 2,

		// Tone Mapping modes

		NoToneMapping: 0, // do not do any tone mapping, not even exposure (required for special purpose passes.)
		LinearToneMapping: 1, // only apply exposure.
		ReinhardToneMapping: 2,
		Uncharted2ToneMapping: 3, // John Hable
		CineonToneMapping: 4, // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson

		// Mapping modes

		UVMapping: 300,

		CubeReflectionMapping: 301,
		CubeRefractionMapping: 302,

		EquirectangularReflectionMapping: 303,
		EquirectangularRefractionMapping: 304,

		SphericalReflectionMapping: 305,
		CubeUVReflectionMapping: 306,
		CubeUVRefractionMapping: 307,

		// Wrapping modes

		RepeatWrapping: 1000,
		ClampToEdgeWrapping: 1001,
		MirroredRepeatWrapping: 1002,

		// Filters

		NearestFilter: 1003,
		NearestMipMapNearestFilter: 1004,
		NearestMipMapLinearFilter: 1005,
		LinearFilter: 1006,
		LinearMipMapNearestFilter: 1007,
		LinearMipMapLinearFilter: 1008,

		// Data types

		UnsignedByteType: 1009,
		ByteType: 1010,
		ShortType: 1011,
		UnsignedShortType: 1012,
		IntType: 1013,
		UnsignedIntType: 1014,
		FloatType: 1015,
		HalfFloatType: 1025,

		// Pixel types

		//UnsignedByteType: 1009,
		UnsignedShort4444Type: 1016,
		UnsignedShort5551Type: 1017,
		UnsignedShort565Type: 1018,

		// Pixel formats

		AlphaFormat: 1019,
		RGBFormat: 1020,
		RGBAFormat: 1021,
		LuminanceFormat: 1022,
		LuminanceAlphaFormat: 1023,
		// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
		RGBEFormat: THREE.RGBAFormat, //1024;
		DepthFormat: 1026,

		// DDS / ST3C Compressed texture formats

		RGB_S3TC_DXT1_Format: 2001,
		RGBA_S3TC_DXT1_Format: 2002,
		RGBA_S3TC_DXT3_Format: 2003,
		RGBA_S3TC_DXT5_Format: 2004,

		// PVRTC compressed texture formats

		RGB_PVRTC_4BPPV1_Format: 2100,
		RGB_PVRTC_2BPPV1_Format: 2101,
		RGBA_PVRTC_4BPPV1_Format: 2102,
		RGBA_PVRTC_2BPPV1_Format: 2103,

		// ETC compressed texture formats

		RGB_ETC1_Format: 2151,

		// Loop styles for AnimationAction

		LoopOnce: 2200,
		LoopRepeat: 2201,
		LoopPingPong: 2202,

		// Interpolation

		InterpolateDiscrete: 2300,
		InterpolateLinear: 2301,
		InterpolateSmooth: 2302,

		// Interpolant ending modes

		ZeroCurvatureEnding: 2400,
		ZeroSlopeEnding: 2401,
		WrapAroundEnding: 2402,

		// Triangle Draw modes

		TrianglesDrawMode: 0,
		TriangleStripDrawMode: 1,
		TriangleFanDrawMode: 2,

		// Texture Encodings

		LinearEncoding: 3000, // No encoding at all.
		sRGBEncoding: 3001,
		GammaEncoding: 3007, // uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput

		// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.
		// These encodings should not specified as output encodings except in rare situations.
		RGBEEncoding: 3002, // AKA Radiance.
		LogLuvEncoding: 3003,
		RGBM7Encoding: 3004,
		RGBM16Encoding: 3005,
		RGBDEncoding: 3006, // MaxRange is 256.

		// Depth packing strategies

		BasicDepthPacking: 3200, // for writing to float textures for high precision or for visualizing results in RGB buffers
		RGBADepthPacking: 3201 // for packing into RGBA buffers.

	});

	// File:src/math/Color.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Color = function (r, g, b) {

		if (g === undefined && b === undefined) {

			// r is THREE.Color, hex or string
			return this.set(r);

		}

		return this.setRGB(r, g, b);

	};

	THREE.Color.prototype = {

		constructor: THREE.Color,

		r: 1, g: 1, b: 1,

		set: function (value) {

			if (value instanceof THREE.Color) {

				this.copy(value);

			} else if (typeof value === 'number') {

				this.setHex(value);

			} else if (typeof value === 'string') {

				this.setStyle(value);

			}

			return this;

		},

		setScalar: function (scalar) {

			this.r = scalar;
			this.g = scalar;
			this.b = scalar;

		},

		setHex: function (hex) {

			hex = Math.floor(hex);

			this.r = (hex >> 16 & 255) / 255;
			this.g = (hex >> 8 & 255) / 255;
			this.b = (hex & 255) / 255;

			return this;

		},

		setRGB: function (r, g, b) {

			this.r = r;
			this.g = g;
			this.b = b;

			return this;

		},

		setHSL: function () {

			function hue2rgb(p, q, t) {

				if (t < 0) t += 1;
				if (t > 1) t -= 1;
				if (t < 1 / 6) return p + (q - p) * 6 * t;
				if (t < 1 / 2) return q;
				if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
				return p;

			}

			return function setHSL(h, s, l) {

				// h,s,l ranges are in 0.0 - 1.0
				h = THREE.Math.euclideanModulo(h, 1);
				s = THREE.Math.clamp(s, 0, 1);
				l = THREE.Math.clamp(l, 0, 1);

				if (s === 0) {

					this.r = this.g = this.b = l;

				} else {

					var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
					var q = (2 * l) - p;

					this.r = hue2rgb(q, p, h + 1 / 3);
					this.g = hue2rgb(q, p, h);
					this.b = hue2rgb(q, p, h - 1 / 3);

				}

				return this;

			};

		}(),

		setStyle: function (style) {

			function handleAlpha(string) {

				if (string === undefined) return;

				if (parseFloat(string) < 1) {

					//console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

				}

			}


			var m;

			if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {

				// rgb / hsl

				var color;
				var name = m[1];
				var components = m[2];

				switch (name) {

					case 'rgb':
					case 'rgba':

						if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {

							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min(255, parseInt(color[1], 10)) / 255;
							this.g = Math.min(255, parseInt(color[2], 10)) / 255;
							this.b = Math.min(255, parseInt(color[3], 10)) / 255;

							handleAlpha(color[5]);

							return this;

						}

						if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {

							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min(100, parseInt(color[1], 10)) / 100;
							this.g = Math.min(100, parseInt(color[2], 10)) / 100;
							this.b = Math.min(100, parseInt(color[3], 10)) / 100;

							handleAlpha(color[5]);

							return this;

						}

						break;

					case 'hsl':
					case 'hsla':

						if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {

							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							var h = parseFloat(color[1]) / 360;
							var s = parseInt(color[2], 10) / 100;
							var l = parseInt(color[3], 10) / 100;

							handleAlpha(color[5]);

							return this.setHSL(h, s, l);

						}

						break;

				}

			} else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {

				// hex color

				var hex = m[1];
				var size = hex.length;

				if (size === 3) {

					// #ff0
					this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
					this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
					this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;

					return this;

				} else if (size === 6) {

					// #ff0000
					this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
					this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
					this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;

					return this;

				}

			}

			if (style && style.length > 0) {

				// color keywords
				var hex = THREE.ColorKeywords[style];

				if (hex !== undefined) {

					// red
					this.setHex(hex);

				} else {

					// unknown color
					//console.warn( 'THREE.Color: Unknown color ' + style );

				}

			}

			return this;

		},

		clone: function () {

			return new this.constructor(this.r, this.g, this.b);

		},

		copy: function (color) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		},

		copyGammaToLinear: function (color, gammaFactor) {

			if (gammaFactor === undefined) gammaFactor = 2.0;

			this.r = Math.pow(color.r, gammaFactor);
			this.g = Math.pow(color.g, gammaFactor);
			this.b = Math.pow(color.b, gammaFactor);

			return this;

		},

		copyLinearToGamma: function (color, gammaFactor) {

			if (gammaFactor === undefined) gammaFactor = 2.0;

			var safeInverse = (gammaFactor > 0) ? (1.0 / gammaFactor) : 1.0;

			this.r = Math.pow(color.r, safeInverse);
			this.g = Math.pow(color.g, safeInverse);
			this.b = Math.pow(color.b, safeInverse);

			return this;

		},

		convertGammaToLinear: function () {

			var r = this.r, g = this.g, b = this.b;

			this.r = r * r;
			this.g = g * g;
			this.b = b * b;

			return this;

		},

		convertLinearToGamma: function () {

			this.r = Math.sqrt(this.r);
			this.g = Math.sqrt(this.g);
			this.b = Math.sqrt(this.b);

			return this;

		},

		getHex: function () {

			return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;

		},

		getHexString: function () {

			return ('000000' + this.getHex().toString(16)).slice(- 6);

		},

		getHSL: function (optionalTarget) {

			// h,s,l ranges are in 0.0 - 1.0

			var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

			var r = this.r, g = this.g, b = this.b;

			var max = Math.max(r, g, b);
			var min = Math.min(r, g, b);

			var hue, saturation;
			var lightness = (min + max) / 2.0;

			if (min === max) {

				hue = 0;
				saturation = 0;

			} else {

				var delta = max - min;

				saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

				switch (max) {

					case r: hue = (g - b) / delta + (g < b ? 6 : 0); break;
					case g: hue = (b - r) / delta + 2; break;
					case b: hue = (r - g) / delta + 4; break;

				}

				hue /= 6;

			}

			hsl.h = hue;
			hsl.s = saturation;
			hsl.l = lightness;

			return hsl;

		},

		getStyle: function () {

			return 'rgb(' + ((this.r * 255) | 0) + ',' + ((this.g * 255) | 0) + ',' + ((this.b * 255) | 0) + ')';

		},

		offsetHSL: function (h, s, l) {

			var hsl = this.getHSL();

			hsl.h += h; hsl.s += s; hsl.l += l;

			this.setHSL(hsl.h, hsl.s, hsl.l);

			return this;

		},

		add: function (color) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		},

		addColors: function (color1, color2) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		},

		addScalar: function (s) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		},

		multiply: function (color) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		},

		multiplyScalar: function (s) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		},

		lerp: function (color, alpha) {

			this.r += (color.r - this.r) * alpha;
			this.g += (color.g - this.g) * alpha;
			this.b += (color.b - this.b) * alpha;

			return this;

		},

		equals: function (c) {

			return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);

		},

		fromArray: function (array, offset) {

			if (offset === undefined) offset = 0;

			this.r = array[offset];
			this.g = array[offset + 1];
			this.b = array[offset + 2];

			return this;

		},

		toArray: function (array, offset) {

			if (array === undefined) array = [];
			if (offset === undefined) offset = 0;

			array[offset] = this.r;
			array[offset + 1] = this.g;
			array[offset + 2] = this.b;

			return array;

		}

	};

	THREE.ColorKeywords = {
		'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32
	};

	// File:src/math/Quaternion.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	THREE.Quaternion = function (x, y, z, w) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = (w !== undefined) ? w : 1;

	};

	THREE.Quaternion.prototype = {

		constructor: THREE.Quaternion,

		get x() {

			return this._x;

		},

		set x(value) {

			this._x = value;
			this.onChangeCallback();

		},

		get y() {

			return this._y;

		},

		set y(value) {

			this._y = value;
			this.onChangeCallback();

		},

		get z() {

			return this._z;

		},

		set z(value) {

			this._z = value;
			this.onChangeCallback();

		},

		get w() {

			return this._w;

		},

		set w(value) {

			this._w = value;
			this.onChangeCallback();

		},

		set: function (x, y, z, w) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor(this._x, this._y, this._z, this._w);

		},

		copy: function (quaternion) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this.onChangeCallback();

			return this;

		},

		setFromEuler: function (euler, update) {

			if (euler instanceof THREE.Euler === false) {

				throw new Error('THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.');

			}

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var c1 = Math.cos(euler._x / 2);
			var c2 = Math.cos(euler._y / 2);
			var c3 = Math.cos(euler._z / 2);
			var s1 = Math.sin(euler._x / 2);
			var s2 = Math.sin(euler._y / 2);
			var s3 = Math.sin(euler._z / 2);

			var order = euler.order;

			if (order === 'XYZ') {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if (order === 'YXZ') {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if (order === 'ZXY') {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if (order === 'ZYX') {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if (order === 'YZX') {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if (order === 'XZY') {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			}

			if (update !== false) this.onChangeCallback();

			return this;

		},

		setFromAxisAngle: function (axis, angle) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			var halfAngle = angle / 2, s = Math.sin(halfAngle);

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos(halfAngle);

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function (m) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements,

				m11 = te[0], m12 = te[4], m13 = te[8],
				m21 = te[1], m22 = te[5], m23 = te[9],
				m31 = te[2], m32 = te[6], m33 = te[10],

				trace = m11 + m22 + m33,
				s;

			if (trace > 0) {

				s = 0.5 / Math.sqrt(trace + 1.0);

				this._w = 0.25 / s;
				this._x = (m32 - m23) * s;
				this._y = (m13 - m31) * s;
				this._z = (m21 - m12) * s;

			} else if (m11 > m22 && m11 > m33) {

				s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);

				this._w = (m32 - m23) / s;
				this._x = 0.25 * s;
				this._y = (m12 + m21) / s;
				this._z = (m13 + m31) / s;

			} else if (m22 > m33) {

				s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);

				this._w = (m13 - m31) / s;
				this._x = (m12 + m21) / s;
				this._y = 0.25 * s;
				this._z = (m23 + m32) / s;

			} else {

				s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);

				this._w = (m21 - m12) / s;
				this._x = (m13 + m31) / s;
				this._y = (m23 + m32) / s;
				this._z = 0.25 * s;

			}

			this.onChangeCallback();

			return this;

		},

		setFromUnitVectors: function () {

			// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

			// assumes direction vectors vFrom and vTo are normalized

			var v1, r;

			var EPS = 0.000001;

			return function setFromUnitVectors(vFrom, vTo) {

				if (v1 === undefined) v1 = new THREE.Vector3();

				r = vFrom.dot(vTo) + 1;

				if (r < EPS) {

					r = 0;

					if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {

						v1.set(- vFrom.y, vFrom.x, 0);

					} else {

						v1.set(0, - vFrom.z, vFrom.y);

					}

				} else {

					v1.crossVectors(vFrom, vTo);

				}

				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;

				return this.normalize();

			};

		}(),

		inverse: function () {

			return this.conjugate().normalize();

		},

		conjugate: function () {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this.onChangeCallback();

			return this;

		},

		dot: function (v) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		},

		lengthSq: function () {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		},

		length: function () {

			return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);

		},

		normalize: function () {

			var l = this.length();

			if (l === 0) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this.onChangeCallback();

			return this;

		},

		multiply: function (q, p) {

			if (p !== undefined) {

				//console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions(q, p);

			}

			return this.multiplyQuaternions(this, q);

		},

		premultiply: function (q) {

			return this.multiplyQuaternions(q, this);

		},

		multiplyQuaternions: function (a, b) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this.onChangeCallback();

			return this;

		},

		slerp: function (qb, t) {

			if (t === 0) return this;
			if (t === 1) return this.copy(qb);

			var x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if (cosHalfTheta < 0) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy(qb);

			}

			if (cosHalfTheta >= 1.0) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

			if (Math.abs(sinHalfTheta) < 0.001) {

				this._w = 0.5 * (w + this._w);
				this._x = 0.5 * (x + this._x);
				this._y = 0.5 * (y + this._y);
				this._z = 0.5 * (z + this._z);

				return this;

			}

			var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
			var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
				ratioB = Math.sin(t * halfTheta) / sinHalfTheta;

			this._w = (w * ratioA + this._w * ratioB);
			this._x = (x * ratioA + this._x * ratioB);
			this._y = (y * ratioA + this._y * ratioB);
			this._z = (z * ratioA + this._z * ratioB);

			this.onChangeCallback();

			return this;

		},

		equals: function (quaternion) {

			return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);

		},

		fromArray: function (array, offset) {

			if (offset === undefined) offset = 0;

			this._x = array[offset];
			this._y = array[offset + 1];
			this._z = array[offset + 2];
			this._w = array[offset + 3];

			this.onChangeCallback();

			return this;

		},

		toArray: function (array, offset) {

			if (array === undefined) array = [];
			if (offset === undefined) offset = 0;

			array[offset] = this._x;
			array[offset + 1] = this._y;
			array[offset + 2] = this._z;
			array[offset + 3] = this._w;

			return array;

		},

		onChange: function (callback) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () { }

	};

	Object.assign(THREE.Quaternion, {

		slerp: function (qa, qb, qm, t) {

			return qm.copy(qa).slerp(qb, t);

		},

		slerpFlat: function (
			dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {

			// fuzz-free, array-based Quaternion SLERP operation

			var x0 = src0[srcOffset0 + 0],
				y0 = src0[srcOffset0 + 1],
				z0 = src0[srcOffset0 + 2],
				w0 = src0[srcOffset0 + 3],

				x1 = src1[srcOffset1 + 0],
				y1 = src1[srcOffset1 + 1],
				z1 = src1[srcOffset1 + 2],
				w1 = src1[srcOffset1 + 3];

			if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {

				var s = 1 - t,

					cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

					dir = (cos >= 0 ? 1 : - 1),
					sqrSin = 1 - cos * cos;

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if (sqrSin > Number.EPSILON) {

					var sin = Math.sqrt(sqrSin),
						len = Math.atan2(sin, cos * dir);

					s = Math.sin(s * len) / sin;
					t = Math.sin(t * len) / sin;

				}

				var tDir = t * dir;

				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;

				// Normalize in case we just did a lerp:
				if (s === 1 - t) {

					var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;

				}

			}

			dst[dstOffset] = x0;
			dst[dstOffset + 1] = y0;
			dst[dstOffset + 2] = z0;
			dst[dstOffset + 3] = w0;

		}

	});

	// File:src/math/Vector2.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	THREE.Vector2 = function (x, y) {

		this.x = x || 0;
		this.y = y || 0;

	};

	THREE.Vector2.prototype = {

		constructor: THREE.Vector2,

		get width() {

			return this.x;

		},

		set width(value) {

			this.x = value;

		},

		get height() {

			return this.y;

		},

		set height(value) {

			this.y = value;

		},

		//

		set: function (x, y) {

			this.x = x;
			this.y = y;

			return this;

		},

		setScalar: function (scalar) {

			this.x = scalar;
			this.y = scalar;

			return this;

		},

		setX: function (x) {

			this.x = x;

			return this;

		},

		setY: function (y) {

			this.y = y;

			return this;

		},

		setComponent: function (index, value) {

			switch (index) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error('index is out of range: ' + index);

			}

		},

		getComponent: function (index) {

			switch (index) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error('index is out of range: ' + index);

			}

		},

		clone: function () {

			return new this.constructor(this.x, this.y);

		},

		copy: function (v) {

			this.x = v.x;
			this.y = v.y;

			return this;

		},

		add: function (v, w) {

			if (w !== undefined) {

				//console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors(v, w);

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		},

		addScalar: function (s) {

			this.x += s;
			this.y += s;

			return this;

		},

		addVectors: function (a, b) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		},

		addScaledVector: function (v, s) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		},

		sub: function (v, w) {

			if (w !== undefined) {

				//console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors(v, w);

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		},

		subScalar: function (s) {

			this.x -= s;
			this.y -= s;

			return this;

		},

		subVectors: function (a, b) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		},

		multiply: function (v) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		},

		multiplyScalar: function (scalar) {

			if (isFinite(scalar)) {

				this.x *= scalar;
				this.y *= scalar;

			} else {

				this.x = 0;
				this.y = 0;

			}

			return this;

		},

		divide: function (v) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		},

		divideScalar: function (scalar) {

			return this.multiplyScalar(1 / scalar);

		},

		min: function (v) {

			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);

			return this;

		},

		max: function (v) {

			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);

			return this;

		},

		clamp: function (min, max) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));

			return this;

		},

		clampScalar: function () {

			var min, max;

			return function clampScalar(minVal, maxVal) {

				if (min === undefined) {

					min = new THREE.Vector2();
					max = new THREE.Vector2();

				}

				min.set(minVal, minVal);
				max.set(maxVal, maxVal);

				return this.clamp(min, max);

			};

		}(),

		clampLength: function (min, max) {

			var length = this.length();

			return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);

		},

		floor: function () {

			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);

			return this;

		},

		ceil: function () {

			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);

			return this;

		},

		round: function () {

			this.x = Math.round(this.x);
			this.y = Math.round(this.y);

			return this;

		},

		roundToZero: function () {

			this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		},

		dot: function (v) {

			return this.x * v.x + this.y * v.y;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y;

		},

		length: function () {

			return Math.sqrt(this.x * this.x + this.y * this.y);

		},

		lengthManhattan: function () {

			return Math.abs(this.x) + Math.abs(this.y);

		},

		normalize: function () {

			return this.divideScalar(this.length());

		},

		angle: function () {

			// computes the angle in radians with respect to the positive x-axis

			var angle = Math.atan2(this.y, this.x);

			if (angle < 0) angle += 2 * Math.PI;

			return angle;

		},

		distanceTo: function (v) {

			return Math.sqrt(this.distanceToSquared(v));

		},

		distanceToSquared: function (v) {

			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		},

		setLength: function (length) {

			return this.multiplyScalar(length / this.length());

		},

		lerp: function (v, alpha) {

			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;

			return this;

		},

		lerpVectors: function (v1, v2, alpha) {

			return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);

		},

		equals: function (v) {

			return ((v.x === this.x) && (v.y === this.y));

		},

		fromArray: function (array, offset) {

			if (offset === undefined) offset = 0;

			this.x = array[offset];
			this.y = array[offset + 1];

			return this;

		},

		toArray: function (array, offset) {

			if (array === undefined) array = [];
			if (offset === undefined) offset = 0;

			array[offset] = this.x;
			array[offset + 1] = this.y;

			return array;

		},

		fromAttribute: function (attribute, index, offset) {

			if (offset === undefined) offset = 0;

			index = index * attribute.itemSize + offset;

			this.x = attribute.array[index];
			this.y = attribute.array[index + 1];

			return this;

		},

		rotateAround: function (center, angle) {

			var c = Math.cos(angle), s = Math.sin(angle);

			var x = this.x - center.x;
			var y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;

		}

	};

	// File:src/math/Vector3.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author *kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Vector3 = function (x, y, z) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;

	};

	THREE.Vector3.prototype = {

		constructor: THREE.Vector3,

		set: function (x, y, z) {

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		},

		setScalar: function (scalar) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		},

		setX: function (x) {

			this.x = x;

			return this;

		},

		setY: function (y) {

			this.y = y;

			return this;

		},

		setZ: function (z) {

			this.z = z;

			return this;

		},

		setComponent: function (index, value) {

			switch (index) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error('index is out of range: ' + index);

			}

		},

		getComponent: function (index) {

			switch (index) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error('index is out of range: ' + index);

			}

		},

		clone: function () {

			return new this.constructor(this.x, this.y, this.z);

		},

		copy: function (v) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		},

		add: function (v, w) {

			if (w !== undefined) {

				//console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors(v, w);

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		},

		addScalar: function (s) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		},

		addVectors: function (a, b) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		},

		addScaledVector: function (v, s) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		},

		sub: function (v, w) {

			if (w !== undefined) {

				//console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors(v, w);

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		},

		subScalar: function (s) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		},

		subVectors: function (a, b) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		},

		multiply: function (v, w) {

			if (w !== undefined) {

				//console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors(v, w);

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		},

		multiplyScalar: function (scalar) {

			if (isFinite(scalar)) {

				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;

			} else {

				this.x = 0;
				this.y = 0;
				this.z = 0;

			}

			return this;

		},

		multiplyVectors: function (a, b) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		},

		applyEuler: function () {

			var quaternion;

			return function applyEuler(euler) {

				if (euler instanceof THREE.Euler === false) {

					//console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

				}

				if (quaternion === undefined) quaternion = new THREE.Quaternion();

				return this.applyQuaternion(quaternion.setFromEuler(euler));

			};

		}(),

		applyAxisAngle: function () {

			var quaternion;

			return function applyAxisAngle(axis, angle) {

				if (quaternion === undefined) quaternion = new THREE.Quaternion();

				return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));

			};

		}(),

		applyMatrix3: function (m) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[0] * x + e[3] * y + e[6] * z;
			this.y = e[1] * x + e[4] * y + e[7] * z;
			this.z = e[2] * x + e[5] * y + e[8] * z;

			return this;

		},

		applyMatrix4: function (m) {

			// input: THREE.Matrix4 affine matrix

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
			this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
			this.z = e[2] * x + e[6] * y + e[10] * z + e[14];

			return this;

		},

		applyProjection: function (m) {

			// input: THREE.Matrix4 projection matrix

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;
			var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]); // perspective divide

			this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
			this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
			this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;

			return this;

		},

		applyQuaternion: function (q) {

			var x = this.x, y = this.y, z = this.z;
			var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		},

		project: function () {

			var matrix;

			return function project(camera) {

				if (matrix === undefined) matrix = new THREE.Matrix4();

				matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
				return this.applyProjection(matrix);

			};

		}(),

		unproject: function () {

			var matrix;

			return function unproject(camera) {

				if (matrix === undefined) matrix = new THREE.Matrix4();

				matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
				return this.applyProjection(matrix);

			};

		}(),

		transformDirection: function (m) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[0] * x + e[4] * y + e[8] * z;
			this.y = e[1] * x + e[5] * y + e[9] * z;
			this.z = e[2] * x + e[6] * y + e[10] * z;

			return this.normalize();

		},

		divide: function (v) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		},

		divideScalar: function (scalar) {

			return this.multiplyScalar(1 / scalar);

		},

		min: function (v) {

			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			this.z = Math.min(this.z, v.z);

			return this;

		},

		max: function (v) {

			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			this.z = Math.max(this.z, v.z);

			return this;

		},

		clamp: function (min, max) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			this.z = Math.max(min.z, Math.min(max.z, this.z));

			return this;

		},

		clampScalar: function () {

			var min, max;

			return function clampScalar(minVal, maxVal) {

				if (min === undefined) {

					min = new THREE.Vector3();
					max = new THREE.Vector3();

				}

				min.set(minVal, minVal, minVal);
				max.set(maxVal, maxVal, maxVal);

				return this.clamp(min, max);

			};

		}(),

		clampLength: function (min, max) {

			var length = this.length();

			return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);

		},

		floor: function () {

			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);

			return this;

		},

		ceil: function () {

			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);

			return this;

		},

		round: function () {

			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);

			return this;

		},

		roundToZero: function () {

			this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		},

		dot: function (v) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		},

		length: function () {

			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);

		},

		lengthManhattan: function () {

			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);

		},

		normalize: function () {

			return this.divideScalar(this.length());

		},

		setLength: function (length) {

			return this.multiplyScalar(length / this.length());

		},

		lerp: function (v, alpha) {

			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			this.z += (v.z - this.z) * alpha;

			return this;

		},

		lerpVectors: function (v1, v2, alpha) {

			return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);

		},

		cross: function (v, w) {

			if (w !== undefined) {

				//console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors(v, w);

			}

			var x = this.x, y = this.y, z = this.z;

			this.x = y * v.z - z * v.y;
			this.y = z * v.x - x * v.z;
			this.z = x * v.y - y * v.x;

			return this;

		},

		crossVectors: function (a, b) {

			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		},

		projectOnVector: function (vector) {

			var scalar = vector.dot(this) / vector.lengthSq();

			return this.copy(vector).multiplyScalar(scalar);

		},

		projectOnPlane: function () {

			var v1;

			return function projectOnPlane(planeNormal) {

				if (v1 === undefined) v1 = new THREE.Vector3();

				v1.copy(this).projectOnVector(planeNormal);

				return this.sub(v1);

			};

		}(),

		reflect: function () {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			var v1;

			return function reflect(normal) {

				if (v1 === undefined) v1 = new THREE.Vector3();

				return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));

			};

		}(),

		angleTo: function (v) {

			var theta = this.dot(v) / (Math.sqrt(this.lengthSq() * v.lengthSq()));

			// clamp, to handle numerical problems

			return Math.acos(THREE.Math.clamp(theta, - 1, 1));

		},

		distanceTo: function (v) {

			return Math.sqrt(this.distanceToSquared(v));

		},

		distanceToSquared: function (v) {

			var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		},

		setFromSpherical: function (s) {

			var sinPhiRadius = Math.sin(s.phi) * s.radius;

			this.x = sinPhiRadius * Math.sin(s.theta);
			this.y = Math.cos(s.phi) * s.radius;
			this.z = sinPhiRadius * Math.cos(s.theta);

			return this;

		},

		setFromMatrixPosition: function (m) {

			return this.setFromMatrixColumn(m, 3);

		},

		setFromMatrixScale: function (m) {

			var sx = this.setFromMatrixColumn(m, 0).length();
			var sy = this.setFromMatrixColumn(m, 1).length();
			var sz = this.setFromMatrixColumn(m, 2).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		},

		setFromMatrixColumn: function (m, index) {

			if (typeof m === 'number') {

				//console.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );
				var temp = m
				m = index;
				index = temp;

			}

			return this.fromArray(m.elements, index * 4);

		},

		equals: function (v) {

			return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));

		},

		fromArray: function (array, offset) {

			if (offset === undefined) offset = 0;

			this.x = array[offset];
			this.y = array[offset + 1];
			this.z = array[offset + 2];

			return this;

		},

		toArray: function (array, offset) {

			if (array === undefined) array = [];
			if (offset === undefined) offset = 0;

			array[offset] = this.x;
			array[offset + 1] = this.y;
			array[offset + 2] = this.z;

			return array;

		},

		fromAttribute: function (attribute, index, offset) {

			if (offset === undefined) offset = 0;

			index = index * attribute.itemSize + offset;

			this.x = attribute.array[index];
			this.y = attribute.array[index + 1];
			this.z = attribute.array[index + 2];

			return this;

		}

	};

	// File:src/math/Vector4.js

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Vector4 = function (x, y, z, w) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = (w !== undefined) ? w : 1;

	};

	THREE.Vector4.prototype = {

		constructor: THREE.Vector4,

		set: function (x, y, z, w) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		},

		setScalar: function (scalar) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;

		},

		setX: function (x) {

			this.x = x;

			return this;

		},

		setY: function (y) {

			this.y = y;

			return this;

		},

		setZ: function (z) {

			this.z = z;

			return this;

		},

		setW: function (w) {

			this.w = w;

			return this;

		},

		setComponent: function (index, value) {

			switch (index) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error('index is out of range: ' + index);

			}

		},

		getComponent: function (index) {

			switch (index) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error('index is out of range: ' + index);

			}

		},

		clone: function () {

			return new this.constructor(this.x, this.y, this.z, this.w);

		},

		copy: function (v) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = (v.w !== undefined) ? v.w : 1;

			return this;

		},

		add: function (v, w) {

			if (w !== undefined) {

				//console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors(v, w);

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		},

		addScalar: function (s) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		},

		addVectors: function (a, b) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		},

		addScaledVector: function (v, s) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		},

		sub: function (v, w) {

			if (w !== undefined) {

				//console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors(v, w);

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		},

		subScalar: function (s) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		},

		subVectors: function (a, b) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		},

		multiplyScalar: function (scalar) {

			if (isFinite(scalar)) {

				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;
				this.w *= scalar;

			} else {

				this.x = 0;
				this.y = 0;
				this.z = 0;
				this.w = 0;

			}

			return this;

		},

		applyMatrix4: function (m) {

			var x = this.x, y = this.y, z = this.z, w = this.w;
			var e = m.elements;

			this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
			this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
			this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
			this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;

			return this;

		},

		divideScalar: function (scalar) {

			return this.multiplyScalar(1 / scalar);

		},

		setAxisAngleFromQuaternion: function (q) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos(q.w);

			var s = Math.sqrt(1 - q.w * q.w);

			if (s < 0.0001) {

				this.x = 1;
				this.y = 0;
				this.z = 0;

			} else {

				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;

			}

			return this;

		},

		setAxisAngleFromRotationMatrix: function (m) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[0], m12 = te[4], m13 = te[8],
				m21 = te[1], m22 = te[5], m23 = te[9],
				m31 = te[2], m32 = te[6], m33 = te[10];

			if ((Math.abs(m12 - m21) < epsilon) &&
				(Math.abs(m13 - m31) < epsilon) &&
				(Math.abs(m23 - m32) < epsilon)) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ((Math.abs(m12 + m21) < epsilon2) &&
					(Math.abs(m13 + m31) < epsilon2) &&
					(Math.abs(m23 + m32) < epsilon2) &&
					(Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {

					// this singularity is identity matrix so angle = 0

					this.set(1, 0, 0, 0);

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				var xx = (m11 + 1) / 2;
				var yy = (m22 + 1) / 2;
				var zz = (m33 + 1) / 2;
				var xy = (m12 + m21) / 4;
				var xz = (m13 + m31) / 4;
				var yz = (m23 + m32) / 4;

				if ((xx > yy) && (xx > zz)) {

					// m11 is the largest diagonal term

					if (xx < epsilon) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt(xx);
						y = xy / x;
						z = xz / x;

					}

				} else if (yy > zz) {

					// m22 is the largest diagonal term

					if (yy < epsilon) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt(yy);
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if (zz < epsilon) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt(zz);
						x = xz / z;
						y = yz / z;

					}

				}

				this.set(x, y, z, angle);

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			var s = Math.sqrt((m32 - m23) * (m32 - m23) +
				(m13 - m31) * (m13 - m31) +
				(m21 - m12) * (m21 - m12)); // used to normalize

			if (Math.abs(s) < 0.001) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = (m32 - m23) / s;
			this.y = (m13 - m31) / s;
			this.z = (m21 - m12) / s;
			this.w = Math.acos((m11 + m22 + m33 - 1) / 2);

			return this;

		},

		min: function (v) {

			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			this.z = Math.min(this.z, v.z);
			this.w = Math.min(this.w, v.w);

			return this;

		},

		max: function (v) {

			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			this.z = Math.max(this.z, v.z);
			this.w = Math.max(this.w, v.w);

			return this;

		},

		clamp: function (min, max) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			this.z = Math.max(min.z, Math.min(max.z, this.z));
			this.w = Math.max(min.w, Math.min(max.w, this.w));

			return this;

		},

		clampScalar: function () {

			var min, max;

			return function clampScalar(minVal, maxVal) {

				if (min === undefined) {

					min = new THREE.Vector4();
					max = new THREE.Vector4();

				}

				min.set(minVal, minVal, minVal, minVal);
				max.set(maxVal, maxVal, maxVal, maxVal);

				return this.clamp(min, max);

			};

		}(),

		floor: function () {

			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			this.w = Math.floor(this.w);

			return this;

		},

		ceil: function () {

			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			this.w = Math.ceil(this.w);

			return this;

		},

		round: function () {

			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			this.w = Math.round(this.w);

			return this;

		},

		roundToZero: function () {

			this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
			this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		},

		dot: function (v) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		},

		length: function () {

			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);

		},

		lengthManhattan: function () {

			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);

		},

		normalize: function () {

			return this.divideScalar(this.length());

		},

		setLength: function (length) {

			return this.multiplyScalar(length / this.length());

		},

		lerp: function (v, alpha) {

			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			this.z += (v.z - this.z) * alpha;
			this.w += (v.w - this.w) * alpha;

			return this;

		},

		lerpVectors: function (v1, v2, alpha) {

			return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);

		},

		equals: function (v) {

			return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));

		},

		fromArray: function (array, offset) {

			if (offset === undefined) offset = 0;

			this.x = array[offset];
			this.y = array[offset + 1];
			this.z = array[offset + 2];
			this.w = array[offset + 3];

			return this;

		},

		toArray: function (array, offset) {

			if (array === undefined) array = [];
			if (offset === undefined) offset = 0;

			array[offset] = this.x;
			array[offset + 1] = this.y;
			array[offset + 2] = this.z;
			array[offset + 3] = this.w;

			return array;

		},

		fromAttribute: function (attribute, index, offset) {

			if (offset === undefined) offset = 0;

			index = index * attribute.itemSize + offset;

			this.x = attribute.array[index];
			this.y = attribute.array[index + 1];
			this.z = attribute.array[index + 2];
			this.w = attribute.array[index + 3];

			return this;

		}

	};

	// File:src/math/Euler.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	THREE.Euler = function (x, y, z, order) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || THREE.Euler.DefaultOrder;

	};

	THREE.Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];

	THREE.Euler.DefaultOrder = 'XYZ';

	THREE.Euler.prototype = {

		constructor: THREE.Euler,

		get x() {

			return this._x;

		},

		set x(value) {

			this._x = value;
			this.onChangeCallback();

		},

		get y() {

			return this._y;

		},

		set y(value) {

			this._y = value;
			this.onChangeCallback();

		},

		get z() {

			return this._z;

		},

		set z(value) {

			this._z = value;
			this.onChangeCallback();

		},

		get order() {

			return this._order;

		},

		set order(value) {

			this._order = value;
			this.onChangeCallback();

		},

		set: function (x, y, z, order) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor(this._x, this._y, this._z, this._order);

		},

		copy: function (euler) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function (m, order, update) {

			var clamp = THREE.Math.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements;
			var m11 = te[0], m12 = te[4], m13 = te[8];
			var m21 = te[1], m22 = te[5], m23 = te[9];
			var m31 = te[2], m32 = te[6], m33 = te[10];

			order = order || this._order;

			if (order === 'XYZ') {

				this._y = Math.asin(clamp(m13, - 1, 1));

				if (Math.abs(m13) < 0.99999) {

					this._x = Math.atan2(- m23, m33);
					this._z = Math.atan2(- m12, m11);

				} else {

					this._x = Math.atan2(m32, m22);
					this._z = 0;

				}

			} else if (order === 'YXZ') {

				this._x = Math.asin(- clamp(m23, - 1, 1));

				if (Math.abs(m23) < 0.99999) {

					this._y = Math.atan2(m13, m33);
					this._z = Math.atan2(m21, m22);

				} else {

					this._y = Math.atan2(- m31, m11);
					this._z = 0;

				}

			} else if (order === 'ZXY') {

				this._x = Math.asin(clamp(m32, - 1, 1));

				if (Math.abs(m32) < 0.99999) {

					this._y = Math.atan2(- m31, m33);
					this._z = Math.atan2(- m12, m22);

				} else {

					this._y = 0;
					this._z = Math.atan2(m21, m11);

				}

			} else if (order === 'ZYX') {

				this._y = Math.asin(- clamp(m31, - 1, 1));

				if (Math.abs(m31) < 0.99999) {

					this._x = Math.atan2(m32, m33);
					this._z = Math.atan2(m21, m11);

				} else {

					this._x = 0;
					this._z = Math.atan2(- m12, m22);

				}

			} else if (order === 'YZX') {

				this._z = Math.asin(clamp(m21, - 1, 1));

				if (Math.abs(m21) < 0.99999) {

					this._x = Math.atan2(- m23, m22);
					this._y = Math.atan2(- m31, m11);

				} else {

					this._x = 0;
					this._y = Math.atan2(m13, m33);

				}

			} else if (order === 'XZY') {

				this._z = Math.asin(- clamp(m12, - 1, 1));

				if (Math.abs(m12) < 0.99999) {

					this._x = Math.atan2(m32, m22);
					this._y = Math.atan2(m13, m11);

				} else {

					this._x = Math.atan2(- m23, m33);
					this._y = 0;

				}

			} else {

				//console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

			}

			this._order = order;

			if (update !== false) this.onChangeCallback();

			return this;

		},

		setFromQuaternion: function () {

			var matrix;

			return function setFromQuaternion(q, order, update) {

				if (matrix === undefined) matrix = new THREE.Matrix4();

				matrix.makeRotationFromQuaternion(q);

				return this.setFromRotationMatrix(matrix, order, update);

			};

		}(),

		setFromVector3: function (v, order) {

			return this.set(v.x, v.y, v.z, order || this._order);

		},

		reorder: function () {

			// WARNING: this discards revolution information -bhouston

			var q = new THREE.Quaternion();

			return function reorder(newOrder) {

				q.setFromEuler(this);

				return this.setFromQuaternion(q, newOrder);

			};

		}(),

		equals: function (euler) {

			return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);

		},

		fromArray: function (array) {

			this._x = array[0];
			this._y = array[1];
			this._z = array[2];
			if (array[3] !== undefined) this._order = array[3];

			this.onChangeCallback();

			return this;

		},

		toArray: function (array, offset) {

			if (array === undefined) array = [];
			if (offset === undefined) offset = 0;

			array[offset] = this._x;
			array[offset + 1] = this._y;
			array[offset + 2] = this._z;
			array[offset + 3] = this._order;

			return array;

		},

		toVector3: function (optionalResult) {

			if (optionalResult) {

				return optionalResult.set(this._x, this._y, this._z);

			} else {

				return new THREE.Vector3(this._x, this._y, this._z);

			}

		},

		onChange: function (callback) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () { }

	};

	// File:src/math/Line3.js

	/**
	 * @author bhouston / http://clara.io
	 */

	THREE.Line3 = function (start, end) {

		this.start = (start !== undefined) ? start : new THREE.Vector3();
		this.end = (end !== undefined) ? end : new THREE.Vector3();

	};

	THREE.Line3.prototype = {

		constructor: THREE.Line3,

		set: function (start, end) {

			this.start.copy(start);
			this.end.copy(end);

			return this;

		},

		clone: function () {

			return new this.constructor().copy(this);

		},

		copy: function (line) {

			this.start.copy(line.start);
			this.end.copy(line.end);

			return this;

		},

		center: function (optionalTarget) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors(this.start, this.end).multiplyScalar(0.5);

		},

		delta: function (optionalTarget) {

			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors(this.end, this.start);

		},

		distanceSq: function () {

			return this.start.distanceToSquared(this.end);

		},

		distance: function () {

			return this.start.distanceTo(this.end);

		},

		at: function (t, optionalTarget) {

			var result = optionalTarget || new THREE.Vector3();

			return this.delta(result).multiplyScalar(t).add(this.start);

		},

		closestPointToPointParameter: function () {

			var startP = new THREE.Vector3();
			var startEnd = new THREE.Vector3();

			return function closestPointToPointParameter(point, clampToLine) {

				startP.subVectors(point, this.start);
				startEnd.subVectors(this.end, this.start);

				var startEnd2 = startEnd.dot(startEnd);
				var startEnd_startP = startEnd.dot(startP);

				var t = startEnd_startP / startEnd2;

				if (clampToLine) {

					t = THREE.Math.clamp(t, 0, 1);

				}

				return t;

			};

		}(),

		closestPointToPoint: function (point, clampToLine, optionalTarget) {

			var t = this.closestPointToPointParameter(point, clampToLine);

			var result = optionalTarget || new THREE.Vector3();

			return this.delta(result).multiplyScalar(t).add(this.start);

		},

		applyMatrix4: function (matrix) {

			this.start.applyMatrix4(matrix);
			this.end.applyMatrix4(matrix);

			return this;

		},

		equals: function (line) {

			return line.start.equals(this.start) && line.end.equals(this.end);

		}

	};

	// File:src/math/Box2.js

	/**
	 * @author bhouston / http://clara.io
	 */

	THREE.Box2 = function (min, max) {

		this.min = (min !== undefined) ? min : new THREE.Vector2(+ Infinity, + Infinity);
		this.max = (max !== undefined) ? max : new THREE.Vector2(- Infinity, - Infinity);

	};

	THREE.Box2.prototype = {

		constructor: THREE.Box2,

		set: function (min, max) {

			this.min.copy(min);
			this.max.copy(max);

			return this;

		},

		setFromPoints: function (points) {

			this.makeEmpty();

			for (var i = 0, il = points.length; i < il; i++) {

				this.expandByPoint(points[i]);

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new THREE.Vector2();

			return function setFromCenterAndSize(center, size) {

				var halfSize = v1.copy(size).multiplyScalar(0.5);
				this.min.copy(center).sub(halfSize);
				this.max.copy(center).add(halfSize);

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy(this);

		},

		copy: function (box) {

			this.min.copy(box.min);
			this.max.copy(box.max);

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = + Infinity;
			this.max.x = this.max.y = - Infinity;

			return this;

		},

		isEmpty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return (this.max.x < this.min.x) || (this.max.y < this.min.y);

		},

		center: function (optionalTarget) {

			var result = optionalTarget || new THREE.Vector2();
			return result.addVectors(this.min, this.max).multiplyScalar(0.5);

		},

		size: function (optionalTarget) {

			var result = optionalTarget || new THREE.Vector2();
			return result.subVectors(this.max, this.min);

		},

		expandByPoint: function (point) {

			this.min.min(point);
			this.max.max(point);

			return this;

		},

		expandByVector: function (vector) {

			this.min.sub(vector);
			this.max.add(vector);

			return this;

		},

		expandByScalar: function (scalar) {

			this.min.addScalar(- scalar);
			this.max.addScalar(scalar);

			return this;

		},

		containsPoint: function (point) {

			if (point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y) {

				return false;

			}

			return true;

		},

		containsBox: function (box) {

			if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) &&
				(this.min.y <= box.min.y) && (box.max.y <= this.max.y)) {

				return true;

			}

			return false;

		},

		getParameter: function (point, optionalTarget) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			var result = optionalTarget || new THREE.Vector2();

			return result.set(
				(point.x - this.min.x) / (this.max.x - this.min.x),
				(point.y - this.min.y) / (this.max.y - this.min.y)
			);

		},

		intersectsBox: function (box) {

			// using 6 splitting planes to rule out intersections.

			if (box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y) {

				return false;

			}

			return true;

		},

		clampPoint: function (point, optionalTarget) {

			var result = optionalTarget || new THREE.Vector2();
			return result.copy(point).clamp(this.min, this.max);

		},

		distanceToPoint: function () {

			var v1 = new THREE.Vector2();

			return function distanceToPoint(point) {

				var clampedPoint = v1.copy(point).clamp(this.min, this.max);
				return clampedPoint.sub(point).length();

			};

		}(),

		intersect: function (box) {

			this.min.max(box.min);
			this.max.min(box.max);

			return this;

		},

		union: function (box) {

			this.min.min(box.min);
			this.max.max(box.max);

			return this;

		},

		translate: function (offset) {

			this.min.add(offset);
			this.max.add(offset);

			return this;

		},

		equals: function (box) {

			return box.min.equals(this.min) && box.max.equals(this.max);

		}

	};

	// File:src/math/Box3.js

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Box3 = function (min, max) {

		this.min = (min !== undefined) ? min : new THREE.Vector3(+ Infinity, + Infinity, + Infinity);
		this.max = (max !== undefined) ? max : new THREE.Vector3(- Infinity, - Infinity, - Infinity);

	};

	THREE.Box3.prototype = {

		constructor: THREE.Box3,

		set: function (min, max) {

			this.min.copy(min);
			this.max.copy(max);

			return this;

		},

		setFromArray: function (array) {

			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;

			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;

			for (var i = 0, l = array.length; i < l; i += 3) {

				var x = array[i];
				var y = array[i + 1];
				var z = array[i + 2];

				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (z < minZ) minZ = z;

				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
				if (z > maxZ) maxZ = z;

			}

			this.min.set(minX, minY, minZ);
			this.max.set(maxX, maxY, maxZ);

		},

		setFromPoints: function (points) {

			this.makeEmpty();

			for (var i = 0, il = points.length; i < il; i++) {

				this.expandByPoint(points[i]);

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new THREE.Vector3();

			return function setFromCenterAndSize(center, size) {

				var halfSize = v1.copy(size).multiplyScalar(0.5);

				this.min.copy(center).sub(halfSize);
				this.max.copy(center).add(halfSize);

				return this;

			};

		}(),

		setFromObject: function () {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			var v1 = new THREE.Vector3();

			return function setFromObject(object) {

				var scope = this;

				object.updateMatrixWorld(true);

				this.makeEmpty();

				object.traverse(function (node) {

					var geometry = node.geometry;

					if (geometry !== undefined) {

						if (geometry instanceof THREE.Geometry) {

							var vertices = geometry.vertices;

							for (var i = 0, il = vertices.length; i < il; i++) {

								v1.copy(vertices[i]);
								v1.applyMatrix4(node.matrixWorld);

								scope.expandByPoint(v1);

							}

						} else if (geometry instanceof THREE.BufferGeometry && geometry.attributes['position'] !== undefined) {

							var positions = geometry.attributes['position'].array;

							for (var i = 0, il = positions.length; i < il; i += 3) {

								v1.fromArray(positions, i);
								v1.applyMatrix4(node.matrixWorld);

								scope.expandByPoint(v1);

							}

						}

					}

				});

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy(this);

		},

		copy: function (box) {

			this.min.copy(box.min);
			this.max.copy(box.max);

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		},

		isEmpty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);

		},

		center: function (optionalTarget) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors(this.min, this.max).multiplyScalar(0.5);

		},

		size: function (optionalTarget) {

			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors(this.max, this.min);

		},

		expandByPoint: function (point) {

			this.min.min(point);
			this.max.max(point);

			return this;

		},

		expandByVector: function (vector) {

			this.min.sub(vector);
			this.max.add(vector);

			return this;

		},

		expandByScalar: function (scalar) {

			this.min.addScalar(- scalar);
			this.max.addScalar(scalar);

			return this;

		},

		containsPoint: function (point) {

			if (point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ||
				point.z < this.min.z || point.z > this.max.z) {

				return false;

			}

			return true;

		},

		containsBox: function (box) {

			if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) &&
				(this.min.y <= box.min.y) && (box.max.y <= this.max.y) &&
				(this.min.z <= box.min.z) && (box.max.z <= this.max.z)) {

				return true;

			}

			return false;

		},

		getParameter: function (point, optionalTarget) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			var result = optionalTarget || new THREE.Vector3();

			return result.set(
				(point.x - this.min.x) / (this.max.x - this.min.x),
				(point.y - this.min.y) / (this.max.y - this.min.y),
				(point.z - this.min.z) / (this.max.z - this.min.z)
			);

		},

		intersectsBox: function (box) {

			// using 6 splitting planes to rule out intersections.

			if (box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ||
				box.max.z < this.min.z || box.min.z > this.max.z) {

				return false;

			}

			return true;

		},

		intersectsSphere: (function () {

			var closestPoint;

			return function intersectsSphere(sphere) {

				if (closestPoint === undefined) closestPoint = new THREE.Vector3();

				// Find the point on the AABB closest to the sphere center.
				this.clampPoint(sphere.center, closestPoint);

				// If that point is inside the sphere, the AABB and sphere intersect.
				return closestPoint.distanceToSquared(sphere.center) <= (sphere.radius * sphere.radius);

			};

		})(),

		intersectsPlane: function (plane) {

			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.

			var min, max;

			if (plane.normal.x > 0) {

				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;

			} else {

				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;

			}

			if (plane.normal.y > 0) {

				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;

			} else {

				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;

			}

			if (plane.normal.z > 0) {

				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;

			} else {

				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;

			}

			return (min <= plane.constant && max >= plane.constant);

		},

		clampPoint: function (point, optionalTarget) {

			var result = optionalTarget || new THREE.Vector3();
			return result.copy(point).clamp(this.min, this.max);

		},

		distanceToPoint: function () {

			var v1 = new THREE.Vector3();

			return function distanceToPoint(point) {

				var clampedPoint = v1.copy(point).clamp(this.min, this.max);
				return clampedPoint.sub(point).length();

			};

		}(),

		getBoundingSphere: function () {

			var v1 = new THREE.Vector3();

			return function getBoundingSphere(optionalTarget) {

				var result = optionalTarget || new THREE.Sphere();

				result.center = this.center();
				result.radius = this.size(v1).length() * 0.5;

				return result;

			};

		}(),

		intersect: function (box) {

			this.min.max(box.min);
			this.max.min(box.max);

			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if (this.isEmpty()) this.makeEmpty();

			return this;

		},

		union: function (box) {

			this.min.min(box.min);
			this.max.max(box.max);

			return this;

		},

		applyMatrix4: function () {

			var points = [
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3()
			];

			return function applyMatrix4(matrix) {

				// transform of empty box is an empty box.
				if (this.isEmpty()) return this;

				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
				points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
				points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
				points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
				points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
				points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
				points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
				points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);	// 111

				this.setFromPoints(points);

				return this;

			};

		}(),

		translate: function (offset) {

			this.min.add(offset);
			this.max.add(offset);

			return this;

		},

		equals: function (box) {

			return box.min.equals(this.min) && box.max.equals(this.max);

		}

	};

	// File:src/math/Matrix3.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 * @author tschw
	 */

	THREE.Matrix3 = function () {

		this.elements = new Float32Array([

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		]);

		if (arguments.length > 0) {

			//console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	};

	THREE.Matrix3.prototype = {

		constructor: THREE.Matrix3,

		set: function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {

			var te = this.elements;

			te[0] = n11; te[1] = n21; te[2] = n31;
			te[3] = n12; te[4] = n22; te[5] = n32;
			te[6] = n13; te[7] = n23; te[8] = n33;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new this.constructor().fromArray(this.elements);

		},

		copy: function (m) {

			var me = m.elements;

			this.set(

				me[0], me[3], me[6],
				me[1], me[4], me[7],
				me[2], me[5], me[8]

			);

			return this;

		},

		setFromMatrix4: function (m) {

			var me = m.elements;

			this.set(

				me[0], me[4], me[8],
				me[1], me[5], me[9],
				me[2], me[6], me[10]

			);

			return this;

		},

		applyToVector3Array: function () {

			var v1;

			return function applyToVector3Array(array, offset, length) {

				if (v1 === undefined) v1 = new THREE.Vector3();
				if (offset === undefined) offset = 0;
				if (length === undefined) length = array.length;

				for (var i = 0, j = offset; i < length; i += 3, j += 3) {

					v1.fromArray(array, j);
					v1.applyMatrix3(this);
					v1.toArray(array, j);

				}

				return array;

			};

		}(),

		applyToBuffer: function () {

			var v1;

			return function applyToBuffer(buffer, offset, length) {

				if (v1 === undefined) v1 = new THREE.Vector3();
				if (offset === undefined) offset = 0;
				if (length === undefined) length = buffer.length / buffer.itemSize;

				for (var i = 0, j = offset; i < length; i++, j++) {

					v1.x = buffer.getX(j);
					v1.y = buffer.getY(j);
					v1.z = buffer.getZ(j);

					v1.applyMatrix3(this);

					buffer.setXYZ(v1.x, v1.y, v1.z);

				}

				return buffer;

			};

		}(),

		multiplyScalar: function (s) {

			var te = this.elements;

			te[0] *= s; te[3] *= s; te[6] *= s;
			te[1] *= s; te[4] *= s; te[7] *= s;
			te[2] *= s; te[5] *= s; te[8] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var a = te[0], b = te[1], c = te[2],
				d = te[3], e = te[4], f = te[5],
				g = te[6], h = te[7], i = te[8];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		},

		getInverse: function (matrix, throwOnDegenerate) {

			if (matrix instanceof THREE.Matrix4) {

				//console.error( "THREE.Matrix3.getInverse no longer takes a Matrix4 argument." );

			}

			var me = matrix.elements,
				te = this.elements,

				n11 = me[0], n21 = me[1], n31 = me[2],
				n12 = me[3], n22 = me[4], n32 = me[5],
				n13 = me[6], n23 = me[7], n33 = me[8],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13;

			if (det === 0) {

				var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";

				if (throwOnDegenerate || false) {

					throw new Error(msg);

				} else {

					//console.warn( msg );

				}

				return this.identity();
			}

			var detInv = 1 / det;

			te[0] = t11 * detInv;
			te[1] = (n31 * n23 - n33 * n21) * detInv;
			te[2] = (n32 * n21 - n31 * n22) * detInv;

			te[3] = t12 * detInv;
			te[4] = (n33 * n11 - n31 * n13) * detInv;
			te[5] = (n31 * n12 - n32 * n11) * detInv;

			te[6] = t13 * detInv;
			te[7] = (n21 * n13 - n23 * n11) * detInv;
			te[8] = (n22 * n11 - n21 * n12) * detInv;

			return this;

		},

		transpose: function () {

			var tmp, m = this.elements;

			tmp = m[1]; m[1] = m[3]; m[3] = tmp;
			tmp = m[2]; m[2] = m[6]; m[6] = tmp;
			tmp = m[5]; m[5] = m[7]; m[7] = tmp;

			return this;

		},

		flattenToArrayOffset: function (array, offset) {

			//console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +"- just use .toArray instead." );

			return this.toArray(array, offset);

		},

		getNormalMatrix: function (matrix4) {

			return this.setFromMatrix4(matrix4).getInverse(this).transpose();

		},

		transposeIntoArray: function (r) {

			var m = this.elements;

			r[0] = m[0];
			r[1] = m[3];
			r[2] = m[6];
			r[3] = m[1];
			r[4] = m[4];
			r[5] = m[7];
			r[6] = m[2];
			r[7] = m[5];
			r[8] = m[8];

			return this;

		},

		fromArray: function (array) {

			this.elements.set(array);

			return this;

		},

		toArray: function (array, offset) {

			if (array === undefined) array = [];
			if (offset === undefined) offset = 0;

			var te = this.elements;

			array[offset] = te[0];
			array[offset + 1] = te[1];
			array[offset + 2] = te[2];

			array[offset + 3] = te[3];
			array[offset + 4] = te[4];
			array[offset + 5] = te[5];

			array[offset + 6] = te[6];
			array[offset + 7] = te[7];
			array[offset + 8] = te[8];

			return array;

		}

	};

	// File:src/math/Matrix4.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Matrix4 = function () {

		this.elements = new Float32Array([

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		]);

		if (arguments.length > 0) {

			//console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	};

	THREE.Matrix4.prototype = {

		constructor: THREE.Matrix4,

		set: function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {

			var te = this.elements;

			te[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;
			te[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;
			te[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;
			te[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new THREE.Matrix4().fromArray(this.elements);

		},

		copy: function (m) {

			this.elements.set(m.elements);

			return this;

		},

		copyPosition: function (m) {

			var te = this.elements;
			var me = m.elements;

			te[12] = me[12];
			te[13] = me[13];
			te[14] = me[14];

			return this;

		},

		extractBasis: function (xAxis, yAxis, zAxis) {

			xAxis.setFromMatrixColumn(this, 0);
			yAxis.setFromMatrixColumn(this, 1);
			zAxis.setFromMatrixColumn(this, 2);

			return this;

		},

		makeBasis: function (xAxis, yAxis, zAxis) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);

			return this;

		},

		extractRotation: function () {

			var v1;

			return function extractRotation(m) {

				if (v1 === undefined) v1 = new THREE.Vector3();

				var te = this.elements;
				var me = m.elements;

				var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
				var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
				var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();

				te[0] = me[0] * scaleX;
				te[1] = me[1] * scaleX;
				te[2] = me[2] * scaleX;

				te[4] = me[4] * scaleY;
				te[5] = me[5] * scaleY;
				te[6] = me[6] * scaleY;

				te[8] = me[8] * scaleZ;
				te[9] = me[9] * scaleZ;
				te[10] = me[10] * scaleZ;

				return this;

			};

		}(),

		makeRotationFromEuler: function (euler) {

			if (euler instanceof THREE.Euler === false) {

				//console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			var te = this.elements;

			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos(x), b = Math.sin(x);
			var c = Math.cos(y), d = Math.sin(y);
			var e = Math.cos(z), f = Math.sin(z);

			if (euler.order === 'XYZ') {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[0] = c * e;
				te[4] = - c * f;
				te[8] = d;

				te[1] = af + be * d;
				te[5] = ae - bf * d;
				te[9] = - b * c;

				te[2] = bf - ae * d;
				te[6] = be + af * d;
				te[10] = a * c;

			} else if (euler.order === 'YXZ') {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[0] = ce + df * b;
				te[4] = de * b - cf;
				te[8] = a * d;

				te[1] = a * f;
				te[5] = a * e;
				te[9] = - b;

				te[2] = cf * b - de;
				te[6] = df + ce * b;
				te[10] = a * c;

			} else if (euler.order === 'ZXY') {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[0] = ce - df * b;
				te[4] = - a * f;
				te[8] = de + cf * b;

				te[1] = cf + de * b;
				te[5] = a * e;
				te[9] = df - ce * b;

				te[2] = - a * d;
				te[6] = b;
				te[10] = a * c;

			} else if (euler.order === 'ZYX') {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[0] = c * e;
				te[4] = be * d - af;
				te[8] = ae * d + bf;

				te[1] = c * f;
				te[5] = bf * d + ae;
				te[9] = af * d - be;

				te[2] = - d;
				te[6] = b * c;
				te[10] = a * c;

			} else if (euler.order === 'YZX') {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[0] = c * e;
				te[4] = bd - ac * f;
				te[8] = bc * f + ad;

				te[1] = f;
				te[5] = a * e;
				te[9] = - b * e;

				te[2] = - d * e;
				te[6] = ad * f + bc;
				te[10] = ac - bd * f;

			} else if (euler.order === 'XZY') {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[0] = c * e;
				te[4] = - f;
				te[8] = d * e;

				te[1] = ac * f + bd;
				te[5] = a * e;
				te[9] = ad * f - bc;

				te[2] = bc * f - ad;
				te[6] = b * e;
				te[10] = bd * f + ac;

			}

			// last column
			te[3] = 0;
			te[7] = 0;
			te[11] = 0;

			// bottom row
			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;

			return this;

		},

		makeRotationFromQuaternion: function (q) {

			var te = this.elements;

			var x = q.x, y = q.y, z = q.z, w = q.w;
			var x2 = x + x, y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;

			te[0] = 1 - (yy + zz);
			te[4] = xy - wz;
			te[8] = xz + wy;

			te[1] = xy + wz;
			te[5] = 1 - (xx + zz);
			te[9] = yz - wx;

			te[2] = xz - wy;
			te[6] = yz + wx;
			te[10] = 1 - (xx + yy);

			// last column
			te[3] = 0;
			te[7] = 0;
			te[11] = 0;

			// bottom row
			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;

			return this;

		},

		lookAt: function () {

			var x, y, z;

			return function lookAt(eye, target, up) {

				if (x === undefined) {

					x = new THREE.Vector3();
					y = new THREE.Vector3();
					z = new THREE.Vector3();

				}

				var te = this.elements;

				z.subVectors(eye, target).normalize();

				if (z.lengthSq() === 0) {

					z.z = 1;

				}

				x.crossVectors(up, z).normalize();

				if (x.lengthSq() === 0) {

					z.z += 0.0001;
					x.crossVectors(up, z).normalize();

				}

				y.crossVectors(z, x);


				te[0] = x.x; te[4] = y.x; te[8] = z.x;
				te[1] = x.y; te[5] = y.y; te[9] = z.y;
				te[2] = x.z; te[6] = y.z; te[10] = z.z;

				return this;

			};

		}(),

		multiply: function (m, n) {

			if (n !== undefined) {

				//console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices(m, n);

			}

			return this.multiplyMatrices(this, m);

		},

		premultiply: function (m) {

			return this.multiplyMatrices(m, this);

		},

		multiplyMatrices: function (a, b) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
			var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
			var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
			var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];

			var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
			var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
			var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
			var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];

			te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		},

		multiplyToArray: function (a, b, r) {

			var te = this.elements;

			this.multiplyMatrices(a, b);

			r[0] = te[0]; r[1] = te[1]; r[2] = te[2]; r[3] = te[3];
			r[4] = te[4]; r[5] = te[5]; r[6] = te[6]; r[7] = te[7];
			r[8] = te[8]; r[9] = te[9]; r[10] = te[10]; r[11] = te[11];
			r[12] = te[12]; r[13] = te[13]; r[14] = te[14]; r[15] = te[15];

			return this;

		},

		multiplyScalar: function (s) {

			var te = this.elements;

			te[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;
			te[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;
			te[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;
			te[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;

			return this;

		},

		applyToVector3Array: function () {

			var v1;

			return function applyToVector3Array(array, offset, length) {

				if (v1 === undefined) v1 = new THREE.Vector3();
				if (offset === undefined) offset = 0;
				if (length === undefined) length = array.length;

				for (var i = 0, j = offset; i < length; i += 3, j += 3) {

					v1.fromArray(array, j);
					v1.applyMatrix4(this);
					v1.toArray(array, j);

				}

				return array;

			};

		}(),

		applyToBuffer: function () {

			var v1;

			return function applyToBuffer(buffer, offset, length) {

				if (v1 === undefined) v1 = new THREE.Vector3();
				if (offset === undefined) offset = 0;
				if (length === undefined) length = buffer.length / buffer.itemSize;

				for (var i = 0, j = offset; i < length; i++, j++) {

					v1.x = buffer.getX(j);
					v1.y = buffer.getY(j);
					v1.z = buffer.getZ(j);

					v1.applyMatrix4(this);

					buffer.setXYZ(v1.x, v1.y, v1.z);

				}

				return buffer;

			};

		}(),

		determinant: function () {

			var te = this.elements;

			var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
			var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
			var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
			var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					- n13 * n24 * n32
					- n14 * n22 * n33
					+ n12 * n24 * n33
					+ n13 * n22 * n34
					- n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					- n11 * n24 * n33
					+ n14 * n21 * n33
					- n13 * n21 * n34
					+ n13 * n24 * n31
					- n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					- n11 * n22 * n34
					- n14 * n21 * n32
					+ n12 * n21 * n34
					+ n14 * n22 * n31
					- n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					- n11 * n23 * n32
					+ n11 * n22 * n33
					+ n13 * n21 * n32
					- n12 * n21 * n33
					+ n12 * n23 * n31
				)

			);

		},

		transpose: function () {

			var te = this.elements;
			var tmp;

			tmp = te[1]; te[1] = te[4]; te[4] = tmp;
			tmp = te[2]; te[2] = te[8]; te[8] = tmp;
			tmp = te[6]; te[6] = te[9]; te[9] = tmp;

			tmp = te[3]; te[3] = te[12]; te[12] = tmp;
			tmp = te[7]; te[7] = te[13]; te[13] = tmp;
			tmp = te[11]; te[11] = te[14]; te[14] = tmp;

			return this;

		},

		flattenToArrayOffset: function (array, offset) {

			//console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " + "- just use .toArray instead." );

			return this.toArray(array, offset);

		},

		getPosition: function () {

			var v1;

			return function getPosition() {

				if (v1 === undefined) v1 = new THREE.Vector3();
				//console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

				return v1.setFromMatrixColumn(this, 3);

			};

		}(),

		setPosition: function (v) {

			var te = this.elements;

			te[12] = v.x;
			te[13] = v.y;
			te[14] = v.z;

			return this;

		},

		getInverse: function (m, throwOnDegenerate) {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements,
				me = m.elements,

				n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3],
				n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7],
				n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11],
				n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if (det === 0) {

				var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

				if (throwOnDegenerate || false) {

					throw new Error(msg);

				} else {

					//console.warn( msg );

				}

				return this.identity();

			}

			var detInv = 1 / det;

			te[0] = t11 * detInv;
			te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
			te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
			te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;

			te[4] = t12 * detInv;
			te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
			te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
			te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;

			te[8] = t13 * detInv;
			te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
			te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
			te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;

			te[12] = t14 * detInv;
			te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
			te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
			te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;

			return this;

		},

		scale: function (v) {

			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;

			te[0] *= x; te[4] *= y; te[8] *= z;
			te[1] *= x; te[5] *= y; te[9] *= z;
			te[2] *= x; te[6] *= y; te[10] *= z;
			te[3] *= x; te[7] *= y; te[11] *= z;

			return this;

		},

		getMaxScaleOnAxis: function () {

			var te = this.elements;

			var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
			var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
			var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];

			return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));

		},

		makeTranslation: function (x, y, z) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationX: function (theta) {

			var c = Math.cos(theta), s = Math.sin(theta);

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationY: function (theta) {

			var c = Math.cos(theta), s = Math.sin(theta);

			this.set(

				c, 0, s, 0,
				0, 1, 0, 0,
				- s, 0, c, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationZ: function (theta) {

			var c = Math.cos(theta), s = Math.sin(theta);

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationAxis: function (axis, angle) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			var c = Math.cos(angle);
			var s = Math.sin(angle);
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeScale: function (x, y, z) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		},

		compose: function (position, quaternion, scale) {

			this.makeRotationFromQuaternion(quaternion);
			this.scale(scale);
			this.setPosition(position);

			return this;

		},

		decompose: function () {

			var vector, matrix;

			return function decompose(position, quaternion, scale) {

				if (vector === undefined) {

					vector = new THREE.Vector3();
					matrix = new THREE.Matrix4();

				}

				var te = this.elements;

				var sx = vector.set(te[0], te[1], te[2]).length();
				var sy = vector.set(te[4], te[5], te[6]).length();
				var sz = vector.set(te[8], te[9], te[10]).length();

				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if (det < 0) {

					sx = - sx;

				}

				position.x = te[12];
				position.y = te[13];
				position.z = te[14];

				// scale the rotation part

				matrix.elements.set(this.elements); // at this point matrix is incomplete so we can't use .copy()

				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;

				matrix.elements[0] *= invSX;
				matrix.elements[1] *= invSX;
				matrix.elements[2] *= invSX;

				matrix.elements[4] *= invSY;
				matrix.elements[5] *= invSY;
				matrix.elements[6] *= invSY;

				matrix.elements[8] *= invSZ;
				matrix.elements[9] *= invSZ;
				matrix.elements[10] *= invSZ;

				quaternion.setFromRotationMatrix(matrix);

				scale.x = sx;
				scale.y = sy;
				scale.z = sz;

				return this;

			};

		}(),

		makeFrustum: function (left, right, bottom, top, near, far) {

			var te = this.elements;
			var x = 2 * near / (right - left);
			var y = 2 * near / (top - bottom);

			var a = (right + left) / (right - left);
			var b = (top + bottom) / (top - bottom);
			var c = - (far + near) / (far - near);
			var d = - 2 * far * near / (far - near);

			te[0] = x; te[4] = 0; te[8] = a; te[12] = 0;
			te[1] = 0; te[5] = y; te[9] = b; te[13] = 0;
			te[2] = 0; te[6] = 0; te[10] = c; te[14] = d;
			te[3] = 0; te[7] = 0; te[11] = - 1; te[15] = 0;

			return this;

		},

		makePerspective: function (fov, aspect, near, far) {

			var ymax = near * Math.tan(THREE.Math.DEG2RAD * fov * 0.5);
			var ymin = - ymax;
			var xmin = ymin * aspect;
			var xmax = ymax * aspect;

			return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);

		},

		makeOrthographic: function (left, right, top, bottom, near, far) {

			var te = this.elements;
			var w = 1.0 / (right - left);
			var h = 1.0 / (top - bottom);
			var p = 1.0 / (far - near);

			var x = (right + left) * w;
			var y = (top + bottom) * h;
			var z = (far + near) * p;

			te[0] = 2 * w; te[4] = 0; te[8] = 0; te[12] = - x;
			te[1] = 0; te[5] = 2 * h; te[9] = 0; te[13] = - y;
			te[2] = 0; te[6] = 0; te[10] = - 2 * p; te[14] = - z;
			te[3] = 0; te[7] = 0; te[11] = 0; te[15] = 1;

			return this;

		},

		equals: function (matrix) {

			var te = this.elements;
			var me = matrix.elements;

			for (var i = 0; i < 16; i++) {

				if (te[i] !== me[i]) return false;

			}

			return true;

		},

		fromArray: function (array) {

			this.elements.set(array);

			return this;

		},

		toArray: function (array, offset) {

			if (array === undefined) array = [];
			if (offset === undefined) offset = 0;

			var te = this.elements;

			array[offset] = te[0];
			array[offset + 1] = te[1];
			array[offset + 2] = te[2];
			array[offset + 3] = te[3];

			array[offset + 4] = te[4];
			array[offset + 5] = te[5];
			array[offset + 6] = te[6];
			array[offset + 7] = te[7];

			array[offset + 8] = te[8];
			array[offset + 9] = te[9];
			array[offset + 10] = te[10];
			array[offset + 11] = te[11];

			array[offset + 12] = te[12];
			array[offset + 13] = te[13];
			array[offset + 14] = te[14];
			array[offset + 15] = te[15];

			return array;

		}

	};

	// File:src/math/Ray.js

	/**
	 * @author bhouston / http://clara.io
	 */

	THREE.Ray = function (origin, direction) {

		this.origin = (origin !== undefined) ? origin : new THREE.Vector3();
		this.direction = (direction !== undefined) ? direction : new THREE.Vector3();

	};

	THREE.Ray.prototype = {

		constructor: THREE.Ray,

		set: function (origin, direction) {

			this.origin.copy(origin);
			this.direction.copy(direction);

			return this;

		},

		clone: function () {

			return new this.constructor().copy(this);

		},

		copy: function (ray) {

			this.origin.copy(ray.origin);
			this.direction.copy(ray.direction);

			return this;

		},

		at: function (t, optionalTarget) {

			var result = optionalTarget || new THREE.Vector3();

			return result.copy(this.direction).multiplyScalar(t).add(this.origin);

		},

		lookAt: function (v) {

			this.direction.copy(v).sub(this.origin).normalize();

			return this;

		},

		recast: function () {

			var v1 = new THREE.Vector3();

			return function recast(t) {

				this.origin.copy(this.at(t, v1));

				return this;

			};

		}(),

		closestPointToPoint: function (point, optionalTarget) {

			var result = optionalTarget || new THREE.Vector3();
			result.subVectors(point, this.origin);
			var directionDistance = result.dot(this.direction);

			if (directionDistance < 0) {

				return result.copy(this.origin);

			}

			return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

		},

		distanceToPoint: function (point) {

			return Math.sqrt(this.distanceSqToPoint(point));

		},

		distanceSqToPoint: function () {

			var v1 = new THREE.Vector3();

			return function distanceSqToPoint(point) {

				var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);

				// point behind the ray

				if (directionDistance < 0) {

					return this.origin.distanceToSquared(point);

				}

				v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

				return v1.distanceToSquared(point);

			};

		}(),

		distanceSqToSegment: function () {

			var segCenter = new THREE.Vector3();
			var segDir = new THREE.Vector3();
			var diff = new THREE.Vector3();

			return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {

				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment

				segCenter.copy(v0).add(v1).multiplyScalar(0.5);
				segDir.copy(v1).sub(v0).normalize();
				diff.copy(this.origin).sub(segCenter);

				var segExtent = v0.distanceTo(v1) * 0.5;
				var a01 = - this.direction.dot(segDir);
				var b0 = diff.dot(this.direction);
				var b1 = - diff.dot(segDir);
				var c = diff.lengthSq();
				var det = Math.abs(1 - a01 * a01);
				var s0, s1, sqrDist, extDet;

				if (det > 0) {

					// The ray and segment are not parallel.

					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;

					if (s0 >= 0) {

						if (s1 >= - extDet) {

							if (s1 <= extDet) {

								// region 0
								// Minimum at interior points of ray and segment.

								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;

							} else {

								// region 1

								s1 = segExtent;
								s0 = Math.max(0, - (a01 * s1 + b0));
								sqrDist = - s0 * s0 + s1 * (s1 + 2 * b1) + c;

							}

						} else {

							// region 5

							s1 = - segExtent;
							s0 = Math.max(0, - (a01 * s1 + b0));
							sqrDist = - s0 * s0 + s1 * (s1 + 2 * b1) + c;

						}

					} else {

						if (s1 <= - extDet) {

							// region 4

							s0 = Math.max(0, - (- a01 * segExtent + b0));
							s1 = (s0 > 0) ? - segExtent : Math.min(Math.max(- segExtent, - b1), segExtent);
							sqrDist = - s0 * s0 + s1 * (s1 + 2 * b1) + c;

						} else if (s1 <= extDet) {

							// region 3

							s0 = 0;
							s1 = Math.min(Math.max(- segExtent, - b1), segExtent);
							sqrDist = s1 * (s1 + 2 * b1) + c;

						} else {

							// region 2

							s0 = Math.max(0, - (a01 * segExtent + b0));
							s1 = (s0 > 0) ? segExtent : Math.min(Math.max(- segExtent, - b1), segExtent);
							sqrDist = - s0 * s0 + s1 * (s1 + 2 * b1) + c;

						}

					}

				} else {

					// Ray and segment are parallel.

					s1 = (a01 > 0) ? - segExtent : segExtent;
					s0 = Math.max(0, - (a01 * s1 + b0));
					sqrDist = - s0 * s0 + s1 * (s1 + 2 * b1) + c;

				}

				if (optionalPointOnRay) {

					optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);

				}

				if (optionalPointOnSegment) {

					optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);

				}

				return sqrDist;

			};

		}(),

		intersectSphere: function () {

			var v1 = new THREE.Vector3();

			return function intersectSphere(sphere, optionalTarget) {

				v1.subVectors(sphere.center, this.origin);
				var tca = v1.dot(this.direction);
				var d2 = v1.dot(v1) - tca * tca;
				var radius2 = sphere.radius * sphere.radius;

				if (d2 > radius2) return null;

				var thc = Math.sqrt(radius2 - d2);

				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;

				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;

				// test to see if both t0 and t1 are behind the ray - if so, return null
				if (t0 < 0 && t1 < 0) return null;

				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if (t0 < 0) return this.at(t1, optionalTarget);

				// else t0 is in front of the ray, so return the first collision point scaled by t0
				return this.at(t0, optionalTarget);

			};

		}(),

		intersectsSphere: function (sphere) {

			return this.distanceToPoint(sphere.center) <= sphere.radius;

		},

		distanceToPlane: function (plane) {

			var denominator = plane.normal.dot(this.direction);

			if (denominator === 0) {

				// line is coplanar, return origin
				if (plane.distanceToPoint(this.origin) === 0) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			var t = - (this.origin.dot(plane.normal) + plane.constant) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t : null;

		},

		intersectPlane: function (plane, optionalTarget) {

			var t = this.distanceToPlane(plane);

			if (t === null) {

				return null;

			}

			return this.at(t, optionalTarget);

		},



		intersectsPlane: function (plane) {

			// check if the ray lies on the plane first

			var distToPoint = plane.distanceToPoint(this.origin);

			if (distToPoint === 0) {

				return true;

			}

			var denominator = plane.normal.dot(this.direction);

			if (denominator * distToPoint < 0) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		},

		intersectBox: function (box, optionalTarget) {

			var tmin, tmax, tymin, tymax, tzmin, tzmax;

			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			var origin = this.origin;

			if (invdirx >= 0) {

				tmin = (box.min.x - origin.x) * invdirx;
				tmax = (box.max.x - origin.x) * invdirx;

			} else {

				tmin = (box.max.x - origin.x) * invdirx;
				tmax = (box.min.x - origin.x) * invdirx;

			}

			if (invdiry >= 0) {

				tymin = (box.min.y - origin.y) * invdiry;
				tymax = (box.max.y - origin.y) * invdiry;

			} else {

				tymin = (box.max.y - origin.y) * invdiry;
				tymax = (box.min.y - origin.y) * invdiry;

			}

			if ((tmin > tymax) || (tymin > tmax)) return null;

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if (tymin > tmin || tmin !== tmin) tmin = tymin;

			if (tymax < tmax || tmax !== tmax) tmax = tymax;

			if (invdirz >= 0) {

				tzmin = (box.min.z - origin.z) * invdirz;
				tzmax = (box.max.z - origin.z) * invdirz;

			} else {

				tzmin = (box.max.z - origin.z) * invdirz;
				tzmax = (box.min.z - origin.z) * invdirz;

			}

			if ((tmin > tzmax) || (tzmin > tmax)) return null;

			if (tzmin > tmin || tmin !== tmin) tmin = tzmin;

			if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

			//return point closest to the ray (positive side)

			if (tmax < 0) return null;

			return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);

		},

		intersectsBox: (function () {

			var v = new THREE.Vector3();

			return function intersectsBox(box) {

				return this.intersectBox(box, v) !== null;

			};

		})(),

		intersectTriangle: function () {

			// Compute the offset origin, edges, and normal.
			var diff = new THREE.Vector3();
			var edge1 = new THREE.Vector3();
			var edge2 = new THREE.Vector3();
			var normal = new THREE.Vector3();

			return function intersectTriangle(a, b, c, backfaceCulling, optionalTarget) {

				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

				edge1.subVectors(b, a);
				edge2.subVectors(c, a);
				normal.crossVectors(edge1, edge2);

				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot(normal);
				var sign;

				if (DdN > 0) {

					if (backfaceCulling) return null;
					sign = 1;

				} else if (DdN < 0) {

					sign = - 1;
					DdN = - DdN;

				} else {

					return null;

				}

				diff.subVectors(this.origin, a);
				var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));

				// b1 < 0, no intersection
				if (DdQxE2 < 0) {

					return null;

				}

				var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));

				// b2 < 0, no intersection
				if (DdE1xQ < 0) {

					return null;

				}

				// b1+b2 > 1, no intersection
				if (DdQxE2 + DdE1xQ > DdN) {

					return null;

				}

				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot(normal);

				// t < 0, no intersection
				if (QdN < 0) {

					return null;

				}

				// Ray intersects triangle.
				return this.at(QdN / DdN, optionalTarget);

			};

		}(),

		applyMatrix4: function (matrix4) {

			this.direction.add(this.origin).applyMatrix4(matrix4);
			this.origin.applyMatrix4(matrix4);
			this.direction.sub(this.origin);
			this.direction.normalize();

			return this;

		},

		equals: function (ray) {

			return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);

		}

	};

	// File:src/math/Sphere.js

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Sphere = function (center, radius) {

		this.center = (center !== undefined) ? center : new THREE.Vector3();
		this.radius = (radius !== undefined) ? radius : 0;

	};

	THREE.Sphere.prototype = {

		constructor: THREE.Sphere,

		set: function (center, radius) {

			this.center.copy(center);
			this.radius = radius;

			return this;

		},

		setFromPoints: function () {

			var box = new THREE.Box3();

			return function setFromPoints(points, optionalCenter) {

				var center = this.center;

				if (optionalCenter !== undefined) {

					center.copy(optionalCenter);

				} else {

					box.setFromPoints(points).center(center);

				}

				var maxRadiusSq = 0;

				for (var i = 0, il = points.length; i < il; i++) {

					maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));

				}

				this.radius = Math.sqrt(maxRadiusSq);

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy(this);

		},

		copy: function (sphere) {

			this.center.copy(sphere.center);
			this.radius = sphere.radius;

			return this;

		},

		empty: function () {

			return (this.radius <= 0);

		},

		containsPoint: function (point) {

			return (point.distanceToSquared(this.center) <= (this.radius * this.radius));

		},

		distanceToPoint: function (point) {

			return (point.distanceTo(this.center) - this.radius);

		},

		intersectsSphere: function (sphere) {

			var radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);

		},

		intersectsBox: function (box) {

			return box.intersectsSphere(this);

		},

		intersectsPlane: function (plane) {

			// We use the following equation to compute the signed distance from
			// the center of the sphere to the plane.
			//
			// distance = q * n - d
			//
			// If this distance is greater than the radius of the sphere,
			// then there is no intersection.

			return Math.abs(this.center.dot(plane.normal) - plane.constant) <= this.radius;

		},

		clampPoint: function (point, optionalTarget) {

			var deltaLengthSq = this.center.distanceToSquared(point);

			var result = optionalTarget || new THREE.Vector3();

			result.copy(point);

			if (deltaLengthSq > (this.radius * this.radius)) {

				result.sub(this.center).normalize();
				result.multiplyScalar(this.radius).add(this.center);

			}

			return result;

		},

		getBoundingBox: function (optionalTarget) {

			var box = optionalTarget || new THREE.Box3();

			box.set(this.center, this.center);
			box.expandByScalar(this.radius);

			return box;

		},

		applyMatrix4: function (matrix) {

			this.center.applyMatrix4(matrix);
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		},

		translate: function (offset) {

			this.center.add(offset);

			return this;

		},

		equals: function (sphere) {

			return sphere.center.equals(this.center) && (sphere.radius === this.radius);

		}

	};

	// File:src/math/Frustum.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://clara.io
	 */

	THREE.Frustum = function (p0, p1, p2, p3, p4, p5) {

		this.planes = [

			(p0 !== undefined) ? p0 : new THREE.Plane(),
			(p1 !== undefined) ? p1 : new THREE.Plane(),
			(p2 !== undefined) ? p2 : new THREE.Plane(),
			(p3 !== undefined) ? p3 : new THREE.Plane(),
			(p4 !== undefined) ? p4 : new THREE.Plane(),
			(p5 !== undefined) ? p5 : new THREE.Plane()

		];

	};

	THREE.Frustum.prototype = {

		constructor: THREE.Frustum,

		set: function (p0, p1, p2, p3, p4, p5) {

			var planes = this.planes;

			planes[0].copy(p0);
			planes[1].copy(p1);
			planes[2].copy(p2);
			planes[3].copy(p3);
			planes[4].copy(p4);
			planes[5].copy(p5);

			return this;

		},

		clone: function () {

			return new this.constructor().copy(this);

		},

		copy: function (frustum) {

			var planes = this.planes;

			for (var i = 0; i < 6; i++) {

				planes[i].copy(frustum.planes[i]);

			}

			return this;

		},

		setFromMatrix: function (m) {

			var planes = this.planes;
			var me = m.elements;
			var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
			var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
			var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
			var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];

			planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
			planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
			planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
			planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
			planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
			planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();

			return this;

		},

		intersectsObject: function () {

			var sphere = new THREE.Sphere();

			return function intersectsObject(object) {

				var geometry = object.geometry;

				if (geometry.boundingSphere === null)
					geometry.computeBoundingSphere();

				sphere.copy(geometry.boundingSphere)
					.applyMatrix4(object.matrixWorld);

				return this.intersectsSphere(sphere);

			};

		}(),

		intersectsSprite: function () {

			var sphere = new THREE.Sphere();

			return function intersectsSprite(sprite) {

				sphere.center.set(0, 0, 0);
				sphere.radius = 0.7071067811865476;
				sphere.applyMatrix4(sprite.matrixWorld);

				return this.intersectsSphere(sphere);

			};

		}(),

		intersectsSphere: function (sphere) {

			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;

			for (var i = 0; i < 6; i++) {

				var distance = planes[i].distanceToPoint(center);

				if (distance < negRadius) {

					return false;

				}

			}

			return true;

		},

		intersectsBox: function () {

			var p1 = new THREE.Vector3(),
				p2 = new THREE.Vector3();

			return function intersectsBox(box) {

				var planes = this.planes;

				for (var i = 0; i < 6; i++) {

					var plane = planes[i];

					p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
					p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
					p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
					p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

					var d1 = plane.distanceToPoint(p1);
					var d2 = plane.distanceToPoint(p2);

					// if both outside plane, no intersection

					if (d1 < 0 && d2 < 0) {

						return false;

					}

				}

				return true;

			};

		}(),


		containsPoint: function (point) {

			var planes = this.planes;

			for (var i = 0; i < 6; i++) {

				if (planes[i].distanceToPoint(point) < 0) {

					return false;

				}

			}

			return true;

		}

	};

	// File:src/math/Plane.js

	/**
	 * @author bhouston / http://clara.io
	 */

	THREE.Plane = function (normal, constant) {

		this.normal = (normal !== undefined) ? normal : new THREE.Vector3(1, 0, 0);
		this.constant = (constant !== undefined) ? constant : 0;

	};

	THREE.Plane.prototype = {

		constructor: THREE.Plane,

		set: function (normal, constant) {

			this.normal.copy(normal);
			this.constant = constant;

			return this;

		},

		setComponents: function (x, y, z, w) {

			this.normal.set(x, y, z);
			this.constant = w;

			return this;

		},

		setFromNormalAndCoplanarPoint: function (normal, point) {

			this.normal.copy(normal);
			this.constant = - point.dot(this.normal);	// must be this.normal, not normal, as this.normal is normalized

			return this;

		},

		setFromCoplanarPoints: function () {

			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();

			return function setFromCoplanarPoints(a, b, c) {

				var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();

				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

				this.setFromNormalAndCoplanarPoint(normal, a);

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy(this);

		},

		copy: function (plane) {

			this.normal.copy(plane.normal);
			this.constant = plane.constant;

			return this;

		},

		normalize: function () {

			// Note: will lead to a divide by zero if the plane is invalid.

			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar(inverseNormalLength);
			this.constant *= inverseNormalLength;

			return this;

		},

		negate: function () {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		},

		distanceToPoint: function (point) {

			return this.normal.dot(point) + this.constant;

		},

		distanceToSphere: function (sphere) {

			return this.distanceToPoint(sphere.center) - sphere.radius;

		},

		projectPoint: function (point, optionalTarget) {

			return this.orthoPoint(point, optionalTarget).sub(point).negate();

		},

		orthoPoint: function (point, optionalTarget) {

			var perpendicularMagnitude = this.distanceToPoint(point);

			var result = optionalTarget || new THREE.Vector3();
			return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);

		},

		intersectLine: function () {

			var v1 = new THREE.Vector3();

			return function intersectLine(line, optionalTarget) {

				var result = optionalTarget || new THREE.Vector3();

				var direction = line.delta(v1);

				var denominator = this.normal.dot(direction);

				if (denominator === 0) {

					// line is coplanar, return origin
					if (this.distanceToPoint(line.start) === 0) {

						return result.copy(line.start);

					}

					// Unsure if this is the correct method to handle this case.
					return undefined;

				}

				var t = - (line.start.dot(this.normal) + this.constant) / denominator;

				if (t < 0 || t > 1) {

					return undefined;

				}

				return result.copy(direction).multiplyScalar(t).add(line.start);

			};

		}(),

		intersectsLine: function (line) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			var startSign = this.distanceToPoint(line.start);
			var endSign = this.distanceToPoint(line.end);

			return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);

		},

		intersectsBox: function (box) {

			return box.intersectsPlane(this);

		},

		intersectsSphere: function (sphere) {

			return sphere.intersectsPlane(this);

		},

		coplanarPoint: function (optionalTarget) {

			var result = optionalTarget || new THREE.Vector3();
			return result.copy(this.normal).multiplyScalar(- this.constant);

		},

		applyMatrix4: function () {

			var v1 = new THREE.Vector3();
			var m1 = new THREE.Matrix3();

			return function applyMatrix4(matrix, optionalNormalMatrix) {

				var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);

				// transform normal based on theory here:
				// http://www.songho.ca/opengl/gl_normaltransform.html
				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
				var normal = this.normal.applyMatrix3(normalMatrix).normalize();

				// recalculate constant (like in setFromNormalAndCoplanarPoint)
				this.constant = - referencePoint.dot(normal);

				return this;

			};

		}(),

		translate: function (offset) {

			this.constant = this.constant - offset.dot(this.normal);

			return this;

		},

		equals: function (plane) {

			return plane.normal.equals(this.normal) && (plane.constant === this.constant);

		}

	};

	// File:src/math/Spherical.js

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The poles (phi) are at the positive and negative y axis.
	 * The equator starts at positive z.
	 */

	THREE.Spherical = function (radius, phi, theta) {

		this.radius = (radius !== undefined) ? radius : 1.0;
		this.phi = (phi !== undefined) ? phi : 0; // up / down towards top and bottom pole
		this.theta = (theta !== undefined) ? theta : 0; // around the equator of the sphere

		return this;

	};

	THREE.Spherical.prototype = {

		constructor: THREE.Spherical,

		set: function (radius, phi, theta) {

			this.radius = radius;
			this.phi = phi;
			this.theta = theta;

			return this;

		},

		clone: function () {

			return new this.constructor().copy(this);

		},

		copy: function (other) {

			this.radius.copy(other.radius);
			this.phi.copy(other.phi);
			this.theta.copy(other.theta);

			return this;

		},

		// restrict phi to be betwee EPS and PI-EPS
		makeSafe: function () {

			var EPS = 0.000001;
			this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));

			return this;

		},

		setFromVector3: function (vec3) {

			this.radius = vec3.length();

			if (this.radius === 0) {

				this.theta = 0;
				this.phi = 0;

			} else {

				this.theta = Math.atan2(vec3.x, vec3.z); // equator angle around y-up axis
				this.phi = Math.acos(THREE.Math.clamp(vec3.y / this.radius, - 1, 1)); // polar angle

			}

			return this;

		},

	};

	// File:src/math/Math.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Math = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,

		generateUUID: function () {

			// http://www.broofa.com/Tools/Math.uuid.htm

			var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
			var uuid = new Array(36);
			var rnd = 0, r;

			return function generateUUID() {

				for (var i = 0; i < 36; i++) {

					if (i === 8 || i === 13 || i === 18 || i === 23) {

						uuid[i] = '-';

					} else if (i === 14) {

						uuid[i] = '4';

					} else {

						if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
						r = rnd & 0xf;
						rnd = rnd >> 4;
						uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];

					}

				}

				return uuid.join('');

			};

		}(),

		clamp: function (value, min, max) {

			return Math.max(min, Math.min(max, value));

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function (n, m) {

			return ((n % m) + m) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function (x, a1, a2, b1, b2) {

			return b1 + (x - a1) * (b2 - b1) / (a2 - a1);

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function (x, min, max) {

			if (x <= min) return 0;
			if (x >= max) return 1;

			x = (x - min) / (max - min);

			return x * x * (3 - 2 * x);

		},

		smootherstep: function (x, min, max) {

			if (x <= min) return 0;
			if (x >= max) return 1;

			x = (x - min) / (max - min);

			return x * x * x * (x * (x * 6 - 15) + 10);

		},

		random16: function () {

			//console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
			return Math.random();

		},

		// Random integer from <low, high> interval

		randInt: function (low, high) {

			return low + Math.floor(Math.random() * (high - low + 1));

		},

		// Random float from <low, high> interval

		randFloat: function (low, high) {

			return low + Math.random() * (high - low);

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function (range) {

			return range * (0.5 - Math.random());

		},

		degToRad: function (degrees) {

			return degrees * THREE.Math.DEG2RAD;

		},

		radToDeg: function (radians) {

			return radians * THREE.Math.RAD2DEG;

		},

		isPowerOfTwo: function (value) {

			return (value & (value - 1)) === 0 && value !== 0;

		},

		nearestPowerOfTwo: function (value) {

			return Math.pow(2, Math.round(Math.log(value) / Math.LN2));

		},

		nextPowerOfTwo: function (value) {

			value--;
			value |= value >> 1;
			value |= value >> 2;
			value |= value >> 4;
			value |= value >> 8;
			value |= value >> 16;
			value++;

			return value;

		}

	};

	// File:src/math/Spline.js

	/**
	 * Spline from Tween.js, slightly optimized (and trashed)
	 * http://sole.github.com/tween.js/examples/05_spline.html
	 *
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Spline = function (points) {

		this.points = points;

		var c = [], v3 = { x: 0, y: 0, z: 0 },
			point, intPoint, weight, w2, w3,
			pa, pb, pc, pd;

		this.initFromArray = function (a) {

			this.points = [];

			for (var i = 0; i < a.length; i++) {

				this.points[i] = { x: a[i][0], y: a[i][1], z: a[i][2] };

			}

		};

		this.getPoint = function (k) {

			point = (this.points.length - 1) * k;
			intPoint = Math.floor(point);
			weight = point - intPoint;

			c[0] = intPoint === 0 ? intPoint : intPoint - 1;
			c[1] = intPoint;
			c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
			c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

			pa = this.points[c[0]];
			pb = this.points[c[1]];
			pc = this.points[c[2]];
			pd = this.points[c[3]];

			w2 = weight * weight;
			w3 = weight * w2;

			v3.x = interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);
			v3.y = interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);
			v3.z = interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);

			return v3;

		};

		this.getControlPointsArray = function () {

			var i, p, l = this.points.length,
				coords = [];

			for (i = 0; i < l; i++) {

				p = this.points[i];
				coords[i] = [p.x, p.y, p.z];

			}

			return coords;

		};

		// approximate length by summing linear segments

		this.getLength = function (nSubDivisions) {

			var i, index, nSamples, position,
				point = 0, intPoint = 0, oldIntPoint = 0,
				oldPosition = new THREE.Vector3(),
				tmpVec = new THREE.Vector3(),
				chunkLengths = [],
				totalLength = 0;

			// first point has 0 length

			chunkLengths[0] = 0;

			if (!nSubDivisions) nSubDivisions = 100;

			nSamples = this.points.length * nSubDivisions;

			oldPosition.copy(this.points[0]);

			for (i = 1; i < nSamples; i++) {

				index = i / nSamples;

				position = this.getPoint(index);
				tmpVec.copy(position);

				totalLength += tmpVec.distanceTo(oldPosition);

				oldPosition.copy(position);

				point = (this.points.length - 1) * index;
				intPoint = Math.floor(point);

				if (intPoint !== oldIntPoint) {

					chunkLengths[intPoint] = totalLength;
					oldIntPoint = intPoint;

				}

			}

			// last point ends with total length

			chunkLengths[chunkLengths.length] = totalLength;

			return { chunks: chunkLengths, total: totalLength };

		};

		this.reparametrizeByArcLength = function (samplingCoef) {

			var i, j,
				index, indexCurrent, indexNext,
				realDistance,
				sampling, position,
				newpoints = [],
				tmpVec = new THREE.Vector3(),
				sl = this.getLength();

			newpoints.push(tmpVec.copy(this.points[0]).clone());

			for (i = 1; i < this.points.length; i++) {

				//tmpVec.copy( this.points[ i - 1 ] );
				//linearDistance = tmpVec.distanceTo( this.points[ i ] );

				realDistance = sl.chunks[i] - sl.chunks[i - 1];

				sampling = Math.ceil(samplingCoef * realDistance / sl.total);

				indexCurrent = (i - 1) / (this.points.length - 1);
				indexNext = i / (this.points.length - 1);

				for (j = 1; j < sampling - 1; j++) {

					index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent);

					position = this.getPoint(index);
					newpoints.push(tmpVec.copy(position).clone());

				}

				newpoints.push(tmpVec.copy(this.points[i]).clone());

			}

			this.points = newpoints;

		};

		// Catmull-Rom

		function interpolate(p0, p1, p2, p3, t, t2, t3) {

			var v0 = (p2 - p0) * 0.5,
				v1 = (p3 - p1) * 0.5;

			return (2 * (p1 - p2) + v0 + v1) * t3 + (- 3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;

		}

	};

	// File:src/math/Triangle.js

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Triangle = function (a, b, c) {

		this.a = (a !== undefined) ? a : new THREE.Vector3();
		this.b = (b !== undefined) ? b : new THREE.Vector3();
		this.c = (c !== undefined) ? c : new THREE.Vector3();

	};

	THREE.Triangle.normal = function () {

		var v0 = new THREE.Vector3();

		return function normal(a, b, c, optionalTarget) {

			var result = optionalTarget || new THREE.Vector3();

			result.subVectors(c, b);
			v0.subVectors(a, b);
			result.cross(v0);

			var resultLengthSq = result.lengthSq();
			if (resultLengthSq > 0) {

				return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));

			}

			return result.set(0, 0, 0);

		};

	}();

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	THREE.Triangle.barycoordFromPoint = function () {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function barycoordFromPoint(point, a, b, c, optionalTarget) {

			v0.subVectors(c, a);
			v1.subVectors(b, a);
			v2.subVectors(point, a);

			var dot00 = v0.dot(v0);
			var dot01 = v0.dot(v1);
			var dot02 = v0.dot(v2);
			var dot11 = v1.dot(v1);
			var dot12 = v1.dot(v2);

			var denom = (dot00 * dot11 - dot01 * dot01);

			var result = optionalTarget || new THREE.Vector3();

			// collinear or singular triangle
			if (denom === 0) {

				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return result.set(- 2, - 1, - 1);

			}

			var invDenom = 1 / denom;
			var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
			var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

			// barycentric coordinates must always sum to 1
			return result.set(1 - u - v, v, u);

		};

	}();

	THREE.Triangle.containsPoint = function () {

		var v1 = new THREE.Vector3();

		return function containsPoint(point, a, b, c) {

			var result = THREE.Triangle.barycoordFromPoint(point, a, b, c, v1);

			return (result.x >= 0) && (result.y >= 0) && ((result.x + result.y) <= 1);

		};

	}();

	THREE.Triangle.prototype = {

		constructor: THREE.Triangle,

		set: function (a, b, c) {

			this.a.copy(a);
			this.b.copy(b);
			this.c.copy(c);

			return this;

		},

		setFromPointsAndIndices: function (points, i0, i1, i2) {

			this.a.copy(points[i0]);
			this.b.copy(points[i1]);
			this.c.copy(points[i2]);

			return this;

		},

		clone: function () {

			return new this.constructor().copy(this);

		},

		copy: function (triangle) {

			this.a.copy(triangle.a);
			this.b.copy(triangle.b);
			this.c.copy(triangle.c);

			return this;

		},

		area: function () {

			var v0 = new THREE.Vector3();
			var v1 = new THREE.Vector3();

			return function area() {

				v0.subVectors(this.c, this.b);
				v1.subVectors(this.a, this.b);

				return v0.cross(v1).length() * 0.5;

			};

		}(),

		midpoint: function (optionalTarget) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);

		},

		normal: function (optionalTarget) {

			return THREE.Triangle.normal(this.a, this.b, this.c, optionalTarget);

		},

		plane: function (optionalTarget) {

			var result = optionalTarget || new THREE.Plane();

			return result.setFromCoplanarPoints(this.a, this.b, this.c);

		},

		barycoordFromPoint: function (point, optionalTarget) {

			return THREE.Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);

		},

		containsPoint: function (point) {

			return THREE.Triangle.containsPoint(point, this.a, this.b, this.c);

		},

		closestPointToPoint: function () {

			var plane, edgeList, projectedPoint, closestPoint;

			return function closestPointToPoint(point, optionalTarget) {

				if (plane === undefined) {

					plane = new THREE.Plane();
					edgeList = [new THREE.Line3(), new THREE.Line3(), new THREE.Line3()];
					projectedPoint = new THREE.Vector3();
					closestPoint = new THREE.Vector3();

				}

				var result = optionalTarget || new THREE.Vector3();
				var minDistance = Infinity;

				// project the point onto the plane of the triangle

				plane.setFromCoplanarPoints(this.a, this.b, this.c);
				plane.projectPoint(point, projectedPoint);

				// check if the projection lies within the triangle

				if (this.containsPoint(projectedPoint) === true) {

					// if so, this is the closest point

					result.copy(projectedPoint);

				} else {

					// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

					edgeList[0].set(this.a, this.b);
					edgeList[1].set(this.b, this.c);
					edgeList[2].set(this.c, this.a);

					for (var i = 0; i < edgeList.length; i++) {

						edgeList[i].closestPointToPoint(projectedPoint, true, closestPoint);

						var distance = projectedPoint.distanceToSquared(closestPoint);

						if (distance < minDistance) {

							minDistance = distance;

							result.copy(closestPoint);

						}

					}

				}

				return result;

			};

		}(),

		equals: function (triangle) {

			return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);

		}

	};

	// File:src/math/Interpolant.js

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 * @author tschw
	 */

	THREE.Interpolant = function (
		parameterPositions, sampleValues, sampleSize, resultBuffer) {

		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;

		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor(sampleSize);
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;

	};

	THREE.Interpolant.prototype = {

		constructor: THREE.Interpolant,

		evaluate: function (t) {

			var pp = this.parameterPositions,
				i1 = this._cachedIndex,

				t1 = pp[i1],
				t0 = pp[i1 - 1];

			validate_interval: {

				seek: {

					var right;

					linear_scan: {
						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if (!(t < t1)) {

							for (var giveUpAt = i1 + 2; ;) {

								if (t1 === undefined) {

									if (t < t0) break forward_scan;

									// after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_(i1 - 1, t, t0);

								}

								if (i1 === giveUpAt) break; // this loop

								t0 = t1;
								t1 = pp[++i1];

								if (t < t1) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;

						}

						//- slower code:
						//-					if ( t < t0 || t0 === undefined ) {
						if (!(t >= t0)) {

							// looping?

							var t1global = pp[1];

							if (t < t1global) {

								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;

							}

							// linear reverse scan

							for (var giveUpAt = i1 - 2; ;) {

								if (t0 === undefined) {

									// before start

									this._cachedIndex = 0;
									return this.beforeStart_(0, t, t1);

								}

								if (i1 === giveUpAt) break; // this loop

								t1 = t0;
								t0 = pp[--i1 - 1];

								if (t >= t0) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;

						}

						// the interval is valid

						break validate_interval;

					} // linear scan

					// binary search

					while (i1 < right) {

						var mid = (i1 + right) >>> 1;

						if (t < pp[mid]) {

							right = mid;

						} else {

							i1 = mid + 1;

						}

					}

					t1 = pp[i1];
					t0 = pp[i1 - 1];

					// check boundary cases, again

					if (t0 === undefined) {

						this._cachedIndex = 0;
						return this.beforeStart_(0, t, t1);

					}

					if (t1 === undefined) {

						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_(i1 - 1, t0, t);

					}

				} // seek

				this._cachedIndex = i1;

				this.intervalChanged_(i1, t0, t1);

			} // validate_interval

			return this.interpolate_(i1, t0, t, t1);

		},

		settings: null, // optional, subclass-specific settings structure
		// Note: The indirection allows central control of many interpolants.

		// --- Protected interface

		DefaultSettings_: {},

		getSettings_: function () {

			return this.settings || this.DefaultSettings_;

		},

		copySampleValue_: function (index) {

			// copies a sample value to the result buffer

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride;

			for (var i = 0; i !== stride; ++i) {

				result[i] = values[offset + i];

			}

			return result;

		},

		// Template methods for derived classes:

		interpolate_: function (i1, t0, t, t1) {

			throw new Error("call to abstract method");
			// implementations shall return this.resultBuffer

		},

		intervalChanged_: function (i1, t0, t1) {

			// empty

		}

	};

	Object.assign(THREE.Interpolant.prototype, {

		beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
			THREE.Interpolant.prototype.copySampleValue_,

		afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
			THREE.Interpolant.prototype.copySampleValue_

	});

	// File:src/math/interpolants/CubicInterpolant.js

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 *
	 * @author tschw
	 */

	THREE.CubicInterpolant = function (
		parameterPositions, sampleValues, sampleSize, resultBuffer) {

		THREE.Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer);

		this._weightPrev = -0;
		this._offsetPrev = -0;
		this._weightNext = -0;
		this._offsetNext = -0;

	};

	THREE.CubicInterpolant.prototype =
		Object.assign(Object.create(THREE.Interpolant.prototype), {

			constructor: THREE.CubicInterpolant,

			DefaultSettings_: {

				endingStart: THREE.ZeroCurvatureEnding,
				endingEnd: THREE.ZeroCurvatureEnding

			},

			intervalChanged_: function (i1, t0, t1) {

				var pp = this.parameterPositions,
					iPrev = i1 - 2,
					iNext = i1 + 1,

					tPrev = pp[iPrev],
					tNext = pp[iNext];

				if (tPrev === undefined) {

					switch (this.getSettings_().endingStart) {

						case THREE.ZeroSlopeEnding:

							// f'(t0) = 0
							iPrev = i1;
							tPrev = 2 * t0 - t1;

							break;

						case THREE.WrapAroundEnding:

							// use the other end of the curve
							iPrev = pp.length - 2;
							tPrev = t0 + pp[iPrev] - pp[iPrev + 1];

							break;

						default: // ZeroCurvatureEnding

							// f''(t0) = 0 a.k.a. Natural Spline
							iPrev = i1;
							tPrev = t1;

					}

				}

				if (tNext === undefined) {

					switch (this.getSettings_().endingEnd) {

						case THREE.ZeroSlopeEnding:

							// f'(tN) = 0
							iNext = i1;
							tNext = 2 * t1 - t0;

							break;

						case THREE.WrapAroundEnding:

							// use the other end of the curve
							iNext = 1;
							tNext = t1 + pp[1] - pp[0];

							break;

						default: // ZeroCurvatureEnding

							// f''(tN) = 0, a.k.a. Natural Spline
							iNext = i1 - 1;
							tNext = t0;

					}

				}

				var halfDt = (t1 - t0) * 0.5,
					stride = this.valueSize;

				this._weightPrev = halfDt / (t0 - tPrev);
				this._weightNext = halfDt / (tNext - t1);
				this._offsetPrev = iPrev * stride;
				this._offsetNext = iNext * stride;

			},

			interpolate_: function (i1, t0, t, t1) {

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,

					o1 = i1 * stride, o0 = o1 - stride,
					oP = this._offsetPrev, oN = this._offsetNext,
					wP = this._weightPrev, wN = this._weightNext,

					p = (t - t0) / (t1 - t0),
					pp = p * p,
					ppp = pp * p;

				// evaluate polynomials

				var sP = - wP * ppp + 2 * wP * pp - wP * p;
				var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
				var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
				var sN = wN * ppp - wN * pp;

				// combine data linearly

				for (var i = 0; i !== stride; ++i) {

					result[i] =
						sP * values[oP + i] +
						s0 * values[o0 + i] +
						s1 * values[o1 + i] +
						sN * values[oN + i];

				}

				return result;

			}

		});

	// File:src/math/interpolants/DiscreteInterpolant.js

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 *
	 * @author tschw
	 */

	THREE.DiscreteInterpolant = function (
		parameterPositions, sampleValues, sampleSize, resultBuffer) {

		THREE.Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer);

	};

	THREE.DiscreteInterpolant.prototype =
		Object.assign(Object.create(THREE.Interpolant.prototype), {

			constructor: THREE.DiscreteInterpolant,

			interpolate_: function (i1, t0, t, t1) {

				return this.copySampleValue_(i1 - 1);

			}

		});

	// File:src/math/interpolants/LinearInterpolant.js

	/**
	 * @author tschw
	 */

	THREE.LinearInterpolant = function (
		parameterPositions, sampleValues, sampleSize, resultBuffer) {

		THREE.Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer);

	};

	THREE.LinearInterpolant.prototype =
		Object.assign(Object.create(THREE.Interpolant.prototype), {

			constructor: THREE.LinearInterpolant,

			interpolate_: function (i1, t0, t, t1) {

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,

					offset1 = i1 * stride,
					offset0 = offset1 - stride,

					weight1 = (t - t0) / (t1 - t0),
					weight0 = 1 - weight1;

				for (var i = 0; i !== stride; ++i) {

					result[i] =
						values[offset0 + i] * weight0 +
						values[offset1 + i] * weight1;

				}

				return result;

			}

		});

	// File:src/math/interpolants/QuaternionLinearInterpolant.js

	/**
	 * Spherical linear unit quaternion interpolant.
	 *
	 * @author tschw
	 */

	THREE.QuaternionLinearInterpolant = function (
		parameterPositions, sampleValues, sampleSize, resultBuffer) {

		THREE.Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer);

	};

	THREE.QuaternionLinearInterpolant.prototype =
		Object.assign(Object.create(THREE.Interpolant.prototype), {

			constructor: THREE.QuaternionLinearInterpolant,

			interpolate_: function (i1, t0, t, t1) {

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,

					offset = i1 * stride,

					alpha = (t - t0) / (t1 - t0);

				for (var end = offset + stride; offset !== end; offset += 4) {

					THREE.Quaternion.slerpFlat(result, 0,
						values, offset - stride, values, offset, alpha);

				}

				return result;

			}

		});

	// File:src/core/Clock.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Clock = function (autoStart) {

		this.autoStart = (autoStart !== undefined) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	};

	THREE.Clock.prototype = {

		constructor: THREE.Clock,

		start: function () {

			this.startTime = (performance || Date).now();

			this.oldTime = this.startTime;
			this.running = true;

		},

		stop: function () {

			this.getElapsedTime();
			this.running = false;

		},

		getElapsedTime: function () {

			this.getDelta();
			return this.elapsedTime;

		},

		getDelta: function () {

			var diff = 0;

			if (this.autoStart && !this.running) {

				this.start();

			}

			if (this.running) {

				var newTime = (performance || Date).now();

				diff = (newTime - this.oldTime) / 1000;
				this.oldTime = newTime;

				this.elapsedTime += diff;

			}

			return diff;

		}

	};

	// File:src/core/EventDispatcher.js

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	THREE.EventDispatcher = function () { };

	Object.assign(THREE.EventDispatcher.prototype, {

		addEventListener: function (type, listener) {

			if (this._listeners === undefined) this._listeners = {};

			var listeners = this._listeners;

			if (listeners[type] === undefined) {

				listeners[type] = [];

			}

			if (listeners[type].indexOf(listener) === - 1) {

				listeners[type].push(listener);

			}

		},

		hasEventListener: function (type, listener) {

			if (this._listeners === undefined) return false;

			var listeners = this._listeners;

			if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== - 1) {

				return true;

			}

			return false;

		},

		removeEventListener: function (type, listener) {

			if (this._listeners === undefined) return;

			var listeners = this._listeners;
			var listenerArray = listeners[type];

			if (listenerArray !== undefined) {

				var index = listenerArray.indexOf(listener);

				if (index !== - 1) {

					listenerArray.splice(index, 1);

				}

			}

		},

		dispatchEvent: function (event) {

			if (this._listeners === undefined) return;

			var listeners = this._listeners;
			var listenerArray = listeners[event.type];

			if (listenerArray !== undefined) {

				event.target = this;

				var array = [], i = 0;
				var length = listenerArray.length;

				for (i = 0; i < length; i++) {

					array[i] = listenerArray[i];

				}

				for (i = 0; i < length; i++) {

					array[i].call(this, event);

				}

			}

		}

	});

	// File:src/core/Layers.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Layers = function () {

		this.mask = 1;

	};

	THREE.Layers.prototype = {

		constructor: THREE.Layers,

		set: function (channel) {

			this.mask = 1 << channel;

		},

		enable: function (channel) {

			this.mask |= 1 << channel;

		},

		toggle: function (channel) {

			this.mask ^= 1 << channel;

		},

		disable: function (channel) {

			this.mask &= ~(1 << channel);

		},

		test: function (layers) {

			return (this.mask & layers.mask) !== 0;

		}

	};

	// File:src/core/Raycaster.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io/
	 * @author stephomi / http://stephaneginier.com/
	 */

	(function (THREE) {

		THREE.Raycaster = function (origin, direction, near, far) {

			this.ray = new THREE.Ray(origin, direction);
			// direction is assumed to be normalized (for accurate distance calculations)

			this.near = near || 0;
			this.far = far || Infinity;

			this.params = {
				Mesh: {},
				Line: {},
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};

			Object.defineProperties(this.params, {
				PointCloud: {
					get: function () {
						//console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
						return this.Points;
					}
				}
			});

		};

		function ascSort(a, b) {

			return a.distance - b.distance;

		}

		function intersectObject(object, raycaster, intersects, recursive) {

			if (object.visible === false) return;

			object.raycast(raycaster, intersects);

			if (recursive === true) {

				var children = object.children;

				for (var i = 0, l = children.length; i < l; i++) {

					intersectObject(children[i], raycaster, intersects, true);

				}

			}

		}

		//

		THREE.Raycaster.prototype = {

			constructor: THREE.Raycaster,

			linePrecision: 1,

			set: function (origin, direction) {

				// direction is assumed to be normalized (for accurate distance calculations)

				this.ray.set(origin, direction);

			},

			setFromCamera: function (coords, camera) {

				if (camera instanceof THREE.PerspectiveCamera) {

					this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
					this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();

				} else if (camera instanceof THREE.OrthographicCamera) {

					this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
					this.ray.direction.set(0, 0, - 1).transformDirection(camera.matrixWorld);

				} else {

					//console.error( 'THREE.Raycaster: Unsupported camera type.' );

				}

			},

			intersectObject: function (object, recursive) {

				var intersects = [];

				intersectObject(object, this, intersects, recursive);

				intersects.sort(ascSort);

				return intersects;

			},

			intersectObjects: function (objects, recursive) {

				var intersects = [];

				if (Array.isArray(objects) === false) {

					//console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;

				}

				for (var i = 0, l = objects.length; i < l; i++) {

					intersectObject(objects[i], this, intersects, recursive);

				}

				intersects.sort(ascSort);

				return intersects;

			}

		};

	}(THREE));

	// File:src/core/Object3D.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */

	THREE.Object3D = function () {

		Object.defineProperty(this, 'id', { value: THREE.Object3DIdCount++ });

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = THREE.Object3D.DefaultUp.clone();

		var position = new THREE.Vector3();
		var rotation = new THREE.Euler();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3(1, 1, 1);

		function onRotationChange() {

			quaternion.setFromEuler(rotation, false);

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion(quaternion, undefined, false);

		}

		rotation.onChange(onRotationChange);
		quaternion.onChange(onQuaternionChange);

		Object.defineProperties(this, {
			position: {
				enumerable: true,
				value: position
			},
			rotation: {
				enumerable: true,
				value: rotation
			},
			quaternion: {
				enumerable: true,
				value: quaternion
			},
			scale: {
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new THREE.Matrix4()
			},
			normalMatrix: {
				value: new THREE.Matrix3()
			}
		});

		this.matrix = new THREE.Matrix4();
		this.matrixWorld = new THREE.Matrix4();

		this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.layers = new THREE.Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.userData = {};

	};

	THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0);
	THREE.Object3D.DefaultMatrixAutoUpdate = true;

	Object.assign(THREE.Object3D.prototype, THREE.EventDispatcher.prototype, {

		applyMatrix: function (matrix) {

			this.matrix.multiplyMatrices(matrix, this.matrix);

			this.matrix.decompose(this.position, this.quaternion, this.scale);

		},

		setRotationFromAxisAngle: function (axis, angle) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle(axis, angle);

		},

		setRotationFromEuler: function (euler) {

			this.quaternion.setFromEuler(euler, true);

		},

		setRotationFromMatrix: function (m) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix(m);

		},

		setRotationFromQuaternion: function (q) {

			// assumes q is normalized

			this.quaternion.copy(q);

		},

		rotateOnAxis: function () {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			var q1 = new THREE.Quaternion();

			return function rotateOnAxis(axis, angle) {

				q1.setFromAxisAngle(axis, angle);

				this.quaternion.multiply(q1);

				return this;

			};

		}(),

		rotateX: function () {

			var v1 = new THREE.Vector3(1, 0, 0);

			return function rotateX(angle) {

				return this.rotateOnAxis(v1, angle);

			};

		}(),

		rotateY: function () {

			var v1 = new THREE.Vector3(0, 1, 0);

			return function rotateY(angle) {

				return this.rotateOnAxis(v1, angle);

			};

		}(),

		rotateZ: function () {

			var v1 = new THREE.Vector3(0, 0, 1);

			return function rotateZ(angle) {

				return this.rotateOnAxis(v1, angle);

			};

		}(),

		translateOnAxis: function () {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			var v1 = new THREE.Vector3();

			return function translateOnAxis(axis, distance) {

				v1.copy(axis).applyQuaternion(this.quaternion);

				this.position.add(v1.multiplyScalar(distance));

				return this;

			};

		}(),

		translateX: function () {

			var v1 = new THREE.Vector3(1, 0, 0);

			return function translateX(distance) {

				return this.translateOnAxis(v1, distance);

			};

		}(),

		translateY: function () {

			var v1 = new THREE.Vector3(0, 1, 0);

			return function translateY(distance) {

				return this.translateOnAxis(v1, distance);

			};

		}(),

		translateZ: function () {

			var v1 = new THREE.Vector3(0, 0, 1);

			return function translateZ(distance) {

				return this.translateOnAxis(v1, distance);

			};

		}(),

		localToWorld: function (vector) {

			return vector.applyMatrix4(this.matrixWorld);

		},

		worldToLocal: function () {

			var m1 = new THREE.Matrix4();

			return function worldToLocal(vector) {

				return vector.applyMatrix4(m1.getInverse(this.matrixWorld));

			};

		}(),

		lookAt: function () {

			// This routine does not support objects with rotated and/or translated parent(s)

			var m1 = new THREE.Matrix4();

			return function lookAt(vector) {

				m1.lookAt(vector, this.position, this.up);

				this.quaternion.setFromRotationMatrix(m1);

			};

		}(),

		add: function (object) {

			if (arguments.length > 1) {

				for (var i = 0; i < arguments.length; i++) {

					this.add(arguments[i]);

				}

				return this;

			}

			if (object === this) {

				//console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;

			}

			if (object instanceof THREE.Object3D) {

				if (object.parent !== null) {

					object.parent.remove(object);

				}

				object.parent = this;
				object.dispatchEvent({ type: 'added' });

				this.children.push(object);

			} else {

				//console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

			}

			return this;

		},

		remove: function (object) {

			if (arguments.length > 1) {

				for (var i = 0; i < arguments.length; i++) {

					this.remove(arguments[i]);

				}

			}

			var index = this.children.indexOf(object);

			if (index !== - 1) {

				object.parent = null;

				object.dispatchEvent({ type: 'removed' });

				this.children.splice(index, 1);

			}

		},

		getObjectById: function (id) {

			return this.getObjectByProperty('id', id);

		},

		getObjectByName: function (name) {

			return this.getObjectByProperty('name', name);

		},

		getObjectByProperty: function (name, value) {

			if (this[name] === value) return this;

			for (var i = 0, l = this.children.length; i < l; i++) {

				var child = this.children[i];
				var object = child.getObjectByProperty(name, value);

				if (object !== undefined) {

					return object;

				}

			}

			return undefined;

		},

		getWorldPosition: function (optionalTarget) {

			var result = optionalTarget || new THREE.Vector3();

			this.updateMatrixWorld(true);

			return result.setFromMatrixPosition(this.matrixWorld);

		},

		getWorldQuaternion: function () {

			var position = new THREE.Vector3();
			var scale = new THREE.Vector3();

			return function getWorldQuaternion(optionalTarget) {

				var result = optionalTarget || new THREE.Quaternion();

				this.updateMatrixWorld(true);

				this.matrixWorld.decompose(position, result, scale);

				return result;

			};

		}(),

		getWorldRotation: function () {

			var quaternion = new THREE.Quaternion();

			return function getWorldRotation(optionalTarget) {

				var result = optionalTarget || new THREE.Euler();

				this.getWorldQuaternion(quaternion);

				return result.setFromQuaternion(quaternion, this.rotation.order, false);

			};

		}(),

		getWorldScale: function () {

			var position = new THREE.Vector3();
			var quaternion = new THREE.Quaternion();

			return function getWorldScale(optionalTarget) {

				var result = optionalTarget || new THREE.Vector3();

				this.updateMatrixWorld(true);

				this.matrixWorld.decompose(position, quaternion, result);

				return result;

			};

		}(),

		getWorldDirection: function () {

			var quaternion = new THREE.Quaternion();

			return function getWorldDirection(optionalTarget) {

				var result = optionalTarget || new THREE.Vector3();

				this.getWorldQuaternion(quaternion);

				return result.set(0, 0, 1).applyQuaternion(quaternion);

			};

		}(),

		raycast: function () { },

		traverse: function (callback) {

			callback(this);

			var children = this.children;

			for (var i = 0, l = children.length; i < l; i++) {

				children[i].traverse(callback);

			}

		},

		traverseVisible: function (callback) {

			if (this.visible === false) return;

			callback(this);

			var children = this.children;

			for (var i = 0, l = children.length; i < l; i++) {

				children[i].traverseVisible(callback);

			}

		},

		traverseAncestors: function (callback) {

			var parent = this.parent;

			if (parent !== null) {

				callback(parent);

				parent.traverseAncestors(callback);

			}

		},

		updateMatrix: function () {

			this.matrix.compose(this.position, this.quaternion, this.scale);

			this.matrixWorldNeedsUpdate = true;

		},

		updateMatrixWorld: function (force) {

			if (this.matrixAutoUpdate === true) this.updateMatrix();

			if (this.matrixWorldNeedsUpdate === true || force === true) {

				if (this.parent === null) {

					this.matrixWorld.copy(this.matrix);

				} else {

					this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			for (var i = 0, l = this.children.length; i < l; i++) {

				this.children[i].updateMatrixWorld(force);

			}

		},

		toJSON: function (meta) {

			// meta is '' when called from JSON.stringify
			var isRootObject = (meta === undefined || meta === '');

			var output = {};

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if (isRootObject) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {}
				};

				output.metadata = {
					version: 4.4,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			var object = {};

			object.uuid = this.uuid;
			object.type = this.type;

			if (this.name !== '') object.name = this.name;
			if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
			if (this.castShadow === true) object.castShadow = true;
			if (this.receiveShadow === true) object.receiveShadow = true;
			if (this.visible === false) object.visible = false;

			object.matrix = this.matrix.toArray();

			//

			if (this.geometry !== undefined) {

				if (meta.geometries[this.geometry.uuid] === undefined) {

					meta.geometries[this.geometry.uuid] = this.geometry.toJSON(meta);

				}

				object.geometry = this.geometry.uuid;

			}

			if (this.material !== undefined) {

				if (meta.materials[this.material.uuid] === undefined) {

					meta.materials[this.material.uuid] = this.material.toJSON(meta);

				}

				object.material = this.material.uuid;

			}

			//

			if (this.children.length > 0) {

				object.children = [];

				for (var i = 0; i < this.children.length; i++) {

					object.children.push(this.children[i].toJSON(meta).object);

				}

			}

			if (isRootObject) {

				var geometries = extractFromCache(meta.geometries);
				var materials = extractFromCache(meta.materials);
				var textures = extractFromCache(meta.textures);
				var images = extractFromCache(meta.images);

				if (geometries.length > 0) output.geometries = geometries;
				if (materials.length > 0) output.materials = materials;
				if (textures.length > 0) output.textures = textures;
				if (images.length > 0) output.images = images;

			}

			output.object = object;

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache(cache) {

				var values = [];
				for (var key in cache) {

					var data = cache[key];
					delete data.metadata;
					values.push(data);

				}
				return values;

			}

		},

		clone: function (recursive) {

			return new this.constructor().copy(this, recursive);

		},

		copy: function (source, recursive) {

			if (recursive === undefined) recursive = true;

			this.name = source.name;

			this.up.copy(source.up);

			this.position.copy(source.position);
			this.quaternion.copy(source.quaternion);
			this.scale.copy(source.scale);

			this.matrix.copy(source.matrix);
			this.matrixWorld.copy(source.matrixWorld);

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.userData = JSON.parse(JSON.stringify(source.userData));

			if (recursive === true) {

				for (var i = 0; i < source.children.length; i++) {

					var child = source.children[i];
					this.add(child.clone());

				}

			}

			return this;

		}

	});

	THREE.Object3DIdCount = 0;

	// File:src/core/Face3.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Face3 = function (a, b, c, normal, color, materialIndex) {

		this.a = a;
		this.b = b;
		this.c = c;

		this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
		this.vertexNormals = Array.isArray(normal) ? normal : [];

		this.color = color instanceof THREE.Color ? color : new THREE.Color();
		this.vertexColors = Array.isArray(color) ? color : [];

		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	};

	THREE.Face3.prototype = {

		constructor: THREE.Face3,

		clone: function () {

			return new this.constructor().copy(this);

		},

		copy: function (source) {

			this.a = source.a;
			this.b = source.b;
			this.c = source.c;

			this.normal.copy(source.normal);
			this.color.copy(source.color);

			this.materialIndex = source.materialIndex;

			for (var i = 0, il = source.vertexNormals.length; i < il; i++) {

				this.vertexNormals[i] = source.vertexNormals[i].clone();

			}

			for (var i = 0, il = source.vertexColors.length; i < il; i++) {

				this.vertexColors[i] = source.vertexColors[i].clone();

			}

			return this;

		}

	};

	// File:src/core/BufferAttribute.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferAttribute = function (array, itemSize, normalized) {

		this.uuid = THREE.Math.generateUUID();

		this.array = array;
		this.itemSize = itemSize;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;
		this.normalized = normalized === true;

	};

	THREE.BufferAttribute.prototype = {

		constructor: THREE.BufferAttribute,

		get count() {

			return this.array.length / this.itemSize;

		},

		set needsUpdate(value) {

			if (value === true) this.version++;

		},

		setDynamic: function (value) {

			this.dynamic = value;

			return this;

		},

		copy: function (source) {

			this.array = new source.array.constructor(source.array);
			this.itemSize = source.itemSize;

			this.dynamic = source.dynamic;

			return this;

		},

		copyAt: function (index1, attribute, index2) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for (var i = 0, l = this.itemSize; i < l; i++) {

				this.array[index1 + i] = attribute.array[index2 + i];

			}

			return this;

		},

		copyArray: function (array) {

			this.array.set(array);

			return this;

		},

		copyColorsArray: function (colors) {

			var array = this.array, offset = 0;

			for (var i = 0, l = colors.length; i < l; i++) {

				var color = colors[i];

				if (color === undefined) {

					//console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new THREE.Color();

				}

				array[offset++] = color.r;
				array[offset++] = color.g;
				array[offset++] = color.b;

			}

			return this;

		},

		copyIndicesArray: function (indices) {

			var array = this.array, offset = 0;

			for (var i = 0, l = indices.length; i < l; i++) {

				var index = indices[i];

				array[offset++] = index.a;
				array[offset++] = index.b;
				array[offset++] = index.c;

			}

			return this;

		},

		copyVector2sArray: function (vectors) {

			var array = this.array, offset = 0;

			for (var i = 0, l = vectors.length; i < l; i++) {

				var vector = vectors[i];

				if (vector === undefined) {

					//console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new THREE.Vector2();

				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;

			}

			return this;

		},

		copyVector3sArray: function (vectors) {

			var array = this.array, offset = 0;

			for (var i = 0, l = vectors.length; i < l; i++) {

				var vector = vectors[i];

				if (vector === undefined) {

					//console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new THREE.Vector3();

				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
				array[offset++] = vector.z;

			}

			return this;

		},

		copyVector4sArray: function (vectors) {

			var array = this.array, offset = 0;

			for (var i = 0, l = vectors.length; i < l; i++) {

				var vector = vectors[i];

				if (vector === undefined) {

					//console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new THREE.Vector4();

				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
				array[offset++] = vector.z;
				array[offset++] = vector.w;

			}

			return this;

		},

		set: function (value, offset) {

			if (offset === undefined) offset = 0;

			this.array.set(value, offset);

			return this;

		},

		getX: function (index) {

			return this.array[index * this.itemSize];

		},

		setX: function (index, x) {

			this.array[index * this.itemSize] = x;

			return this;

		},

		getY: function (index) {

			return this.array[index * this.itemSize + 1];

		},

		setY: function (index, y) {

			this.array[index * this.itemSize + 1] = y;

			return this;

		},

		getZ: function (index) {

			return this.array[index * this.itemSize + 2];

		},

		setZ: function (index, z) {

			this.array[index * this.itemSize + 2] = z;

			return this;

		},

		getW: function (index) {

			return this.array[index * this.itemSize + 3];

		},

		setW: function (index, w) {

			this.array[index * this.itemSize + 3] = w;

			return this;

		},

		setXY: function (index, x, y) {

			index *= this.itemSize;

			this.array[index + 0] = x;
			this.array[index + 1] = y;

			return this;

		},

		setXYZ: function (index, x, y, z) {

			index *= this.itemSize;

			this.array[index + 0] = x;
			this.array[index + 1] = y;
			this.array[index + 2] = z;

			return this;

		},

		setXYZW: function (index, x, y, z, w) {

			index *= this.itemSize;

			this.array[index + 0] = x;
			this.array[index + 1] = y;
			this.array[index + 2] = z;
			this.array[index + 3] = w;

			return this;

		},

		clone: function () {

			return new this.constructor().copy(this);

		}

	};

	//

	THREE.Int8Attribute = function (array, itemSize) {

		return new THREE.BufferAttribute(new Int8Array(array), itemSize);

	};

	THREE.Uint8Attribute = function (array, itemSize) {

		return new THREE.BufferAttribute(new Uint8Array(array), itemSize);

	};

	THREE.Uint8ClampedAttribute = function (array, itemSize) {

		return new THREE.BufferAttribute(new Uint8ClampedArray(array), itemSize);

	};

	THREE.Int16Attribute = function (array, itemSize) {

		return new THREE.BufferAttribute(new Int16Array(array), itemSize);

	};

	THREE.Uint16Attribute = function (array, itemSize) {

		return new THREE.BufferAttribute(new Uint16Array(array), itemSize);

	};

	THREE.Int32Attribute = function (array, itemSize) {

		return new THREE.BufferAttribute(new Int32Array(array), itemSize);

	};

	THREE.Uint32Attribute = function (array, itemSize) {

		return new THREE.BufferAttribute(new Uint32Array(array), itemSize);

	};

	THREE.Float32Attribute = function (array, itemSize) {

		return new THREE.BufferAttribute(new Float32Array(array), itemSize);

	};

	THREE.Float64Attribute = function (array, itemSize) {

		return new THREE.BufferAttribute(new Float64Array(array), itemSize);

	};


	// Deprecated

	THREE.DynamicBufferAttribute = function (array, itemSize) {

		//console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
		return new THREE.BufferAttribute(array, itemSize).setDynamic(true);

	};

	// File:src/core/InstancedBufferAttribute.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InstancedBufferAttribute = function (array, itemSize, meshPerAttribute) {

		THREE.BufferAttribute.call(this, array, itemSize);

		this.meshPerAttribute = meshPerAttribute || 1;

	};

	THREE.InstancedBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype);
	THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;

	THREE.InstancedBufferAttribute.prototype.copy = function (source) {

		THREE.BufferAttribute.prototype.copy.call(this, source);

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	};

	// File:src/core/InterleavedBuffer.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InterleavedBuffer = function (array, stride) {

		this.uuid = THREE.Math.generateUUID();

		this.array = array;
		this.stride = stride;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	};

	THREE.InterleavedBuffer.prototype = {

		constructor: THREE.InterleavedBuffer,

		get length() {

			return this.array.length;

		},

		get count() {

			return this.array.length / this.stride;

		},

		set needsUpdate(value) {

			if (value === true) this.version++;

		},

		setDynamic: function (value) {

			this.dynamic = value;

			return this;

		},

		copy: function (source) {

			this.array = new source.array.constructor(source.array);
			this.stride = source.stride;
			this.dynamic = source.dynamic;

			return this;

		},

		copyAt: function (index1, attribute, index2) {

			index1 *= this.stride;
			index2 *= attribute.stride;

			for (var i = 0, l = this.stride; i < l; i++) {

				this.array[index1 + i] = attribute.array[index2 + i];

			}

			return this;

		},

		set: function (value, offset) {

			if (offset === undefined) offset = 0;

			this.array.set(value, offset);

			return this;

		},

		clone: function () {

			return new this.constructor().copy(this);

		}

	};

	// File:src/core/InstancedInterleavedBuffer.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InstancedInterleavedBuffer = function (array, stride, meshPerAttribute) {

		THREE.InterleavedBuffer.call(this, array, stride);

		this.meshPerAttribute = meshPerAttribute || 1;

	};

	THREE.InstancedInterleavedBuffer.prototype = Object.create(THREE.InterleavedBuffer.prototype);
	THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;

	THREE.InstancedInterleavedBuffer.prototype.copy = function (source) {

		THREE.InterleavedBuffer.prototype.copy.call(this, source);

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	};

	// File:src/core/InterleavedBufferAttribute.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InterleavedBufferAttribute = function (interleavedBuffer, itemSize, offset) {

		this.uuid = THREE.Math.generateUUID();

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

	};


	THREE.InterleavedBufferAttribute.prototype = {

		constructor: THREE.InterleavedBufferAttribute,

		get length() {

			//console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
			return this.array.length;

		},

		get count() {

			return this.data.count;

		},

		setX: function (index, x) {

			this.data.array[index * this.data.stride + this.offset] = x;

			return this;

		},

		setY: function (index, y) {

			this.data.array[index * this.data.stride + this.offset + 1] = y;

			return this;

		},

		setZ: function (index, z) {

			this.data.array[index * this.data.stride + this.offset + 2] = z;

			return this;

		},

		setW: function (index, w) {

			this.data.array[index * this.data.stride + this.offset + 3] = w;

			return this;

		},

		getX: function (index) {

			return this.data.array[index * this.data.stride + this.offset];

		},

		getY: function (index) {

			return this.data.array[index * this.data.stride + this.offset + 1];

		},

		getZ: function (index) {

			return this.data.array[index * this.data.stride + this.offset + 2];

		},

		getW: function (index) {

			return this.data.array[index * this.data.stride + this.offset + 3];

		},

		setXY: function (index, x, y) {

			index = index * this.data.stride + this.offset;

			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;

			return this;

		},

		setXYZ: function (index, x, y, z) {

			index = index * this.data.stride + this.offset;

			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			this.data.array[index + 2] = z;

			return this;

		},

		setXYZW: function (index, x, y, z, w) {

			index = index * this.data.stride + this.offset;

			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			this.data.array[index + 2] = z;
			this.data.array[index + 3] = w;

			return this;

		}

	};

	// File:src/core/Geometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://clara.io
	 */

	THREE.Geometry = function () {

		Object.defineProperty(this, 'id', { value: THREE.GeometryIdCount++ });

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Geometry';

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];

		this.morphTargets = [];
		this.morphNormals = [];

		this.skinWeights = [];
		this.skinIndices = [];

		this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.verticesNeedUpdate = false;
		this.elementsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;

	};

	Object.assign(THREE.Geometry.prototype, THREE.EventDispatcher.prototype, {

		applyMatrix: function (matrix) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);

			for (var i = 0, il = this.vertices.length; i < il; i++) {

				var vertex = this.vertices[i];
				vertex.applyMatrix4(matrix);

			}

			for (var i = 0, il = this.faces.length; i < il; i++) {

				var face = this.faces[i];
				face.normal.applyMatrix3(normalMatrix).normalize();

				for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {

					face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();

				}

			}

			if (this.boundingBox !== null) {

				this.computeBoundingBox();

			}

			if (this.boundingSphere !== null) {

				this.computeBoundingSphere();

			}

			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;

			return this;

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1;

			return function rotateX(angle) {

				if (m1 === undefined) m1 = new THREE.Matrix4();

				m1.makeRotationX(angle);

				this.applyMatrix(m1);

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1;

			return function rotateY(angle) {

				if (m1 === undefined) m1 = new THREE.Matrix4();

				m1.makeRotationY(angle);

				this.applyMatrix(m1);

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1;

			return function rotateZ(angle) {

				if (m1 === undefined) m1 = new THREE.Matrix4();

				m1.makeRotationZ(angle);

				this.applyMatrix(m1);

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1;

			return function translate(x, y, z) {

				if (m1 === undefined) m1 = new THREE.Matrix4();

				m1.makeTranslation(x, y, z);

				this.applyMatrix(m1);

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1;

			return function scale(x, y, z) {

				if (m1 === undefined) m1 = new THREE.Matrix4();

				m1.makeScale(x, y, z);

				this.applyMatrix(m1);

				return this;

			};

		}(),

		lookAt: function () {

			var obj;

			return function lookAt(vector) {

				if (obj === undefined) obj = new THREE.Object3D();

				obj.lookAt(vector);

				obj.updateMatrix();

				this.applyMatrix(obj.matrix);

			};

		}(),

		fromBufferGeometry: function (geometry) {

			var scope = this;

			var indices = geometry.index !== null ? geometry.index.array : undefined;
			var attributes = geometry.attributes;

			var positions = attributes.position.array;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
			var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

			if (uvs2 !== undefined) this.faceVertexUvs[1] = [];

			var tempNormals = [];
			var tempUVs = [];
			var tempUVs2 = [];

			for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {

				scope.vertices.push(new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]));

				if (normals !== undefined) {

					tempNormals.push(new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]));

				}

				if (colors !== undefined) {

					scope.colors.push(new THREE.Color(colors[i], colors[i + 1], colors[i + 2]));

				}

				if (uvs !== undefined) {

					tempUVs.push(new THREE.Vector2(uvs[j], uvs[j + 1]));

				}

				if (uvs2 !== undefined) {

					tempUVs2.push(new THREE.Vector2(uvs2[j], uvs2[j + 1]));

				}

			}

			function addFace(a, b, c, materialIndex) {

				var vertexNormals = normals !== undefined ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];
				var vertexColors = colors !== undefined ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];

				var face = new THREE.Face3(a, b, c, vertexNormals, vertexColors, materialIndex);

				scope.faces.push(face);

				if (uvs !== undefined) {

					scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]);

				}

				if (uvs2 !== undefined) {

					scope.faceVertexUvs[1].push([tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone()]);

				}

			}

			if (indices !== undefined) {

				var groups = geometry.groups;

				if (groups.length > 0) {

					for (var i = 0; i < groups.length; i++) {

						var group = groups[i];

						var start = group.start;
						var count = group.count;

						for (var j = start, jl = start + count; j < jl; j += 3) {

							addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);

						}

					}

				} else {

					for (var i = 0; i < indices.length; i += 3) {

						addFace(indices[i], indices[i + 1], indices[i + 2]);

					}

				}

			} else {

				for (var i = 0; i < positions.length / 3; i += 3) {

					addFace(i, i + 1, i + 2);

				}

			}

			this.computeFaceNormals();

			if (geometry.boundingBox !== null) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			if (geometry.boundingSphere !== null) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			return this;

		},

		center: function () {

			this.computeBoundingBox();

			var offset = this.boundingBox.center().negate();

			this.translate(offset.x, offset.y, offset.z);

			return offset;

		},

		normalize: function () {

			this.computeBoundingSphere();

			var center = this.boundingSphere.center;
			var radius = this.boundingSphere.radius;

			var s = radius === 0 ? 1 : 1.0 / radius;

			var matrix = new THREE.Matrix4();
			matrix.set(
				s, 0, 0, - s * center.x,
				0, s, 0, - s * center.y,
				0, 0, s, - s * center.z,
				0, 0, 0, 1
			);

			this.applyMatrix(matrix);

			return this;

		},

		computeFaceNormals: function () {

			var cb = new THREE.Vector3(), ab = new THREE.Vector3();

			for (var f = 0, fl = this.faces.length; f < fl; f++) {

				var face = this.faces[f];

				var vA = this.vertices[face.a];
				var vB = this.vertices[face.b];
				var vC = this.vertices[face.c];

				cb.subVectors(vC, vB);
				ab.subVectors(vA, vB);
				cb.cross(ab);

				cb.normalize();

				face.normal.copy(cb);

			}

		},

		computeVertexNormals: function (areaWeighted) {

			if (areaWeighted === undefined) areaWeighted = true;

			var v, vl, f, fl, face, vertices;

			vertices = new Array(this.vertices.length);

			for (v = 0, vl = this.vertices.length; v < vl; v++) {

				vertices[v] = new THREE.Vector3();

			}

			if (areaWeighted) {

				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm

				var vA, vB, vC;
				var cb = new THREE.Vector3(), ab = new THREE.Vector3();

				for (f = 0, fl = this.faces.length; f < fl; f++) {

					face = this.faces[f];

					vA = this.vertices[face.a];
					vB = this.vertices[face.b];
					vC = this.vertices[face.c];

					cb.subVectors(vC, vB);
					ab.subVectors(vA, vB);
					cb.cross(ab);

					vertices[face.a].add(cb);
					vertices[face.b].add(cb);
					vertices[face.c].add(cb);

				}

			} else {

				for (f = 0, fl = this.faces.length; f < fl; f++) {

					face = this.faces[f];

					vertices[face.a].add(face.normal);
					vertices[face.b].add(face.normal);
					vertices[face.c].add(face.normal);

				}

			}

			for (v = 0, vl = this.vertices.length; v < vl; v++) {

				vertices[v].normalize();

			}

			for (f = 0, fl = this.faces.length; f < fl; f++) {

				face = this.faces[f];

				var vertexNormals = face.vertexNormals;

				if (vertexNormals.length === 3) {

					vertexNormals[0].copy(vertices[face.a]);
					vertexNormals[1].copy(vertices[face.b]);
					vertexNormals[2].copy(vertices[face.c]);

				} else {

					vertexNormals[0] = vertices[face.a].clone();
					vertexNormals[1] = vertices[face.b].clone();
					vertexNormals[2] = vertices[face.c].clone();

				}

			}

			if (this.faces.length > 0) {

				this.normalsNeedUpdate = true;

			}

		},

		computeMorphNormals: function () {

			var i, il, f, fl, face;

			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)

			for (f = 0, fl = this.faces.length; f < fl; f++) {

				face = this.faces[f];

				if (!face.__originalFaceNormal) {

					face.__originalFaceNormal = face.normal.clone();

				} else {

					face.__originalFaceNormal.copy(face.normal);

				}

				if (!face.__originalVertexNormals) face.__originalVertexNormals = [];

				for (i = 0, il = face.vertexNormals.length; i < il; i++) {

					if (!face.__originalVertexNormals[i]) {

						face.__originalVertexNormals[i] = face.vertexNormals[i].clone();

					} else {

						face.__originalVertexNormals[i].copy(face.vertexNormals[i]);

					}

				}

			}

			// use temp geometry to compute face and vertex normals for each morph

			var tmpGeo = new THREE.Geometry();
			tmpGeo.faces = this.faces;

			for (i = 0, il = this.morphTargets.length; i < il; i++) {

				// create on first access

				if (!this.morphNormals[i]) {

					this.morphNormals[i] = {};
					this.morphNormals[i].faceNormals = [];
					this.morphNormals[i].vertexNormals = [];

					var dstNormalsFace = this.morphNormals[i].faceNormals;
					var dstNormalsVertex = this.morphNormals[i].vertexNormals;

					var faceNormal, vertexNormals;

					for (f = 0, fl = this.faces.length; f < fl; f++) {

						faceNormal = new THREE.Vector3();
						vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

						dstNormalsFace.push(faceNormal);
						dstNormalsVertex.push(vertexNormals);

					}

				}

				var morphNormals = this.morphNormals[i];

				// set vertices to morph target

				tmpGeo.vertices = this.morphTargets[i].vertices;

				// compute morph normals

				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();

				// store morph normals

				var faceNormal, vertexNormals;

				for (f = 0, fl = this.faces.length; f < fl; f++) {

					face = this.faces[f];

					faceNormal = morphNormals.faceNormals[f];
					vertexNormals = morphNormals.vertexNormals[f];

					faceNormal.copy(face.normal);

					vertexNormals.a.copy(face.vertexNormals[0]);
					vertexNormals.b.copy(face.vertexNormals[1]);
					vertexNormals.c.copy(face.vertexNormals[2]);

				}

			}

			// restore original normals

			for (f = 0, fl = this.faces.length; f < fl; f++) {

				face = this.faces[f];

				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;

			}

		},

		computeTangents: function () {

			//console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

		},

		computeLineDistances: function () {

			var d = 0;
			var vertices = this.vertices;

			for (var i = 0, il = vertices.length; i < il; i++) {

				if (i > 0) {

					d += vertices[i].distanceTo(vertices[i - 1]);

				}

				this.lineDistances[i] = d;

			}

		},

		computeBoundingBox: function () {

			if (this.boundingBox === null) {

				this.boundingBox = new THREE.Box3();

			}

			this.boundingBox.setFromPoints(this.vertices);

		},

		computeBoundingSphere: function () {

			if (this.boundingSphere === null) {

				this.boundingSphere = new THREE.Sphere();

			}

			this.boundingSphere.setFromPoints(this.vertices);

		},

		merge: function (geometry, matrix, materialIndexOffset) {

			if (geometry instanceof THREE.Geometry === false) {

				//console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;

			}

			var normalMatrix,
				vertexOffset = this.vertices.length,
				vertices1 = this.vertices,
				vertices2 = geometry.vertices,
				faces1 = this.faces,
				faces2 = geometry.faces,
				uvs1 = this.faceVertexUvs[0],
				uvs2 = geometry.faceVertexUvs[0];

			if (materialIndexOffset === undefined) materialIndexOffset = 0;

			if (matrix !== undefined) {

				normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);

			}

			// vertices

			for (var i = 0, il = vertices2.length; i < il; i++) {

				var vertex = vertices2[i];

				var vertexCopy = vertex.clone();

				if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);

				vertices1.push(vertexCopy);

			}

			// faces

			for (i = 0, il = faces2.length; i < il; i++) {

				var face = faces2[i], faceCopy, normal, color,
					faceVertexNormals = face.vertexNormals,
					faceVertexColors = face.vertexColors;

				faceCopy = new THREE.Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
				faceCopy.normal.copy(face.normal);

				if (normalMatrix !== undefined) {

					faceCopy.normal.applyMatrix3(normalMatrix).normalize();

				}

				for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {

					normal = faceVertexNormals[j].clone();

					if (normalMatrix !== undefined) {

						normal.applyMatrix3(normalMatrix).normalize();

					}

					faceCopy.vertexNormals.push(normal);

				}

				faceCopy.color.copy(face.color);

				for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {

					color = faceVertexColors[j];
					faceCopy.vertexColors.push(color.clone());

				}

				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

				faces1.push(faceCopy);

			}

			// uvs

			for (i = 0, il = uvs2.length; i < il; i++) {

				var uv = uvs2[i], uvCopy = [];

				if (uv === undefined) {

					continue;

				}

				for (var j = 0, jl = uv.length; j < jl; j++) {

					uvCopy.push(uv[j].clone());

				}

				uvs1.push(uvCopy);

			}

		},

		mergeMesh: function (mesh) {

			if (mesh instanceof THREE.Mesh === false) {

				//console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;

			}

			mesh.matrixAutoUpdate && mesh.updateMatrix();

			this.merge(mesh.geometry, mesh.matrix);

		},

		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */

		mergeVertices: function () {

			var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
			var unique = [], changes = [];

			var v, key;
			var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
			var precision = Math.pow(10, precisionPoints);
			var i, il, face;
			var indices, j, jl;

			for (i = 0, il = this.vertices.length; i < il; i++) {

				v = this.vertices[i];
				key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);

				if (verticesMap[key] === undefined) {

					verticesMap[key] = i;
					unique.push(this.vertices[i]);
					changes[i] = unique.length - 1;

				} else {

					////console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[i] = changes[verticesMap[key]];

				}

			}


			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];

			for (i = 0, il = this.faces.length; i < il; i++) {

				face = this.faces[i];

				face.a = changes[face.a];
				face.b = changes[face.b];
				face.c = changes[face.c];

				indices = [face.a, face.b, face.c];

				var dupIndex = - 1;

				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for (var n = 0; n < 3; n++) {

					if (indices[n] === indices[(n + 1) % 3]) {

						dupIndex = n;
						faceIndicesToRemove.push(i);
						break;

					}

				}

			}

			for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {

				var idx = faceIndicesToRemove[i];

				this.faces.splice(idx, 1);

				for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {

					this.faceVertexUvs[j].splice(idx, 1);

				}

			}

			// Use unique set of vertices

			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;

		},

		sortFacesByMaterialIndex: function () {

			var faces = this.faces;
			var length = faces.length;

			// tag faces

			for (var i = 0; i < length; i++) {

				faces[i]._id = i;

			}

			// sort faces

			function materialIndexSort(a, b) {

				return a.materialIndex - b.materialIndex;

			}

			faces.sort(materialIndexSort);

			// sort uvs

			var uvs1 = this.faceVertexUvs[0];
			var uvs2 = this.faceVertexUvs[1];

			var newUvs1, newUvs2;

			if (uvs1 && uvs1.length === length) newUvs1 = [];
			if (uvs2 && uvs2.length === length) newUvs2 = [];

			for (var i = 0; i < length; i++) {

				var id = faces[i]._id;

				if (newUvs1) newUvs1.push(uvs1[id]);
				if (newUvs2) newUvs2.push(uvs2[id]);

			}

			if (newUvs1) this.faceVertexUvs[0] = newUvs1;
			if (newUvs2) this.faceVertexUvs[1] = newUvs2;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.4,
					type: 'Geometry',
					generator: 'Geometry.toJSON'
				}
			};

			// standard Geometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if (this.name !== '') data.name = this.name;

			if (this.parameters !== undefined) {

				var parameters = this.parameters;

				for (var key in parameters) {

					if (parameters[key] !== undefined) data[key] = parameters[key];

				}

				return data;

			}

			var vertices = [];

			for (var i = 0; i < this.vertices.length; i++) {

				var vertex = this.vertices[i];
				vertices.push(vertex.x, vertex.y, vertex.z);

			}

			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};

			for (var i = 0; i < this.faces.length; i++) {

				var face = this.faces[i];

				var hasMaterial = true;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;

				var faceType = 0;

				faceType = setBit(faceType, 0, 0); // isQuad
				faceType = setBit(faceType, 1, hasMaterial);
				faceType = setBit(faceType, 2, hasFaceUv);
				faceType = setBit(faceType, 3, hasFaceVertexUv);
				faceType = setBit(faceType, 4, hasFaceNormal);
				faceType = setBit(faceType, 5, hasFaceVertexNormal);
				faceType = setBit(faceType, 6, hasFaceColor);
				faceType = setBit(faceType, 7, hasFaceVertexColor);

				faces.push(faceType);
				faces.push(face.a, face.b, face.c);
				faces.push(face.materialIndex);

				if (hasFaceVertexUv) {

					var faceVertexUvs = this.faceVertexUvs[0][i];

					faces.push(
						getUvIndex(faceVertexUvs[0]),
						getUvIndex(faceVertexUvs[1]),
						getUvIndex(faceVertexUvs[2])
					);

				}

				if (hasFaceNormal) {

					faces.push(getNormalIndex(face.normal));

				}

				if (hasFaceVertexNormal) {

					var vertexNormals = face.vertexNormals;

					faces.push(
						getNormalIndex(vertexNormals[0]),
						getNormalIndex(vertexNormals[1]),
						getNormalIndex(vertexNormals[2])
					);

				}

				if (hasFaceColor) {

					faces.push(getColorIndex(face.color));

				}

				if (hasFaceVertexColor) {

					var vertexColors = face.vertexColors;

					faces.push(
						getColorIndex(vertexColors[0]),
						getColorIndex(vertexColors[1]),
						getColorIndex(vertexColors[2])
					);

				}

			}

			function setBit(value, position, enabled) {

				return enabled ? value | (1 << position) : value & (~(1 << position));

			}

			function getNormalIndex(normal) {

				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

				if (normalsHash[hash] !== undefined) {

					return normalsHash[hash];

				}

				normalsHash[hash] = normals.length / 3;
				normals.push(normal.x, normal.y, normal.z);

				return normalsHash[hash];

			}

			function getColorIndex(color) {

				var hash = color.r.toString() + color.g.toString() + color.b.toString();

				if (colorsHash[hash] !== undefined) {

					return colorsHash[hash];

				}

				colorsHash[hash] = colors.length;
				colors.push(color.getHex());

				return colorsHash[hash];

			}

			function getUvIndex(uv) {

				var hash = uv.x.toString() + uv.y.toString();

				if (uvsHash[hash] !== undefined) {

					return uvsHash[hash];

				}

				uvsHash[hash] = uvs.length / 2;
				uvs.push(uv.x, uv.y);

				return uvsHash[hash];

			}

			data.data = {};

			data.data.vertices = vertices;
			data.data.normals = normals;
			if (colors.length > 0) data.data.colors = colors;
			if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility
			data.data.faces = faces;

			return data;

		},

		clone: function () {

			/*
			// Handle primitives
	
			var parameters = this.parameters;
	
			if ( parameters !== undefined ) {
	
				var values = [];
	
				for ( var key in parameters ) {
	
					values.push( parameters[ key ] );
	
				}
	
				var geometry = Object.create( this.constructor.prototype );
				this.constructor.apply( geometry, values );
				return geometry;
	
			}
	
			return new this.constructor().copy( this );
			*/

			return new THREE.Geometry().copy(this);

		},

		copy: function (source) {

			this.vertices = [];
			this.faces = [];
			this.faceVertexUvs = [[]];

			var vertices = source.vertices;

			for (var i = 0, il = vertices.length; i < il; i++) {

				this.vertices.push(vertices[i].clone());

			}

			var faces = source.faces;

			for (var i = 0, il = faces.length; i < il; i++) {

				this.faces.push(faces[i].clone());

			}

			for (var i = 0, il = source.faceVertexUvs.length; i < il; i++) {

				var faceVertexUvs = source.faceVertexUvs[i];

				if (this.faceVertexUvs[i] === undefined) {

					this.faceVertexUvs[i] = [];

				}

				for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {

					var uvs = faceVertexUvs[j], uvsCopy = [];

					for (var k = 0, kl = uvs.length; k < kl; k++) {

						var uv = uvs[k];

						uvsCopy.push(uv.clone());

					}

					this.faceVertexUvs[i].push(uvsCopy);

				}

			}

			return this;

		},

		dispose: function () {

			this.dispatchEvent({ type: 'dispose' });

		}

	});

	THREE.GeometryIdCount = 0;

	// File:src/core/DirectGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.DirectGeometry = function () {

		Object.defineProperty(this, 'id', { value: THREE.GeometryIdCount++ });

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'DirectGeometry';

		this.indices = [];
		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];

		this.groups = [];

		this.morphTargets = {};

		this.skinWeights = [];
		this.skinIndices = [];

		// this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.verticesNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.groupsNeedUpdate = false;

	};

	Object.assign(THREE.DirectGeometry.prototype, THREE.EventDispatcher.prototype, {

		computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
		computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,

		computeFaceNormals: function () {

			//console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

		},

		computeVertexNormals: function () {

			//console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

		},

		computeGroups: function (geometry) {

			var group;
			var groups = [];
			var materialIndex;

			var faces = geometry.faces;

			for (var i = 0; i < faces.length; i++) {

				var face = faces[i];

				// materials

				if (face.materialIndex !== materialIndex) {

					materialIndex = face.materialIndex;

					if (group !== undefined) {

						group.count = (i * 3) - group.start;
						groups.push(group);

					}

					group = {
						start: i * 3,
						materialIndex: materialIndex
					};

				}

			}

			if (group !== undefined) {

				group.count = (i * 3) - group.start;
				groups.push(group);

			}

			this.groups = groups;

		},

		fromGeometry: function (geometry) {

			var faces = geometry.faces;
			var vertices = geometry.vertices;
			var faceVertexUvs = geometry.faceVertexUvs;

			var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
			var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;

			// morphs

			var morphTargets = geometry.morphTargets;
			var morphTargetsLength = morphTargets.length;

			var morphTargetsPosition;

			if (morphTargetsLength > 0) {

				morphTargetsPosition = [];

				for (var i = 0; i < morphTargetsLength; i++) {

					morphTargetsPosition[i] = [];

				}

				this.morphTargets.position = morphTargetsPosition;

			}

			var morphNormals = geometry.morphNormals;
			var morphNormalsLength = morphNormals.length;

			var morphTargetsNormal;

			if (morphNormalsLength > 0) {

				morphTargetsNormal = [];

				for (var i = 0; i < morphNormalsLength; i++) {

					morphTargetsNormal[i] = [];

				}

				this.morphTargets.normal = morphTargetsNormal;

			}

			// skins

			var skinIndices = geometry.skinIndices;
			var skinWeights = geometry.skinWeights;

			var hasSkinIndices = skinIndices.length === vertices.length;
			var hasSkinWeights = skinWeights.length === vertices.length;

			//

			for (var i = 0; i < faces.length; i++) {

				var face = faces[i];

				this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);

				var vertexNormals = face.vertexNormals;

				if (vertexNormals.length === 3) {

					this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);

				} else {

					var normal = face.normal;

					this.normals.push(normal, normal, normal);

				}

				var vertexColors = face.vertexColors;

				if (vertexColors.length === 3) {

					this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);

				} else {

					var color = face.color;

					this.colors.push(color, color, color);

				}

				if (hasFaceVertexUv === true) {

					var vertexUvs = faceVertexUvs[0][i];

					if (vertexUvs !== undefined) {

						this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);

					} else {

						//console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

						this.uvs.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());

					}

				}

				if (hasFaceVertexUv2 === true) {

					var vertexUvs = faceVertexUvs[1][i];

					if (vertexUvs !== undefined) {

						this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);

					} else {

						//console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

						this.uvs2.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());

					}

				}

				// morphs

				for (var j = 0; j < morphTargetsLength; j++) {

					var morphTarget = morphTargets[j].vertices;

					morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);

				}

				for (var j = 0; j < morphNormalsLength; j++) {

					var morphNormal = morphNormals[j].vertexNormals[i];

					morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);

				}

				// skins

				if (hasSkinIndices) {

					this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);

				}

				if (hasSkinWeights) {

					this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);

				}

			}

			this.computeGroups(geometry);

			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
			this.groupsNeedUpdate = geometry.groupsNeedUpdate;

			return this;

		},

		dispose: function () {

			this.dispatchEvent({ type: 'dispose' });

		}

	});

	// File:src/core/BufferGeometry.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferGeometry = function () {

		Object.defineProperty(this, 'id', { value: THREE.GeometryIdCount++ });

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

	};

	Object.assign(THREE.BufferGeometry.prototype, THREE.EventDispatcher.prototype, {

		getIndex: function () {

			return this.index;

		},

		setIndex: function (index) {

			this.index = index;

		},

		addAttribute: function (name, attribute) {

			if (attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false) {

				//console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

				this.addAttribute(name, new THREE.BufferAttribute(arguments[1], arguments[2]));

				return;

			}

			if (name === 'index') {

				//console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
				this.setIndex(attribute);

				return;

			}

			this.attributes[name] = attribute;

			return this;

		},

		getAttribute: function (name) {

			return this.attributes[name];

		},

		removeAttribute: function (name) {

			delete this.attributes[name];

			return this;

		},

		addGroup: function (start, count, materialIndex) {

			this.groups.push({

				start: start,
				count: count,
				materialIndex: materialIndex !== undefined ? materialIndex : 0

			});

		},

		clearGroups: function () {

			this.groups = [];

		},

		setDrawRange: function (start, count) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		},

		applyMatrix: function (matrix) {

			var position = this.attributes.position;

			if (position !== undefined) {

				matrix.applyToVector3Array(position.array);
				position.needsUpdate = true;

			}

			var normal = this.attributes.normal;

			if (normal !== undefined) {

				var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);

				normalMatrix.applyToVector3Array(normal.array);
				normal.needsUpdate = true;

			}

			if (this.boundingBox !== null) {

				this.computeBoundingBox();

			}

			if (this.boundingSphere !== null) {

				this.computeBoundingSphere();

			}

			return this;

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1;

			return function rotateX(angle) {

				if (m1 === undefined) m1 = new THREE.Matrix4();

				m1.makeRotationX(angle);

				this.applyMatrix(m1);

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1;

			return function rotateY(angle) {

				if (m1 === undefined) m1 = new THREE.Matrix4();

				m1.makeRotationY(angle);

				this.applyMatrix(m1);

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1;

			return function rotateZ(angle) {

				if (m1 === undefined) m1 = new THREE.Matrix4();

				m1.makeRotationZ(angle);

				this.applyMatrix(m1);

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1;

			return function translate(x, y, z) {

				if (m1 === undefined) m1 = new THREE.Matrix4();

				m1.makeTranslation(x, y, z);

				this.applyMatrix(m1);

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1;

			return function scale(x, y, z) {

				if (m1 === undefined) m1 = new THREE.Matrix4();

				m1.makeScale(x, y, z);

				this.applyMatrix(m1);

				return this;

			};

		}(),

		lookAt: function () {

			var obj;

			return function lookAt(vector) {

				if (obj === undefined) obj = new THREE.Object3D();

				obj.lookAt(vector);

				obj.updateMatrix();

				this.applyMatrix(obj.matrix);

			};

		}(),

		center: function () {

			this.computeBoundingBox();

			var offset = this.boundingBox.center().negate();

			this.translate(offset.x, offset.y, offset.z);

			return offset;

		},

		setFromObject: function (object) {

			// //console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

			var geometry = object.geometry;

			if (object instanceof THREE.Points || object instanceof THREE.Line) {

				var positions = new THREE.Float32Attribute(geometry.vertices.length * 3, 3);
				var colors = new THREE.Float32Attribute(geometry.colors.length * 3, 3);

				this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
				this.addAttribute('color', colors.copyColorsArray(geometry.colors));

				if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {

					var lineDistances = new THREE.Float32Attribute(geometry.lineDistances.length, 1);

					this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));

				}

				if (geometry.boundingSphere !== null) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				if (geometry.boundingBox !== null) {

					this.boundingBox = geometry.boundingBox.clone();

				}

			} else if (object instanceof THREE.Mesh) {

				if (geometry instanceof THREE.Geometry) {

					this.fromGeometry(geometry);

				}

			}

			return this;

		},

		updateFromObject: function (object) {

			var geometry = object.geometry;

			if (object instanceof THREE.Mesh) {

				var direct = geometry.__directGeometry;

				if (direct === undefined) {

					return this.fromGeometry(geometry);

				}

				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;

				geometry = direct;

			}

			if (geometry.verticesNeedUpdate === true) {

				var attribute = this.attributes.position;

				if (attribute !== undefined) {

					attribute.copyVector3sArray(geometry.vertices);
					attribute.needsUpdate = true;

				}

				geometry.verticesNeedUpdate = false;

			}

			if (geometry.normalsNeedUpdate === true) {

				var attribute = this.attributes.normal;

				if (attribute !== undefined) {

					attribute.copyVector3sArray(geometry.normals);
					attribute.needsUpdate = true;

				}

				geometry.normalsNeedUpdate = false;

			}

			if (geometry.colorsNeedUpdate === true) {

				var attribute = this.attributes.color;

				if (attribute !== undefined) {

					attribute.copyColorsArray(geometry.colors);
					attribute.needsUpdate = true;

				}

				geometry.colorsNeedUpdate = false;

			}

			if (geometry.uvsNeedUpdate) {

				var attribute = this.attributes.uv;

				if (attribute !== undefined) {

					attribute.copyVector2sArray(geometry.uvs);
					attribute.needsUpdate = true;

				}

				geometry.uvsNeedUpdate = false;

			}

			if (geometry.lineDistancesNeedUpdate) {

				var attribute = this.attributes.lineDistance;

				if (attribute !== undefined) {

					attribute.copyArray(geometry.lineDistances);
					attribute.needsUpdate = true;

				}

				geometry.lineDistancesNeedUpdate = false;

			}

			if (geometry.groupsNeedUpdate) {

				geometry.computeGroups(object.geometry);
				this.groups = geometry.groups;

				geometry.groupsNeedUpdate = false;

			}

			return this;

		},

		fromGeometry: function (geometry) {

			geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry(geometry);

			return this.fromDirectGeometry(geometry.__directGeometry);

		},

		fromDirectGeometry: function (geometry) {

			var positions = new Float32Array(geometry.vertices.length * 3);
			this.addAttribute('position', new THREE.BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));

			if (geometry.normals.length > 0) {

				var normals = new Float32Array(geometry.normals.length * 3);
				this.addAttribute('normal', new THREE.BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));

			}

			if (geometry.colors.length > 0) {

				var colors = new Float32Array(geometry.colors.length * 3);
				this.addAttribute('color', new THREE.BufferAttribute(colors, 3).copyColorsArray(geometry.colors));

			}

			if (geometry.uvs.length > 0) {

				var uvs = new Float32Array(geometry.uvs.length * 2);
				this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));

			}

			if (geometry.uvs2.length > 0) {

				var uvs2 = new Float32Array(geometry.uvs2.length * 2);
				this.addAttribute('uv2', new THREE.BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));

			}

			if (geometry.indices.length > 0) {

				var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
				var indices = new TypeArray(geometry.indices.length * 3);
				this.setIndex(new THREE.BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));

			}

			// groups

			this.groups = geometry.groups;

			// morphs

			for (var name in geometry.morphTargets) {

				var array = [];
				var morphTargets = geometry.morphTargets[name];

				for (var i = 0, l = morphTargets.length; i < l; i++) {

					var morphTarget = morphTargets[i];

					var attribute = new THREE.Float32Attribute(morphTarget.length * 3, 3);

					array.push(attribute.copyVector3sArray(morphTarget));

				}

				this.morphAttributes[name] = array;

			}

			// skinning

			if (geometry.skinIndices.length > 0) {

				var skinIndices = new THREE.Float32Attribute(geometry.skinIndices.length * 4, 4);
				this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));

			}

			if (geometry.skinWeights.length > 0) {

				var skinWeights = new THREE.Float32Attribute(geometry.skinWeights.length * 4, 4);
				this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));

			}

			//

			if (geometry.boundingSphere !== null) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if (geometry.boundingBox !== null) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			return this;

		},

		computeBoundingBox: function () {

			if (this.boundingBox === null) {

				this.boundingBox = new THREE.Box3();

			}

			var positions = this.attributes.position.array;

			if (positions !== undefined) {

				this.boundingBox.setFromArray(positions);

			} else {

				this.boundingBox.makeEmpty();

			}

			if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {

				//console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

			}

		},

		computeBoundingSphere: function () {

			var box = new THREE.Box3();
			var vector = new THREE.Vector3();

			return function computeBoundingSphere() {

				if (this.boundingSphere === null) {

					this.boundingSphere = new THREE.Sphere();

				}

				var positions = this.attributes.position;

				if (positions) {

					var array = positions.array;
					var center = this.boundingSphere.center;

					box.setFromArray(array);
					box.center(center);

					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

					var maxRadiusSq = 0;

					for (var i = 0, il = array.length; i < il; i += 3) {

						vector.fromArray(array, i);
						maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));

					}

					this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

					if (isNaN(this.boundingSphere.radius)) {

						//console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

					}

				}

			};

		}(),

		computeFaceNormals: function () {

			// backwards compatibility

		},

		computeVertexNormals: function () {

			var index = this.index;
			var attributes = this.attributes;
			var groups = this.groups;

			if (attributes.position) {

				var positions = attributes.position.array;

				if (attributes.normal === undefined) {

					this.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(positions.length), 3));

				} else {

					// reset existing normals to zero

					var array = attributes.normal.array;

					for (var i = 0, il = array.length; i < il; i++) {

						array[i] = 0;

					}

				}

				var normals = attributes.normal.array;

				var vA, vB, vC,

					pA = new THREE.Vector3(),
					pB = new THREE.Vector3(),
					pC = new THREE.Vector3(),

					cb = new THREE.Vector3(),
					ab = new THREE.Vector3();

				// indexed elements

				if (index) {

					var indices = index.array;

					if (groups.length === 0) {

						this.addGroup(0, indices.length);

					}

					for (var j = 0, jl = groups.length; j < jl; ++j) {

						var group = groups[j];

						var start = group.start;
						var count = group.count;

						for (var i = start, il = start + count; i < il; i += 3) {

							vA = indices[i + 0] * 3;
							vB = indices[i + 1] * 3;
							vC = indices[i + 2] * 3;

							pA.fromArray(positions, vA);
							pB.fromArray(positions, vB);
							pC.fromArray(positions, vC);

							cb.subVectors(pC, pB);
							ab.subVectors(pA, pB);
							cb.cross(ab);

							normals[vA] += cb.x;
							normals[vA + 1] += cb.y;
							normals[vA + 2] += cb.z;

							normals[vB] += cb.x;
							normals[vB + 1] += cb.y;
							normals[vB + 2] += cb.z;

							normals[vC] += cb.x;
							normals[vC + 1] += cb.y;
							normals[vC + 2] += cb.z;

						}

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for (var i = 0, il = positions.length; i < il; i += 9) {

						pA.fromArray(positions, i);
						pB.fromArray(positions, i + 3);
						pC.fromArray(positions, i + 6);

						cb.subVectors(pC, pB);
						ab.subVectors(pA, pB);
						cb.cross(ab);

						normals[i] = cb.x;
						normals[i + 1] = cb.y;
						normals[i + 2] = cb.z;

						normals[i + 3] = cb.x;
						normals[i + 4] = cb.y;
						normals[i + 5] = cb.z;

						normals[i + 6] = cb.x;
						normals[i + 7] = cb.y;
						normals[i + 8] = cb.z;

					}

				}

				this.normalizeNormals();

				attributes.normal.needsUpdate = true;

			}

		},

		merge: function (geometry, offset) {

			if (geometry instanceof THREE.BufferGeometry === false) {

				//console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;

			}

			if (offset === undefined) offset = 0;

			var attributes = this.attributes;

			for (var key in attributes) {

				if (geometry.attributes[key] === undefined) continue;

				var attribute1 = attributes[key];
				var attributeArray1 = attribute1.array;

				var attribute2 = geometry.attributes[key];
				var attributeArray2 = attribute2.array;

				var attributeSize = attribute2.itemSize;

				for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {

					attributeArray1[j] = attributeArray2[i];

				}

			}

			return this;

		},

		normalizeNormals: function () {

			var normals = this.attributes.normal.array;

			var x, y, z, n;

			for (var i = 0, il = normals.length; i < il; i += 3) {

				x = normals[i];
				y = normals[i + 1];
				z = normals[i + 2];

				n = 1.0 / Math.sqrt(x * x + y * y + z * z);

				normals[i] *= n;
				normals[i + 1] *= n;
				normals[i + 2] *= n;

			}

		},

		toNonIndexed: function () {

			if (this.index === null) {

				//console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
				return this;

			}

			var geometry2 = new THREE.BufferGeometry();

			var indices = this.index.array;
			var attributes = this.attributes;

			for (var name in attributes) {

				var attribute = attributes[name];

				var array = attribute.array;
				var itemSize = attribute.itemSize;

				var array2 = new array.constructor(indices.length * itemSize);

				var index = 0, index2 = 0;

				for (var i = 0, l = indices.length; i < l; i++) {

					index = indices[i] * itemSize;

					for (var j = 0; j < itemSize; j++) {

						array2[index2++] = array[index++];

					}

				}

				geometry2.addAttribute(name, new THREE.BufferAttribute(array2, itemSize));

			}

			return geometry2;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.4,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if (this.name !== '') data.name = this.name;

			if (this.parameters !== undefined) {

				var parameters = this.parameters;

				for (var key in parameters) {

					if (parameters[key] !== undefined) data[key] = parameters[key];

				}

				return data;

			}

			data.data = { attributes: {} };

			var index = this.index;

			if (index !== null) {

				var array = Array.prototype.slice.call(index.array);

				data.data.index = {
					type: index.array.constructor.name,
					array: array
				};

			}

			var attributes = this.attributes;

			for (var key in attributes) {

				var attribute = attributes[key];

				var array = Array.prototype.slice.call(attribute.array);

				data.data.attributes[key] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: array,
					normalized: attribute.normalized
				};

			}

			var groups = this.groups;

			if (groups.length > 0) {

				data.data.groups = JSON.parse(JSON.stringify(groups));

			}

			var boundingSphere = this.boundingSphere;

			if (boundingSphere !== null) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};

			}

			return data;

		},

		clone: function () {

			/*
			// Handle primitives
	
			var parameters = this.parameters;
	
			if ( parameters !== undefined ) {
	
				var values = [];
	
				for ( var key in parameters ) {
	
					values.push( parameters[ key ] );
	
				}
	
				var geometry = Object.create( this.constructor.prototype );
				this.constructor.apply( geometry, values );
				return geometry;
	
			}
	
			return new this.constructor().copy( this );
			*/

			return new THREE.BufferGeometry().copy(this);

		},

		copy: function (source) {

			var index = source.index;

			if (index !== null) {

				this.setIndex(index.clone());

			}

			var attributes = source.attributes;

			for (var name in attributes) {

				var attribute = attributes[name];
				this.addAttribute(name, attribute.clone());

			}

			var groups = source.groups;

			for (var i = 0, l = groups.length; i < l; i++) {

				var group = groups[i];
				this.addGroup(group.start, group.count, group.materialIndex);

			}

			return this;

		},

		dispose: function () {

			this.dispatchEvent({ type: 'dispose' });

		}

	});

	THREE.BufferGeometry.MaxIndex = 65535;

	// File:src/core/InstancedBufferGeometry.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InstancedBufferGeometry = function () {

		THREE.BufferGeometry.call(this);

		this.type = 'InstancedBufferGeometry';
		this.maxInstancedCount = undefined;

	};

	THREE.InstancedBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
	THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;

	THREE.InstancedBufferGeometry.prototype.addGroup = function (start, count, instances) {

		this.groups.push({

			start: start,
			count: count,
			instances: instances

		});

	};

	THREE.InstancedBufferGeometry.prototype.copy = function (source) {

		var index = source.index;

		if (index !== null) {

			this.setIndex(index.clone());

		}

		var attributes = source.attributes;

		for (var name in attributes) {

			var attribute = attributes[name];
			this.addAttribute(name, attribute.clone());

		}

		var groups = source.groups;

		for (var i = 0, l = groups.length; i < l; i++) {

			var group = groups[i];
			this.addGroup(group.start, group.count, group.instances);

		}

		return this;

	};

	// File:src/core/Uniform.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Uniform = function (value) {

		if (typeof value === 'string') {

			//console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
			value = arguments[1];

		}

		this.value = value;

		this.dynamic = false;

	};

	THREE.Uniform.prototype = {

		constructor: THREE.Uniform,

		onUpdate: function (callback) {

			this.dynamic = true;
			this.onUpdateCallback = callback;

			return this;

		}

	};

	// File:src/animation/AnimationAction.js

	/**
	 *
	 * Action provided by AnimationMixer for scheduling clip playback on specific
	 * objects.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 *
	 */

	THREE.AnimationAction = function () {

		throw new Error("THREE.AnimationAction: " +
			"Use mixer.clipAction for construction.");

	};

	THREE.AnimationAction._new =
		function AnimationAction(mixer, clip, localRoot) {

			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot || null;

			var tracks = clip.tracks,
				nTracks = tracks.length,
				interpolants = new Array(nTracks);

			var interpolantSettings = {
				endingStart: THREE.ZeroCurvatureEnding,
				endingEnd: THREE.ZeroCurvatureEnding
			};

			for (var i = 0; i !== nTracks; ++i) {

				var interpolant = tracks[i].createInterpolant(null);
				interpolants[i] = interpolant;
				interpolant.settings = interpolantSettings;

			}

			this._interpolantSettings = interpolantSettings;

			this._interpolants = interpolants;	// bound by the mixer

			// inside: PropertyMixer (managed by the mixer)
			this._propertyBindings = new Array(nTracks);

			this._cacheIndex = null;			// for the memory manager
			this._byClipCacheIndex = null;		// for the memory manager

			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;

			this.loop = THREE.LoopRepeat;
			this._loopCount = -1;

			// global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action
			this._startTime = null;

			// scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop
			this.time = 0;

			this.timeScale = 1;
			this._effectiveTimeScale = 1;

			this.weight = 1;
			this._effectiveWeight = 1;

			this.repetitions = Infinity; 		// no. of repetitions when looping

			this.paused = false;				// false -> zero effective time scale
			this.enabled = true;				// true -> zero effective weight

			this.clampWhenFinished = false;	// keep feeding the last frame?

			this.zeroSlopeAtStart = true;		// for smooth interpolation w/o separate
			this.zeroSlopeAtEnd = true;		// clips for start, loop and end

		};

	THREE.AnimationAction._new.prototype = {

		constructor: THREE.AnimationAction._new,

		// State & Scheduling

		play: function () {

			this._mixer._activateAction(this);

			return this;

		},

		stop: function () {

			this._mixer._deactivateAction(this);

			return this.reset();

		},

		reset: function () {

			this.paused = false;
			this.enabled = true;

			this.time = 0;			// restart clip
			this._loopCount = -1;	// forget previous loops
			this._startTime = null;	// forget scheduling

			return this.stopFading().stopWarping();

		},

		isRunning: function () {

			var start = this._startTime;

			return this.enabled && !this.paused && this.timeScale !== 0 &&
				this._startTime === null && this._mixer._isActiveAction(this);

		},

		// return true when play has been called
		isScheduled: function () {

			return this._mixer._isActiveAction(this);

		},

		startAt: function (time) {

			this._startTime = time;

			return this;

		},

		setLoop: function (mode, repetitions) {

			this.loop = mode;
			this.repetitions = repetitions;

			return this;

		},

		// Weight

		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		setEffectiveWeight: function (weight) {

			this.weight = weight;

			// note: same logic as when updated at runtime
			this._effectiveWeight = this.enabled ? weight : 0;

			return this.stopFading();

		},

		// return the weight considering fading and .enabled
		getEffectiveWeight: function () {

			return this._effectiveWeight;

		},

		fadeIn: function (duration) {

			return this._scheduleFading(duration, 0, 1);

		},

		fadeOut: function (duration) {

			return this._scheduleFading(duration, 1, 0);

		},

		crossFadeFrom: function (fadeOutAction, duration, warp) {

			var mixer = this._mixer;

			fadeOutAction.fadeOut(duration);
			this.fadeIn(duration);

			if (warp) {

				var fadeInDuration = this._clip.duration,
					fadeOutDuration = fadeOutAction._clip.duration,

					startEndRatio = fadeOutDuration / fadeInDuration,
					endStartRatio = fadeInDuration / fadeOutDuration;

				fadeOutAction.warp(1.0, startEndRatio, duration);
				this.warp(endStartRatio, 1.0, duration);

			}

			return this;

		},

		crossFadeTo: function (fadeInAction, duration, warp) {

			return fadeInAction.crossFadeFrom(this, duration, warp);

		},

		stopFading: function () {

			var weightInterpolant = this._weightInterpolant;

			if (weightInterpolant !== null) {

				this._weightInterpolant = null;
				this._mixer._takeBackControlInterpolant(weightInterpolant);

			}

			return this;

		},

		// Time Scale Control

		// set the weight stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		setEffectiveTimeScale: function (timeScale) {

			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;

			return this.stopWarping();

		},

		// return the time scale considering warping and .paused
		getEffectiveTimeScale: function () {

			return this._effectiveTimeScale;

		},

		setDuration: function (duration) {

			this.timeScale = this._clip.duration / duration;

			return this.stopWarping();

		},

		syncWith: function (action) {

			this.time = action.time;
			this.timeScale = action.timeScale;

			return this.stopWarping();

		},

		halt: function (duration) {

			return this.warp(this._effectiveTimeScale, 0, duration);

		},

		warp: function (startTimeScale, endTimeScale, duration) {

			var mixer = this._mixer, now = mixer.time,
				interpolant = this._timeScaleInterpolant,

				timeScale = this.timeScale;

			if (interpolant === null) {

				interpolant = mixer._lendControlInterpolant(),
					this._timeScaleInterpolant = interpolant;

			}

			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[0] = now;
			times[1] = now + duration;

			values[0] = startTimeScale / timeScale;
			values[1] = endTimeScale / timeScale;

			return this;

		},

		stopWarping: function () {

			var timeScaleInterpolant = this._timeScaleInterpolant;

			if (timeScaleInterpolant !== null) {

				this._timeScaleInterpolant = null;
				this._mixer._takeBackControlInterpolant(timeScaleInterpolant);

			}

			return this;

		},

		// Object Accessors

		getMixer: function () {

			return this._mixer;

		},

		getClip: function () {

			return this._clip;

		},

		getRoot: function () {

			return this._localRoot || this._mixer._root;

		},

		// Interna

		_update: function (time, deltaTime, timeDirection, accuIndex) {
			// called by the mixer

			var startTime = this._startTime;

			if (startTime !== null) {

				// check for scheduled start of action

				var timeRunning = (time - startTime) * timeDirection;
				if (timeRunning < 0 || timeDirection === 0) {

					return; // yet to come / don't decide when delta = 0

				}

				// start

				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;

			}

			// apply time scale and advance time

			deltaTime *= this._updateTimeScale(time);
			var clipTime = this._updateTime(deltaTime);

			// note: _updateTime may disable the action resulting in
			// an effective weight of 0

			var weight = this._updateWeight(time);

			if (weight > 0) {

				var interpolants = this._interpolants;
				var propertyMixers = this._propertyBindings;

				for (var j = 0, m = interpolants.length; j !== m; ++j) {

					interpolants[j].evaluate(clipTime);
					propertyMixers[j].accumulate(accuIndex, weight);

				}

			}

		},

		_updateWeight: function (time) {

			var weight = 0;

			if (this.enabled) {

				weight = this.weight;
				var interpolant = this._weightInterpolant;

				if (interpolant !== null) {

					var interpolantValue = interpolant.evaluate(time)[0];

					weight *= interpolantValue;

					if (time > interpolant.parameterPositions[1]) {

						this.stopFading();

						if (interpolantValue === 0) {

							// faded out, disable
							this.enabled = false;

						}

					}

				}

			}

			this._effectiveWeight = weight;
			return weight;

		},

		_updateTimeScale: function (time) {

			var timeScale = 0;

			if (!this.paused) {

				timeScale = this.timeScale;

				var interpolant = this._timeScaleInterpolant;

				if (interpolant !== null) {

					var interpolantValue = interpolant.evaluate(time)[0];

					timeScale *= interpolantValue;

					if (time > interpolant.parameterPositions[1]) {

						this.stopWarping();

						if (timeScale === 0) {

							// motion has halted, pause
							this.paused = true;

						} else {

							// warp done - apply final time scale
							this.timeScale = timeScale;

						}

					}

				}

			}

			this._effectiveTimeScale = timeScale;
			return timeScale;

		},

		_updateTime: function (deltaTime) {

			var time = this.time + deltaTime;

			if (deltaTime === 0) return time;

			var duration = this._clip.duration,

				loop = this.loop,
				loopCount = this._loopCount;

			if (loop === THREE.LoopOnce) {

				if (loopCount === -1) {
					// just started

					this.loopCount = 0;
					this._setEndings(true, true, false);

				}

				handle_stop: {

					if (time >= duration) {

						time = duration;

					} else if (time < 0) {

						time = 0;

					} else break handle_stop;

					if (this.clampWhenFinished) this.paused = true;
					else this.enabled = false;

					this._mixer.dispatchEvent({
						type: 'finished', action: this,
						direction: deltaTime < 0 ? -1 : 1
					});

				}

			} else { // repetitive Repeat or PingPong

				var pingPong = (loop === THREE.LoopPingPong);

				if (loopCount === -1) {
					// just started

					if (deltaTime >= 0) {

						loopCount = 0;

						this._setEndings(
							true, this.repetitions === 0, pingPong);

					} else {

						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1

						this._setEndings(
							this.repetitions === 0, true, pingPong);

					}

				}

				if (time >= duration || time < 0) {
					// wrap around

					var loopDelta = Math.floor(time / duration); // signed
					time -= duration * loopDelta;

					loopCount += Math.abs(loopDelta);

					var pending = this.repetitions - loopCount;

					if (pending < 0) {
						// have to stop (switch state, clamp time, fire event)

						if (this.clampWhenFinished) this.paused = true;
						else this.enabled = false;

						time = deltaTime > 0 ? duration : 0;

						this._mixer.dispatchEvent({
							type: 'finished', action: this,
							direction: deltaTime > 0 ? 1 : -1
						});

					} else {
						// keep running

						if (pending === 0) {
							// entering the last round

							var atStart = deltaTime < 0;
							this._setEndings(atStart, !atStart, pingPong);

						} else {

							this._setEndings(false, false, pingPong);

						}

						this._loopCount = loopCount;

						this._mixer.dispatchEvent({
							type: 'loop', action: this, loopDelta: loopDelta
						});

					}

				}

				if (pingPong && (loopCount & 1) === 1) {
					// invert time for the "pong round"

					this.time = time;
					return duration - time;

				}

			}

			this.time = time;
			return time;

		},

		_setEndings: function (atStart, atEnd, pingPong) {

			var settings = this._interpolantSettings;

			if (pingPong) {

				settings.endingStart = THREE.ZeroSlopeEnding;
				settings.endingEnd = THREE.ZeroSlopeEnding;

			} else {

				// assuming for LoopOnce atStart == atEnd == true

				if (atStart) {

					settings.endingStart = this.zeroSlopeAtStart ?
						THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;

				} else {

					settings.endingStart = THREE.WrapAroundEnding;

				}

				if (atEnd) {

					settings.endingEnd = this.zeroSlopeAtEnd ?
						THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;

				} else {

					settings.endingEnd = THREE.WrapAroundEnding;

				}

			}

		},

		_scheduleFading: function (duration, weightNow, weightThen) {

			var mixer = this._mixer, now = mixer.time,
				interpolant = this._weightInterpolant;

			if (interpolant === null) {

				interpolant = mixer._lendControlInterpolant(),
					this._weightInterpolant = interpolant;

			}

			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[0] = now; values[0] = weightNow;
			times[1] = now + duration; values[1] = weightThen;

			return this;

		}

	};


	// File:src/animation/AnimationClip.js

	/**
	 *
	 * Reusable set of Tracks that represent an animation.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	THREE.AnimationClip = function (name, duration, tracks) {

		this.name = name;
		this.tracks = tracks;
		this.duration = (duration !== undefined) ? duration : -1;

		this.uuid = THREE.Math.generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if (this.duration < 0) {

			this.resetDuration();

		}

		// maybe only do these on demand, as doing them here could potentially slow down loading
		// but leaving these here during development as this ensures a lot of testing of these functions
		this.trim();
		this.optimize();

	};

	THREE.AnimationClip.prototype = {

		constructor: THREE.AnimationClip,

		resetDuration: function () {

			var tracks = this.tracks,
				duration = 0;

			for (var i = 0, n = tracks.length; i !== n; ++i) {

				var track = this.tracks[i];

				duration = Math.max(
					duration, track.times[track.times.length - 1]);

			}

			this.duration = duration;

		},

		trim: function () {

			for (var i = 0; i < this.tracks.length; i++) {

				this.tracks[i].trim(0, this.duration);

			}

			return this;

		},

		optimize: function () {

			for (var i = 0; i < this.tracks.length; i++) {

				this.tracks[i].optimize();

			}

			return this;

		}

	};

	// Static methods:

	Object.assign(THREE.AnimationClip, {

		parse: function (json) {

			var tracks = [],
				jsonTracks = json.tracks,
				frameTime = 1.0 / (json.fps || 1.0);

			for (var i = 0, n = jsonTracks.length; i !== n; ++i) {

				tracks.push(THREE.KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));

			}

			return new THREE.AnimationClip(json.name, json.duration, tracks);

		},


		toJSON: function (clip) {

			var tracks = [],
				clipTracks = clip.tracks;

			var json = {

				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks

			};

			for (var i = 0, n = clipTracks.length; i !== n; ++i) {

				tracks.push(THREE.KeyframeTrack.toJSON(clipTracks[i]));

			}

			return json;

		},


		CreateFromMorphTargetSequence: function (name, morphTargetSequence, fps, noLoop) {

			var numMorphTargets = morphTargetSequence.length;
			var tracks = [];

			for (var i = 0; i < numMorphTargets; i++) {

				var times = [];
				var values = [];

				times.push(
					(i + numMorphTargets - 1) % numMorphTargets,
					i,
					(i + 1) % numMorphTargets);

				values.push(0, 1, 0);

				var order = THREE.AnimationUtils.getKeyframeOrder(times);
				times = THREE.AnimationUtils.sortedArray(times, 1, order);
				values = THREE.AnimationUtils.sortedArray(values, 1, order);

				// if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.
				if (!noLoop && times[0] === 0) {

					times.push(numMorphTargets);
					values.push(values[0]);

				}

				tracks.push(
					new THREE.NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[i].name + ']',
						times, values
					).scale(1.0 / fps));
			}

			return new THREE.AnimationClip(name, -1, tracks);

		},

		findByName: function (objectOrClipArray, name) {

			var clipArray = objectOrClipArray;

			if (!Array.isArray(objectOrClipArray)) {

				var o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;

			}

			for (var i = 0; i < clipArray.length; i++) {

				if (clipArray[i].name === name) {

					return clipArray[i];

				}
			}

			return null;

		},

		CreateClipsFromMorphTargetSequences: function (morphTargets, fps, noLoop) {

			var animationToMorphTargets = {};

			// tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
			var pattern = /^([\w-]*?)([\d]+)$/;

			// sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002
			for (var i = 0, il = morphTargets.length; i < il; i++) {

				var morphTarget = morphTargets[i];
				var parts = morphTarget.name.match(pattern);

				if (parts && parts.length > 1) {

					var name = parts[1];

					var animationMorphTargets = animationToMorphTargets[name];
					if (!animationMorphTargets) {

						animationToMorphTargets[name] = animationMorphTargets = [];

					}

					animationMorphTargets.push(morphTarget);

				}

			}

			var clips = [];

			for (var name in animationToMorphTargets) {

				clips.push(THREE.AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));

			}

			return clips;

		},

		// parse the animation.hierarchy format
		parseAnimation: function (animation, bones, nodeName) {

			if (!animation) {

				//console.error( "  no animation in JSONLoader data" );
				return null;

			}

			var addNonemptyTrack = function (
				trackType, trackName, animationKeys, propertyName, destTracks) {

				// only return track if there are actually keys.
				if (animationKeys.length !== 0) {

					var times = [];
					var values = [];

					THREE.AnimationUtils.flattenJSON(
						animationKeys, times, values, propertyName);

					// empty keys are filtered out, so check again
					if (times.length !== 0) {

						destTracks.push(new trackType(trackName, times, values));

					}

				}

			};

			var tracks = [];

			var clipName = animation.name || 'default';
			// automatic length determination in AnimationClip.
			var duration = animation.length || -1;
			var fps = animation.fps || 30;

			var hierarchyTracks = animation.hierarchy || [];

			for (var h = 0; h < hierarchyTracks.length; h++) {

				var animationKeys = hierarchyTracks[h].keys;

				// skip empty tracks
				if (!animationKeys || animationKeys.length === 0) continue;

				// process morph targets in a way exactly compatible
				// with AnimationHandler.init( animation )
				if (animationKeys[0].morphTargets) {

					// figure out all morph targets used in this track
					var morphTargetNames = {};
					for (var k = 0; k < animationKeys.length; k++) {

						if (animationKeys[k].morphTargets) {

							for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {

								morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
							}

						}

					}

					// create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.
					for (var morphTargetName in morphTargetNames) {

						var times = [];
						var values = [];

						for (var m = 0;
							m !== animationKeys[k].morphTargets.length; ++m) {

							var animationKey = animationKeys[k];

							times.push(animationKey.time);
							values.push((animationKey.morphTarget === morphTargetName) ? 1 : 0);

						}

						tracks.push(new THREE.NumberKeyframeTrack(
							'.morphTargetInfluence[' + morphTargetName + ']', times, values));

					}

					duration = morphTargetNames.length * (fps || 1.0);

				} else {
					// ...assume skeletal animation

					var boneName = '.bones[' + bones[h].name + ']';

					addNonemptyTrack(
						THREE.VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks);

					addNonemptyTrack(
						THREE.QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks);

					addNonemptyTrack(
						THREE.VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks);

				}

			}

			if (tracks.length === 0) {

				return null;

			}

			var clip = new THREE.AnimationClip(clipName, duration, tracks);

			return clip;

		}

	});

	// File:src/animation/AnimationMixer.js

	/**
	 *
	 * Player for AnimationClips.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	THREE.AnimationMixer = function (root) {

		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;

		this.time = 0;

		this.timeScale = 1.0;

	};

	Object.assign(THREE.AnimationMixer.prototype, THREE.EventDispatcher.prototype, {

		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction: function (clip, optionalRoot) {

			var root = optionalRoot || this._root,
				rootUuid = root.uuid,

				clipObject = typeof clip === 'string' ?
					THREE.AnimationClip.findByName(root, clip) : clip,

				clipUuid = clipObject !== null ? clipObject.uuid : clip,

				actionsForClip = this._actionsByClip[clipUuid],
				prototypeAction = null;

			if (actionsForClip !== undefined) {

				var existingAction =
					actionsForClip.actionByRoot[rootUuid];

				if (existingAction !== undefined) {

					return existingAction;

				}

				// we know the clip, so we don't have to parse all
				// the bindings again but can just copy
				prototypeAction = actionsForClip.knownActions[0];

				// also, take the clip from the prototype action
				if (clipObject === null)
					clipObject = prototypeAction._clip;

			}

			// clip must be known when specified via string
			if (clipObject === null) return null;

			// allocate all resources required to run it
			var newAction = new THREE.
				AnimationMixer._Action(this, clipObject, optionalRoot);

			this._bindAction(newAction, prototypeAction);

			// and make the action known to the memory manager
			this._addInactiveAction(newAction, clipUuid, rootUuid);

			return newAction;

		},

		// get an existing action
		existingAction: function (clip, optionalRoot) {

			var root = optionalRoot || this._root,
				rootUuid = root.uuid,

				clipObject = typeof clip === 'string' ?
					THREE.AnimationClip.findByName(root, clip) : clip,

				clipUuid = clipObject ? clipObject.uuid : clip,

				actionsForClip = this._actionsByClip[clipUuid];

			if (actionsForClip !== undefined) {

				return actionsForClip.actionByRoot[rootUuid] || null;

			}

			return null;

		},

		// deactivates all previously scheduled actions
		stopAllAction: function () {

			var actions = this._actions,
				nActions = this._nActiveActions,
				bindings = this._bindings,
				nBindings = this._nActiveBindings;

			this._nActiveActions = 0;
			this._nActiveBindings = 0;

			for (var i = 0; i !== nActions; ++i) {

				actions[i].reset();

			}

			for (var i = 0; i !== nBindings; ++i) {

				bindings[i].useCount = 0;

			}

			return this;

		},

		// advance the time and update apply the animation
		update: function (deltaTime) {

			deltaTime *= this.timeScale;

			var actions = this._actions,
				nActions = this._nActiveActions,

				time = this.time += deltaTime,
				timeDirection = Math.sign(deltaTime),

				accuIndex = this._accuIndex ^= 1;

			// run active actions

			for (var i = 0; i !== nActions; ++i) {

				var action = actions[i];

				if (action.enabled) {

					action._update(time, deltaTime, timeDirection, accuIndex);

				}

			}

			// update scene graph

			var bindings = this._bindings,
				nBindings = this._nActiveBindings;

			for (var i = 0; i !== nBindings; ++i) {

				bindings[i].apply(accuIndex);

			}

			return this;

		},

		// return this mixer's root target object
		getRoot: function () {

			return this._root;

		},

		// free all resources specific to a particular clip
		uncacheClip: function (clip) {

			var actions = this._actions,
				clipUuid = clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[clipUuid];

			if (actionsForClip !== undefined) {

				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away

				var actionsToRemove = actionsForClip.knownActions;

				for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {

					var action = actionsToRemove[i];

					this._deactivateAction(action);

					var cacheIndex = action._cacheIndex,
						lastInactiveAction = actions[actions.length - 1];

					action._cacheIndex = null;
					action._byClipCacheIndex = null;

					lastInactiveAction._cacheIndex = cacheIndex;
					actions[cacheIndex] = lastInactiveAction;
					actions.pop();

					this._removeInactiveBindingsForAction(action);

				}

				delete actionsByClip[clipUuid];

			}

		},

		// free all resources specific to a particular root target object
		uncacheRoot: function (root) {

			var rootUuid = root.uuid,
				actionsByClip = this._actionsByClip;

			for (var clipUuid in actionsByClip) {

				var actionByRoot = actionsByClip[clipUuid].actionByRoot,
					action = actionByRoot[rootUuid];

				if (action !== undefined) {

					this._deactivateAction(action);
					this._removeInactiveAction(action);

				}

			}

			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[rootUuid];

			if (bindingByName !== undefined) {

				for (var trackName in bindingByName) {

					var binding = bindingByName[trackName];
					binding.restoreOriginalState();
					this._removeInactiveBinding(binding);

				}

			}

		},

		// remove a targeted clip from the cache
		uncacheAction: function (clip, optionalRoot) {

			var action = this.existingAction(clip, optionalRoot);

			if (action !== null) {

				this._deactivateAction(action);
				this._removeInactiveAction(action);

			}

		}

	});

	THREE.AnimationMixer._Action = THREE.AnimationAction._new;

	// Implementation details:

	Object.assign(THREE.AnimationMixer.prototype, {

		_bindAction: function (action, prototypeAction) {

			var root = action._localRoot || this._root,
				tracks = action._clip.tracks,
				nTracks = tracks.length,
				bindings = action._propertyBindings,
				interpolants = action._interpolants,
				rootUuid = root.uuid,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingsByName = bindingsByRoot[rootUuid];

			if (bindingsByName === undefined) {

				bindingsByName = {};
				bindingsByRoot[rootUuid] = bindingsByName;

			}

			for (var i = 0; i !== nTracks; ++i) {

				var track = tracks[i],
					trackName = track.name,
					binding = bindingsByName[trackName];

				if (binding !== undefined) {

					bindings[i] = binding;

				} else {

					binding = bindings[i];

					if (binding !== undefined) {

						// existing binding, make sure the cache knows

						if (binding._cacheIndex === null) {

							++binding.referenceCount;
							this._addInactiveBinding(binding, rootUuid, trackName);

						}

						continue;

					}

					var path = prototypeAction && prototypeAction.
						_propertyBindings[i].binding.parsedPath;

					binding = new THREE.PropertyMixer(
						THREE.PropertyBinding.create(root, trackName, path),
						track.ValueTypeName, track.getValueSize());

					++binding.referenceCount;
					this._addInactiveBinding(binding, rootUuid, trackName);

					bindings[i] = binding;

				}

				interpolants[i].resultBuffer = binding.buffer;

			}

		},

		_activateAction: function (action) {

			if (!this._isActiveAction(action)) {

				if (action._cacheIndex === null) {

					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind

					var rootUuid = (action._localRoot || this._root).uuid,
						clipUuid = action._clip.uuid,
						actionsForClip = this._actionsByClip[clipUuid];

					this._bindAction(action,
						actionsForClip && actionsForClip.knownActions[0]);

					this._addInactiveAction(action, clipUuid, rootUuid);

				}

				var bindings = action._propertyBindings;

				// increment reference counts / sort out state
				for (var i = 0, n = bindings.length; i !== n; ++i) {

					var binding = bindings[i];

					if (binding.useCount++ === 0) {

						this._lendBinding(binding);
						binding.saveOriginalState();

					}

				}

				this._lendAction(action);

			}

		},

		_deactivateAction: function (action) {

			if (this._isActiveAction(action)) {

				var bindings = action._propertyBindings;

				// decrement reference counts / sort out state
				for (var i = 0, n = bindings.length; i !== n; ++i) {

					var binding = bindings[i];

					if (--binding.useCount === 0) {

						binding.restoreOriginalState();
						this._takeBackBinding(binding);

					}

				}

				this._takeBackAction(action);

			}

		},

		// Memory manager

		_initMemoryManager: function () {

			this._actions = []; // 'nActiveActions' followed by inactive ones
			this._nActiveActions = 0;

			this._actionsByClip = {};
			// inside:
			// {
			// 		knownActions: Array< _Action >	- used as prototypes
			// 		actionByRoot: _Action			- lookup
			// }


			this._bindings = []; // 'nActiveBindings' followed by inactive ones
			this._nActiveBindings = 0;

			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


			this._controlInterpolants = []; // same game as above
			this._nActiveControlInterpolants = 0;

			var scope = this;

			this.stats = {

				actions: {
					get total() { return scope._actions.length; },
					get inUse() { return scope._nActiveActions; }
				},
				bindings: {
					get total() { return scope._bindings.length; },
					get inUse() { return scope._nActiveBindings; }
				},
				controlInterpolants: {
					get total() { return scope._controlInterpolants.length; },
					get inUse() { return scope._nActiveControlInterpolants; }
				}

			};

		},

		// Memory management for _Action objects

		_isActiveAction: function (action) {

			var index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;

		},

		_addInactiveAction: function (action, clipUuid, rootUuid) {

			var actions = this._actions,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[clipUuid];

			if (actionsForClip === undefined) {

				actionsForClip = {

					knownActions: [action],
					actionByRoot: {}

				};

				action._byClipCacheIndex = 0;

				actionsByClip[clipUuid] = actionsForClip;

			} else {

				var knownActions = actionsForClip.knownActions;

				action._byClipCacheIndex = knownActions.length;
				knownActions.push(action);

			}

			action._cacheIndex = actions.length;
			actions.push(action);

			actionsForClip.actionByRoot[rootUuid] = action;

		},

		_removeInactiveAction: function (action) {

			var actions = this._actions,
				lastInactiveAction = actions[actions.length - 1],
				cacheIndex = action._cacheIndex;

			lastInactiveAction._cacheIndex = cacheIndex;
			actions[cacheIndex] = lastInactiveAction;
			actions.pop();

			action._cacheIndex = null;


			var clipUuid = action._clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[clipUuid],
				knownActionsForClip = actionsForClip.knownActions,

				lastKnownAction =
					knownActionsForClip[knownActionsForClip.length - 1],

				byClipCacheIndex = action._byClipCacheIndex;

			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[byClipCacheIndex] = lastKnownAction;
			knownActionsForClip.pop();

			action._byClipCacheIndex = null;


			var actionByRoot = actionsForClip.actionByRoot,
				rootUuid = (actions._localRoot || this._root).uuid;

			delete actionByRoot[rootUuid];

			if (knownActionsForClip.length === 0) {

				delete actionsByClip[clipUuid];

			}

			this._removeInactiveBindingsForAction(action);

		},

		_removeInactiveBindingsForAction: function (action) {

			var bindings = action._propertyBindings;
			for (var i = 0, n = bindings.length; i !== n; ++i) {

				var binding = bindings[i];

				if (--binding.referenceCount === 0) {

					this._removeInactiveBinding(binding);

				}

			}

		},

		_lendAction: function (action) {

			// [ active actions |  inactive actions  ]
			// [  active actions >| inactive actions ]
			//                 s        a
			//                  <-swap->
			//                 a        s

			var actions = this._actions,
				prevIndex = action._cacheIndex,

				lastActiveIndex = this._nActiveActions++,

				firstInactiveAction = actions[lastActiveIndex];

			action._cacheIndex = lastActiveIndex;
			actions[lastActiveIndex] = action;

			firstInactiveAction._cacheIndex = prevIndex;
			actions[prevIndex] = firstInactiveAction;

		},

		_takeBackAction: function (action) {

			// [  active actions  | inactive actions ]
			// [ active actions |< inactive actions  ]
			//        a        s
			//         <-swap->
			//        s        a

			var actions = this._actions,
				prevIndex = action._cacheIndex,

				firstInactiveIndex = --this._nActiveActions,

				lastActiveAction = actions[firstInactiveIndex];

			action._cacheIndex = firstInactiveIndex;
			actions[firstInactiveIndex] = action;

			lastActiveAction._cacheIndex = prevIndex;
			actions[prevIndex] = lastActiveAction;

		},

		// Memory management for PropertyMixer objects

		_addInactiveBinding: function (binding, rootUuid, trackName) {

			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[rootUuid],

				bindings = this._bindings;

			if (bindingByName === undefined) {

				bindingByName = {};
				bindingsByRoot[rootUuid] = bindingByName;

			}

			bindingByName[trackName] = binding;

			binding._cacheIndex = bindings.length;
			bindings.push(binding);

		},

		_removeInactiveBinding: function (binding) {

			var bindings = this._bindings,
				propBinding = binding.binding,
				rootUuid = propBinding.rootNode.uuid,
				trackName = propBinding.path,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[rootUuid],

				lastInactiveBinding = bindings[bindings.length - 1],
				cacheIndex = binding._cacheIndex;

			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[cacheIndex] = lastInactiveBinding;
			bindings.pop();

			delete bindingByName[trackName];

			remove_empty_map: {

				for (var _ in bindingByName) break remove_empty_map;

				delete bindingsByRoot[rootUuid];

			}

		},

		_lendBinding: function (binding) {

			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				lastActiveIndex = this._nActiveBindings++,

				firstInactiveBinding = bindings[lastActiveIndex];

			binding._cacheIndex = lastActiveIndex;
			bindings[lastActiveIndex] = binding;

			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[prevIndex] = firstInactiveBinding;

		},

		_takeBackBinding: function (binding) {

			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				firstInactiveIndex = --this._nActiveBindings,

				lastActiveBinding = bindings[firstInactiveIndex];

			binding._cacheIndex = firstInactiveIndex;
			bindings[firstInactiveIndex] = binding;

			lastActiveBinding._cacheIndex = prevIndex;
			bindings[prevIndex] = lastActiveBinding;

		},


		// Memory management of Interpolants for weight and time scale

		_lendControlInterpolant: function () {

			var interpolants = this._controlInterpolants,
				lastActiveIndex = this._nActiveControlInterpolants++,
				interpolant = interpolants[lastActiveIndex];

			if (interpolant === undefined) {

				interpolant = new THREE.LinearInterpolant(
					new Float32Array(2), new Float32Array(2),
					1, this._controlInterpolantsResultBuffer);

				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[lastActiveIndex] = interpolant;

			}

			return interpolant;

		},

		_takeBackControlInterpolant: function (interpolant) {

			var interpolants = this._controlInterpolants,
				prevIndex = interpolant.__cacheIndex,

				firstInactiveIndex = --this._nActiveControlInterpolants,

				lastActiveInterpolant = interpolants[firstInactiveIndex];

			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[firstInactiveIndex] = interpolant;

			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[prevIndex] = lastActiveInterpolant;

		},

		_controlInterpolantsResultBuffer: new Float32Array(1)

	});

	// File:src/animation/AnimationObjectGroup.js

	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 * 	-	Add objects you would otherwise pass as 'root' to the
	 * 		constructor or the .clipAction method of AnimationMixer.
	 *
	 * 	-	Instead pass this object as 'root'.
	 *
	 * 	-	You can also add and remove objects later when the mixer
	 * 		is running.
	 *
	 * Note:
	 *
	 *  	Objects of this class appear as one object to the mixer,
	 *  	so cache control of the individual objects must be done
	 *  	on the group.
	 *
	 * Limitation:
	 *
	 * 	- 	The animated properties must be compatible among the
	 * 		all objects in the group.
	 *
	 *  -	A single property can either be controlled through a
	 *  	target group or directly, but not both.
	 *
	 * @author tschw
	 */

	THREE.AnimationObjectGroup = function (var_args) {

		this.uuid = THREE.Math.generateUUID();

		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call(arguments);

		this.nCachedObjects_ = 0;			// threshold
		// note: read by PropertyBinding.Composite

		var indices = {};
		this._indicesByUUID = indices;		// for bookkeeping

		for (var i = 0, n = arguments.length; i !== n; ++i) {

			indices[arguments[i].uuid] = i;

		}

		this._paths = [];					// inside: string
		this._parsedPaths = [];				// inside: { we don't care, here }
		this._bindings = []; 				// inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

		var scope = this;

		this.stats = {

			objects: {
				get total() { return scope._objects.length; },
				get inUse() { return this.total - scope.nCachedObjects_; }
			},

			get bindingsPerObject() { return scope._bindings.length; }

		};

	};

	THREE.AnimationObjectGroup.prototype = {

		constructor: THREE.AnimationObjectGroup,

		add: function (var_args) {

			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				nBindings = bindings.length;

			for (var i = 0, n = arguments.length; i !== n; ++i) {

				var object = arguments[i],
					uuid = object.uuid,
					index = indicesByUUID[uuid];

				if (index === undefined) {

					// unknown object -> add it to the ACTIVE region

					index = nObjects++;
					indicesByUUID[uuid] = index;
					objects.push(object);

					// accounting is done, now do the same for all bindings

					for (var j = 0, m = nBindings; j !== m; ++j) {

						bindings[j].push(
							new THREE.PropertyBinding(
								object, paths[j], parsedPaths[j]));

					}

				} else if (index < nCachedObjects) {

					var knownObject = objects[index];

					// move existing object to the ACTIVE region

					var firstActiveIndex = --nCachedObjects,
						lastCachedObject = objects[firstActiveIndex];

					indicesByUUID[lastCachedObject.uuid] = index;
					objects[index] = lastCachedObject;

					indicesByUUID[uuid] = firstActiveIndex;
					objects[firstActiveIndex] = object;

					// accounting is done, now do the same for all bindings

					for (var j = 0, m = nBindings; j !== m; ++j) {

						var bindingsForPath = bindings[j],
							lastCached = bindingsForPath[firstActiveIndex],
							binding = bindingsForPath[index];

						bindingsForPath[index] = lastCached;

						if (binding === undefined) {

							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist

							binding = new THREE.PropertyBinding(
								object, paths[j], parsedPaths[j]);

						}

						bindingsForPath[firstActiveIndex] = binding;

					}

				} else if (objects[index] !== knownObject) {

					//console.error( "Different objects with the same UUID " +
					//		"detected. Clean the caches or recreate your " +
					//		"infrastructure when reloading scenes..." );

				} // else the object is already where we want it to be

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		remove: function (var_args) {

			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;

			for (var i = 0, n = arguments.length; i !== n; ++i) {

				var object = arguments[i],
					uuid = object.uuid,
					index = indicesByUUID[uuid];

				if (index !== undefined && index >= nCachedObjects) {

					// move existing object into the CACHED region

					var lastCachedIndex = nCachedObjects++,
						firstActiveObject = objects[lastCachedIndex];

					indicesByUUID[firstActiveObject.uuid] = index;
					objects[index] = firstActiveObject;

					indicesByUUID[uuid] = lastCachedIndex;
					objects[lastCachedIndex] = object;

					// accounting is done, now do the same for all bindings

					for (var j = 0, m = nBindings; j !== m; ++j) {

						var bindingsForPath = bindings[j],
							firstActive = bindingsForPath[lastCachedIndex],
							binding = bindingsForPath[index];

						bindingsForPath[index] = firstActive;
						bindingsForPath[lastCachedIndex] = binding;

					}

				}

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		// remove & forget
		uncache: function (var_args) {

			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;

			for (var i = 0, n = arguments.length; i !== n; ++i) {

				var object = arguments[i],
					uuid = object.uuid,
					index = indicesByUUID[uuid];

				if (index !== undefined) {

					delete indicesByUUID[uuid];

					if (index < nCachedObjects) {

						// object is cached, shrink the CACHED region

						var firstActiveIndex = --nCachedObjects,
							lastCachedObject = objects[firstActiveIndex],
							lastIndex = --nObjects,
							lastObject = objects[lastIndex];

						// last cached object takes this object's place
						indicesByUUID[lastCachedObject.uuid] = index;
						objects[index] = lastCachedObject;

						// last object goes to the activated slot and pop
						indicesByUUID[lastObject.uuid] = firstActiveIndex;
						objects[firstActiveIndex] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for (var j = 0, m = nBindings; j !== m; ++j) {

							var bindingsForPath = bindings[j],
								lastCached = bindingsForPath[firstActiveIndex],
								last = bindingsForPath[lastIndex];

							bindingsForPath[index] = lastCached;
							bindingsForPath[firstActiveIndex] = last;
							bindingsForPath.pop();

						}

					} else {

						// object is active, just swap with the last and pop

						var lastIndex = --nObjects,
							lastObject = objects[lastIndex];

						indicesByUUID[lastObject.uuid] = index;
						objects[index] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for (var j = 0, m = nBindings; j !== m; ++j) {

							var bindingsForPath = bindings[j];

							bindingsForPath[index] = bindingsForPath[lastIndex];
							bindingsForPath.pop();

						}

					} // cached or active

				} // if object is known

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		// Internal interface used by befriended PropertyBinding.Composite:

		subscribe_: function (path, parsedPath) {
			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group

			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[path],
				bindings = this._bindings;

			if (index !== undefined) return bindings[index];

			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				bindingsForPath = new Array(nObjects);

			index = bindings.length;

			indicesByPath[path] = index;

			paths.push(path);
			parsedPaths.push(parsedPath);
			bindings.push(bindingsForPath);

			for (var i = nCachedObjects,
				n = objects.length; i !== n; ++i) {

				var object = objects[i];

				bindingsForPath[i] =
					new THREE.PropertyBinding(object, path, parsedPath);

			}

			return bindingsForPath;

		},

		unsubscribe_: function (path) {
			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'

			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[path];

			if (index !== undefined) {

				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					lastBindingsIndex = bindings.length - 1,
					lastBindings = bindings[lastBindingsIndex],
					lastBindingsPath = path[lastBindingsIndex];

				indicesByPath[lastBindingsPath] = index;

				bindings[index] = lastBindings;
				bindings.pop();

				parsedPaths[index] = parsedPaths[lastBindingsIndex];
				parsedPaths.pop();

				paths[index] = paths[lastBindingsIndex];
				paths.pop();

			}

		}

	};


	// File:src/animation/AnimationUtils.js

	/**
	 * @author tschw
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	THREE.AnimationUtils = {

		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function (array, from, to) {

			if (THREE.AnimationUtils.isTypedArray(array)) {

				return new array.constructor(array.subarray(from, to));

			}

			return array.slice(from, to);

		},

		// converts an array to a specific type
		convertArray: function (array, type, forceClone) {

			if (!array || // let 'undefined' and 'null' pass
				!forceClone && array.constructor === type) return array;

			if (typeof type.BYTES_PER_ELEMENT === 'number') {

				return new type(array); // create typed array

			}

			return Array.prototype.slice.call(array); // create Array

		},

		isTypedArray: function (object) {

			return ArrayBuffer.isView(object) &&
				!(object instanceof DataView);

		},

		// returns an array by which times and values can be sorted
		getKeyframeOrder: function (times) {

			function compareTime(i, j) {

				return times[i] - times[j];

			}

			var n = times.length;
			var result = new Array(n);
			for (var i = 0; i !== n; ++i) result[i] = i;

			result.sort(compareTime);

			return result;

		},

		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function (values, stride, order) {

			var nValues = values.length;
			var result = new values.constructor(nValues);

			for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {

				var srcOffset = order[i] * stride;

				for (var j = 0; j !== stride; ++j) {

					result[dstOffset++] = values[srcOffset + j];

				}

			}

			return result;

		},

		// function for parsing AOS keyframe formats
		flattenJSON: function (jsonKeys, times, values, valuePropertyName) {

			var i = 1, key = jsonKeys[0];

			while (key !== undefined && key[valuePropertyName] === undefined) {

				key = jsonKeys[i++];

			}

			if (key === undefined) return; // no data

			var value = key[valuePropertyName];
			if (value === undefined) return; // no data

			if (Array.isArray(value)) {

				do {

					value = key[valuePropertyName];

					if (value !== undefined) {

						times.push(key.time);
						values.push.apply(values, value); // push all elements

					}

					key = jsonKeys[i++];

				} while (key !== undefined);

			} else if (value.toArray !== undefined) {
				// ...assume THREE.Math-ish

				do {

					value = key[valuePropertyName];

					if (value !== undefined) {

						times.push(key.time);
						value.toArray(values, values.length);

					}

					key = jsonKeys[i++];

				} while (key !== undefined);

			} else {
				// otherwise push as-is

				do {

					value = key[valuePropertyName];

					if (value !== undefined) {

						times.push(key.time);
						values.push(value);

					}

					key = jsonKeys[i++];

				} while (key !== undefined);

			}

		}

	};

	// File:src/animation/KeyframeTrack.js

	/**
	 *
	 * A timed sequence of keyframes for a specific property.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	THREE.KeyframeTrack = function (name, times, values, interpolation) {

		if (name === undefined) throw new Error("track name is undefined");

		if (times === undefined || times.length === 0) {

			throw new Error("no keyframes in track named " + name);

		}

		this.name = name;

		this.times = THREE.AnimationUtils.convertArray(times, this.TimeBufferType);
		this.values = THREE.AnimationUtils.convertArray(values, this.ValueBufferType);

		this.setInterpolation(interpolation || this.DefaultInterpolation);

		this.validate();
		this.optimize();

	};

	THREE.KeyframeTrack.prototype = {

		constructor: THREE.KeyframeTrack,

		TimeBufferType: Float32Array,
		ValueBufferType: Float32Array,

		DefaultInterpolation: THREE.InterpolateLinear,

		InterpolantFactoryMethodDiscrete: function (result) {

			return new THREE.DiscreteInterpolant(
				this.times, this.values, this.getValueSize(), result);

		},

		InterpolantFactoryMethodLinear: function (result) {

			return new THREE.LinearInterpolant(
				this.times, this.values, this.getValueSize(), result);

		},

		InterpolantFactoryMethodSmooth: function (result) {

			return new THREE.CubicInterpolant(
				this.times, this.values, this.getValueSize(), result);

		},

		setInterpolation: function (interpolation) {

			var factoryMethod;

			switch (interpolation) {

				case THREE.InterpolateDiscrete:

					factoryMethod = this.InterpolantFactoryMethodDiscrete;

					break;

				case THREE.InterpolateLinear:

					factoryMethod = this.InterpolantFactoryMethodLinear;

					break;

				case THREE.InterpolateSmooth:

					factoryMethod = this.InterpolantFactoryMethodSmooth;

					break;

			}

			if (factoryMethod === undefined) {

				var message = "unsupported interpolation for " +
					this.ValueTypeName + " keyframe track named " + this.name;

				if (this.createInterpolant === undefined) {

					// fall back to default, unless the default itself is messed up
					if (interpolation !== this.DefaultInterpolation) {

						this.setInterpolation(this.DefaultInterpolation);

					} else {

						throw new Error(message); // fatal, in this case

					}

				}

				//console.warn( message );
				return;

			}

			this.createInterpolant = factoryMethod;

		},

		getInterpolation: function () {

			switch (this.createInterpolant) {

				case this.InterpolantFactoryMethodDiscrete:

					return THREE.InterpolateDiscrete;

				case this.InterpolantFactoryMethodLinear:

					return THREE.InterpolateLinear;

				case this.InterpolantFactoryMethodSmooth:

					return THREE.InterpolateSmooth;

			}

		},

		getValueSize: function () {

			return this.values.length / this.times.length;

		},

		// move all keyframes either forwards or backwards in time
		shift: function (timeOffset) {

			if (timeOffset !== 0.0) {

				var times = this.times;

				for (var i = 0, n = times.length; i !== n; ++i) {

					times[i] += timeOffset;

				}

			}

			return this;

		},

		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale: function (timeScale) {

			if (timeScale !== 1.0) {

				var times = this.times;

				for (var i = 0, n = times.length; i !== n; ++i) {

					times[i] *= timeScale;

				}

			}

			return this;

		},

		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim: function (startTime, endTime) {

			var times = this.times,
				nKeys = times.length,
				from = 0,
				to = nKeys - 1;

			while (from !== nKeys && times[from] < startTime) ++from;
			while (to !== -1 && times[to] > endTime) --to;

			++to; // inclusive -> exclusive bound

			if (from !== 0 || to !== nKeys) {

				// empty tracks are forbidden, so keep at least one keyframe
				if (from >= to) to = Math.max(to, 1), from = to - 1;

				var stride = this.getValueSize();
				this.times = THREE.AnimationUtils.arraySlice(times, from, to);
				this.values = THREE.AnimationUtils.
					arraySlice(this.values, from * stride, to * stride);

			}

			return this;

		},

		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate: function () {

			var valid = true;

			var valueSize = this.getValueSize();
			if (valueSize - Math.floor(valueSize) !== 0) {

				//console.error( "invalid value size in track", this );
				valid = false;

			}

			var times = this.times,
				values = this.values,

				nKeys = times.length;

			if (nKeys === 0) {

				//console.error( "track is empty", this );
				valid = false;

			}

			var prevTime = null;

			for (var i = 0; i !== nKeys; i++) {

				var currTime = times[i];

				if (typeof currTime === 'number' && isNaN(currTime)) {

					//console.error( "time is not a valid number", this, i, currTime );
					valid = false;
					break;

				}

				if (prevTime !== null && prevTime > currTime) {

					//console.error( "out of order keys", this, i, currTime, prevTime );
					valid = false;
					break;

				}

				prevTime = currTime;

			}

			if (values !== undefined) {

				if (THREE.AnimationUtils.isTypedArray(values)) {

					for (var i = 0, n = values.length; i !== n; ++i) {

						var value = values[i];

						if (isNaN(value)) {

							//console.error( "value is not a valid number", this, i, value );
							valid = false;
							break;

						}

					}

				}

			}

			return valid;

		},

		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		optimize: function () {

			var times = this.times,
				values = this.values,
				stride = this.getValueSize(),

				writeIndex = 1;

			for (var i = 1, n = times.length - 1; i <= n; ++i) {

				var keep = false;

				var time = times[i];
				var timeNext = times[i + 1];

				// remove adjacent keyframes scheduled at the same time

				if (time !== timeNext && (i !== 1 || time !== time[0])) {

					// remove unnecessary keyframes same as their neighbors
					var offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for (var j = 0; j !== stride; ++j) {

						var value = values[offset + j];

						if (value !== values[offsetP + j] ||
							value !== values[offsetN + j]) {

							keep = true;
							break;

						}

					}

				}

				// in-place compaction

				if (keep) {

					if (i !== writeIndex) {

						times[writeIndex] = times[i];

						var readOffset = i * stride,
							writeOffset = writeIndex * stride;

						for (var j = 0; j !== stride; ++j) {

							values[writeOffset + j] = values[readOffset + j];

						}


					}

					++writeIndex;

				}

			}

			if (writeIndex !== times.length) {

				this.times = THREE.AnimationUtils.arraySlice(times, 0, writeIndex);
				this.values = THREE.AnimationUtils.arraySlice(values, 0, writeIndex * stride);

			}

			return this;

		}

	};

	// Static methods:

	Object.assign(THREE.KeyframeTrack, {

		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):

		parse: function (json) {

			if (json.type === undefined) {

				throw new Error("track type undefined, can not parse");

			}

			var trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName(json.type);

			if (json.times === undefined) {

				var times = [], values = [];

				THREE.AnimationUtils.flattenJSON(json.keys, times, values, 'value');

				json.times = times;
				json.values = values;

			}

			// derived classes can define a static parse method
			if (trackType.parse !== undefined) {

				return trackType.parse(json);

			} else {

				// by default, we asssume a constructor compatible with the base
				return new trackType(
					json.name, json.times, json.values, json.interpolation);

			}

		},

		toJSON: function (track) {

			var trackType = track.constructor;

			var json;

			// derived classes can define a static toJSON method
			if (trackType.toJSON !== undefined) {

				json = trackType.toJSON(track);

			} else {

				// by default, we assume the data can be serialized as-is
				json = {

					'name': track.name,
					'times': THREE.AnimationUtils.convertArray(track.times, Array),
					'values': THREE.AnimationUtils.convertArray(track.values, Array)

				};

				var interpolation = track.getInterpolation();

				if (interpolation !== track.DefaultInterpolation) {

					json.interpolation = interpolation;

				}

			}

			json.type = track.ValueTypeName; // mandatory

			return json;

		},

		_getTrackTypeForValueTypeName: function (typeName) {

			switch (typeName.toLowerCase()) {

				case "scalar":
				case "double":
				case "float":
				case "number":
				case "integer":

					return THREE.NumberKeyframeTrack;

				case "vector":
				case "vector2":
				case "vector3":
				case "vector4":

					return THREE.VectorKeyframeTrack;

				case "color":

					return THREE.ColorKeyframeTrack;

				case "quaternion":

					return THREE.QuaternionKeyframeTrack;

				case "bool":
				case "boolean":

					return THREE.BooleanKeyframeTrack;

				case "string":

					return THREE.StringKeyframeTrack;

			}

			throw new Error("Unsupported typeName: " + typeName);

		}

	});

	// File:src/animation/PropertyBinding.js

	/**
	 *
	 * A reference to a real property in the scene graph.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	THREE.PropertyBinding = function (rootNode, path, parsedPath) {

		this.path = path;
		this.parsedPath = parsedPath ||
			THREE.PropertyBinding.parseTrackName(path);

		this.node = THREE.PropertyBinding.findNode(
			rootNode, this.parsedPath.nodeName) || rootNode;

		this.rootNode = rootNode;

	};

	THREE.PropertyBinding.prototype = {

		constructor: THREE.PropertyBinding,

		getValue: function getValue_unbound(targetArray, offset) {

			this.bind();
			this.getValue(targetArray, offset);

			// Note: This class uses a State pattern on a per-method basis:
			// 'bind' sets 'this.getValue' / 'setValue' and shadows the
			// prototype version of these methods with one that represents
			// the bound state. When the property is not found, the methods
			// become no-ops.

		},

		setValue: function getValue_unbound(sourceArray, offset) {

			this.bind();
			this.setValue(sourceArray, offset);

		},

		// create getter / setter pair for a property in the scene graph
		bind: function () {

			var targetObject = this.node,
				parsedPath = this.parsedPath,

				objectName = parsedPath.objectName,
				propertyName = parsedPath.propertyName,
				propertyIndex = parsedPath.propertyIndex;

			if (!targetObject) {

				targetObject = THREE.PropertyBinding.findNode(
					this.rootNode, parsedPath.nodeName) || this.rootNode;

				this.node = targetObject;

			}

			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;

			// ensure there is a value node
			if (!targetObject) {

				//console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
				return;

			}

			if (objectName) {

				var objectIndex = parsedPath.objectIndex;

				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch (objectName) {

					case 'materials':

						if (!targetObject.material) {

							//console.error( '  can not bind to material as node does not have a material', this );
							return;

						}

						if (!targetObject.material.materials) {

							//console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
							return;

						}

						targetObject = targetObject.material.materials;

						break;

					case 'bones':

						if (!targetObject.skeleton) {

							//console.error( '  can not bind to bones as node does not have a skeleton', this );
							return;

						}

						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.

						targetObject = targetObject.skeleton.bones;

						// support resolving morphTarget names into indices.
						for (var i = 0; i < targetObject.length; i++) {

							if (targetObject[i].name === objectIndex) {

								objectIndex = i;
								break;

							}

						}

						break;

					default:

						if (targetObject[objectName] === undefined) {

							//console.error( '  can not bind to objectName of node, undefined', this );
							return;

						}

						targetObject = targetObject[objectName];

				}


				if (objectIndex !== undefined) {

					if (targetObject[objectIndex] === undefined) {

						//console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
						return;

					}

					targetObject = targetObject[objectIndex];

				}

			}

			// resolve property
			var nodeProperty = targetObject[propertyName];

			if (nodeProperty === undefined) {

				var nodeName = parsedPath.nodeName;

				//console.error( "  trying to update property for track: " + nodeName + '.' + propertyName + " but it wasn't found.", targetObject );
				return;

			}

			// determine versioning scheme
			var versioning = this.Versioning.None;

			if (targetObject.needsUpdate !== undefined) { // material

				versioning = this.Versioning.NeedsUpdate;
				this.targetObject = targetObject;

			} else if (targetObject.matrixWorldNeedsUpdate !== undefined) { // node transform

				versioning = this.Versioning.MatrixWorldNeedsUpdate;
				this.targetObject = targetObject;

			}

			// determine how the property gets bound
			var bindingType = this.BindingType.Direct;

			if (propertyIndex !== undefined) {
				// access a sub element of the property array (only primitives are supported right now)

				if (propertyName === "morphTargetInfluences") {
					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

					// support resolving morphTarget names into indices.
					if (!targetObject.geometry) {

						//console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
						return;

					}

					if (!targetObject.geometry.morphTargets) {

						//console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
						return;

					}

					for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {

						if (targetObject.geometry.morphTargets[i].name === propertyIndex) {

							propertyIndex = i;
							break;

						}

					}

				}

				bindingType = this.BindingType.ArrayElement;

				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;

			} else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
				// must use copy for Object3D.Euler/Quaternion

				bindingType = this.BindingType.HasFromToArray;

				this.resolvedProperty = nodeProperty;

			} else if (nodeProperty.length !== undefined) {

				bindingType = this.BindingType.EntireArray;

				this.resolvedProperty = nodeProperty;

			} else {

				this.propertyName = propertyName;

			}

			// select getter / setter
			this.getValue = this.GetterByBindingType[bindingType];
			this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];

		},

		unbind: function () {

			this.node = null;

			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;

		}

	};

	Object.assign(THREE.PropertyBinding.prototype, { // prototype, continued

		// these are used to "bind" a nonexistent property
		_getValue_unavailable: function () { },
		_setValue_unavailable: function () { },

		// initial state of these methods that calls 'bind'
		_getValue_unbound: THREE.PropertyBinding.prototype.getValue,
		_setValue_unbound: THREE.PropertyBinding.prototype.setValue,

		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3
		},

		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2
		},

		GetterByBindingType: [

			function getValue_direct(buffer, offset) {

				buffer[offset] = this.node[this.propertyName];

			},

			function getValue_array(buffer, offset) {

				var source = this.resolvedProperty;

				for (var i = 0, n = source.length; i !== n; ++i) {

					buffer[offset++] = source[i];

				}

			},

			function getValue_arrayElement(buffer, offset) {

				buffer[offset] = this.resolvedProperty[this.propertyIndex];

			},

			function getValue_toArray(buffer, offset) {

				this.resolvedProperty.toArray(buffer, offset);

			}

		],

		SetterByBindingTypeAndVersioning: [

			[
				// Direct

				function setValue_direct(buffer, offset) {

					this.node[this.propertyName] = buffer[offset];

				},

				function setValue_direct_setNeedsUpdate(buffer, offset) {

					this.node[this.propertyName] = buffer[offset];
					this.targetObject.needsUpdate = true;

				},

				function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {

					this.node[this.propertyName] = buffer[offset];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// EntireArray

				function setValue_array(buffer, offset) {

					var dest = this.resolvedProperty;

					for (var i = 0, n = dest.length; i !== n; ++i) {

						dest[i] = buffer[offset++];

					}

				},

				function setValue_array_setNeedsUpdate(buffer, offset) {

					var dest = this.resolvedProperty;

					for (var i = 0, n = dest.length; i !== n; ++i) {

						dest[i] = buffer[offset++];

					}

					this.targetObject.needsUpdate = true;

				},

				function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {

					var dest = this.resolvedProperty;

					for (var i = 0, n = dest.length; i !== n; ++i) {

						dest[i] = buffer[offset++];

					}

					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// ArrayElement

				function setValue_arrayElement(buffer, offset) {

					this.resolvedProperty[this.propertyIndex] = buffer[offset];

				},

				function setValue_arrayElement_setNeedsUpdate(buffer, offset) {

					this.resolvedProperty[this.propertyIndex] = buffer[offset];
					this.targetObject.needsUpdate = true;

				},

				function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {

					this.resolvedProperty[this.propertyIndex] = buffer[offset];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// HasToFromArray

				function setValue_fromArray(buffer, offset) {

					this.resolvedProperty.fromArray(buffer, offset);

				},

				function setValue_fromArray_setNeedsUpdate(buffer, offset) {

					this.resolvedProperty.fromArray(buffer, offset);
					this.targetObject.needsUpdate = true;

				},

				function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {

					this.resolvedProperty.fromArray(buffer, offset);
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			]

		]

	});

	THREE.PropertyBinding.Composite =
		function (targetGroup, path, optionalParsedPath) {

			var parsedPath = optionalParsedPath ||
				THREE.PropertyBinding.parseTrackName(path);

			this._targetGroup = targetGroup;
			this._bindings = targetGroup.subscribe_(path, parsedPath);

		};

	THREE.PropertyBinding.Composite.prototype = {

		constructor: THREE.PropertyBinding.Composite,

		getValue: function (array, offset) {

			this.bind(); // bind all binding

			var firstValidIndex = this._targetGroup.nCachedObjects_,
				binding = this._bindings[firstValidIndex];

			// and only call .getValue on the first
			if (binding !== undefined) binding.getValue(array, offset);

		},

		setValue: function (array, offset) {

			var bindings = this._bindings;

			for (var i = this._targetGroup.nCachedObjects_,
				n = bindings.length; i !== n; ++i) {

				bindings[i].setValue(array, offset);

			}

		},

		bind: function () {

			var bindings = this._bindings;

			for (var i = this._targetGroup.nCachedObjects_,
				n = bindings.length; i !== n; ++i) {

				bindings[i].bind();

			}

		},

		unbind: function () {

			var bindings = this._bindings;

			for (var i = this._targetGroup.nCachedObjects_,
				n = bindings.length; i !== n; ++i) {

				bindings[i].unbind();

			}

		}

	};

	THREE.PropertyBinding.create = function (root, path, parsedPath) {

		if (!(root instanceof THREE.AnimationObjectGroup)) {

			return new THREE.PropertyBinding(root, path, parsedPath);

		} else {

			return new THREE.PropertyBinding.Composite(root, path, parsedPath);

		}

	};

	THREE.PropertyBinding.parseTrackName = function (trackName) {

		// matches strings in the form of:
		//    nodeName.property
		//    nodeName.property[accessor]
		//    nodeName.material.property[accessor]
		//    uuid.property[accessor]
		//    uuid.objectName[objectIndex].propertyName[propertyIndex]
		//    parentName/nodeName.property
		//    parentName/parentName/nodeName.property[index]
		//	  .bone[Armature.DEF_cog].position
		// created and tested via https://regex101.com/#javascript

		var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_.:\- ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/;
		var matches = re.exec(trackName);

		if (!matches) {

			throw new Error("cannot parse trackName at all: " + trackName);

		}

		if (matches.index === re.lastIndex) {

			re.lastIndex++;

		}

		var results = {
			// directoryName: matches[ 1 ], // (tschw) currently unused
			nodeName: matches[3], 	// allowed to be null, specified root node.
			objectName: matches[5],
			objectIndex: matches[7],
			propertyName: matches[9],
			propertyIndex: matches[11]	// allowed to be null, specifies that the whole property is set.
		};

		if (results.propertyName === null || results.propertyName.length === 0) {

			throw new Error("can not parse propertyName from trackName: " + trackName);

		}

		return results;

	};

	THREE.PropertyBinding.findNode = function (root, nodeName) {

		if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {

			return root;

		}

		// search into skeleton bones.
		if (root.skeleton) {

			var searchSkeleton = function (skeleton) {

				for (var i = 0; i < skeleton.bones.length; i++) {

					var bone = skeleton.bones[i];

					if (bone.name === nodeName) {

						return bone;

					}
				}

				return null;

			};

			var bone = searchSkeleton(root.skeleton);

			if (bone) {

				return bone;

			}
		}

		// search into node subtree.
		if (root.children) {

			var searchNodeSubtree = function (children) {

				for (var i = 0; i < children.length; i++) {

					var childNode = children[i];

					if (childNode.name === nodeName || childNode.uuid === nodeName) {

						return childNode;

					}

					var result = searchNodeSubtree(childNode.children);

					if (result) return result;

				}

				return null;

			};

			var subTreeNode = searchNodeSubtree(root.children);

			if (subTreeNode) {

				return subTreeNode;

			}

		}

		return null;

	};

	// File:src/animation/PropertyMixer.js

	/**
	 *
	 * Buffered scene graph property that allows weighted accumulation.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	THREE.PropertyMixer = function (binding, typeName, valueSize) {

		this.binding = binding;
		this.valueSize = valueSize;

		var bufferType = Float64Array,
			mixFunction;

		switch (typeName) {

			case 'quaternion': mixFunction = this._slerp; break;

			case 'string':
			case 'bool':

				bufferType = Array, mixFunction = this._select; break;

			default: mixFunction = this._lerp;

		}

		this.buffer = new bufferType(valueSize * 4);
		// layout: [ incoming | accu0 | accu1 | orig ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property

		this._mixBufferRegion = mixFunction;

		this.cumulativeWeight = 0;

		this.useCount = 0;
		this.referenceCount = 0;

	};

	THREE.PropertyMixer.prototype = {

		constructor: THREE.PropertyMixer,

		// accumulate data in the 'incoming' region into 'accu<i>'
		accumulate: function (accuIndex, weight) {

			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place

			var buffer = this.buffer,
				stride = this.valueSize,
				offset = accuIndex * stride + stride,

				currentWeight = this.cumulativeWeight;

			if (currentWeight === 0) {

				// accuN := incoming * weight

				for (var i = 0; i !== stride; ++i) {

					buffer[offset + i] = buffer[i];

				}

				currentWeight = weight;

			} else {

				// accuN := accuN + incoming * weight

				currentWeight += weight;
				var mix = weight / currentWeight;
				this._mixBufferRegion(buffer, offset, 0, mix, stride);

			}

			this.cumulativeWeight = currentWeight;

		},

		// apply the state of 'accu<i>' to the binding when accus differ
		apply: function (accuIndex) {

			var stride = this.valueSize,
				buffer = this.buffer,
				offset = accuIndex * stride + stride,

				weight = this.cumulativeWeight,

				binding = this.binding;

			this.cumulativeWeight = 0;

			if (weight < 1) {

				// accuN := accuN + original * ( 1 - cumulativeWeight )

				var originalValueOffset = stride * 3;

				this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride);

			}

			for (var i = stride, e = stride + stride; i !== e; ++i) {

				if (buffer[i] !== buffer[i + stride]) {

					// value has changed -> update scene graph

					binding.setValue(buffer, offset);
					break;

				}

			}

		},

		// remember the state of the bound property and copy it to both accus
		saveOriginalState: function () {

			var binding = this.binding;

			var buffer = this.buffer,
				stride = this.valueSize,

				originalValueOffset = stride * 3;

			binding.getValue(buffer, originalValueOffset);

			// accu[0..1] := orig -- initially detect changes against the original
			for (var i = stride, e = originalValueOffset; i !== e; ++i) {

				buffer[i] = buffer[originalValueOffset + (i % stride)];

			}

			this.cumulativeWeight = 0;

		},

		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState: function () {

			var originalValueOffset = this.valueSize * 3;
			this.binding.setValue(this.buffer, originalValueOffset);

		},


		// mix functions

		_select: function (buffer, dstOffset, srcOffset, t, stride) {

			if (t >= 0.5) {

				for (var i = 0; i !== stride; ++i) {

					buffer[dstOffset + i] = buffer[srcOffset + i];

				}

			}

		},

		_slerp: function (buffer, dstOffset, srcOffset, t, stride) {

			THREE.Quaternion.slerpFlat(buffer, dstOffset,
				buffer, dstOffset, buffer, srcOffset, t);

		},

		_lerp: function (buffer, dstOffset, srcOffset, t, stride) {

			var s = 1 - t;

			for (var i = 0; i !== stride; ++i) {

				var j = dstOffset + i;

				buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;

			}

		}

	};

	// File:src/animation/tracks/BooleanKeyframeTrack.js

	/**
	 *
	 * A Track of Boolean keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	THREE.BooleanKeyframeTrack = function (name, times, values) {

		THREE.KeyframeTrack.call(this, name, times, values);

	};

	THREE.BooleanKeyframeTrack.prototype =
		Object.assign(Object.create(THREE.KeyframeTrack.prototype), {

			constructor: THREE.BooleanKeyframeTrack,

			ValueTypeName: 'bool',
			ValueBufferType: Array,

			DefaultInterpolation: THREE.InterpolateDiscrete,

			InterpolantFactoryMethodLinear: undefined,
			InterpolantFactoryMethodSmooth: undefined

			// Note: Actually this track could have a optimized / compressed
			// representation of a single value and a custom interpolant that
			// computes "firstValue ^ isOdd( index )".

		});

	// File:src/animation/tracks/ColorKeyframeTrack.js

	/**
	 *
	 * A Track of keyframe values that represent color.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	THREE.ColorKeyframeTrack = function (name, times, values, interpolation) {

		THREE.KeyframeTrack.call(this, name, times, values, interpolation);

	};

	THREE.ColorKeyframeTrack.prototype =
		Object.assign(Object.create(THREE.KeyframeTrack.prototype), {

			constructor: THREE.ColorKeyframeTrack,

			ValueTypeName: 'color'

			// ValueBufferType is inherited

			// DefaultInterpolation is inherited


			// Note: Very basic implementation and nothing special yet.
			// However, this is the place for color space parameterization.

		});

	// File:src/animation/tracks/NumberKeyframeTrack.js

	/**
	 *
	 * A Track of numeric keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	THREE.NumberKeyframeTrack = function (name, times, values, interpolation) {

		THREE.KeyframeTrack.call(this, name, times, values, interpolation);

	};

	THREE.NumberKeyframeTrack.prototype =
		Object.assign(Object.create(THREE.KeyframeTrack.prototype), {

			constructor: THREE.NumberKeyframeTrack,

			ValueTypeName: 'number',

			// ValueBufferType is inherited

			// DefaultInterpolation is inherited

		});

	// File:src/animation/tracks/QuaternionKeyframeTrack.js

	/**
	 *
	 * A Track of quaternion keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	THREE.QuaternionKeyframeTrack = function (name, times, values, interpolation) {

		THREE.KeyframeTrack.call(this, name, times, values, interpolation);

	};

	THREE.QuaternionKeyframeTrack.prototype =
		Object.assign(Object.create(THREE.KeyframeTrack.prototype), {

			constructor: THREE.QuaternionKeyframeTrack,

			ValueTypeName: 'quaternion',

			// ValueBufferType is inherited

			DefaultInterpolation: THREE.InterpolateLinear,

			InterpolantFactoryMethodLinear: function (result) {

				return new THREE.QuaternionLinearInterpolant(
					this.times, this.values, this.getValueSize(), result);

			},

			InterpolantFactoryMethodSmooth: undefined // not yet implemented

		});

	// File:src/animation/tracks/StringKeyframeTrack.js

	/**
	 *
	 * A Track that interpolates Strings
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	THREE.StringKeyframeTrack = function (name, times, values, interpolation) {

		THREE.KeyframeTrack.call(this, name, times, values, interpolation);

	};

	THREE.StringKeyframeTrack.prototype =
		Object.assign(Object.create(THREE.KeyframeTrack.prototype), {

			constructor: THREE.StringKeyframeTrack,

			ValueTypeName: 'string',
			ValueBufferType: Array,

			DefaultInterpolation: THREE.InterpolateDiscrete,

			InterpolantFactoryMethodLinear: undefined,

			InterpolantFactoryMethodSmooth: undefined

		});

	// File:src/animation/tracks/VectorKeyframeTrack.js

	/**
	 *
	 * A Track of vectored keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	THREE.VectorKeyframeTrack = function (name, times, values, interpolation) {

		THREE.KeyframeTrack.call(this, name, times, values, interpolation);

	};

	THREE.VectorKeyframeTrack.prototype =
		Object.assign(Object.create(THREE.KeyframeTrack.prototype), {

			constructor: THREE.VectorKeyframeTrack,

			ValueTypeName: 'vector'

			// ValueBufferType is inherited

			// DefaultInterpolation is inherited

		});

	// File:src/audio/Audio.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */

	THREE.Audio = function (listener) {

		THREE.Object3D.call(this);

		this.type = 'Audio';

		this.context = listener.context;
		this.source = this.context.createBufferSource();
		this.source.onended = this.onEnded.bind(this);

		this.gain = this.context.createGain();
		this.gain.connect(listener.getInput());

		this.autoplay = false;

		this.startTime = 0;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.sourceType = 'empty';

		this.filters = [];

	};

	THREE.Audio.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {

		constructor: THREE.Audio,

		getOutput: function () {

			return this.gain;

		},

		setNodeSource: function (audioNode) {

			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();

			return this;

		},

		setBuffer: function (audioBuffer) {

			this.source.buffer = audioBuffer;
			this.sourceType = 'buffer';

			if (this.autoplay) this.play();

			return this;

		},

		play: function () {

			if (this.isPlaying === true) {

				//console.warn( 'THREE.Audio: Audio is already playing.' );
				return;

			}

			if (this.hasPlaybackControl === false) {

				//console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			var source = this.context.createBufferSource();

			source.buffer = this.source.buffer;
			source.loop = this.source.loop;
			source.onended = this.source.onended;
			source.start(0, this.startTime);
			source.playbackRate.value = this.playbackRate;

			this.isPlaying = true;

			this.source = source;

			return this.connect();

		},

		pause: function () {

			if (this.hasPlaybackControl === false) {

				//console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.source.stop();
			this.startTime = this.context.currentTime;
			this.isPlaying = false;

			return this;

		},

		stop: function () {

			if (this.hasPlaybackControl === false) {

				//console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.source.stop();
			this.startTime = 0;
			this.isPlaying = false;

			return this;

		},

		connect: function () {

			if (this.filters.length > 0) {

				this.source.connect(this.filters[0]);

				for (var i = 1, l = this.filters.length; i < l; i++) {

					this.filters[i - 1].connect(this.filters[i]);

				}

				this.filters[this.filters.length - 1].connect(this.getOutput());

			} else {

				this.source.connect(this.getOutput());

			}

			return this;

		},

		disconnect: function () {

			if (this.filters.length > 0) {

				this.source.disconnect(this.filters[0]);

				for (var i = 1, l = this.filters.length; i < l; i++) {

					this.filters[i - 1].disconnect(this.filters[i]);

				}

				this.filters[this.filters.length - 1].disconnect(this.getOutput());

			} else {

				this.source.disconnect(this.getOutput());

			}

			return this;

		},

		getFilters: function () {

			return this.filters;

		},

		setFilters: function (value) {

			if (!value) value = [];

			if (this.isPlaying === true) {

				this.disconnect();
				this.filters = value;
				this.connect();

			} else {

				this.filters = value;

			}

			return this;

		},

		getFilter: function () {

			return this.getFilters()[0];

		},

		setFilter: function (filter) {

			return this.setFilters(filter ? [filter] : []);

		},

		setPlaybackRate: function (value) {

			if (this.hasPlaybackControl === false) {

				//console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.playbackRate = value;

			if (this.isPlaying === true) {

				this.source.playbackRate.value = this.playbackRate;

			}

			return this;

		},

		getPlaybackRate: function () {

			return this.playbackRate;

		},

		onEnded: function () {

			this.isPlaying = false;

		},

		getLoop: function () {

			if (this.hasPlaybackControl === false) {

				//console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return false;

			}

			return this.source.loop;

		},

		setLoop: function (value) {

			if (this.hasPlaybackControl === false) {

				//console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.source.loop = value;

		},

		getVolume: function () {

			return this.gain.gain.value;

		},


		setVolume: function (value) {

			this.gain.gain.value = value;

			return this;

		}

	});

	// File:src/audio/AudioAnalyser.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AudioAnalyser = function (audio, fftSize) {

		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

		this.data = new Uint8Array(this.analyser.frequencyBinCount);

		audio.getOutput().connect(this.analyser);

	};

	Object.assign(THREE.AudioAnalyser.prototype, {

		getFrequencyData: function () {

			this.analyser.getByteFrequencyData(this.data);

			return this.data;

		},

		getAverageFrequency: function () {

			var value = 0, data = this.getFrequencyData();

			for (var i = 0; i < data.length; i++) {

				value += data[i];

			}

			return value / data.length;

		}

	});

	// File:src/audio/AudioContext.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	Object.defineProperty(THREE, 'AudioContext', {

		get: (function () {

			var context;

			return function get() {

				if (context === undefined) {

					context = new (window.AudioContext || window.webkitAudioContext)();

				}

				return context;

			};

		})()

	});

	// File:src/audio/PositionalAudio.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.PositionalAudio = function (listener) {

		THREE.Audio.call(this, listener);

		this.panner = this.context.createPanner();
		this.panner.connect(this.gain);

	};

	THREE.PositionalAudio.prototype = Object.assign(Object.create(THREE.Audio.prototype), {

		constructor: THREE.PositionalAudio,

		getOutput: function () {

			return this.panner;

		},

		getRefDistance: function () {

			return this.panner.refDistance;

		},

		setRefDistance: function (value) {

			this.panner.refDistance = value;

		},

		getRolloffFactor: function () {

			return this.panner.rolloffFactor;

		},

		setRolloffFactor: function (value) {

			this.panner.rolloffFactor = value;

		},

		getDistanceModel: function () {

			return this.panner.distanceModel;

		},

		setDistanceModel: function (value) {

			this.panner.distanceModel = value;

		},

		getMaxDistance: function () {

			return this.panner.maxDistance;

		},

		setMaxDistance: function (value) {

			this.panner.maxDistance = value;

		},

		updateMatrixWorld: (function () {

			var position = new THREE.Vector3();

			return function updateMatrixWorld(force) {

				THREE.Object3D.prototype.updateMatrixWorld.call(this, force);

				position.setFromMatrixPosition(this.matrixWorld);

				this.panner.setPosition(position.x, position.y, position.z);

			};

		})()


	});

	// File:src/audio/AudioListener.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AudioListener = function () {

		THREE.Object3D.call(this);

		this.type = 'AudioListener';

		this.context = THREE.AudioContext;

		this.gain = this.context.createGain();
		this.gain.connect(this.context.destination);

		this.filter = null;

	};

	THREE.AudioListener.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {

		constructor: THREE.AudioListener,

		getInput: function () {

			return this.gain;

		},

		removeFilter: function () {

			if (this.filter !== null) {

				this.gain.disconnect(this.filter);
				this.filter.disconnect(this.context.destination);
				this.gain.connect(this.context.destination);
				this.filter = null;

			}

		},

		getFilter: function () {

			return this.filter;

		},

		setFilter: function (value) {

			if (this.filter !== null) {

				this.gain.disconnect(this.filter);
				this.filter.disconnect(this.context.destination);

			} else {

				this.gain.disconnect(this.context.destination);

			}

			this.filter = value;
			this.gain.connect(this.filter);
			this.filter.connect(this.context.destination);

		},

		getMasterVolume: function () {

			return this.gain.gain.value;

		},

		setMasterVolume: function (value) {

			this.gain.gain.value = value;

		},

		updateMatrixWorld: (function () {

			var position = new THREE.Vector3();
			var quaternion = new THREE.Quaternion();
			var scale = new THREE.Vector3();

			var orientation = new THREE.Vector3();

			return function updateMatrixWorld(force) {

				THREE.Object3D.prototype.updateMatrixWorld.call(this, force);

				var listener = this.context.listener;
				var up = this.up;

				this.matrixWorld.decompose(position, quaternion, scale);

				orientation.set(0, 0, - 1).applyQuaternion(quaternion);

				listener.setPosition(position.x, position.y, position.z);
				listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);

			};

		})()

	});

	// File:src/cameras/Camera.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.Camera = function () {

		THREE.Object3D.call(this);

		this.type = 'Camera';

		this.matrixWorldInverse = new THREE.Matrix4();
		this.projectionMatrix = new THREE.Matrix4();

	};

	THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
	THREE.Camera.prototype.constructor = THREE.Camera;

	THREE.Camera.prototype.getWorldDirection = function () {

		var quaternion = new THREE.Quaternion();

		return function getWorldDirection(optionalTarget) {

			var result = optionalTarget || new THREE.Vector3();

			this.getWorldQuaternion(quaternion);

			return result.set(0, 0, - 1).applyQuaternion(quaternion);

		};

	}();

	THREE.Camera.prototype.lookAt = function () {

		// This routine does not support cameras with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function lookAt(vector) {

			m1.lookAt(this.position, vector, this.up);

			this.quaternion.setFromRotationMatrix(m1);

		};

	}();

	THREE.Camera.prototype.clone = function () {

		return new this.constructor().copy(this);

	};

	THREE.Camera.prototype.copy = function (source) {

		THREE.Object3D.prototype.copy.call(this, source);

		this.matrixWorldInverse.copy(source.matrixWorldInverse);
		this.projectionMatrix.copy(source.projectionMatrix);

		return this;

	};

	// File:src/cameras/CubeCamera.js

	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.CubeCamera = function (near, far, cubeResolution) {

		THREE.Object3D.call(this);

		this.type = 'CubeCamera';

		var fov = 90, aspect = 1;

		var cameraPX = new THREE.PerspectiveCamera(fov, aspect, near, far);
		cameraPX.up.set(0, - 1, 0);
		cameraPX.lookAt(new THREE.Vector3(1, 0, 0));
		this.add(cameraPX);

		var cameraNX = new THREE.PerspectiveCamera(fov, aspect, near, far);
		cameraNX.up.set(0, - 1, 0);
		cameraNX.lookAt(new THREE.Vector3(- 1, 0, 0));
		this.add(cameraNX);

		var cameraPY = new THREE.PerspectiveCamera(fov, aspect, near, far);
		cameraPY.up.set(0, 0, 1);
		cameraPY.lookAt(new THREE.Vector3(0, 1, 0));
		this.add(cameraPY);

		var cameraNY = new THREE.PerspectiveCamera(fov, aspect, near, far);
		cameraNY.up.set(0, 0, - 1);
		cameraNY.lookAt(new THREE.Vector3(0, - 1, 0));
		this.add(cameraNY);

		var cameraPZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
		cameraPZ.up.set(0, - 1, 0);
		cameraPZ.lookAt(new THREE.Vector3(0, 0, 1));
		this.add(cameraPZ);

		var cameraNZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
		cameraNZ.up.set(0, - 1, 0);
		cameraNZ.lookAt(new THREE.Vector3(0, 0, - 1));
		this.add(cameraNZ);

		var options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };

		this.renderTarget = new THREE.WebGLRenderTargetCube(cubeResolution, cubeResolution, options);

		this.updateCubeMap = function (renderer, scene) {

			if (this.parent === null) this.updateMatrixWorld();

			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.texture.generateMipmaps;

			renderTarget.texture.generateMipmaps = false;

			renderTarget.activeCubeFace = 0;
			renderer.render(scene, cameraPX, renderTarget);

			renderTarget.activeCubeFace = 1;
			renderer.render(scene, cameraNX, renderTarget);

			renderTarget.activeCubeFace = 2;
			renderer.render(scene, cameraPY, renderTarget);

			renderTarget.activeCubeFace = 3;
			renderer.render(scene, cameraNY, renderTarget);

			renderTarget.activeCubeFace = 4;
			renderer.render(scene, cameraPZ, renderTarget);

			renderTarget.texture.generateMipmaps = generateMipmaps;

			renderTarget.activeCubeFace = 5;
			renderer.render(scene, cameraNZ, renderTarget);

			renderer.setRenderTarget(null);

		};

	};

	THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
	THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

	// File:src/cameras/OrthographicCamera.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author arose / http://github.com/arose
	 */

	THREE.OrthographicCamera = function (left, right, top, bottom, near, far) {

		THREE.Camera.call(this);

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = (near !== undefined) ? near : 0.1;
		this.far = (far !== undefined) ? far : 2000;

		this.updateProjectionMatrix();

	};

	THREE.OrthographicCamera.prototype = Object.assign(Object.create(THREE.Camera.prototype), {

		constructor: THREE.OrthographicCamera,

		copy: function (source) {

			THREE.Camera.prototype.copy.call(this, source);

			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;

			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign({}, source.view);

			return this;

		},

		setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {

			this.view = {
				fullWidth: fullWidth,
				fullHeight: fullHeight,
				offsetX: x,
				offsetY: y,
				width: width,
				height: height
			};

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			this.view = null;
			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			var dx = (this.right - this.left) / (2 * this.zoom);
			var dy = (this.top - this.bottom) / (2 * this.zoom);
			var cx = (this.right + this.left) / 2;
			var cy = (this.top + this.bottom) / 2;

			var left = cx - dx;
			var right = cx + dx;
			var top = cy + dy;
			var bottom = cy - dy;

			if (this.view !== null) {

				var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
				var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
				var scaleW = (this.right - this.left) / this.view.width;
				var scaleH = (this.top - this.bottom) / this.view.height;

				left += scaleW * (this.view.offsetX / zoomW);
				right = left + scaleW * (this.view.width / zoomW);
				top -= scaleH * (this.view.offsetY / zoomH);
				bottom = top - scaleH * (this.view.height / zoomH);

			}

			this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);

		},

		toJSON: function (meta) {

			var data = THREE.Object3D.prototype.toJSON.call(this, meta);

			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;

			if (this.view !== null) data.object.view = Object.assign({}, this.view);

			return data;

		}

	});

	// File:src/cameras/PerspectiveCamera.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author tschw
	 */

	THREE.PerspectiveCamera = function (fov, aspect, near, far) {

		THREE.Camera.call(this);

		this.type = 'PerspectiveCamera';

		this.fov = fov !== undefined ? fov : 50;
		this.zoom = 1;

		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
		this.focus = 10;

		this.aspect = aspect !== undefined ? aspect : 1;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	};

	THREE.PerspectiveCamera.prototype = Object.assign(Object.create(THREE.Camera.prototype), {

		constructor: THREE.PerspectiveCamera,

		copy: function (source) {

			THREE.Camera.prototype.copy.call(this, source);

			this.fov = source.fov;
			this.zoom = source.zoom;

			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;

			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign({}, source.view);

			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;

			return this;

		},

		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength: function (focalLength) {

			// see http://www.bobatkins.com/photography/technical/field_of_view.html
			var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

			this.fov = THREE.Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
			this.updateProjectionMatrix();

		},

		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength: function () {

			var vExtentSlope = Math.tan(THREE.Math.DEG2RAD * 0.5 * this.fov);

			return 0.5 * this.getFilmHeight() / vExtentSlope;

		},

		getEffectiveFOV: function () {

			return THREE.Math.RAD2DEG * 2 * Math.atan(
				Math.tan(THREE.Math.DEG2RAD * 0.5 * this.fov) / this.zoom);

		},

		getFilmWidth: function () {

			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min(this.aspect, 1);

		},

		getFilmHeight: function () {

			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max(this.aspect, 1);

		},

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   var w = 1920;
		 *   var h = 1080;
		 *   var fullWidth = w * 3;
		 *   var fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {

			this.aspect = fullWidth / fullHeight;

			this.view = {
				fullWidth: fullWidth,
				fullHeight: fullHeight,
				offsetX: x,
				offsetY: y,
				width: width,
				height: height
			};

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			this.view = null;
			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			var near = this.near,
				top = near * Math.tan(
					THREE.Math.DEG2RAD * 0.5 * this.fov) / this.zoom,
				height = 2 * top,
				width = this.aspect * height,
				left = - 0.5 * width,
				view = this.view;

			if (view !== null) {

				var fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;

				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;

			}

			var skew = this.filmOffset;
			if (skew !== 0) left += near * skew / this.getFilmWidth();

			this.projectionMatrix.makeFrustum(
				left, left + width, top - height, top, near, this.far);

		},

		toJSON: function (meta) {

			var data = THREE.Object3D.prototype.toJSON.call(this, meta);

			data.object.fov = this.fov;
			data.object.zoom = this.zoom;

			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;

			data.object.aspect = this.aspect;

			if (this.view !== null) data.object.view = Object.assign({}, this.view);

			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;

			return data;

		}

	});

	// File:src/cameras/StereoCamera.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.StereoCamera = function () {

		this.type = 'StereoCamera';

		this.aspect = 1;

		this.cameraL = new THREE.PerspectiveCamera();
		this.cameraL.layers.enable(1);
		this.cameraL.matrixAutoUpdate = false;

		this.cameraR = new THREE.PerspectiveCamera();
		this.cameraR.layers.enable(2);
		this.cameraR.matrixAutoUpdate = false;

	};

	Object.assign(THREE.StereoCamera.prototype, {

		update: (function () {

			var focus, fov, aspect, near, far;

			var eyeRight = new THREE.Matrix4();
			var eyeLeft = new THREE.Matrix4();

			return function update(camera) {

				var needsUpdate = focus !== camera.focus || fov !== camera.fov ||
					aspect !== camera.aspect * this.aspect || near !== camera.near ||
					far !== camera.far;

				if (needsUpdate) {

					focus = camera.focus;
					fov = camera.fov;
					aspect = camera.aspect * this.aspect;
					near = camera.near;
					far = camera.far;

					// Off-axis stereoscopic effect based on
					// http://paulbourke.net/stereographics/stereorender/

					var projectionMatrix = camera.projectionMatrix.clone();
					var eyeSep = 0.064 / 2;
					var eyeSepOnProjection = eyeSep * near / focus;
					var ymax = near * Math.tan(THREE.Math.DEG2RAD * fov * 0.5);
					var xmin, xmax;

					// translate xOffset

					eyeLeft.elements[12] = - eyeSep;
					eyeRight.elements[12] = eyeSep;

					// for left eye

					xmin = - ymax * aspect + eyeSepOnProjection;
					xmax = ymax * aspect + eyeSepOnProjection;

					projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
					projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);

					this.cameraL.projectionMatrix.copy(projectionMatrix);

					// for right eye

					xmin = - ymax * aspect - eyeSepOnProjection;
					xmax = ymax * aspect - eyeSepOnProjection;

					projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
					projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);

					this.cameraR.projectionMatrix.copy(projectionMatrix);

				}

				this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
				this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);

			};

		})()

	});

	// File:src/lights/Light.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Light = function (color, intensity) {

		THREE.Object3D.call(this);

		this.type = 'Light';

		this.color = new THREE.Color(color);
		this.intensity = intensity !== undefined ? intensity : 1;

		this.receiveShadow = undefined;

	};

	THREE.Light.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {

		constructor: THREE.Light,

		copy: function (source) {

			THREE.Object3D.prototype.copy.call(this, source);

			this.color.copy(source.color);
			this.intensity = source.intensity;

			return this;

		},

		toJSON: function (meta) {

			var data = THREE.Object3D.prototype.toJSON.call(this, meta);

			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;

			if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();

			if (this.distance !== undefined) data.object.distance = this.distance;
			if (this.angle !== undefined) data.object.angle = this.angle;
			if (this.decay !== undefined) data.object.decay = this.decay;
			if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;

			return data;

		}

	});

	// File:src/lights/LightShadow.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LightShadow = function (camera) {

		this.camera = camera;

		this.bias = 0;
		this.radius = 1;

		this.mapSize = new THREE.Vector2(512, 512);

		this.map = null;
		this.matrix = new THREE.Matrix4();

	};

	Object.assign(THREE.LightShadow.prototype, {

		copy: function (source) {

			this.camera = source.camera.clone();

			this.bias = source.bias;
			this.radius = source.radius;

			this.mapSize.copy(source.mapSize);

			return this;

		},

		clone: function () {

			return new this.constructor().copy(this);

		}

	});

	// File:src/lights/AmbientLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AmbientLight = function (color, intensity) {

		THREE.Light.call(this, color, intensity);

		this.type = 'AmbientLight';

		this.castShadow = undefined;

	};

	THREE.AmbientLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {

		constructor: THREE.AmbientLight

	});

	// File:src/lights/DirectionalLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.DirectionalLight = function (color, intensity) {

		THREE.Light.call(this, color, intensity);

		this.type = 'DirectionalLight';

		this.position.set(0, 1, 0);
		this.updateMatrix();

		this.target = new THREE.Object3D();

		this.shadow = new THREE.DirectionalLightShadow();

	};

	THREE.DirectionalLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {

		constructor: THREE.DirectionalLight,

		copy: function (source) {

			THREE.Light.prototype.copy.call(this, source);

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	});

	// File:src/lights/DirectionalLightShadow.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.DirectionalLightShadow = function (light) {

		THREE.LightShadow.call(this, new THREE.OrthographicCamera(- 5, 5, 5, - 5, 0.5, 500));

	};

	THREE.DirectionalLightShadow.prototype = Object.assign(Object.create(THREE.LightShadow.prototype), {

		constructor: THREE.DirectionalLightShadow

	});

	// File:src/lights/HemisphereLight.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.HemisphereLight = function (skyColor, groundColor, intensity) {

		THREE.Light.call(this, skyColor, intensity);

		this.type = 'HemisphereLight';

		this.castShadow = undefined;

		this.position.set(0, 1, 0);
		this.updateMatrix();

		this.groundColor = new THREE.Color(groundColor);

	};

	THREE.HemisphereLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {

		constructor: THREE.HemisphereLight,

		copy: function (source) {

			THREE.Light.prototype.copy.call(this, source);

			this.groundColor.copy(source.groundColor);

			return this;

		}

	});

	// File:src/lights/PointLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	THREE.PointLight = function (color, intensity, distance, decay) {

		THREE.Light.call(this, color, intensity);

		this.type = 'PointLight';

		Object.defineProperty(this, 'power', {
			get: function () {
				// intensity = power per solid angle.
				// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
				return this.intensity * 4 * Math.PI;

			},
			set: function (power) {
				// intensity = power per solid angle.
				// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
				this.intensity = power / (4 * Math.PI);
			}
		});

		this.distance = (distance !== undefined) ? distance : 0;
		this.decay = (decay !== undefined) ? decay : 1;	// for physically correct lights, should be 2.

		this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(90, 1, 0.5, 500));

	};

	THREE.PointLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {

		constructor: THREE.PointLight,

		copy: function (source) {

			THREE.Light.prototype.copy.call(this, source);

			this.distance = source.distance;
			this.decay = source.decay;

			this.shadow = source.shadow.clone();

			return this;

		}

	});

	// File:src/lights/SpotLight.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SpotLight = function (color, intensity, distance, angle, penumbra, decay) {

		THREE.Light.call(this, color, intensity);

		this.type = 'SpotLight';

		this.position.set(0, 1, 0);
		this.updateMatrix();

		this.target = new THREE.Object3D();

		Object.defineProperty(this, 'power', {
			get: function () {
				// intensity = power per solid angle.
				// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
				return this.intensity * Math.PI;
			},
			set: function (power) {
				// intensity = power per solid angle.
				// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
				this.intensity = power / Math.PI;
			}
		});

		this.distance = (distance !== undefined) ? distance : 0;
		this.angle = (angle !== undefined) ? angle : Math.PI / 3;
		this.penumbra = (penumbra !== undefined) ? penumbra : 0;
		this.decay = (decay !== undefined) ? decay : 1;	// for physically correct lights, should be 2.

		this.shadow = new THREE.SpotLightShadow();

	};

	THREE.SpotLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {

		constructor: THREE.SpotLight,

		copy: function (source) {

			THREE.Light.prototype.copy.call(this, source);

			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	});

	// File:src/lights/SpotLightShadow.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.SpotLightShadow = function () {

		THREE.LightShadow.call(this, new THREE.PerspectiveCamera(50, 1, 0.5, 500));

	};

	THREE.SpotLightShadow.prototype = Object.assign(Object.create(THREE.LightShadow.prototype), {

		constructor: THREE.SpotLightShadow,

		update: function (light) {

			var fov = THREE.Math.RAD2DEG * 2 * light.angle;
			var aspect = this.mapSize.width / this.mapSize.height;
			var far = light.distance || 500;

			var camera = this.camera;

			if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {

				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();

			}

		}

	});

	// File:src/loaders/AudioLoader.js

	/**
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */

	THREE.AudioLoader = function (manager) {

		this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;

	};

	Object.assign(THREE.AudioLoader.prototype, {

		load: function (url, onLoad, onProgress, onError) {

			var loader = new THREE.XHRLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.load(url, function (buffer) {

				var context = THREE.AudioContext;

				context.decodeAudioData(buffer, function (audioBuffer) {

					onLoad(audioBuffer);

				});

			}, onProgress, onError);

		}

	});

	// File:src/loaders/Cache.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Cache = {

		enabled: false,

		files: {},

		add: function (key, file) {

			if (this.enabled === false) return;

			// //console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[key] = file;

		},

		get: function (key) {

			if (this.enabled === false) return;

			// //console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[key];

		},

		remove: function (key) {

			delete this.files[key];

		},

		clear: function () {

			this.files = {};

		}

	};

	// File:src/loaders/Loader.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Loader = function () {

		this.onLoadStart = function () { };
		this.onLoadProgress = function () { };
		this.onLoadComplete = function () { };

	};

	THREE.Loader.prototype = {

		constructor: THREE.Loader,

		crossOrigin: undefined,

		extractUrlBase: function (url) {

			var parts = url.split('/');

			if (parts.length === 1) return './';

			parts.pop();

			return parts.join('/') + '/';

		},

		initMaterials: function (materials, texturePath, crossOrigin) {

			var array = [];

			for (var i = 0; i < materials.length; ++i) {

				array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);

			}

			return array;

		},

		createMaterial: (function () {

			var color, textureLoader, materialLoader;

			return function createMaterial(m, texturePath, crossOrigin) {

				if (color === undefined) color = new THREE.Color();
				if (textureLoader === undefined) textureLoader = new THREE.TextureLoader();
				if (materialLoader === undefined) materialLoader = new THREE.MaterialLoader();

				// convert from old material format

				var textures = {};

				function loadTexture(path, repeat, offset, wrap, anisotropy) {

					var fullPath = texturePath + path;
					var loader = THREE.Loader.Handlers.get(fullPath);

					var texture;

					if (loader !== null) {

						texture = loader.load(fullPath);

					} else {

						textureLoader.setCrossOrigin(crossOrigin);
						texture = textureLoader.load(fullPath);

					}

					if (repeat !== undefined) {

						texture.repeat.fromArray(repeat);

						if (repeat[0] !== 1) texture.wrapS = THREE.RepeatWrapping;
						if (repeat[1] !== 1) texture.wrapT = THREE.RepeatWrapping;

					}

					if (offset !== undefined) {

						texture.offset.fromArray(offset);

					}

					if (wrap !== undefined) {

						if (wrap[0] === 'repeat') texture.wrapS = THREE.RepeatWrapping;
						if (wrap[0] === 'mirror') texture.wrapS = THREE.MirroredRepeatWrapping;

						if (wrap[1] === 'repeat') texture.wrapT = THREE.RepeatWrapping;
						if (wrap[1] === 'mirror') texture.wrapT = THREE.MirroredRepeatWrapping;

					}

					if (anisotropy !== undefined) {

						texture.anisotropy = anisotropy;

					}

					var uuid = THREE.Math.generateUUID();

					textures[uuid] = texture;

					return uuid;

				}

				//

				var json = {
					uuid: THREE.Math.generateUUID(),
					type: 'MeshLambertMaterial'
				};

				for (var name in m) {

					var value = m[name];

					switch (name) {
						case 'DbgColor':
						case 'DbgIndex':
						case 'opticalDensity':
						case 'illumination':
							break;
						case 'DbgName':
							json.name = value;
							break;
						case 'blending':
							json.blending = THREE[value];
							break;
						case 'colorAmbient':
						case 'mapAmbient':
							//console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
							break;
						case 'colorDiffuse':
							json.color = color.fromArray(value).getHex();
							break;
						case 'colorSpecular':
							json.specular = color.fromArray(value).getHex();
							break;
						case 'colorEmissive':
							json.emissive = color.fromArray(value).getHex();
							break;
						case 'specularCoef':
							json.shininess = value;
							break;
						case 'shading':
							if (value.toLowerCase() === 'basic') json.type = 'MeshBasicMaterial';
							if (value.toLowerCase() === 'phong') json.type = 'MeshPhongMaterial';
							if (value.toLowerCase() === 'standard') json.type = 'MeshStandardMaterial';
							break;
						case 'mapDiffuse':
							json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
							break;
						case 'mapDiffuseRepeat':
						case 'mapDiffuseOffset':
						case 'mapDiffuseWrap':
						case 'mapDiffuseAnisotropy':
							break;
						case 'mapEmissive':
							json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
							break;
						case 'mapEmissiveRepeat':
						case 'mapEmissiveOffset':
						case 'mapEmissiveWrap':
						case 'mapEmissiveAnisotropy':
							break;
						case 'mapLight':
							json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
							break;
						case 'mapLightRepeat':
						case 'mapLightOffset':
						case 'mapLightWrap':
						case 'mapLightAnisotropy':
							break;
						case 'mapAO':
							json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
							break;
						case 'mapAORepeat':
						case 'mapAOOffset':
						case 'mapAOWrap':
						case 'mapAOAnisotropy':
							break;
						case 'mapBump':
							json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
							break;
						case 'mapBumpScale':
							json.bumpScale = value;
							break;
						case 'mapBumpRepeat':
						case 'mapBumpOffset':
						case 'mapBumpWrap':
						case 'mapBumpAnisotropy':
							break;
						case 'mapNormal':
							json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
							break;
						case 'mapNormalFactor':
							json.normalScale = [value, value];
							break;
						case 'mapNormalRepeat':
						case 'mapNormalOffset':
						case 'mapNormalWrap':
						case 'mapNormalAnisotropy':
							break;
						case 'mapSpecular':
							json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
							break;
						case 'mapSpecularRepeat':
						case 'mapSpecularOffset':
						case 'mapSpecularWrap':
						case 'mapSpecularAnisotropy':
							break;
						case 'mapMetalness':
							json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
							break;
						case 'mapMetalnessRepeat':
						case 'mapMetalnessOffset':
						case 'mapMetalnessWrap':
						case 'mapMetalnessAnisotropy':
							break;
						case 'mapRoughness':
							json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
							break;
						case 'mapRoughnessRepeat':
						case 'mapRoughnessOffset':
						case 'mapRoughnessWrap':
						case 'mapRoughnessAnisotropy':
							break;
						case 'mapAlpha':
							json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
							break;
						case 'mapAlphaRepeat':
						case 'mapAlphaOffset':
						case 'mapAlphaWrap':
						case 'mapAlphaAnisotropy':
							break;
						case 'flipSided':
							json.side = THREE.BackSide;
							break;
						case 'doubleSided':
							json.side = THREE.DoubleSide;
							break;
						case 'transparency':
							//console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
							json.opacity = value;
							break;
						case 'depthTest':
						case 'depthWrite':
						case 'colorWrite':
						case 'opacity':
						case 'reflectivity':
						case 'transparent':
						case 'visible':
						case 'wireframe':
							json[name] = value;
							break;
						case 'vertexColors':
							if (value === true) json.vertexColors = THREE.VertexColors;
							if (value === 'face') json.vertexColors = THREE.FaceColors;
							break;
						default:
							//console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
							break;
					}

				}

				if (json.type === 'MeshBasicMaterial') delete json.emissive;
				if (json.type !== 'MeshPhongMaterial') delete json.specular;

				if (json.opacity < 1) json.transparent = true;

				materialLoader.setTextures(textures);

				return materialLoader.parse(json);

			};

		})()

	};

	THREE.Loader.Handlers = {

		handlers: [],

		add: function (regex, loader) {

			this.handlers.push(regex, loader);

		},

		get: function (file) {

			var handlers = this.handlers;

			for (var i = 0, l = handlers.length; i < l; i += 2) {

				var regex = handlers[i];
				var loader = handlers[i + 1];

				if (regex.test(file)) {

					return loader;

				}

			}

			return null;

		}

	};

	// File:src/loaders/XHRLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.XHRLoader = function (manager) {

		this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;

	};

	Object.assign(THREE.XHRLoader.prototype, {

		load: function (url, onLoad, onProgress, onError) {

			if (this.path !== undefined) url = this.path + url;

			var scope = this;

			var cached = THREE.Cache.get(url);

			if (cached !== undefined) {

				if (onLoad) {

					setTimeout(function () {

						onLoad(cached);

					}, 0);

				}

				return cached;

			}

			var request = new XMLHttpRequest();
			request.overrideMimeType('text/plain');
			request.open('GET', url, true);

			request.addEventListener('load', function (event) {

				var response = event.target.response;

				THREE.Cache.add(url, response);

				if (this.status === 200) {

					if (onLoad) onLoad(response);

					scope.manager.itemEnd(url);

				} else if (this.status === 0) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					//console.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );

					if (onLoad) onLoad(response);

					scope.manager.itemEnd(url);

				} else {

					if (onError) onError(event);

					scope.manager.itemError(url);

				}

			}, false);

			if (onProgress !== undefined) {

				request.addEventListener('progress', function (event) {

					onProgress(event);

				}, false);

			}

			request.addEventListener('error', function (event) {

				if (onError) onError(event);

				scope.manager.itemError(url);

			}, false);

			if (this.responseType !== undefined) request.responseType = this.responseType;
			if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;

			request.send(null);

			scope.manager.itemStart(url);

			return request;

		},

		setPath: function (value) {

			this.path = value;
			return this;

		},

		setResponseType: function (value) {

			this.responseType = value;
			return this;

		},

		setWithCredentials: function (value) {

			this.withCredentials = value;
			return this;

		}

	});

	// File:src/loaders/FontLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.FontLoader = function (manager) {

		this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;

	};

	Object.assign(THREE.FontLoader.prototype, {

		load: function (url, onLoad, onProgress, onError) {

			var scope = this;

			var loader = new THREE.XHRLoader(this.manager);
			loader.load(url, function (text) {

				var json;

				try {

					json = JSON.parse(text);

				} catch (e) {

					//console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
					json = JSON.parse(text.substring(65, text.length - 2));

				}

				var font = scope.parse(json);

				if (onLoad) onLoad(font);

			}, onProgress, onError);

		},

		parse: function (json) {

			return new THREE.Font(json);

		}

	});

	// File:src/loaders/ImageLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.ImageLoader = function (manager) {

		this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;

	};

	Object.assign(THREE.ImageLoader.prototype, {

		load: function (url, onLoad, onProgress, onError) {

			var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
			image.onload = function () {

				URL.revokeObjectURL(image.src);
				if (onLoad) onLoad(image);

			};

			if (url.indexOf('data:') === 0) {

				image.src = url;

			} else {

				var loader = new THREE.XHRLoader(this.manager);
				loader.setPath(this.path);
				loader.setResponseType('blob');
				loader.load(url, function (blob) {

					image.src = URL.createObjectURL(blob);

				}, onProgress, onError);

			}

			return image;

		},

		setCrossOrigin: function (value) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function (value) {

			this.path = value;
			return this;

		}

	});

	// File:src/loaders/JSONLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.JSONLoader = function (manager) {

		if (typeof manager === 'boolean') {

			//console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
			manager = undefined;

		}

		this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;

		this.withCredentials = false;

	};

	Object.assign(THREE.JSONLoader.prototype, {

		load: function (url, onLoad, onProgress, onError) {

			var scope = this;

			var texturePath = this.texturePath && (typeof this.texturePath === "string") ? this.texturePath : THREE.Loader.prototype.extractUrlBase(url);

			var loader = new THREE.XHRLoader(this.manager);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function (text) {

				var json = JSON.parse(text);
				var metadata = json.metadata;

				if (metadata !== undefined) {

					var type = metadata.type;

					if (type !== undefined) {

						if (type.toLowerCase() === 'object') {

							//console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
							return;

						}

						if (type.toLowerCase() === 'scene') {

							//console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
							return;

						}

					}

				}

				var object = scope.parse(json, texturePath);
				onLoad(object.geometry, object.materials);

			}, onProgress, onError);

		},

		setTexturePath: function (value) {

			this.texturePath = value;

		},

		parse: function (json, texturePath) {

			var geometry = new THREE.Geometry(),
				scale = (json.scale !== undefined) ? 1.0 / json.scale : 1.0;

			parseModel(scale);

			parseSkin();
			parseMorphing(scale);
			parseAnimations();

			geometry.computeFaceNormals();
			geometry.computeBoundingSphere();

			function parseModel(scale) {

				function isBitSet(value, position) {

					return value & (1 << position);

				}

				var i, j, fi,

					offset, zLength,

					colorIndex, normalIndex, uvIndex, materialIndex,

					type,
					isQuad,
					hasMaterial,
					hasFaceVertexUv,
					hasFaceNormal, hasFaceVertexNormal,
					hasFaceColor, hasFaceVertexColor,

					vertex, face, faceA, faceB, hex, normal,

					uvLayer, uv, u, v,

					faces = json.faces,
					vertices = json.vertices,
					normals = json.normals,
					colors = json.colors,

					nUvLayers = 0;

				if (json.uvs !== undefined) {

					// disregard empty arrays

					for (i = 0; i < json.uvs.length; i++) {

						if (json.uvs[i].length) nUvLayers++;

					}

					for (i = 0; i < nUvLayers; i++) {

						geometry.faceVertexUvs[i] = [];

					}

				}

				offset = 0;
				zLength = vertices.length;

				while (offset < zLength) {

					vertex = new THREE.Vector3();

					vertex.x = vertices[offset++] * scale;
					vertex.y = vertices[offset++] * scale;
					vertex.z = vertices[offset++] * scale;

					geometry.vertices.push(vertex);

				}

				offset = 0;
				zLength = faces.length;

				while (offset < zLength) {

					type = faces[offset++];


					isQuad = isBitSet(type, 0);
					hasMaterial = isBitSet(type, 1);
					hasFaceVertexUv = isBitSet(type, 3);
					hasFaceNormal = isBitSet(type, 4);
					hasFaceVertexNormal = isBitSet(type, 5);
					hasFaceColor = isBitSet(type, 6);
					hasFaceVertexColor = isBitSet(type, 7);

					// //console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

					if (isQuad) {

						faceA = new THREE.Face3();
						faceA.a = faces[offset];
						faceA.b = faces[offset + 1];
						faceA.c = faces[offset + 3];

						faceB = new THREE.Face3();
						faceB.a = faces[offset + 1];
						faceB.b = faces[offset + 2];
						faceB.c = faces[offset + 3];

						offset += 4;

						if (hasMaterial) {

							materialIndex = faces[offset++];
							faceA.materialIndex = materialIndex;
							faceB.materialIndex = materialIndex;

						}

						// to get face <=> uv index correspondence

						fi = geometry.faces.length;

						if (hasFaceVertexUv) {

							for (i = 0; i < nUvLayers; i++) {

								uvLayer = json.uvs[i];

								geometry.faceVertexUvs[i][fi] = [];
								geometry.faceVertexUvs[i][fi + 1] = [];

								for (j = 0; j < 4; j++) {

									uvIndex = faces[offset++];

									u = uvLayer[uvIndex * 2];
									v = uvLayer[uvIndex * 2 + 1];

									uv = new THREE.Vector2(u, v);

									if (j !== 2) geometry.faceVertexUvs[i][fi].push(uv);
									if (j !== 0) geometry.faceVertexUvs[i][fi + 1].push(uv);

								}

							}

						}

						if (hasFaceNormal) {

							normalIndex = faces[offset++] * 3;

							faceA.normal.set(
								normals[normalIndex++],
								normals[normalIndex++],
								normals[normalIndex]
							);

							faceB.normal.copy(faceA.normal);

						}

						if (hasFaceVertexNormal) {

							for (i = 0; i < 4; i++) {

								normalIndex = faces[offset++] * 3;

								normal = new THREE.Vector3(
									normals[normalIndex++],
									normals[normalIndex++],
									normals[normalIndex]
								);


								if (i !== 2) faceA.vertexNormals.push(normal);
								if (i !== 0) faceB.vertexNormals.push(normal);

							}

						}


						if (hasFaceColor) {

							colorIndex = faces[offset++];
							hex = colors[colorIndex];

							faceA.color.setHex(hex);
							faceB.color.setHex(hex);

						}


						if (hasFaceVertexColor) {

							for (i = 0; i < 4; i++) {

								colorIndex = faces[offset++];
								hex = colors[colorIndex];

								if (i !== 2) faceA.vertexColors.push(new THREE.Color(hex));
								if (i !== 0) faceB.vertexColors.push(new THREE.Color(hex));

							}

						}

						geometry.faces.push(faceA);
						geometry.faces.push(faceB);

					} else {

						face = new THREE.Face3();
						face.a = faces[offset++];
						face.b = faces[offset++];
						face.c = faces[offset++];

						if (hasMaterial) {

							materialIndex = faces[offset++];
							face.materialIndex = materialIndex;

						}

						// to get face <=> uv index correspondence

						fi = geometry.faces.length;

						if (hasFaceVertexUv) {

							for (i = 0; i < nUvLayers; i++) {

								uvLayer = json.uvs[i];

								geometry.faceVertexUvs[i][fi] = [];

								for (j = 0; j < 3; j++) {

									uvIndex = faces[offset++];

									u = uvLayer[uvIndex * 2];
									v = uvLayer[uvIndex * 2 + 1];

									uv = new THREE.Vector2(u, v);

									geometry.faceVertexUvs[i][fi].push(uv);

								}

							}

						}

						if (hasFaceNormal) {

							normalIndex = faces[offset++] * 3;

							face.normal.set(
								normals[normalIndex++],
								normals[normalIndex++],
								normals[normalIndex]
							);

						}

						if (hasFaceVertexNormal) {

							for (i = 0; i < 3; i++) {

								normalIndex = faces[offset++] * 3;

								normal = new THREE.Vector3(
									normals[normalIndex++],
									normals[normalIndex++],
									normals[normalIndex]
								);

								face.vertexNormals.push(normal);

							}

						}


						if (hasFaceColor) {

							colorIndex = faces[offset++];
							face.color.setHex(colors[colorIndex]);

						}


						if (hasFaceVertexColor) {

							for (i = 0; i < 3; i++) {

								colorIndex = faces[offset++];
								face.vertexColors.push(new THREE.Color(colors[colorIndex]));

							}

						}

						geometry.faces.push(face);

					}

				}

			}

			function parseSkin() {

				var influencesPerVertex = (json.influencesPerVertex !== undefined) ? json.influencesPerVertex : 2;

				if (json.skinWeights) {

					for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {

						var x = json.skinWeights[i];
						var y = (influencesPerVertex > 1) ? json.skinWeights[i + 1] : 0;
						var z = (influencesPerVertex > 2) ? json.skinWeights[i + 2] : 0;
						var w = (influencesPerVertex > 3) ? json.skinWeights[i + 3] : 0;

						geometry.skinWeights.push(new THREE.Vector4(x, y, z, w));

					}

				}

				if (json.skinIndices) {

					for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {

						var a = json.skinIndices[i];
						var b = (influencesPerVertex > 1) ? json.skinIndices[i + 1] : 0;
						var c = (influencesPerVertex > 2) ? json.skinIndices[i + 2] : 0;
						var d = (influencesPerVertex > 3) ? json.skinIndices[i + 3] : 0;

						geometry.skinIndices.push(new THREE.Vector4(a, b, c, d));

					}

				}

				geometry.bones = json.bones;

				if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {

					//console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
					//	geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

				}

			}

			function parseMorphing(scale) {

				if (json.morphTargets !== undefined) {

					for (var i = 0, l = json.morphTargets.length; i < l; i++) {

						geometry.morphTargets[i] = {};
						geometry.morphTargets[i].name = json.morphTargets[i].name;
						geometry.morphTargets[i].vertices = [];

						var dstVertices = geometry.morphTargets[i].vertices;
						var srcVertices = json.morphTargets[i].vertices;

						for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {

							var vertex = new THREE.Vector3();
							vertex.x = srcVertices[v] * scale;
							vertex.y = srcVertices[v + 1] * scale;
							vertex.z = srcVertices[v + 2] * scale;

							dstVertices.push(vertex);

						}

					}

				}

				if (json.morphColors !== undefined && json.morphColors.length > 0) {

					//console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

					var faces = geometry.faces;
					var morphColors = json.morphColors[0].colors;

					for (var i = 0, l = faces.length; i < l; i++) {

						faces[i].color.fromArray(morphColors, i * 3);

					}

				}

			}

			function parseAnimations() {

				var outputAnimations = [];

				// parse old style Bone/Hierarchy animations
				var animations = [];

				if (json.animation !== undefined) {

					animations.push(json.animation);

				}

				if (json.animations !== undefined) {

					if (json.animations.length) {

						animations = animations.concat(json.animations);

					} else {

						animations.push(json.animations);

					}

				}

				for (var i = 0; i < animations.length; i++) {

					var clip = THREE.AnimationClip.parseAnimation(animations[i], geometry.bones);
					if (clip) outputAnimations.push(clip);

				}

				// parse implicit morph animations
				if (geometry.morphTargets) {

					// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
					var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
					outputAnimations = outputAnimations.concat(morphAnimationClips);

				}

				if (outputAnimations.length > 0) geometry.animations = outputAnimations;

			}

			if (json.materials === undefined || json.materials.length === 0) {

				return { geometry: geometry };

			} else {

				var materials = THREE.Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);

				return { geometry: geometry, materials: materials };

			}

		}

	});

	// File:src/loaders/LoadingManager.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LoadingManager = function (onLoad, onProgress, onError) {

		var scope = this;

		var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function (url) {

			itemsTotal++;

			if (isLoading === false) {

				if (scope.onStart !== undefined) {

					scope.onStart(url, itemsLoaded, itemsTotal);

				}

			}

			isLoading = true;

		};

		this.itemEnd = function (url) {

			itemsLoaded++;

			if (scope.onProgress !== undefined) {

				scope.onProgress(url, itemsLoaded, itemsTotal);

			}

			if (itemsLoaded === itemsTotal) {

				isLoading = false;

				if (scope.onLoad !== undefined) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function (url) {

			if (scope.onError !== undefined) {

				scope.onError(url);

			}

		};

	};

	THREE.DefaultLoadingManager = new THREE.LoadingManager();

	// File:src/loaders/BufferGeometryLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferGeometryLoader = function (manager) {

		this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;

	};

	Object.assign(THREE.BufferGeometryLoader.prototype, {

		load: function (url, onLoad, onProgress, onError) {

			var scope = this;

			var loader = new THREE.XHRLoader(scope.manager);
			loader.load(url, function (text) {

				onLoad(scope.parse(JSON.parse(text)));

			}, onProgress, onError);

		},

		parse: function (json) {

			var geometry = new THREE.BufferGeometry();

			var index = json.data.index;

			var TYPED_ARRAYS = {
				'Int8Array': Int8Array,
				'Uint8Array': Uint8Array,
				'Uint8ClampedArray': Uint8ClampedArray,
				'Int16Array': Int16Array,
				'Uint16Array': Uint16Array,
				'Int32Array': Int32Array,
				'Uint32Array': Uint32Array,
				'Float32Array': Float32Array,
				'Float64Array': Float64Array
			};

			if (index !== undefined) {

				var typedArray = new TYPED_ARRAYS[index.type](index.array);
				geometry.setIndex(new THREE.BufferAttribute(typedArray, 1));

			}

			var attributes = json.data.attributes;

			for (var key in attributes) {

				var attribute = attributes[key];
				var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);

				geometry.addAttribute(key, new THREE.BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));

			}

			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if (groups !== undefined) {

				for (var i = 0, n = groups.length; i !== n; ++i) {

					var group = groups[i];

					geometry.addGroup(group.start, group.count, group.materialIndex);

				}

			}

			var boundingSphere = json.data.boundingSphere;

			if (boundingSphere !== undefined) {

				var center = new THREE.Vector3();

				if (boundingSphere.center !== undefined) {

					center.fromArray(boundingSphere.center);

				}

				geometry.boundingSphere = new THREE.Sphere(center, boundingSphere.radius);

			}

			return geometry;

		}

	});

	// File:src/loaders/MaterialLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.MaterialLoader = function (manager) {

		this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
		this.textures = {};

	};

	Object.assign(THREE.MaterialLoader.prototype, {

		load: function (url, onLoad, onProgress, onError) {

			var scope = this;

			var loader = new THREE.XHRLoader(scope.manager);
			loader.load(url, function (text) {

				onLoad(scope.parse(JSON.parse(text)));

			}, onProgress, onError);

		},

		setTextures: function (value) {

			this.textures = value;

		},

		getTexture: function (name) {

			var textures = this.textures;

			if (textures[name] === undefined) {

				//console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[name];

		},

		parse: function (json) {

			var material = new THREE[json.type];

			if (json.uuid !== undefined) material.uuid = json.uuid;
			if (json.name !== undefined) material.name = json.name;
			if (json.color !== undefined) material.color.setHex(json.color);
			if (json.roughness !== undefined) material.roughness = json.roughness;
			if (json.metalness !== undefined) material.metalness = json.metalness;
			if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
			if (json.specular !== undefined) material.specular.setHex(json.specular);
			if (json.shininess !== undefined) material.shininess = json.shininess;
			if (json.uniforms !== undefined) material.uniforms = json.uniforms;
			if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
			if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
			if (json.vertexColors !== undefined) material.vertexColors = json.vertexColors;
			if (json.shading !== undefined) material.shading = json.shading;
			if (json.blending !== undefined) material.blending = json.blending;
			if (json.side !== undefined) material.side = json.side;
			if (json.opacity !== undefined) material.opacity = json.opacity;
			if (json.transparent !== undefined) material.transparent = json.transparent;
			if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
			if (json.depthTest !== undefined) material.depthTest = json.depthTest;
			if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
			if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
			if (json.wireframe !== undefined) material.wireframe = json.wireframe;
			if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;

			// for PointsMaterial
			if (json.size !== undefined) material.size = json.size;
			if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;

			// maps

			if (json.map !== undefined) material.map = this.getTexture(json.map);

			if (json.alphaMap !== undefined) {

				material.alphaMap = this.getTexture(json.alphaMap);
				material.transparent = true;

			}

			if (json.bumpMap !== undefined) material.bumpMap = this.getTexture(json.bumpMap);
			if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;

			if (json.normalMap !== undefined) material.normalMap = this.getTexture(json.normalMap);
			if (json.normalScale !== undefined) {

				var normalScale = json.normalScale;

				if (Array.isArray(normalScale) === false) {

					// Blender exporter used to export a scalar. See #7459

					normalScale = [normalScale, normalScale];

				}

				material.normalScale = new THREE.Vector2().fromArray(normalScale);

			}

			if (json.displacementMap !== undefined) material.displacementMap = this.getTexture(json.displacementMap);
			if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
			if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;

			if (json.roughnessMap !== undefined) material.roughnessMap = this.getTexture(json.roughnessMap);
			if (json.metalnessMap !== undefined) material.metalnessMap = this.getTexture(json.metalnessMap);

			if (json.emissiveMap !== undefined) material.emissiveMap = this.getTexture(json.emissiveMap);
			if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;

			if (json.specularMap !== undefined) material.specularMap = this.getTexture(json.specularMap);

			if (json.envMap !== undefined) {

				material.envMap = this.getTexture(json.envMap);
				material.combine = THREE.MultiplyOperation;

			}

			if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;

			if (json.lightMap !== undefined) material.lightMap = this.getTexture(json.lightMap);
			if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;

			if (json.aoMap !== undefined) material.aoMap = this.getTexture(json.aoMap);
			if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;

			// MultiMaterial

			if (json.materials !== undefined) {

				for (var i = 0, l = json.materials.length; i < l; i++) {

					material.materials.push(this.parse(json.materials[i]));

				}

			}

			return material;

		}

	});

	// File:src/loaders/ObjectLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.ObjectLoader = function (manager) {

		this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
		this.texturePath = '';

	};

	Object.assign(THREE.ObjectLoader.prototype, {

		load: function (url, onLoad, onProgress, onError) {

			if (this.texturePath === '') {

				this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);

			}

			var scope = this;

			var loader = new THREE.XHRLoader(scope.manager);
			loader.load(url, function (text) {

				scope.parse(JSON.parse(text), onLoad);

			}, onProgress, onError);

		},

		setTexturePath: function (value) {

			this.texturePath = value;

		},

		setCrossOrigin: function (value) {

			this.crossOrigin = value;

		},

		parse: function (json, onLoad) {

			var geometries = this.parseGeometries(json.geometries);

			var images = this.parseImages(json.images, function () {

				if (onLoad !== undefined) onLoad(object);

			});

			var textures = this.parseTextures(json.textures, images);
			var materials = this.parseMaterials(json.materials, textures);

			var object = this.parseObject(json.object, geometries, materials);

			if (json.animations) {

				object.animations = this.parseAnimations(json.animations);

			}

			if (json.images === undefined || json.images.length === 0) {

				if (onLoad !== undefined) onLoad(object);

			}

			return object;

		},

		parseGeometries: function (json) {

			var geometries = {};

			if (json !== undefined) {

				var geometryLoader = new THREE.JSONLoader();
				var bufferGeometryLoader = new THREE.BufferGeometryLoader();

				for (var i = 0, l = json.length; i < l; i++) {

					var geometry;
					var data = json[i];

					switch (data.type) {

						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':

							geometry = new THREE[data.type](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);

							break;

						case 'BoxGeometry':
						case 'BoxBufferGeometry':
						case 'CubeGeometry': // backwards compatible

							geometry = new THREE[data.type](
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);

							break;

						case 'CircleGeometry':
						case 'CircleBufferGeometry':

							geometry = new THREE[data.type](
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'CylinderGeometry':
						case 'CylinderBufferGeometry':

							geometry = new THREE[data.type](
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'ConeGeometry':
						case 'ConeBufferGeometry':

							geometry = new THREE[data.type](
								data.radius,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'SphereGeometry':
						case 'SphereBufferGeometry':

							geometry = new THREE[data.type](
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'DodecahedronGeometry':
						case 'IcosahedronGeometry':
						case 'OctahedronGeometry':
						case 'TetrahedronGeometry':

							geometry = new THREE[data.type](
								data.radius,
								data.detail
							);

							break;

						case 'RingGeometry':
						case 'RingBufferGeometry':

							geometry = new THREE[data.type](
								data.innerRadius,
								data.outerRadius,
								data.thetaSegments,
								data.phiSegments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'TorusGeometry':
						case 'TorusBufferGeometry':

							geometry = new THREE[data.type](
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);

							break;

						case 'TorusKnotGeometry':
						case 'TorusKnotBufferGeometry':

							geometry = new THREE[data.type](
								data.radius,
								data.tube,
								data.tubularSegments,
								data.radialSegments,
								data.p,
								data.q
							);

							break;

						case 'LatheGeometry':
						case 'LatheBufferGeometry':

							geometry = new THREE[data.type](
								data.points,
								data.segments,
								data.phiStart,
								data.phiLength
							);

							break;

						case 'BufferGeometry':

							geometry = bufferGeometryLoader.parse(data);

							break;

						case 'Geometry':

							geometry = geometryLoader.parse(data.data, this.texturePath).geometry;

							break;

						default:

							//console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

							continue;

					}

					geometry.uuid = data.uuid;

					if (data.name !== undefined) geometry.name = data.name;

					geometries[data.uuid] = geometry;

				}

			}

			return geometries;

		},

		parseMaterials: function (json, textures) {

			var materials = {};

			if (json !== undefined) {

				var loader = new THREE.MaterialLoader();
				loader.setTextures(textures);

				for (var i = 0, l = json.length; i < l; i++) {

					var material = loader.parse(json[i]);
					materials[material.uuid] = material;

				}

			}

			return materials;

		},

		parseAnimations: function (json) {

			var animations = [];

			for (var i = 0; i < json.length; i++) {

				var clip = THREE.AnimationClip.parse(json[i]);

				animations.push(clip);

			}

			return animations;

		},

		parseImages: function (json, onLoad) {

			var scope = this;
			var images = {};

			function loadImage(url) {

				scope.manager.itemStart(url);

				return loader.load(url, function () {

					scope.manager.itemEnd(url);

				});

			}

			if (json !== undefined && json.length > 0) {

				var manager = new THREE.LoadingManager(onLoad);

				var loader = new THREE.ImageLoader(manager);
				loader.setCrossOrigin(this.crossOrigin);

				for (var i = 0, l = json.length; i < l; i++) {

					var image = json[i];
					var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;

					images[image.uuid] = loadImage(path);

				}

			}

			return images;

		},

		parseTextures: function (json, images) {

			function parseConstant(value) {

				if (typeof (value) === 'number') return value;

				//console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

				return THREE[value];

			}

			var textures = {};

			if (json !== undefined) {

				for (var i = 0, l = json.length; i < l; i++) {

					var data = json[i];

					if (data.image === undefined) {

						//console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

					}

					if (images[data.image] === undefined) {

						//console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

					}

					var texture = new THREE.Texture(images[data.image]);
					texture.needsUpdate = true;

					texture.uuid = data.uuid;

					if (data.name !== undefined) texture.name = data.name;
					if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping);
					if (data.offset !== undefined) texture.offset = new THREE.Vector2(data.offset[0], data.offset[1]);
					if (data.repeat !== undefined) texture.repeat = new THREE.Vector2(data.repeat[0], data.repeat[1]);
					if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter);
					if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter);
					if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
					if (Array.isArray(data.wrap)) {

						texture.wrapS = parseConstant(data.wrap[0]);
						texture.wrapT = parseConstant(data.wrap[1]);

					}

					textures[data.uuid] = texture;

				}

			}

			return textures;

		},

		parseObject: function () {

			var matrix = new THREE.Matrix4();

			return function parseObject(data, geometries, materials) {

				var object;

				function getGeometry(name) {

					if (geometries[name] === undefined) {

						//console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

					}

					return geometries[name];

				}

				function getMaterial(name) {

					if (name === undefined) return undefined;

					if (materials[name] === undefined) {

						//console.warn( 'THREE.ObjectLoader: Undefined material', name );

					}

					return materials[name];

				}

				switch (data.type) {

					case 'Scene':

						object = new THREE.Scene();

						break;

					case 'PerspectiveCamera':

						object = new THREE.PerspectiveCamera(data.fov, data.aspect, data.near, data.far);

						if (data.focus !== undefined) object.focus = data.focus;
						if (data.zoom !== undefined) object.zoom = data.zoom;
						if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
						if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
						if (data.view !== undefined) object.view = Object.assign({}, data.view);

						break;

					case 'OrthographicCamera':

						object = new THREE.OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);

						break;

					case 'AmbientLight':

						object = new THREE.AmbientLight(data.color, data.intensity);

						break;

					case 'DirectionalLight':

						object = new THREE.DirectionalLight(data.color, data.intensity);

						break;

					case 'PointLight':

						object = new THREE.PointLight(data.color, data.intensity, data.distance, data.decay);

						break;

					case 'SpotLight':

						object = new THREE.SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);

						break;

					case 'HemisphereLight':

						object = new THREE.HemisphereLight(data.color, data.groundColor, data.intensity);

						break;

					case 'Mesh':

						var geometry = getGeometry(data.geometry);
						var material = getMaterial(data.material);

						if (geometry.bones && geometry.bones.length > 0) {

							object = new THREE.SkinnedMesh(geometry, material);

						} else {

							object = new THREE.Mesh(geometry, material);

						}

						break;

					case 'LOD':

						object = new THREE.LOD();

						break;

					case 'Line':

						object = new THREE.Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);

						break;

					case 'PointCloud':
					case 'Points':

						object = new THREE.Points(getGeometry(data.geometry), getMaterial(data.material));

						break;

					case 'Sprite':

						object = new THREE.Sprite(getMaterial(data.material));

						break;

					case 'Group':

						object = new THREE.Group();

						break;

					default:

						object = new THREE.Object3D();

				}

				object.uuid = data.uuid;

				if (data.name !== undefined) object.name = data.name;
				if (data.matrix !== undefined) {

					matrix.fromArray(data.matrix);
					matrix.decompose(object.position, object.quaternion, object.scale);

				} else {

					if (data.position !== undefined) object.position.fromArray(data.position);
					if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
					if (data.scale !== undefined) object.scale.fromArray(data.scale);

				}

				if (data.castShadow !== undefined) object.castShadow = data.castShadow;
				if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;

				if (data.visible !== undefined) object.visible = data.visible;
				if (data.userData !== undefined) object.userData = data.userData;

				if (data.children !== undefined) {

					for (var child in data.children) {

						object.add(this.parseObject(data.children[child], geometries, materials));

					}

				}

				if (data.type === 'LOD') {

					var levels = data.levels;

					for (var l = 0; l < levels.length; l++) {

						var level = levels[l];
						var child = object.getObjectByProperty('uuid', level.object);

						if (child !== undefined) {

							object.addLevel(child, level.distance);

						}

					}

				}

				return object;

			};

		}()

	});

	// File:src/loaders/TextureLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.TextureLoader = function (manager) {

		this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;

	};

	Object.assign(THREE.TextureLoader.prototype, {

		load: function (url, onLoad, onProgress, onError) {

			var texture = new THREE.Texture();

			var loader = new THREE.ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			loader.setPath(this.path);
			loader.load(url, function (image) {

				texture.image = image;
				texture.needsUpdate = true;

				if (onLoad !== undefined) {

					onLoad(texture);

				}

			}, onProgress, onError);

			return texture;

		},

		setCrossOrigin: function (value) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function (value) {

			this.path = value;
			return this;

		}

	});

	// File:src/loaders/CubeTextureLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CubeTextureLoader = function (manager) {

		this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;

	};

	Object.assign(THREE.CubeTextureLoader.prototype, {

		load: function (urls, onLoad, onProgress, onError) {

			var texture = new THREE.CubeTexture();

			var loader = new THREE.ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			loader.setPath(this.path);

			var loaded = 0;

			function loadTexture(i) {

				loader.load(urls[i], function (image) {

					texture.images[i] = image;

					loaded++;

					if (loaded === 6) {

						texture.needsUpdate = true;

						if (onLoad) onLoad(texture);

					}

				}, undefined, onError);

			}

			for (var i = 0; i < urls.length; ++i) {

				loadTexture(i);

			}

			return texture;

		},

		setCrossOrigin: function (value) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function (value) {

			this.path = value;
			return this;

		}

	});

	// File:src/loaders/BinaryTextureLoader.js

	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */

	THREE.DataTextureLoader = THREE.BinaryTextureLoader = function (manager) {

		this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	};

	Object.assign(THREE.BinaryTextureLoader.prototype, {

		load: function (url, onLoad, onProgress, onError) {

			var scope = this;

			var texture = new THREE.DataTexture();

			var loader = new THREE.XHRLoader(this.manager);
			loader.setResponseType('arraybuffer');

			loader.load(url, function (buffer) {

				var texData = scope._parser(buffer);

				if (!texData) return;

				if (undefined !== texData.image) {

					texture.image = texData.image;

				} else if (undefined !== texData.data) {

					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;

				}

				texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
				texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

				texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
				texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

				texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

				if (undefined !== texData.format) {

					texture.format = texData.format;

				}
				if (undefined !== texData.type) {

					texture.type = texData.type;

				}

				if (undefined !== texData.mipmaps) {

					texture.mipmaps = texData.mipmaps;

				}

				if (1 === texData.mipmapCount) {

					texture.minFilter = THREE.LinearFilter;

				}

				texture.needsUpdate = true;

				if (onLoad) onLoad(texture, texData);

			}, onProgress, onError);


			return texture;

		}

	});

	// File:src/loaders/CompressedTextureLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */

	THREE.CompressedTextureLoader = function (manager) {

		this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	};

	Object.assign(THREE.CompressedTextureLoader.prototype, {

		load: function (url, onLoad, onProgress, onError) {

			var scope = this;

			var images = [];

			var texture = new THREE.CompressedTexture();
			texture.image = images;

			var loader = new THREE.XHRLoader(this.manager);
			loader.setPath(this.path);
			loader.setResponseType('arraybuffer');

			function loadTexture(i) {

				loader.load(url[i], function (buffer) {

					var texDatas = scope._parser(buffer, true);

					images[i] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};

					loaded += 1;

					if (loaded === 6) {

						if (texDatas.mipmapCount === 1)
							texture.minFilter = THREE.LinearFilter;

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if (onLoad) onLoad(texture);

					}

				}, onProgress, onError);

			}

			if (Array.isArray(url)) {

				var loaded = 0;

				for (var i = 0, il = url.length; i < il; ++i) {

					loadTexture(i);

				}

			} else {

				// compressed cubemap texture stored in a single DDS file

				loader.load(url, function (buffer) {

					var texDatas = scope._parser(buffer, true);

					if (texDatas.isCubemap) {

						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for (var f = 0; f < faces; f++) {

							images[f] = { mipmaps: [] };

							for (var i = 0; i < texDatas.mipmapCount; i++) {

								images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
								images[f].format = texDatas.format;
								images[f].width = texDatas.width;
								images[f].height = texDatas.height;

							}

						}

					} else {

						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;

					}

					if (texDatas.mipmapCount === 1) {

						texture.minFilter = THREE.LinearFilter;

					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if (onLoad) onLoad(texture);

				}, onProgress, onError);

			}

			return texture;

		},

		setPath: function (value) {

			this.path = value;
			return this;

		}

	});

	// File:src/materials/Material.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Material = function () {

		Object.defineProperty(this, 'id', { value: THREE.MaterialIdCount++ });

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Material';

		this.fog = true;
		this.lights = true;

		this.blending = THREE.NormalBlending;
		this.side = THREE.FrontSide;
		this.shading = THREE.SmoothShading; // THREE.FlatShading, THREE.SmoothShading
		this.vertexColors = THREE.NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

		this.opacity = 1;
		this.transparent = false;

		this.blendSrc = THREE.SrcAlphaFactor;
		this.blendDst = THREE.OneMinusSrcAlphaFactor;
		this.blendEquation = THREE.AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = THREE.LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.clippingPlanes = null;
		this.clipShadows = false;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.alphaTest = 0;
		this.premultipliedAlpha = false;

		this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

		this.visible = true;

		this._needsUpdate = true;

	};

	THREE.Material.prototype = {

		constructor: THREE.Material,

		get needsUpdate() {

			return this._needsUpdate;

		},

		set needsUpdate(value) {

			if (value === true) this.update();
			this._needsUpdate = value;

		},

		setValues: function (values) {

			if (values === undefined) return;

			for (var key in values) {

				var newValue = values[key];

				if (newValue === undefined) {

					//console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;

				}

				var currentValue = this[key];

				if (currentValue === undefined) {

					//console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
					continue;

				}

				if (currentValue instanceof THREE.Color) {

					currentValue.set(newValue);

				} else if (currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3) {

					currentValue.copy(newValue);

				} else if (key === 'overdraw') {

					// ensure overdraw is backwards-compatible with legacy boolean type
					this[key] = Number(newValue);

				} else {

					this[key] = newValue;

				}

			}

		},

		toJSON: function (meta) {

			var isRoot = meta === undefined;

			if (isRoot) {

				meta = {
					textures: {},
					images: {}
				};

			}

			var data = {
				metadata: {
					version: 4.4,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;

			if (this.name !== '') data.name = this.name;

			if (this.color instanceof THREE.Color) data.color = this.color.getHex();

			if (this.roughness !== undefined) data.roughness = this.roughness;
			if (this.metalness !== undefined) data.metalness = this.metalness;

			if (this.emissive instanceof THREE.Color) data.emissive = this.emissive.getHex();
			if (this.specular instanceof THREE.Color) data.specular = this.specular.getHex();
			if (this.shininess !== undefined) data.shininess = this.shininess;

			if (this.map instanceof THREE.Texture) data.map = this.map.toJSON(meta).uuid;
			if (this.alphaMap instanceof THREE.Texture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
			if (this.lightMap instanceof THREE.Texture) data.lightMap = this.lightMap.toJSON(meta).uuid;
			if (this.bumpMap instanceof THREE.Texture) {

				data.bumpMap = this.bumpMap.toJSON(meta).uuid;
				data.bumpScale = this.bumpScale;

			}
			if (this.normalMap instanceof THREE.Texture) {

				data.normalMap = this.normalMap.toJSON(meta).uuid;
				data.normalScale = this.normalScale.toArray();

			}
			if (this.displacementMap instanceof THREE.Texture) {

				data.displacementMap = this.displacementMap.toJSON(meta).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}
			if (this.roughnessMap instanceof THREE.Texture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
			if (this.metalnessMap instanceof THREE.Texture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;

			if (this.emissiveMap instanceof THREE.Texture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
			if (this.specularMap instanceof THREE.Texture) data.specularMap = this.specularMap.toJSON(meta).uuid;

			if (this.envMap instanceof THREE.Texture) {

				data.envMap = this.envMap.toJSON(meta).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap

			}

			if (this.size !== undefined) data.size = this.size;
			if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;

			if (this.blending !== THREE.NormalBlending) data.blending = this.blending;
			if (this.shading !== THREE.SmoothShading) data.shading = this.shading;
			if (this.side !== THREE.FrontSide) data.side = this.side;
			if (this.vertexColors !== THREE.NoColors) data.vertexColors = this.vertexColors;

			if (this.opacity < 1) data.opacity = this.opacity;
			if (this.transparent === true) data.transparent = this.transparent;
			if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
			if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
			if (this.wireframe === true) data.wireframe = this.wireframe;
			if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;

			// TODO: Copied from Object3D.toJSON

			function extractFromCache(cache) {

				var values = [];

				for (var key in cache) {

					var data = cache[key];
					delete data.metadata;
					values.push(data);

				}

				return values;

			}

			if (isRoot) {

				var textures = extractFromCache(meta.textures);
				var images = extractFromCache(meta.images);

				if (textures.length > 0) data.textures = textures;
				if (images.length > 0) data.images = images;

			}

			return data;

		},

		clone: function () {

			return new this.constructor().copy(this);

		},

		copy: function (source) {

			this.name = source.name;

			this.fog = source.fog;
			this.lights = source.lights;

			this.blending = source.blending;
			this.side = source.side;
			this.shading = source.shading;
			this.vertexColors = source.vertexColors;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.colorWrite = source.colorWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.alphaTest = source.alphaTest;

			this.premultipliedAlpha = source.premultipliedAlpha;

			this.overdraw = source.overdraw;

			this.visible = source.visible;
			this.clipShadows = source.clipShadows;

			var srcPlanes = source.clippingPlanes,
				dstPlanes = null;

			if (srcPlanes !== null) {

				var n = srcPlanes.length;
				dstPlanes = new Array(n);

				for (var i = 0; i !== n; ++i)
					dstPlanes[i] = srcPlanes[i].clone();

			}

			this.clippingPlanes = dstPlanes;

			return this;

		},

		update: function () {

			this.dispatchEvent({ type: 'update' });

		},

		dispose: function () {

			this.dispatchEvent({ type: 'dispose' });

		}

	};

	Object.assign(THREE.Material.prototype, THREE.EventDispatcher.prototype);

	THREE.MaterialIdCount = 0;

	// File:src/materials/LineBasicMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round"
	 * }
	 */

	THREE.LineBasicMaterial = function (parameters) {

		THREE.Material.call(this);

		this.type = 'LineBasicMaterial';

		this.color = new THREE.Color(0xffffff);

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.lights = false;

		this.setValues(parameters);

	};

	THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
	THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

	THREE.LineBasicMaterial.prototype.copy = function (source) {

		THREE.Material.prototype.copy.call(this, source);

		this.color.copy(source.color);

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		return this;

	};

	// File:src/materials/LineDashedMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>
	 * }
	 */

	THREE.LineDashedMaterial = function (parameters) {

		THREE.Material.call(this);

		this.type = 'LineDashedMaterial';

		this.color = new THREE.Color(0xffffff);

		this.linewidth = 1;

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.lights = false;

		this.setValues(parameters);

	};

	THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
	THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

	THREE.LineDashedMaterial.prototype.copy = function (source) {

		THREE.Material.prototype.copy.call(this, source);

		this.color.copy(source.color);

		this.linewidth = source.linewidth;

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;

	};

	// File:src/materials/MeshBasicMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>
	 * }
	 */

	THREE.MeshBasicMaterial = function (parameters) {

		THREE.Material.call(this);

		this.type = 'MeshBasicMaterial';

		this.color = new THREE.Color(0xffffff); // emissive

		this.map = null;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;

		this.lights = false;

		this.setValues(parameters);

	};

	THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
	THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

	THREE.MeshBasicMaterial.prototype.copy = function (source) {

		THREE.Material.prototype.copy.call(this, source);

		this.color.copy(source.color);

		this.map = source.map;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		return this;

	};

	// File:src/materials/MeshDepthMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / https://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	THREE.MeshDepthMaterial = function (parameters) {

		THREE.Material.call(this);

		this.type = 'MeshDepthMaterial';

		this.depthPacking = THREE.BasicDepthPacking;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;
		this.lights = false;

		this.setValues(parameters);

	};

	THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
	THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

	THREE.MeshDepthMaterial.prototype.copy = function (source) {

		THREE.Material.prototype.copy.call(this, source);

		this.depthPacking = source.depthPacking;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	};

	// File:src/materials/MeshLambertMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	THREE.MeshLambertMaterial = function (parameters) {

		THREE.Material.call(this);

		this.type = 'MeshLambertMaterial';

		this.color = new THREE.Color(0xffffff); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new THREE.Color(0x000000);
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues(parameters);

	};

	THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
	THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

	THREE.MeshLambertMaterial.prototype.copy = function (source) {

		THREE.Material.prototype.copy.call(this, source);

		this.color.copy(source.color);

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	// File:src/materials/MeshNormalMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	THREE.MeshNormalMaterial = function (parameters) {

		THREE.Material.call(this, parameters);

		this.type = 'MeshNormalMaterial';

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;
		this.lights = false;
		this.morphTargets = false;

		this.setValues(parameters);

	};

	THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
	THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

	THREE.MeshNormalMaterial.prototype.copy = function (source) {

		THREE.Material.prototype.copy.call(this, source);

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	};

	// File:src/materials/MeshPhongMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	THREE.MeshPhongMaterial = function (parameters) {

		THREE.Material.call(this);

		this.type = 'MeshPhongMaterial';

		this.color = new THREE.Color(0xffffff); // diffuse
		this.specular = new THREE.Color(0x111111);
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new THREE.Color(0x000000);
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalScale = new THREE.Vector2(1, 1);

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues(parameters);

	};

	THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
	THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

	THREE.MeshPhongMaterial.prototype.copy = function (source) {

		THREE.Material.prototype.copy.call(this, source);

		this.color.copy(source.color);
		this.specular.copy(source.specular);
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalScale.copy(source.normalScale);

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	// File:src/materials/MeshStandardMaterial.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  roughness: <float>,
	 *  metalness: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *  metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  envMapIntensity: <float>
	 *
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	THREE.MeshStandardMaterial = function (parameters) {

		THREE.Material.call(this);

		this.defines = { 'STANDARD': '' };

		this.type = 'MeshStandardMaterial';

		this.color = new THREE.Color(0xffffff); // diffuse
		this.roughness = 0.5;
		this.metalness = 0.5;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new THREE.Color(0x000000);
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalScale = new THREE.Vector2(1, 1);

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.roughnessMap = null;

		this.metalnessMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapIntensity = 1.0;

		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues(parameters);

	};

	THREE.MeshStandardMaterial.prototype = Object.create(THREE.Material.prototype);
	THREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;

	THREE.MeshStandardMaterial.prototype.copy = function (source) {

		THREE.Material.prototype.copy.call(this, source);

		this.defines = { 'STANDARD': '' };

		this.color.copy(source.color);
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalScale.copy(source.normalScale);

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;

		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	// File:src/materials/MeshPhysicalMaterial.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  reflectivity: <float>
	 * }
	 */

	THREE.MeshPhysicalMaterial = function (parameters) {

		THREE.MeshStandardMaterial.call(this);

		this.defines = { 'PHYSICAL': '' };

		this.type = 'MeshPhysicalMaterial';

		this.reflectivity = 0.5; // maps to F0 = 0.04

		this.clearCoat = 0.0;
		this.clearCoatRoughness = 0.0;

		this.setValues(parameters);

	};

	THREE.MeshPhysicalMaterial.prototype = Object.create(THREE.MeshStandardMaterial.prototype);
	THREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial;

	THREE.MeshPhysicalMaterial.prototype.copy = function (source) {

		THREE.MeshStandardMaterial.prototype.copy.call(this, source);

		this.defines = { 'PHYSICAL': '' };

		this.reflectivity = source.reflectivity;

		this.clearCoat = source.clearCoat;
		this.clearCoatRoughness = source.clearCoatRoughness;

		return this;

	};

	// File:src/materials/MultiMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.MultiMaterial = function (materials) {

		this.uuid = THREE.Math.generateUUID();

		this.type = 'MultiMaterial';

		this.materials = materials instanceof Array ? materials : [];

		this.visible = true;

	};

	THREE.MultiMaterial.prototype = {

		constructor: THREE.MultiMaterial,

		toJSON: function (meta) {

			var output = {
				metadata: {
					version: 4.2,
					type: 'material',
					generator: 'MaterialExporter'
				},
				uuid: this.uuid,
				type: this.type,
				materials: []
			};

			var materials = this.materials;

			for (var i = 0, l = materials.length; i < l; i++) {

				var material = materials[i].toJSON(meta);
				delete material.metadata;

				output.materials.push(material);

			}

			output.visible = this.visible;

			return output;

		},

		clone: function () {

			var material = new this.constructor();

			for (var i = 0; i < this.materials.length; i++) {

				material.materials.push(this.materials[i].clone());

			}

			material.visible = this.visible;

			return material;

		}

	};

	// File:src/materials/PointsMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>
	 * }
	 */

	THREE.PointsMaterial = function (parameters) {

		THREE.Material.call(this);

		this.type = 'PointsMaterial';

		this.color = new THREE.Color(0xffffff);

		this.map = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.lights = false;

		this.setValues(parameters);

	};

	THREE.PointsMaterial.prototype = Object.create(THREE.Material.prototype);
	THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;

	THREE.PointsMaterial.prototype.copy = function (source) {

		THREE.Material.prototype.copy.call(this, source);

		this.color.copy(source.color);

		this.map = source.map;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		return this;

	};

	// File:src/materials/ShaderMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	THREE.ShaderMaterial = function (parameters) {

		THREE.Material.call(this);

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};

		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.skinning = false; // set to use skinning attribute streams
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals

		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [1, 1, 1],
			'uv': [0, 0],
			'uv2': [0, 0]
		};

		this.index0AttributeName = undefined;

		if (parameters !== undefined) {

			if (parameters.attributes !== undefined) {

				//console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			}

			this.setValues(parameters);

		}

	};

	THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
	THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

	THREE.ShaderMaterial.prototype.copy = function (source) {

		THREE.Material.prototype.copy.call(this, source);

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = THREE.UniformsUtils.clone(source.uniforms);

		this.defines = source.defines;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.lights = source.lights;
		this.clipping = source.clipping;

		this.skinning = source.skinning;

		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.extensions = source.extensions;

		return this;

	};

	THREE.ShaderMaterial.prototype.toJSON = function (meta) {

		var data = THREE.Material.prototype.toJSON.call(this, meta);

		data.uniforms = this.uniforms;
		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		return data;

	};

	// File:src/materials/RawShaderMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.RawShaderMaterial = function (parameters) {

		THREE.ShaderMaterial.call(this, parameters);

		this.type = 'RawShaderMaterial';

	};

	THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
	THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;

	// File:src/materials/SpriteMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2()
	 * }
	 */

	THREE.SpriteMaterial = function (parameters) {

		THREE.Material.call(this);

		this.type = 'SpriteMaterial';

		this.color = new THREE.Color(0xffffff);
		this.map = null;

		this.rotation = 0;

		this.fog = false;
		this.lights = false;

		this.setValues(parameters);

	};

	THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);
	THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

	THREE.SpriteMaterial.prototype.copy = function (source) {

		THREE.Material.prototype.copy.call(this, source);

		this.color.copy(source.color);
		this.map = source.map;

		this.rotation = source.rotation;

		return this;

	};

	// File:src/materials/ShadowMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.ShadowMaterial = function () {

		THREE.ShaderMaterial.call(this, {
			uniforms: THREE.UniformsUtils.merge([
				THREE.UniformsLib["lights"],
				{
					opacity: { value: 1.0 }
				}
			]),
			vertexShader: THREE.ShaderChunk['shadow_vert'],
			fragmentShader: THREE.ShaderChunk['shadow_frag']
		});

		this.lights = true;
		this.transparent = true;

		Object.defineProperties(this, {
			opacity: {
				enumerable: true,
				get: function () {
					return this.uniforms.opacity.value;
				},
				set: function (value) {
					this.uniforms.opacity.value = value;
				}
			}
		});

	};

	THREE.ShadowMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
	THREE.ShadowMaterial.prototype.constructor = THREE.ShadowMaterial;

	// File:src/textures/Texture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	THREE.Texture = function (image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {

		Object.defineProperty(this, 'id', { value: THREE.TextureIdCount++ });

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.sourceFile = '';

		this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
		this.mipmaps = [];

		this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

		this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

		this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

		this.format = format !== undefined ? format : THREE.RGBAFormat;
		this.type = type !== undefined ? type : THREE.UnsignedByteType;

		this.offset = new THREE.Vector2(0, 0);
		this.repeat = new THREE.Vector2(1, 1);

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)


		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding !== undefined ? encoding : THREE.LinearEncoding;

		this.version = 0;
		this.onUpdate = null;

	};

	THREE.Texture.DEFAULT_IMAGE = undefined;
	THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

	THREE.Texture.prototype = {

		constructor: THREE.Texture,

		set needsUpdate(value) {

			if (value === true) this.version++;

		},

		clone: function () {

			return new this.constructor().copy(this);

		},

		copy: function (source) {

			this.image = source.image;
			this.mipmaps = source.mipmaps.slice(0);

			this.mapping = source.mapping;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.type = source.type;

			this.offset.copy(source.offset);
			this.repeat.copy(source.repeat);

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;

			return this;

		},

		toJSON: function (meta) {

			if (meta.textures[this.uuid] !== undefined) {

				return meta.textures[this.uuid];

			}

			function getDataURL(image) {

				var canvas;

				if (image.toDataURL !== undefined) {

					canvas = image;

				} else {

					canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
					canvas.width = image.width;
					canvas.height = image.height;

					canvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height);

				}

				if (canvas.width > 2048 || canvas.height > 2048) {

					return canvas.toDataURL('image/jpeg', 0.6);

				} else {

					return canvas.toDataURL('image/png');

				}

			}

			var output = {
				metadata: {
					version: 4.4,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				mapping: this.mapping,

				repeat: [this.repeat.x, this.repeat.y],
				offset: [this.offset.x, this.offset.y],
				wrap: [this.wrapS, this.wrapT],

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy
			};

			if (this.image !== undefined) {

				// TODO: Move to THREE.Image

				var image = this.image;

				if (image.uuid === undefined) {

					image.uuid = THREE.Math.generateUUID(); // UGH

				}

				if (meta.images[image.uuid] === undefined) {

					meta.images[image.uuid] = {
						uuid: image.uuid,
						url: getDataURL(image)
					};

				}

				output.image = image.uuid;

			}

			meta.textures[this.uuid] = output;

			return output;

		},

		dispose: function () {

			this.dispatchEvent({ type: 'dispose' });

		},

		transformUv: function (uv) {

			if (this.mapping !== THREE.UVMapping) return;

			uv.multiply(this.repeat);
			uv.add(this.offset);

			if (uv.x < 0 || uv.x > 1) {

				switch (this.wrapS) {

					case THREE.RepeatWrapping:

						uv.x = uv.x - Math.floor(uv.x);
						break;

					case THREE.ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case THREE.MirroredRepeatWrapping:

						if (Math.abs(Math.floor(uv.x) % 2) === 1) {

							uv.x = Math.ceil(uv.x) - uv.x;

						} else {

							uv.x = uv.x - Math.floor(uv.x);

						}
						break;

				}

			}

			if (uv.y < 0 || uv.y > 1) {

				switch (this.wrapT) {

					case THREE.RepeatWrapping:

						uv.y = uv.y - Math.floor(uv.y);
						break;

					case THREE.ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case THREE.MirroredRepeatWrapping:

						if (Math.abs(Math.floor(uv.y) % 2) === 1) {

							uv.y = Math.ceil(uv.y) - uv.y;

						} else {

							uv.y = uv.y - Math.floor(uv.y);

						}
						break;

				}

			}

			if (this.flipY) {

				uv.y = 1 - uv.y;

			}

		}

	};

	Object.assign(THREE.Texture.prototype, THREE.EventDispatcher.prototype);

	THREE.TextureIdCount = 0;

	// File:src/textures/DepthTexture.js

	/**
	 * @author Matt DesLauriers / @mattdesl
	 */

	THREE.DepthTexture = function (width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {

		THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, THREE.DepthFormat, type, anisotropy);

		this.image = { width: width, height: height };

		this.type = type !== undefined ? type : THREE.UnsignedShortType;

		this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;

		this.flipY = false;
		this.generateMipmaps = false;

	};

	THREE.DepthTexture.prototype = Object.create(THREE.Texture.prototype);
	THREE.DepthTexture.prototype.constructor = THREE.DepthTexture;

	// File:src/textures/CanvasTexture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CanvasTexture = function (canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {

		THREE.Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);

		this.needsUpdate = true;

	};

	THREE.CanvasTexture.prototype = Object.create(THREE.Texture.prototype);
	THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

	// File:src/textures/CubeTexture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CubeTexture = function (images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {

		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;

		THREE.Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

		this.flipY = false;

	};

	THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype);
	THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

	Object.defineProperty(THREE.CubeTexture.prototype, 'images', {

		get: function () {

			return this.image;

		},

		set: function (value) {

			this.image = value;

		}

	});

	// File:src/textures/CompressedTexture.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.CompressedTexture = function (mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {

		THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	};

	THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
	THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

	// File:src/textures/DataTexture.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.DataTexture = function (data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {

		THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

		this.image = { data: data, width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;

		this.flipY = false;
		this.generateMipmaps = false;

	};

	THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
	THREE.DataTexture.prototype.constructor = THREE.DataTexture;

	// File:src/textures/VideoTexture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.VideoTexture = function (video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {

		THREE.Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);

		this.generateMipmaps = false;

		var scope = this;

		function update() {

			requestAnimationFrame(update);

			if (video.readyState >= video.HAVE_CURRENT_DATA) {

				scope.needsUpdate = true;

			}

		}

		update();

	};

	THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype);
	THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

	// File:src/objects/Group.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Group = function () {

		THREE.Object3D.call(this);

		this.type = 'Group';

	};

	THREE.Group.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {

		constructor: THREE.Group

	});

	// File:src/objects/Points.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Points = function (geometry, material) {

		THREE.Object3D.call(this);

		this.type = 'Points';

		this.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();
		this.material = material !== undefined ? material : new THREE.PointsMaterial({ color: Math.random() * 0xffffff });

	};

	THREE.Points.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {

		constructor: THREE.Points,

		raycast: (function () {

			var inverseMatrix = new THREE.Matrix4();
			var ray = new THREE.Ray();
			var sphere = new THREE.Sphere();

			return function raycast(raycaster, intersects) {

				var object = this;
				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;
				var threshold = raycaster.params.Points.threshold;

				// Checking boundingSphere distance to ray

				if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

				sphere.copy(geometry.boundingSphere);
				sphere.applyMatrix4(matrixWorld);

				if (raycaster.ray.intersectsSphere(sphere) === false) return;

				//

				inverseMatrix.getInverse(matrixWorld);
				ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

				var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
				var localThresholdSq = localThreshold * localThreshold;
				var position = new THREE.Vector3();

				function testPoint(point, index) {

					var rayPointDistanceSq = ray.distanceSqToPoint(point);

					if (rayPointDistanceSq < localThresholdSq) {

						var intersectPoint = ray.closestPointToPoint(point);
						intersectPoint.applyMatrix4(matrixWorld);

						var distance = raycaster.ray.origin.distanceTo(intersectPoint);

						if (distance < raycaster.near || distance > raycaster.far) return;

						intersects.push({

							distance: distance,
							distanceToRay: Math.sqrt(rayPointDistanceSq),
							point: intersectPoint.clone(),
							index: index,
							face: null,
							object: object

						});

					}

				}

				if (geometry instanceof THREE.BufferGeometry) {

					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;

					if (index !== null) {

						var indices = index.array;

						for (var i = 0, il = indices.length; i < il; i++) {

							var a = indices[i];

							position.fromArray(positions, a * 3);

							testPoint(position, a);

						}

					} else {

						for (var i = 0, l = positions.length / 3; i < l; i++) {

							position.fromArray(positions, i * 3);

							testPoint(position, i);

						}

					}

				} else {

					var vertices = geometry.vertices;

					for (var i = 0, l = vertices.length; i < l; i++) {

						testPoint(vertices[i], i);

					}

				}

			};

		}()),

		clone: function () {

			return new this.constructor(this.geometry, this.material).copy(this);

		}

	});

	// File:src/objects/Line.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Line = function (geometry, material, mode) {

		if (mode === 1) {

			////console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
			return new THREE.LineSegments(geometry, material);

		}

		THREE.Object3D.call(this);

		this.type = 'Line';

		this.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();
		this.material = material !== undefined ? material : new THREE.LineBasicMaterial({ color: Math.random() * 0xffffff });

	};

	THREE.Line.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {

		constructor: THREE.Line,

		raycast: (function () {

			var inverseMatrix = new THREE.Matrix4();
			var ray = new THREE.Ray();
			var sphere = new THREE.Sphere();

			return function raycast(raycaster, intersects) {

				var precision = raycaster.linePrecision;
				var precisionSq = precision * precision;

				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;

				// Checking boundingSphere distance to ray

				if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

				sphere.copy(geometry.boundingSphere);
				sphere.applyMatrix4(matrixWorld);

				if (raycaster.ray.intersectsSphere(sphere) === false) return;

				//

				inverseMatrix.getInverse(matrixWorld);
				ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

				var vStart = new THREE.Vector3();
				var vEnd = new THREE.Vector3();
				var interSegment = new THREE.Vector3();
				var interRay = new THREE.Vector3();
				var step = this instanceof THREE.LineSegments ? 2 : 1;

				if (geometry instanceof THREE.BufferGeometry) {

					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;

					if (index !== null) {

						var indices = index.array;

						for (var i = 0, l = indices.length - 1; i < l; i += step) {

							var a = indices[i];
							var b = indices[i + 1];

							vStart.fromArray(positions, a * 3);
							vEnd.fromArray(positions, b * 3);

							var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

							if (distSq > precisionSq) continue;

							interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo(interRay);

							if (distance < raycaster.near || distance > raycaster.far) continue;

							intersects.push({

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4(this.matrixWorld),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							});

						}

					} else {

						for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {

							vStart.fromArray(positions, 3 * i);
							vEnd.fromArray(positions, 3 * i + 3);

							var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

							if (distSq > precisionSq) continue;

							interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo(interRay);

							if (distance < raycaster.near || distance > raycaster.far) continue;

							intersects.push({

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4(this.matrixWorld),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							});

						}

					}

				} else if (geometry instanceof THREE.Geometry) {

					var vertices = geometry.vertices;
					var nbVertices = vertices.length;

					for (var i = 0; i < nbVertices - 1; i += step) {

						var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);

						if (distSq > precisionSq) continue;

						interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo(interRay);

						if (distance < raycaster.near || distance > raycaster.far) continue;

						intersects.push({

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4(this.matrixWorld),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						});

					}

				}

			};

		}()),

		clone: function () {

			return new this.constructor(this.geometry, this.material).copy(this);

		}

	});

	// File:src/objects/LineSegments.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LineSegments = function (geometry, material) {

		THREE.Line.call(this, geometry, material);

		this.type = 'LineSegments';

	};

	THREE.LineSegments.prototype = Object.assign(Object.create(THREE.Line.prototype), {

		constructor: THREE.LineSegments

	});

	// File:src/objects/Mesh.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */

	THREE.Mesh = function (geometry, material) {

		THREE.Object3D.call(this);

		this.type = 'Mesh';

		this.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();
		this.material = material !== undefined ? material : new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff });

		this.drawMode = THREE.TrianglesDrawMode;

		this.updateMorphTargets();

	};

	THREE.Mesh.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {

		constructor: THREE.Mesh,

		setDrawMode: function (value) {

			this.drawMode = value;

		},

		copy: function (source) {

			THREE.Object3D.prototype.copy.call(this, source);

			this.drawMode = source.drawMode;

			return this;

		},

		updateMorphTargets: function () {

			if (this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0) {

				this.morphTargetBase = - 1;
				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for (var m = 0, ml = this.geometry.morphTargets.length; m < ml; m++) {

					this.morphTargetInfluences.push(0);
					this.morphTargetDictionary[this.geometry.morphTargets[m].name] = m;

				}

			}

		},

		getMorphTargetIndexByName: function (name) {

			if (this.morphTargetDictionary[name] !== undefined) {

				return this.morphTargetDictionary[name];

			}

			////console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

			return 0;

		},

		raycast: (function () {

			var inverseMatrix = new THREE.Matrix4();
			var ray = new THREE.Ray();
			var sphere = new THREE.Sphere();

			var vA = new THREE.Vector3();
			var vB = new THREE.Vector3();
			var vC = new THREE.Vector3();

			var tempA = new THREE.Vector3();
			var tempB = new THREE.Vector3();
			var tempC = new THREE.Vector3();

			var uvA = new THREE.Vector2();
			var uvB = new THREE.Vector2();
			var uvC = new THREE.Vector2();

			var barycoord = new THREE.Vector3();

			var intersectionPoint = new THREE.Vector3();
			var intersectionPointWorld = new THREE.Vector3();

			function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {

				THREE.Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);

				uv1.multiplyScalar(barycoord.x);
				uv2.multiplyScalar(barycoord.y);
				uv3.multiplyScalar(barycoord.z);

				uv1.add(uv2).add(uv3);

				return uv1.clone();

			}

			function checkIntersection(object, raycaster, ray, pA, pB, pC, point) {

				var intersect;
				var material = object.material;

				if (material.side === THREE.BackSide) {

					intersect = ray.intersectTriangle(pC, pB, pA, true, point);

				} else {

					intersect = ray.intersectTriangle(pA, pB, pC, material.side !== THREE.DoubleSide, point);

				}

				if (intersect === null) return null;

				intersectionPointWorld.copy(point);
				intersectionPointWorld.applyMatrix4(object.matrixWorld);

				var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);

				if (distance < raycaster.near || distance > raycaster.far) return null;

				return {
					distance: distance,
					point: intersectionPointWorld.clone(),
					object: object
				};

			}

			function checkBufferGeometryIntersection(object, raycaster, ray, positions, uvs, a, b, c) {

				vA.fromArray(positions, a * 3);
				vB.fromArray(positions, b * 3);
				vC.fromArray(positions, c * 3);

				var intersection = checkIntersection(object, raycaster, ray, vA, vB, vC, intersectionPoint);

				if (intersection) {

					if (uvs) {

						uvA.fromArray(uvs, a * 2);
						uvB.fromArray(uvs, b * 2);
						uvC.fromArray(uvs, c * 2);

						intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);

					}

					intersection.face = new THREE.Face3(a, b, c, THREE.Triangle.normal(vA, vB, vC));
					intersection.faceIndex = a;

				}

				return intersection;

			}

			return function raycast(raycaster, intersects) {

				var geometry = this.geometry;
				var material = this.material;
				var matrixWorld = this.matrixWorld;

				if (material === undefined) return;

				// Checking boundingSphere distance to ray

				if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

				sphere.copy(geometry.boundingSphere);
				sphere.applyMatrix4(matrixWorld);

				if (raycaster.ray.intersectsSphere(sphere) === false) return;

				//

				inverseMatrix.getInverse(matrixWorld);
				ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

				// Check boundingBox before continuing

				if (geometry.boundingBox !== null) {

					if (ray.intersectsBox(geometry.boundingBox) === false) return;

				}

				var uvs, intersection;

				if (geometry instanceof THREE.BufferGeometry) {

					var a, b, c;
					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;

					if (attributes.uv !== undefined) {

						uvs = attributes.uv.array;

					}

					if (index !== null) {

						var indices = index.array;

						for (var i = 0, l = indices.length; i < l; i += 3) {

							a = indices[i];
							b = indices[i + 1];
							c = indices[i + 2];

							intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);

							if (intersection) {

								intersection.faceIndex = Math.floor(i / 3); // triangle number in indices buffer semantics
								intersects.push(intersection);

							}

						}

					} else {


						for (var i = 0, l = positions.length; i < l; i += 9) {

							a = i / 3;
							b = a + 1;
							c = a + 2;

							intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);

							if (intersection) {

								intersection.index = a; // triangle number in positions buffer semantics
								intersects.push(intersection);

							}

						}

					}

				} else if (geometry instanceof THREE.Geometry) {

					var fvA, fvB, fvC;
					var isFaceMaterial = material instanceof THREE.MultiMaterial;
					var materials = isFaceMaterial === true ? material.materials : null;

					var vertices = geometry.vertices;
					var faces = geometry.faces;
					var faceVertexUvs = geometry.faceVertexUvs[0];
					if (faceVertexUvs.length > 0) uvs = faceVertexUvs;

					for (var f = 0, fl = faces.length; f < fl; f++) {

						var face = faces[f];
						var faceMaterial = isFaceMaterial === true ? materials[face.materialIndex] : material;

						if (faceMaterial === undefined) continue;

						fvA = vertices[face.a];
						fvB = vertices[face.b];
						fvC = vertices[face.c];

						if (faceMaterial.morphTargets === true) {

							var morphTargets = geometry.morphTargets;
							var morphInfluences = this.morphTargetInfluences;

							vA.set(0, 0, 0);
							vB.set(0, 0, 0);
							vC.set(0, 0, 0);

							for (var t = 0, tl = morphTargets.length; t < tl; t++) {

								var influence = morphInfluences[t];

								if (influence === 0) continue;

								var targets = morphTargets[t].vertices;

								vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
								vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
								vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);

							}

							vA.add(fvA);
							vB.add(fvB);
							vC.add(fvC);

							fvA = vA;
							fvB = vB;
							fvC = vC;

						}

						intersection = checkIntersection(this, raycaster, ray, fvA, fvB, fvC, intersectionPoint);

						if (intersection) {

							if (uvs) {

								var uvs_f = uvs[f];
								uvA.copy(uvs_f[0]);
								uvB.copy(uvs_f[1]);
								uvC.copy(uvs_f[2]);

								intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);

							}

							intersection.face = face;
							intersection.faceIndex = f;
							intersects.push(intersection);

						}

					}

				}

			};

		}()),

		clone: function () {

			return new this.constructor(this.geometry, this.material).copy(this);

		}

	});

	// File:src/objects/Bone.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.Bone = function (skin) {

		THREE.Object3D.call(this);

		this.type = 'Bone';

		this.skin = skin;

	};

	THREE.Bone.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {

		constructor: THREE.Bone,

		copy: function (source) {

			THREE.Object3D.prototype.copy.call(this, source);

			this.skin = source.skin;

			return this;

		}

	});

	// File:src/objects/Skeleton.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */

	THREE.Skeleton = function (bones, boneInverses, useVertexTexture) {

		this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

		this.identityMatrix = new THREE.Matrix4();

		// copy the bone array

		bones = bones || [];

		this.bones = bones.slice(0);

		// create a bone texture or an array of floats

		if (this.useVertexTexture) {

			// layout (1 matrix = 4 pixels)
			//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
			//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
			//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
			//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


			var size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix
			size = THREE.Math.nextPowerOfTwo(Math.ceil(size));
			size = Math.max(size, 4);

			this.boneTextureWidth = size;
			this.boneTextureHeight = size;

			this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4); // 4 floats per RGBA pixel
			this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType);

		} else {

			this.boneMatrices = new Float32Array(16 * this.bones.length);

		}

		// use the supplied bone inverses or calculate the inverses

		if (boneInverses === undefined) {

			this.calculateInverses();

		} else {

			if (this.bones.length === boneInverses.length) {

				this.boneInverses = boneInverses.slice(0);

			} else {

				////console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

				this.boneInverses = [];

				for (var b = 0, bl = this.bones.length; b < bl; b++) {

					this.boneInverses.push(new THREE.Matrix4());

				}

			}

		}

	};

	Object.assign(THREE.Skeleton.prototype, {

		calculateInverses: function () {

			this.boneInverses = [];

			for (var b = 0, bl = this.bones.length; b < bl; b++) {

				var inverse = new THREE.Matrix4();

				if (this.bones[b]) {

					inverse.getInverse(this.bones[b].matrixWorld);

				}

				this.boneInverses.push(inverse);

			}

		},

		pose: function () {

			var bone;

			// recover the bind-time world matrices

			for (var b = 0, bl = this.bones.length; b < bl; b++) {

				bone = this.bones[b];

				if (bone) {

					bone.matrixWorld.getInverse(this.boneInverses[b]);

				}

			}

			// compute the local matrices, positions, rotations and scales

			for (var b = 0, bl = this.bones.length; b < bl; b++) {

				bone = this.bones[b];

				if (bone) {

					if (bone.parent instanceof THREE.Bone) {

						bone.matrix.getInverse(bone.parent.matrixWorld);
						bone.matrix.multiply(bone.matrixWorld);

					} else {

						bone.matrix.copy(bone.matrixWorld);

					}

					bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);

				}

			}

		},

		update: (function () {

			var offsetMatrix = new THREE.Matrix4();

			return function update() {

				// flatten bone matrices to array

				for (var b = 0, bl = this.bones.length; b < bl; b++) {

					// compute the offset between the current and the original transform

					var matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;

					offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]);
					offsetMatrix.toArray(this.boneMatrices, b * 16);

				}

				if (this.useVertexTexture) {

					this.boneTexture.needsUpdate = true;

				}

			};

		})(),

		clone: function () {

			return new THREE.Skeleton(this.bones, this.boneInverses, this.useVertexTexture);

		}

	});

	// File:src/objects/SkinnedMesh.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.SkinnedMesh = function (geometry, material, useVertexTexture) {

		THREE.Mesh.call(this, geometry, material);

		this.type = 'SkinnedMesh';

		this.bindMode = "attached";
		this.bindMatrix = new THREE.Matrix4();
		this.bindMatrixInverse = new THREE.Matrix4();

		// init bones

		// TODO: remove bone creation as there is no reason (other than
		// convenience) for THREE.SkinnedMesh to do this.

		var bones = [];

		if (this.geometry && this.geometry.bones !== undefined) {

			var bone, gbone;

			for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {

				gbone = this.geometry.bones[b];

				bone = new THREE.Bone(this);
				bones.push(bone);

				bone.name = gbone.name;
				bone.position.fromArray(gbone.pos);
				bone.quaternion.fromArray(gbone.rotq);
				if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl);

			}

			for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {

				gbone = this.geometry.bones[b];

				if (gbone.parent !== - 1 && gbone.parent !== null &&
					bones[gbone.parent] !== undefined) {

					bones[gbone.parent].add(bones[b]);

				} else {

					this.add(bones[b]);

				}

			}

		}

		this.normalizeSkinWeights();

		this.updateMatrixWorld(true);
		this.bind(new THREE.Skeleton(bones, undefined, useVertexTexture), this.matrixWorld);

	};


	THREE.SkinnedMesh.prototype = Object.assign(Object.create(THREE.Mesh.prototype), {

		constructor: THREE.SkinnedMesh,

		bind: function (skeleton, bindMatrix) {

			this.skeleton = skeleton;

			if (bindMatrix === undefined) {

				this.updateMatrixWorld(true);

				this.skeleton.calculateInverses();

				bindMatrix = this.matrixWorld;

			}

			this.bindMatrix.copy(bindMatrix);
			this.bindMatrixInverse.getInverse(bindMatrix);

		},

		pose: function () {

			this.skeleton.pose();

		},

		normalizeSkinWeights: function () {

			if (this.geometry instanceof THREE.Geometry) {

				for (var i = 0; i < this.geometry.skinWeights.length; i++) {

					var sw = this.geometry.skinWeights[i];

					var scale = 1.0 / sw.lengthManhattan();

					if (scale !== Infinity) {

						sw.multiplyScalar(scale);

					} else {

						sw.set(1, 0, 0, 0); // do something reasonable

					}

				}

			} else if (this.geometry instanceof THREE.BufferGeometry) {

				var vec = new THREE.Vector4();

				var skinWeight = this.geometry.attributes.skinWeight;

				for (var i = 0; i < skinWeight.count; i++) {

					vec.x = skinWeight.getX(i);
					vec.y = skinWeight.getY(i);
					vec.z = skinWeight.getZ(i);
					vec.w = skinWeight.getW(i);

					var scale = 1.0 / vec.lengthManhattan();

					if (scale !== Infinity) {

						vec.multiplyScalar(scale);

					} else {

						vec.set(1, 0, 0, 0); // do something reasonable

					}

					skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w);

				}

			}

		},

		updateMatrixWorld: function (force) {

			THREE.Mesh.prototype.updateMatrixWorld.call(this, true);

			if (this.bindMode === "attached") {

				this.bindMatrixInverse.getInverse(this.matrixWorld);

			} else if (this.bindMode === "detached") {

				this.bindMatrixInverse.getInverse(this.bindMatrix);

			} else {

				////console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

			}

		},

		clone: function () {

			return new this.constructor(this.geometry, this.material, this.skeleton.useVertexTexture).copy(this);

		}

	});

	// File:src/objects/LOD.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LOD = function () {

		THREE.Object3D.call(this);

		this.type = 'LOD';

		Object.defineProperties(this, {
			levels: {
				enumerable: true,
				value: []
			}
		});

	};


	THREE.LOD.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {

		constructor: THREE.LOD,

		copy: function (source) {

			THREE.Object3D.prototype.copy.call(this, source, false);

			var levels = source.levels;

			for (var i = 0, l = levels.length; i < l; i++) {

				var level = levels[i];

				this.addLevel(level.object.clone(), level.distance);

			}

			return this;

		},

		addLevel: function (object, distance) {

			if (distance === undefined) distance = 0;

			distance = Math.abs(distance);

			var levels = this.levels;

			for (var l = 0; l < levels.length; l++) {

				if (distance < levels[l].distance) {

					break;

				}

			}

			levels.splice(l, 0, { distance: distance, object: object });

			this.add(object);

		},

		getObjectForDistance: function (distance) {

			var levels = this.levels;

			for (var i = 1, l = levels.length; i < l; i++) {

				if (distance < levels[i].distance) {

					break;

				}

			}

			return levels[i - 1].object;

		},

		raycast: (function () {

			var matrixPosition = new THREE.Vector3();

			return function raycast(raycaster, intersects) {

				matrixPosition.setFromMatrixPosition(this.matrixWorld);

				var distance = raycaster.ray.origin.distanceTo(matrixPosition);

				this.getObjectForDistance(distance).raycast(raycaster, intersects);

			};

		}()),

		update: function () {

			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();

			return function update(camera) {

				var levels = this.levels;

				if (levels.length > 1) {

					v1.setFromMatrixPosition(camera.matrixWorld);
					v2.setFromMatrixPosition(this.matrixWorld);

					var distance = v1.distanceTo(v2);

					levels[0].object.visible = true;

					for (var i = 1, l = levels.length; i < l; i++) {

						if (distance >= levels[i].distance) {

							levels[i - 1].object.visible = false;
							levels[i].object.visible = true;

						} else {

							break;

						}

					}

					for (; i < l; i++) {

						levels[i].object.visible = false;

					}

				}

			};

		}(),

		toJSON: function (meta) {

			var data = THREE.Object3D.prototype.toJSON.call(this, meta);

			data.object.levels = [];

			var levels = this.levels;

			for (var i = 0, l = levels.length; i < l; i++) {

				var level = levels[i];

				data.object.levels.push({
					object: level.object.uuid,
					distance: level.distance
				});

			}

			return data;

		}

	});

	// File:src/objects/Sprite.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Sprite = function (material) {

		THREE.Object3D.call(this);

		this.type = 'Sprite';

		this.material = (material !== undefined) ? material : new THREE.SpriteMaterial();

	};

	THREE.Sprite.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {

		constructor: THREE.Sprite,

		raycast: (function () {

			var matrixPosition = new THREE.Vector3();

			return function raycast(raycaster, intersects) {

				matrixPosition.setFromMatrixPosition(this.matrixWorld);

				var distanceSq = raycaster.ray.distanceSqToPoint(matrixPosition);
				var guessSizeSq = this.scale.x * this.scale.y / 4;

				if (distanceSq > guessSizeSq) {

					return;

				}

				intersects.push({

					distance: Math.sqrt(distanceSq),
					point: this.position,
					face: null,
					object: this

				});

			};

		}()),

		clone: function () {

			return new this.constructor(this.material).copy(this);

		}

	});

	// File:src/objects/LensFlare.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.LensFlare = function (texture, size, distance, blending, color) {

		THREE.Object3D.call(this);

		this.lensFlares = [];

		this.positionScreen = new THREE.Vector3();
		this.customUpdateCallback = undefined;

		if (texture !== undefined) {

			this.add(texture, size, distance, blending, color);

		}

	};

	THREE.LensFlare.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {

		constructor: THREE.LensFlare,

		copy: function (source) {

			THREE.Object3D.prototype.copy.call(this, source);

			this.positionScreen.copy(source.positionScreen);
			this.customUpdateCallback = source.customUpdateCallback;

			for (var i = 0, l = source.lensFlares.length; i < l; i++) {

				this.lensFlares.push(source.lensFlares[i]);

			}

			return this;

		},

		add: function (texture, size, distance, blending, color, opacity) {

			if (size === undefined) size = - 1;
			if (distance === undefined) distance = 0;
			if (opacity === undefined) opacity = 1;
			if (color === undefined) color = new THREE.Color(0xffffff);
			if (blending === undefined) blending = THREE.NormalBlending;

			distance = Math.min(distance, Math.max(0, distance));

			this.lensFlares.push({
				texture: texture,	// THREE.Texture
				size: size, 		// size in pixels (-1 = use texture.width)
				distance: distance, 	// distance (0-1) from light source (0=at light source)
				x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
				scale: 1, 		// scale
				rotation: 0, 		// rotation
				opacity: opacity,	// opacity
				color: color,		// color
				blending: blending	// blending
			});

		},

		/*
		 * Update lens flares update positions on all flares based on the screen position
		 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
		 */

		updateLensFlares: function () {

			var f, fl = this.lensFlares.length;
			var flare;
			var vecX = - this.positionScreen.x * 2;
			var vecY = - this.positionScreen.y * 2;

			for (f = 0; f < fl; f++) {

				flare = this.lensFlares[f];

				flare.x = this.positionScreen.x + vecX * flare.distance;
				flare.y = this.positionScreen.y + vecY * flare.distance;

				flare.wantedRotation = flare.x * Math.PI * 0.25;
				flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;

			}

		}

	});

	// File:src/scenes/Scene.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Scene = function () {

		THREE.Object3D.call(this);

		this.type = 'Scene';

		this.background = null;
		this.fog = null;
		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

	};

	THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
	THREE.Scene.prototype.constructor = THREE.Scene;

	THREE.Scene.prototype.copy = function (source, recursive) {

		THREE.Object3D.prototype.copy.call(this, source, recursive);

		if (source.background !== null) this.background = source.background.clone();
		if (source.fog !== null) this.fog = source.fog.clone();
		if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();

		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	};

	// File:src/scenes/Fog.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Fog = function (color, near, far) {

		this.name = '';

		this.color = new THREE.Color(color);

		this.near = (near !== undefined) ? near : 1;
		this.far = (far !== undefined) ? far : 1000;

	};

	THREE.Fog.prototype.clone = function () {

		return new THREE.Fog(this.color.getHex(), this.near, this.far);

	};

	// File:src/scenes/FogExp2.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.FogExp2 = function (color, density) {

		this.name = '';

		this.color = new THREE.Color(color);
		this.density = (density !== undefined) ? density : 0.00025;

	};

	THREE.FogExp2.prototype.clone = function () {

		return new THREE.FogExp2(this.color.getHex(), this.density);

	};

	// File:src/renderers/shaders/ShaderChunk.js

	THREE.ShaderChunk = {};

	// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

	THREE.ShaderChunk['alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

	THREE.ShaderChunk['alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

	THREE.ShaderChunk['alphatest_fragment'] = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl

	THREE.ShaderChunk['aomap_fragment'] = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl

	THREE.ShaderChunk['aomap_pars_fragment'] = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";

	// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl

	THREE.ShaderChunk['begin_vertex'] = "\nvec3 transformed = vec3( position );\n";

	// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl

	THREE.ShaderChunk['beginnormal_vertex'] = "\nvec3 objectNormal = vec3( normal );\n";

	// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl

	THREE.ShaderChunk['bsdfs'] = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n	return any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n		if( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n			float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n			float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n			return distanceFalloff * maxDistanceCutoffFactor;\n#else\n			return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n		}\n		return 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n	return specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

	// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

	THREE.ShaderChunk['bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl

	THREE.ShaderChunk['clipping_planes_fragment'] = "#if NUM_CLIPPING_PLANES > 0\n	for ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n		vec4 plane = clippingPlanes[ i ];\n		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n	}\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl

	THREE.ShaderChunk['clipping_planes_pars_fragment'] = "#if NUM_CLIPPING_PLANES > 0\n	#if ! defined( PHYSICAL ) && ! defined( PHONG )\n		varying vec3 vViewPosition;\n	#endif\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl

	THREE.ShaderChunk['clipping_planes_pars_vertex'] = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	varying vec3 vViewPosition;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl

	THREE.ShaderChunk['clipping_planes_vertex'] = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	vViewPosition = - mvPosition.xyz;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

	THREE.ShaderChunk['color_fragment'] = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";

	// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

	THREE.ShaderChunk['color_pars_fragment'] = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

	THREE.ShaderChunk['color_pars_vertex'] = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";

	// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

	THREE.ShaderChunk['color_vertex'] = "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif";

	// File:src/renderers/shaders/ShaderChunk/common.glsl

	THREE.ShaderChunk['common'] = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n";

	// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl

	THREE.ShaderChunk['cube_uv_reflection_fragment'] = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n	vec3 absDirection = abs(direction);\n	int face = -1;\n	if( absDirection.x > absDirection.z ) {\n		if(absDirection.x > absDirection.y )\n			face = direction.x > 0.0 ? 0 : 3;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	else {\n		if(absDirection.z > absDirection.y )\n			face = direction.z > 0.0 ? 2 : 5;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	return face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n	float dxRoughness = dFdx(roughness);\n	float dyRoughness = dFdy(roughness);\n	vec3 dx = dFdx( vec * scale * dxRoughness );\n	vec3 dy = dFdy( vec * scale * dyRoughness );\n	float d = max( dot( dx, dx ), dot( dy, dy ) );\n	d = clamp(d, 1.0, cubeUV_rangeClamp);\n	float mipLevel = 0.5 * log2(d);\n	return vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n	float a = 16.0 * cubeUV_rcpTextureSize;\n	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n	float powScale = exp2_packed.x * exp2_packed.y;\n	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n	bool bRes = mipLevel == 0.0;\n	scale =  bRes && (scale < a) ? a : scale;\n	vec3 r;\n	vec2 offset;\n	int face = getFaceFromDirection(direction);\n	float rcpPowScale = 1.0 / powScale;\n	if( face == 0) {\n		r = vec3(direction.x, -direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 1) {\n		r = vec3(direction.y, direction.x, direction.z);\n		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 2) {\n		r = vec3(direction.z, direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 3) {\n		r = vec3(direction.x, direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	else if( face == 4) {\n		r = vec3(direction.y, direction.x, -direction.z);\n		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	else {\n		r = vec3(direction.z, -direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	r = normalize(r);\n	float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n	vec2 base = offset + vec2( texelOffset );\n	return base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n	float roughnessVal = roughness* cubeUV_maxLods3;\n	float r1 = floor(roughnessVal);\n	float r2 = r1 + 1.0;\n	float t = fract(roughnessVal);\n	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n	float s = mipInfo.y;\n	float level0 = mipInfo.x;\n	float level1 = level0 + 1.0;\n	level1 = level1 > 5.0 ? 5.0 : level1;\n	level0 += min( floor( s + 0.5 ), 5.0 );\n	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n	vec4 result = mix(color10, color20, t);\n	return vec4(result.rgb, 1.0);\n}\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

	THREE.ShaderChunk['defaultnormal_vertex'] = "#ifdef FLIP_SIDED\n	objectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

	// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl

	THREE.ShaderChunk['displacementmap_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl

	THREE.ShaderChunk['displacementmap_pars_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl

	THREE.ShaderChunk['emissivemap_fragment'] = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl

	THREE.ShaderChunk['emissivemap_pars_fragment'] = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl

	THREE.ShaderChunk['encodings_pars_fragment'] = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n";

	// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl

	THREE.ShaderChunk['encodings_fragment'] = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

	THREE.ShaderChunk['envmap_fragment'] = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n	envColor = envMapTexelToLinear( envColor );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

	THREE.ShaderChunk['envmap_pars_fragment'] = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n	uniform float reflectivity;\n	uniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n		varying vec3 vWorldPosition;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

	THREE.ShaderChunk['envmap_pars_vertex'] = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

	THREE.ShaderChunk['envmap_vertex'] = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

	THREE.ShaderChunk['fog_fragment'] = "#ifdef USE_FOG\n	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	#ifdef FOG_EXP2\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

	THREE.ShaderChunk['fog_pars_fragment'] = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

	THREE.ShaderChunk['lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

	THREE.ShaderChunk['lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

	THREE.ShaderChunk['lights_lambert_vertex'] = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl

	THREE.ShaderChunk['lights_pars'] = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		if ( testLightInRange( lightDistance, pointLight.distance ) ) {\n			directLight.color = pointLight.color;\n			directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		#include <normal_flip>\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		#include <normal_flip>\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n			sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

	THREE.ShaderChunk['lights_phong_fragment'] = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

	THREE.ShaderChunk['lights_phong_pars_fragment'] = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)\n";

	// File:src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl

	THREE.ShaderChunk['lights_physical_fragment'] = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl

	THREE.ShaderChunk['lights_physical_pars_fragment'] = "struct PhysicalMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n	#ifndef STANDARD\n		float clearCoat;\n		float clearCoatRoughness;\n	#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	#ifndef STANDARD\n		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n	#ifndef STANDARD\n		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

	// File:src/renderers/shaders/ShaderChunk/lights_template.glsl

	THREE.ShaderChunk['lights_template'] = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef USE_LIGHTMAP\n		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n	 	irradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n	#endif\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n	#ifndef STANDARD\n		vec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n	#else\n		vec3 clearCoatRadiance = vec3( 0.0 );\n	#endif\n		\n	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

	THREE.ShaderChunk['logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

	THREE.ShaderChunk['logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n	uniform float logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

	THREE.ShaderChunk['logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n	uniform float logDepthBufFC;\n#endif";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

	THREE.ShaderChunk['logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n	#endif\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

	THREE.ShaderChunk['map_fragment'] = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

	THREE.ShaderChunk['map_pars_fragment'] = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

	THREE.ShaderChunk['map_particle_fragment'] = "#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

	THREE.ShaderChunk['map_particle_pars_fragment'] = "#ifdef USE_MAP\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl

	THREE.ShaderChunk['metalnessmap_fragment'] = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.r;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl

	THREE.ShaderChunk['metalnessmap_pars_fragment'] = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";

	// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

	THREE.ShaderChunk['morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

	THREE.ShaderChunk['morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";

	// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

	THREE.ShaderChunk['morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/normal_flip.glsl

	THREE.ShaderChunk['normal_flip'] = "#ifdef DOUBLE_SIDED\n	float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n	float flipNormal = 1.0;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl

	THREE.ShaderChunk['normal_fragment'] = "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

	THREE.ShaderChunk['normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n	}\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/packing.glsl

	THREE.ShaderChunk['packing'] = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

	// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl

	THREE.ShaderChunk['premultiplied_alpha_fragment'] = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl

	THREE.ShaderChunk['project_vertex'] = "#ifdef USE_SKINNING\n	vec4 mvPosition = modelViewMatrix * skinned;\n#else\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";

	// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl

	THREE.ShaderChunk['roughnessmap_fragment'] = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.r;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl

	THREE.ShaderChunk['roughnessmap_pars_fragment'] = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

	THREE.ShaderChunk['shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return 1.0;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		vec3 bd3D = normalize( lightToPosition );\n		float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

	THREE.ShaderChunk['shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

	THREE.ShaderChunk['shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl

	THREE.ShaderChunk['shadowmask_pars_fragment'] = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}\n";

	// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

	THREE.ShaderChunk['skinbase_vertex'] = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

	// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

	THREE.ShaderChunk['skinning_pars_vertex'] = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

	THREE.ShaderChunk['skinning_vertex'] = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

	THREE.ShaderChunk['skinnormal_vertex'] = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

	THREE.ShaderChunk['specularmap_fragment'] = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";

	// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

	THREE.ShaderChunk['specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";

	// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl

	THREE.ShaderChunk['tonemapping_fragment'] = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl

	THREE.ShaderChunk['tonemapping_pars_fragment'] = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

	// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl

	THREE.ShaderChunk['uv2_pars_fragment'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl

	THREE.ShaderChunk['uv2_pars_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl

	THREE.ShaderChunk['uv2_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl

	THREE.ShaderChunk['uv_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl

	THREE.ShaderChunk['uv_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl

	THREE.ShaderChunk['uv_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";

	// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

	THREE.ShaderChunk['worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n	#ifdef USE_SKINNING\n		vec4 worldPosition = modelMatrix * skinned;\n	#else\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n	#endif\n#endif\n";

	// File:src/renderers/shaders/UniformsUtils.js

	/**
	 * Uniform Utilities
	 */

	THREE.UniformsUtils = {

		merge: function (uniforms) {

			var merged = {};

			for (var u = 0; u < uniforms.length; u++) {

				var tmp = this.clone(uniforms[u]);

				for (var p in tmp) {

					merged[p] = tmp[p];

				}

			}

			return merged;

		},

		clone: function (uniforms_src) {

			var uniforms_dst = {};

			for (var u in uniforms_src) {

				uniforms_dst[u] = {};

				for (var p in uniforms_src[u]) {

					var parameter_src = uniforms_src[u][p];

					if (parameter_src instanceof THREE.Color ||
						parameter_src instanceof THREE.Vector2 ||
						parameter_src instanceof THREE.Vector3 ||
						parameter_src instanceof THREE.Vector4 ||
						parameter_src instanceof THREE.Matrix3 ||
						parameter_src instanceof THREE.Matrix4 ||
						parameter_src instanceof THREE.Texture) {

						uniforms_dst[u][p] = parameter_src.clone();

					} else if (Array.isArray(parameter_src)) {

						uniforms_dst[u][p] = parameter_src.slice();

					} else {

						uniforms_dst[u][p] = parameter_src;

					}

				}

			}

			return uniforms_dst;

		}

	};

	// File:src/renderers/shaders/UniformsLib.js

	/**
	 * Uniforms library for shared webgl shaders
	 */

	THREE.UniformsLib = {

		common: {

			"diffuse": { value: new THREE.Color(0xeeeeee) },
			"opacity": { value: 1.0 },

			"map": { value: null },
			"offsetRepeat": { value: new THREE.Vector4(0, 0, 1, 1) },

			"specularMap": { value: null },
			"alphaMap": { value: null },

			"envMap": { value: null },
			"flipEnvMap": { value: - 1 },
			"reflectivity": { value: 1.0 },
			"refractionRatio": { value: 0.98 }

		},

		aomap: {

			"aoMap": { value: null },
			"aoMapIntensity": { value: 1 }

		},

		lightmap: {

			"lightMap": { value: null },
			"lightMapIntensity": { value: 1 }

		},

		emissivemap: {

			"emissiveMap": { value: null }

		},

		bumpmap: {

			"bumpMap": { value: null },
			"bumpScale": { value: 1 }

		},

		normalmap: {

			"normalMap": { value: null },
			"normalScale": { value: new THREE.Vector2(1, 1) }

		},

		displacementmap: {

			"displacementMap": { value: null },
			"displacementScale": { value: 1 },
			"displacementBias": { value: 0 }

		},

		roughnessmap: {

			"roughnessMap": { value: null }

		},

		metalnessmap: {

			"metalnessMap": { value: null }

		},

		fog: {

			"fogDensity": { value: 0.00025 },
			"fogNear": { value: 1 },
			"fogFar": { value: 2000 },
			"fogColor": { value: new THREE.Color(0xffffff) }

		},

		lights: {

			"ambientLightColor": { value: [] },

			"directionalLights": {
				value: [], properties: {
					"direction": {},
					"color": {},

					"shadow": {},
					"shadowBias": {},
					"shadowRadius": {},
					"shadowMapSize": {}
				}
			},

			"directionalShadowMap": { value: [] },
			"directionalShadowMatrix": { value: [] },

			"spotLights": {
				value: [], properties: {
					"color": {},
					"position": {},
					"direction": {},
					"distance": {},
					"coneCos": {},
					"penumbraCos": {},
					"decay": {},

					"shadow": {},
					"shadowBias": {},
					"shadowRadius": {},
					"shadowMapSize": {}
				}
			},

			"spotShadowMap": { value: [] },
			"spotShadowMatrix": { value: [] },

			"pointLights": {
				value: [], properties: {
					"color": {},
					"position": {},
					"decay": {},
					"distance": {},

					"shadow": {},
					"shadowBias": {},
					"shadowRadius": {},
					"shadowMapSize": {}
				}
			},

			"pointShadowMap": { value: [] },
			"pointShadowMatrix": { value: [] },

			"hemisphereLights": {
				value: [], properties: {
					"direction": {},
					"skyColor": {},
					"groundColor": {}
				}
			}

		},

		points: {

			"diffuse": { value: new THREE.Color(0xeeeeee) },
			"opacity": { value: 1.0 },
			"size": { value: 1.0 },
			"scale": { value: 1.0 },
			"map": { value: null },
			"offsetRepeat": { value: new THREE.Vector4(0, 0, 1, 1) }

		}

	};

	// File:src/renderers/shaders/ShaderLib/cube_frag.glsl

	THREE.ShaderChunk['cube_frag'] = "uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n	#include <logdepthbuf_fragment>\n}\n";

	// File:src/renderers/shaders/ShaderLib/cube_vert.glsl

	THREE.ShaderChunk['cube_vert'] = "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";

	// File:src/renderers/shaders/ShaderLib/depth_frag.glsl

	THREE.ShaderChunk['depth_frag'] = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n	#endif\n}\n";

	// File:src/renderers/shaders/ShaderLib/depth_vert.glsl

	THREE.ShaderChunk['depth_vert'] = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";

	// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl

	THREE.ShaderChunk['distanceRGBA_frag'] = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	gl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";

	// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl

	THREE.ShaderChunk['distanceRGBA_vert'] = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition;\n}\n";

	// File:src/renderers/shaders/ShaderLib/equirect_frag.glsl

	THREE.ShaderChunk['equirect_frag'] = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 direction = normalize( vWorldPosition );\n	vec2 sampleUV;\n	sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <logdepthbuf_fragment>\n}\n";

	// File:src/renderers/shaders/ShaderLib/equirect_vert.glsl

	THREE.ShaderChunk['equirect_vert'] = "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";

	// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl

	THREE.ShaderChunk['linedashed_frag'] = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";

	// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl

	THREE.ShaderChunk['linedashed_vert'] = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";

	// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl

	THREE.ShaderChunk['meshbasic_frag'] = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight;\n	reflectedLight.directDiffuse = vec3( 0.0 );\n	reflectedLight.directSpecular = vec3( 0.0 );\n	reflectedLight.indirectDiffuse = diffuseColor.rgb;\n	reflectedLight.indirectSpecular = vec3( 0.0 );\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <normal_flip>\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";

	// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl

	THREE.ShaderChunk['meshbasic_vert'] = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n}\n";

	// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl

	THREE.ShaderChunk['meshlambert_frag'] = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <normal_flip>\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";

	// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl

	THREE.ShaderChunk['meshlambert_vert'] = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n}\n";

	// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl

	THREE.ShaderChunk['meshphong_frag'] = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_flip>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";

	// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl

	THREE.ShaderChunk['meshphong_vert'] = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n}\n";

	// File:src/renderers/shaders/ShaderLib/meshphysical_frag.glsl

	THREE.ShaderChunk['meshphysical_frag'] = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n	uniform float clearCoat;\n	uniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_flip>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";

	// File:src/renderers/shaders/ShaderLib/meshphysical_vert.glsl

	THREE.ShaderChunk['meshphysical_vert'] = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n";

	// File:src/renderers/shaders/ShaderLib/normal_frag.glsl

	THREE.ShaderChunk['normal_frag'] = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	gl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n	#include <logdepthbuf_fragment>\n}\n";

	// File:src/renderers/shaders/ShaderLib/normal_vert.glsl

	THREE.ShaderChunk['normal_vert'] = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vNormal = normalize( normalMatrix * normal );\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";

	// File:src/renderers/shaders/ShaderLib/points_frag.glsl

	THREE.ShaderChunk['points_frag'] = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";

	// File:src/renderers/shaders/ShaderLib/points_vert.glsl

	THREE.ShaderChunk['points_vert'] = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <project_vertex>\n	#ifdef USE_SIZEATTENUATION\n		gl_PointSize = size * ( scale / - mvPosition.z );\n	#else\n		gl_PointSize = size;\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n";

	// File:src/renderers/shaders/ShaderLib/shadow_frag.glsl

	THREE.ShaderChunk['shadow_frag'] = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n";

	// File:src/renderers/shaders/ShaderLib/shadow_vert.glsl

	THREE.ShaderChunk['shadow_vert'] = "#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n";

	// File:src/renderers/shaders/ShaderLib.js

	/**
	 * Webgl Shader Library for three.js
	 *
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */


	THREE.ShaderLib = {

		'basic': {

			uniforms: THREE.UniformsUtils.merge([

				THREE.UniformsLib['common'],
				THREE.UniformsLib['aomap'],
				THREE.UniformsLib['fog']

			]),

			vertexShader: THREE.ShaderChunk['meshbasic_vert'],
			fragmentShader: THREE.ShaderChunk['meshbasic_frag']

		},

		'lambert': {

			uniforms: THREE.UniformsUtils.merge([

				THREE.UniformsLib['common'],
				THREE.UniformsLib['aomap'],
				THREE.UniformsLib['lightmap'],
				THREE.UniformsLib['emissivemap'],
				THREE.UniformsLib['fog'],
				THREE.UniformsLib['lights'],

				{
					"emissive": { value: new THREE.Color(0x000000) }
				}

			]),

			vertexShader: THREE.ShaderChunk['meshlambert_vert'],
			fragmentShader: THREE.ShaderChunk['meshlambert_frag']

		},

		'phong': {

			uniforms: THREE.UniformsUtils.merge([

				THREE.UniformsLib['common'],
				THREE.UniformsLib['aomap'],
				THREE.UniformsLib['lightmap'],
				THREE.UniformsLib['emissivemap'],
				THREE.UniformsLib['bumpmap'],
				THREE.UniformsLib['normalmap'],
				THREE.UniformsLib['displacementmap'],
				THREE.UniformsLib['fog'],
				THREE.UniformsLib['lights'],

				{
					"emissive": { value: new THREE.Color(0x000000) },
					"specular": { value: new THREE.Color(0x111111) },
					"shininess": { value: 30 }
				}

			]),

			vertexShader: THREE.ShaderChunk['meshphong_vert'],
			fragmentShader: THREE.ShaderChunk['meshphong_frag']

		},

		'standard': {

			uniforms: THREE.UniformsUtils.merge([

				THREE.UniformsLib['common'],
				THREE.UniformsLib['aomap'],
				THREE.UniformsLib['lightmap'],
				THREE.UniformsLib['emissivemap'],
				THREE.UniformsLib['bumpmap'],
				THREE.UniformsLib['normalmap'],
				THREE.UniformsLib['displacementmap'],
				THREE.UniformsLib['roughnessmap'],
				THREE.UniformsLib['metalnessmap'],
				THREE.UniformsLib['fog'],
				THREE.UniformsLib['lights'],

				{
					"emissive": { value: new THREE.Color(0x000000) },
					"roughness": { value: 0.5 },
					"metalness": { value: 0 },
					"envMapIntensity": { value: 1 }, // temporary
				}

			]),

			vertexShader: THREE.ShaderChunk['meshphysical_vert'],
			fragmentShader: THREE.ShaderChunk['meshphysical_frag']

		},

		'points': {

			uniforms: THREE.UniformsUtils.merge([

				THREE.UniformsLib['points'],
				THREE.UniformsLib['fog']

			]),

			vertexShader: THREE.ShaderChunk['points_vert'],
			fragmentShader: THREE.ShaderChunk['points_frag']

		},

		'dashed': {

			uniforms: THREE.UniformsUtils.merge([

				THREE.UniformsLib['common'],
				THREE.UniformsLib['fog'],

				{
					"scale": { value: 1 },
					"dashSize": { value: 1 },
					"totalSize": { value: 2 }
				}

			]),

			vertexShader: THREE.ShaderChunk['linedashed_vert'],
			fragmentShader: THREE.ShaderChunk['linedashed_frag']

		},

		'depth': {

			uniforms: THREE.UniformsUtils.merge([

				THREE.UniformsLib['common'],
				THREE.UniformsLib['displacementmap']

			]),

			vertexShader: THREE.ShaderChunk['depth_vert'],
			fragmentShader: THREE.ShaderChunk['depth_frag']

		},

		'normal': {

			uniforms: {

				"opacity": { value: 1.0 }

			},

			vertexShader: THREE.ShaderChunk['normal_vert'],
			fragmentShader: THREE.ShaderChunk['normal_frag']

		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		'cube': {

			uniforms: {
				"tCube": { value: null },
				"tFlip": { value: - 1 }
			},

			vertexShader: THREE.ShaderChunk['cube_vert'],
			fragmentShader: THREE.ShaderChunk['cube_frag']

		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		'equirect': {

			uniforms: {
				"tEquirect": { value: null },
				"tFlip": { value: - 1 }
			},

			vertexShader: THREE.ShaderChunk['equirect_vert'],
			fragmentShader: THREE.ShaderChunk['equirect_frag']

		},

		'distanceRGBA': {

			uniforms: {

				"lightPos": { value: new THREE.Vector3() }

			},

			vertexShader: THREE.ShaderChunk['distanceRGBA_vert'],
			fragmentShader: THREE.ShaderChunk['distanceRGBA_frag']

		}

	};

	THREE.ShaderLib['physical'] = {

		uniforms: THREE.UniformsUtils.merge([

			THREE.ShaderLib['standard'].uniforms,

			{
				"clearCoat": { value: 0 },
				"clearCoatRoughness": { value: 0 }
			}

		]),

		vertexShader: THREE.ShaderChunk['meshphysical_vert'],
		fragmentShader: THREE.ShaderChunk['meshphysical_frag']

	};

	// File:src/renderers/WebGLRenderer.js

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 * @author tschw
	 */

	THREE.WebGLRenderer = function (parameters, useExtensions) {
		var _useExtensions = typeof useExtensions !== 'undefined' ? useExtensions : true;
		////console.log( 'THREE.WebGLRenderer', THREE.REVISION );

		parameters = parameters || {};

		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'),
			_context = parameters.context !== undefined ? parameters.context : null,

			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

		var lights = [];

		var opaqueObjects = [];
		var opaqueObjectsLastIndex = - 1;
		var transparentObjects = [];
		var transparentObjectsLastIndex = - 1;

		var morphInfluences = new Float32Array(8);

		var sprites = [];
		var lensFlares = [];

		// public properties

		this.domElement = _canvas;
		this.context = null;

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false;

		// physically based shading

		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;

		// physical lights

		this.physicallyCorrectLights = false;

		// tone mapping

		this.toneMapping = THREE.LinearToneMapping;
		this.toneMappingExposure = 1.0;
		this.toneMappingWhitePoint = 1.0;

		// morphs

		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;

		// internal properties

		var _this = this,

			// internal state cache

			_currentProgram = null,
			_currentRenderTarget = null,
			_currentFramebuffer = null,
			_currentMaterialId = - 1,
			_currentGeometryProgram = '',
			_currentCamera = null,

			_currentScissor = new THREE.Vector4(),
			_currentScissorTest = null,

			_currentViewport = new THREE.Vector4(),

			//

			_usedTextureUnits = 0,

			//

			_clearColor = new THREE.Color(0x000000),
			_clearAlpha = 0,

			_width = _canvas.width,
			_height = _canvas.height,

			_pixelRatio = 1,

			_scissor = new THREE.Vector4(0, 0, _width, _height),
			_scissorTest = false,

			_viewport = new THREE.Vector4(0, 0, _width, _height),

			// frustum

			_frustum = new THREE.Frustum(),

			// clipping

			_clipping = new THREE.WebGLClipping(),
			_clippingEnabled = false,
			_localClippingEnabled = false,

			_sphere = new THREE.Sphere(),

			// camera matrices cache

			_projScreenMatrix = new THREE.Matrix4(),

			_vector3 = new THREE.Vector3(),

			// light arrays cache

			_lights = {

				hash: '',

				ambient: [0, 0, 0],
				directional: [],
				directionalShadowMap: [],
				directionalShadowMatrix: [],
				spot: [],
				spotShadowMap: [],
				spotShadowMatrix: [],
				point: [],
				pointShadowMap: [],
				pointShadowMatrix: [],
				hemi: [],

				shadows: []

			},

			// info

			_infoRender = {

				calls: 0,
				vertices: 0,
				faces: 0,
				points: 0

			};

		this.info = {

			render: _infoRender,
			memory: {

				geometries: 0,
				textures: 0

			},
			programs: null

		};


		// initialize

		var _gl;

		try {

			var attributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer
			};

			_gl = _context || _canvas.getContext('webgl', attributes) || _canvas.getContext('experimental-webgl', attributes);

			if (_gl === null) {

				if (_canvas.getContext('webgl') !== null) {

					throw 'Error creating WebGL context with your selected attributes.';

				} else {

					throw 'Error creating WebGL context.';

				}

			}

			// Some experimental-webgl implementations do not have getShaderPrecisionFormat

			if (_gl.getShaderPrecisionFormat === undefined) {

				_gl.getShaderPrecisionFormat = function () {

					return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

				};

			}

			_canvas.addEventListener('webglcontextlost', onContextLost, false);

		} catch (error) {

			//console.error( 'THREE.WebGLRenderer: ' + error );

		}

		var extensions = new THREE.WebGLExtensions(_gl);

		if (_useExtensions) {
			extensions.get('WEBGL_depth_texture');
			extensions.get('OES_texture_float');
			extensions.get('OES_texture_float_linear');
			extensions.get('OES_texture_half_float');
			extensions.get('OES_texture_half_float_linear');
			extensions.get('OES_standard_derivatives');
			extensions.get('ANGLE_instanced_arrays');

			if (extensions.get('OES_element_index_uint')) {

				THREE.BufferGeometry.MaxIndex = 4294967296;

			}
		}


		var capabilities = new THREE.WebGLCapabilities(_gl, extensions, parameters);

		var state = new THREE.WebGLState(_gl, extensions, paramThreeToGL);
		var properties = new THREE.WebGLProperties();
		var textures = new THREE.WebGLTextures(_gl, extensions, state, properties, capabilities, paramThreeToGL, this.info);
		var objects = new THREE.WebGLObjects(_gl, properties, this.info);
		var programCache = new THREE.WebGLPrograms(this, capabilities);
		var lightCache = new THREE.WebGLLights();

		this.info.programs = programCache.programs;

		var bufferRenderer = new THREE.WebGLBufferRenderer(_gl, extensions, _infoRender);
		var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer(_gl, extensions, _infoRender);

		//

		var backgroundCamera = new THREE.OrthographicCamera(- 1, 1, 1, - 1, 0, 1);
		var backgroundCamera2 = new THREE.PerspectiveCamera();
		var backgroundPlaneMesh = new THREE.Mesh(
			new THREE.PlaneBufferGeometry(2, 2),
			new THREE.MeshBasicMaterial({ depthTest: false, depthWrite: false })
		);
		var backgroundBoxShader = THREE.ShaderLib['cube'];
		var backgroundBoxMesh = new THREE.Mesh(
			new THREE.BoxBufferGeometry(5, 5, 5),
			new THREE.ShaderMaterial({
				uniforms: backgroundBoxShader.uniforms,
				vertexShader: backgroundBoxShader.vertexShader,
				fragmentShader: backgroundBoxShader.fragmentShader,
				depthTest: false,
				depthWrite: false,
				side: THREE.BackSide
			})
		);
		objects.update(backgroundPlaneMesh);
		objects.update(backgroundBoxMesh);

		//

		function getTargetPixelRatio() {

			return _currentRenderTarget === null ? _pixelRatio : 1;

		}

		function glClearColor(r, g, b, a) {

			if (_premultipliedAlpha === true) {

				r *= a; g *= a; b *= a;

			}

			state.clearColor(r, g, b, a);

		}

		function setDefaultGLState() {

			state.init();

			state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
			state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));

			glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);

		}

		function resetGLState() {

			_currentProgram = null;
			_currentCamera = null;

			_currentGeometryProgram = '';
			_currentMaterialId = - 1;

			state.reset();

		}

		setDefaultGLState();

		this.context = _gl;
		this.capabilities = capabilities;
		this.extensions = extensions;
		this.properties = properties;
		this.state = state;

		// shadow map

		var shadowMap = new THREE.WebGLShadowMap(this, _lights, objects);

		this.shadowMap = shadowMap;


		// Plugins

		var spritePlugin = new THREE.SpritePlugin(this, sprites);
		var lensFlarePlugin = new THREE.LensFlarePlugin(this, lensFlares);

		// API

		this.getContext = function () {

			return _gl;

		};

		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		this.forceContextLoss = function () {

			extensions.get('WEBGL_lose_context').loseContext();

		};

		this.getMaxAnisotropy = function () {

			return capabilities.getMaxAnisotropy();

		};

		this.getPrecision = function () {

			return capabilities.precision;

		};

		this.getPixelRatio = function () {

			return _pixelRatio;

		};

		this.setPixelRatio = function (value) {

			if (value === undefined) return;

			_pixelRatio = value;

			this.setSize(_viewport.z, _viewport.w, false);

		};

		this.getSize = function () {

			return {
				width: _width,
				height: _height
			};

		};

		this.setSize = function (width, height, updateStyle) {

			_width = width;
			_height = height;

			_canvas.width = width * _pixelRatio;
			_canvas.height = height * _pixelRatio;

			if (updateStyle !== false) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport(0, 0, width, height);

		};

		this.setViewport = function (x, y, width, height) {

			state.viewport(_viewport.set(x, y, width, height));

		};

		this.setScissor = function (x, y, width, height) {

			state.scissor(_scissor.set(x, y, width, height));

		};

		this.setScissorTest = function (boolean) {

			state.setScissorTest(_scissorTest = boolean);

		};

		// Clearing

		this.getClearColor = function () {

			return _clearColor;

		};

		this.setClearColor = function (color, alpha) {

			_clearColor.set(color);

			_clearAlpha = alpha !== undefined ? alpha : 1;

			glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);

		};

		this.getClearAlpha = function () {

			return _clearAlpha;

		};

		this.setClearAlpha = function (alpha) {

			_clearAlpha = alpha;

			glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);

		};

		this.clear = function (color, depth, stencil) {

			var bits = 0;

			if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;
			if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;
			if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;

			_gl.clear(bits);

		};

		this.clearColor = function () {

			this.clear(true, false, false);

		};

		this.clearDepth = function () {

			this.clear(false, true, false);

		};

		this.clearStencil = function () {

			this.clear(false, false, true);

		};

		this.clearTarget = function (renderTarget, color, depth, stencil) {

			this.setRenderTarget(renderTarget);
			this.clear(color, depth, stencil);

		};

		// Reset

		this.resetGLState = resetGLState;

		this.dispose = function () {

			transparentObjects = [];
			transparentObjectsLastIndex = -1;
			opaqueObjects = [];
			opaqueObjectsLastIndex = -1;

			_canvas.removeEventListener('webglcontextlost', onContextLost, false);

		};

		// Events

		function onContextLost(event) {

			event.preventDefault();

			resetGLState();
			setDefaultGLState();

			properties.clear();

		}

		function onMaterialDispose(event) {

			var material = event.target;

			material.removeEventListener('dispose', onMaterialDispose);

			deallocateMaterial(material);

		}

		// Buffer deallocation

		function deallocateMaterial(material) {

			releaseMaterialProgramReference(material);

			properties.delete(material);

		}


		function releaseMaterialProgramReference(material) {

			var programInfo = properties.get(material).program;

			material.program = undefined;

			if (programInfo !== undefined) {

				programCache.releaseProgram(programInfo);

			}

		}

		// Buffer rendering

		this.renderBufferImmediate = function (object, program, material) {

			state.initAttributes();

			var buffers = properties.get(object);

			if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
			if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
			if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
			if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();

			var attributes = program.getAttributes();

			if (object.hasPositions) {

				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
				_gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);

				state.enableAttribute(attributes.position);
				_gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);

			}

			if (object.hasNormals) {

				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);

				if (material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.type !== 'MeshPhysicalMaterial' && material.shading === THREE.FlatShading) {

					for (var i = 0, l = object.count * 3; i < l; i += 9) {

						var array = object.normalArray;

						var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
						var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
						var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;

						array[i + 0] = nx;
						array[i + 1] = ny;
						array[i + 2] = nz;

						array[i + 3] = nx;
						array[i + 4] = ny;
						array[i + 5] = nz;

						array[i + 6] = nx;
						array[i + 7] = ny;
						array[i + 8] = nz;

					}

				}

				_gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);

				state.enableAttribute(attributes.normal);

				_gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, false, 0, 0);

			}

			if (object.hasUvs && material.map) {

				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
				_gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);

				state.enableAttribute(attributes.uv);

				_gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);

			}

			if (object.hasColors && material.vertexColors !== THREE.NoColors) {

				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
				_gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);

				state.enableAttribute(attributes.color);

				_gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, false, 0, 0);

			}

			state.disableUnusedAttributes();

			_gl.drawArrays(_gl.TRIANGLES, 0, object.count);

			object.count = 0;

		};

		this.renderBufferDirect = function (camera, fog, geometry, material, object, group) {

			setMaterial(material);

			var program = setProgram(camera, fog, material, object);

			var updateBuffers = false;
			var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

			if (geometryProgram !== _currentGeometryProgram) {

				_currentGeometryProgram = geometryProgram;
				updateBuffers = true;

			}

			// morph targets

			var morphTargetInfluences = object.morphTargetInfluences;

			if (morphTargetInfluences !== undefined) {

				var activeInfluences = [];

				for (var i = 0, l = morphTargetInfluences.length; i < l; i++) {

					var influence = morphTargetInfluences[i];
					activeInfluences.push([influence, i]);

				}

				activeInfluences.sort(absNumericalSort);

				if (activeInfluences.length > 8) {

					activeInfluences.length = 8;

				}

				var morphAttributes = geometry.morphAttributes;

				for (var i = 0, l = activeInfluences.length; i < l; i++) {

					var influence = activeInfluences[i];
					morphInfluences[i] = influence[0];

					if (influence[0] !== 0) {

						var index = influence[1];

						if (material.morphTargets === true && morphAttributes.position) geometry.addAttribute('morphTarget' + i, morphAttributes.position[index]);
						if (material.morphNormals === true && morphAttributes.normal) geometry.addAttribute('morphNormal' + i, morphAttributes.normal[index]);

					} else {

						if (material.morphTargets === true) geometry.removeAttribute('morphTarget' + i);
						if (material.morphNormals === true) geometry.removeAttribute('morphNormal' + i);

					}

				}

				program.getUniforms().setValue(
					_gl, 'morphTargetInfluences', morphInfluences);

				updateBuffers = true;

			}

			//

			var index = geometry.index;
			var position = geometry.attributes.position;

			if (material.wireframe === true) {

				index = objects.getWireframeAttribute(geometry);

			}

			var renderer;

			if (index !== null) {

				renderer = indexedBufferRenderer;
				renderer.setIndex(index);

			} else {

				renderer = bufferRenderer;

			}

			if (updateBuffers) {

				setupVertexAttributes(material, program, geometry);

				if (index !== null) {

					_gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer(index));

				}

			}

			//

			var dataStart = 0;
			var dataCount = Infinity;

			if (index !== null) {

				dataCount = index.count;

			} else if (position !== undefined) {

				dataCount = position.count;

			}

			var rangeStart = geometry.drawRange.start;
			var rangeCount = geometry.drawRange.count;

			var groupStart = group !== null ? group.start : 0;
			var groupCount = group !== null ? group.count : Infinity;

			var drawStart = Math.max(dataStart, rangeStart, groupStart);
			var drawEnd = Math.min(dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;

			var drawCount = Math.max(0, drawEnd - drawStart + 1);

			//

			if (object instanceof THREE.Mesh) {

				if (material.wireframe === true) {

					state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
					renderer.setMode(_gl.LINES);

				} else {

					switch (object.drawMode) {

						case THREE.TrianglesDrawMode:
							renderer.setMode(_gl.TRIANGLES);
							break;

						case THREE.TriangleStripDrawMode:
							renderer.setMode(_gl.TRIANGLE_STRIP);
							break;

						case THREE.TriangleFanDrawMode:
							renderer.setMode(_gl.TRIANGLE_FAN);
							break;

					}

				}


			} else if (object instanceof THREE.Line) {

				var lineWidth = material.linewidth;

				if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

				state.setLineWidth(lineWidth * getTargetPixelRatio());

				if (object instanceof THREE.LineSegments) {

					renderer.setMode(_gl.LINES);

				} else {

					renderer.setMode(_gl.LINE_STRIP);

				}

			} else if (object instanceof THREE.Points) {

				renderer.setMode(_gl.POINTS);

			}

			if (geometry instanceof THREE.InstancedBufferGeometry) {

				if (geometry.maxInstancedCount > 0) {

					renderer.renderInstances(geometry, drawStart, drawCount);

				}

			} else {

				renderer.render(drawStart, drawCount);

			}

		};

		function setupVertexAttributes(material, program, geometry, startIndex) {

			var extension;

			if (geometry instanceof THREE.InstancedBufferGeometry) {

				extension = extensions.get('ANGLE_instanced_arrays');

				if (extension === null) {

					//console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			if (startIndex === undefined) startIndex = 0;

			state.initAttributes();

			var geometryAttributes = geometry.attributes;

			var programAttributes = program.getAttributes();

			var materialDefaultAttributeValues = material.defaultAttributeValues;

			for (var name in programAttributes) {

				var programAttribute = programAttributes[name];

				if (programAttribute >= 0) {

					var geometryAttribute = geometryAttributes[name];

					if (geometryAttribute !== undefined) {

						var type = _gl.FLOAT;
						var array = geometryAttribute.array;
						var normalized = geometryAttribute.normalized;

						if (array instanceof Float32Array) {

							type = _gl.FLOAT;

						} else if (array instanceof Float64Array) {

							//console.warn("Unsupported data buffer format: Float64Array");

						} else if (array instanceof Uint16Array) {

							type = _gl.UNSIGNED_SHORT;

						} else if (array instanceof Int16Array) {

							type = _gl.SHORT;

						} else if (array instanceof Uint32Array) {

							type = _gl.UNSIGNED_INT;

						} else if (array instanceof Int32Array) {

							type = _gl.INT;

						} else if (array instanceof Int8Array) {

							type = _gl.BYTE;

						} else if (array instanceof Uint8Array) {

							type = _gl.UNSIGNED_BYTE;

						}

						var size = geometryAttribute.itemSize;
						var buffer = objects.getAttributeBuffer(geometryAttribute);

						if (geometryAttribute instanceof THREE.InterleavedBufferAttribute) {

							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;

							if (data instanceof THREE.InstancedInterleavedBuffer) {

								state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute, extension);

								if (geometry.maxInstancedCount === undefined) {

									geometry.maxInstancedCount = data.meshPerAttribute * data.count;

								}

							} else {

								state.enableAttribute(programAttribute);

							}

							_gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
							_gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, (startIndex * stride + offset) * data.array.BYTES_PER_ELEMENT);

						} else {

							if (geometryAttribute instanceof THREE.InstancedBufferAttribute) {

								state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute, extension);

								if (geometry.maxInstancedCount === undefined) {

									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							} else {

								state.enableAttribute(programAttribute);

							}

							_gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
							_gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT);

						}

					} else if (materialDefaultAttributeValues !== undefined) {

						var value = materialDefaultAttributeValues[name];

						if (value !== undefined) {

							switch (value.length) {

								case 2:
									_gl.vertexAttrib2fv(programAttribute, value);
									break;

								case 3:
									_gl.vertexAttrib3fv(programAttribute, value);
									break;

								case 4:
									_gl.vertexAttrib4fv(programAttribute, value);
									break;

								default:
									_gl.vertexAttrib1fv(programAttribute, value);

							}

						}

					}

				}

			}

			state.disableUnusedAttributes();

		}

		// Sorting

		function absNumericalSort(a, b) {

			return Math.abs(b[0]) - Math.abs(a[0]);

		}

		function painterSortStable(a, b) {

			if (a.object.renderOrder !== b.object.renderOrder) {

				return a.object.renderOrder - b.object.renderOrder;

			} else if (a.material.id !== b.material.id) {

				return a.material.id - b.material.id;

			} else if (a.z !== b.z) {

				return a.z - b.z;

			} else {

				return a.id - b.id;

			}

		}

		function reversePainterSortStable(a, b) {

			if (a.object.renderOrder !== b.object.renderOrder) {

				return a.object.renderOrder - b.object.renderOrder;

			} if (a.z !== b.z) {

				return b.z - a.z;

			} else {

				return a.id - b.id;

			}

		}

		// Rendering

		this.render = function (scene, camera, renderTarget, forceClear) {

			if (camera instanceof THREE.Camera === false) {

				//console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			var fog = scene.fog;

			// reset caching for this frame

			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
			_currentCamera = null;

			// update scene graph

			if (scene.autoUpdate === true) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if (camera.parent === null) camera.updateMatrixWorld();

			camera.matrixWorldInverse.getInverse(camera.matrixWorld);

			_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
			_frustum.setFromMatrix(_projScreenMatrix);

			lights.length = 0;

			opaqueObjectsLastIndex = - 1;
			transparentObjectsLastIndex = - 1;

			sprites.length = 0;
			lensFlares.length = 0;

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);

			projectObject(scene, camera);

			opaqueObjects.length = opaqueObjectsLastIndex + 1;
			transparentObjects.length = transparentObjectsLastIndex + 1;

			if (_this.sortObjects === true) {

				opaqueObjects.sort(painterSortStable);
				transparentObjects.sort(reversePainterSortStable);

			}

			//

			if (_clippingEnabled) _clipping.beginShadows();

			setupShadows(lights);

			shadowMap.render(scene, camera);

			setupLights(lights, camera);

			if (_clippingEnabled) _clipping.endShadows();

			//

			_infoRender.calls = 0;
			_infoRender.vertices = 0;
			_infoRender.faces = 0;
			_infoRender.points = 0;

			if (renderTarget === undefined) {

				renderTarget = null;

			}

			this.setRenderTarget(renderTarget);

			//

			var background = scene.background;

			if (background === null) {

				glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);

			} else if (background instanceof THREE.Color) {

				glClearColor(background.r, background.g, background.b, 1);

			}

			if (this.autoClear || forceClear) {

				this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);

			}

			if (background instanceof THREE.CubeTexture) {

				backgroundCamera2.projectionMatrix.copy(camera.projectionMatrix);

				backgroundCamera2.matrixWorld.extractRotation(camera.matrixWorld);
				backgroundCamera2.matrixWorldInverse.getInverse(backgroundCamera2.matrixWorld);

				backgroundBoxMesh.material.uniforms["tCube"].value = background;
				backgroundBoxMesh.modelViewMatrix.multiplyMatrices(backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld);

				_this.renderBufferDirect(backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null);

			} else if (background instanceof THREE.Texture) {

				backgroundPlaneMesh.material.map = background;

				_this.renderBufferDirect(backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null);

			}

			//

			if (scene.overrideMaterial) {

				var overrideMaterial = scene.overrideMaterial;

				renderObjects(opaqueObjects, camera, fog, overrideMaterial);
				renderObjects(transparentObjects, camera, fog, overrideMaterial);

			} else {

				// opaque pass (front-to-back order)

				state.setBlending(THREE.NoBlending);
				renderObjects(opaqueObjects, camera, fog);

				// transparent pass (back-to-front order)

				renderObjects(transparentObjects, camera, fog);

			}

			// custom render plugins (post pass)

			spritePlugin.render(scene, camera);
			lensFlarePlugin.render(scene, camera, _currentViewport);

			// Generate mipmap if we're using any kind of mipmap filtering

			if (renderTarget) {

				textures.updateRenderTargetMipmap(renderTarget);

			}

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.setDepthTest(true);
			state.setDepthWrite(true);
			state.setColorWrite(true);

			// _gl.finish();

		};

		function pushRenderItem(object, geometry, material, z, group) {

			var array, index;

			// allocate the next position in the appropriate array

			if (material.transparent) {

				array = transparentObjects;
				index = ++transparentObjectsLastIndex;

			} else {

				array = opaqueObjects;
				index = ++opaqueObjectsLastIndex;

			}

			// recycle existing render item or grow the array

			var renderItem = array[index];

			if (renderItem !== undefined) {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.z = _vector3.z;
				renderItem.group = group;

			} else {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					z: _vector3.z,
					group: group
				};

				// assert( index === array.length );
				array.push(renderItem);

			}

		}

		// TODO Duplicated code (Frustum)

		function isObjectViewable(object) {

			var geometry = object.geometry;

			if (geometry.boundingSphere === null)
				geometry.computeBoundingSphere();

			_sphere.copy(geometry.boundingSphere).
				applyMatrix4(object.matrixWorld);

			return isSphereViewable(_sphere);

		}

		function isSpriteViewable(sprite) {

			_sphere.center.set(0, 0, 0);
			_sphere.radius = 0.7071067811865476;
			_sphere.applyMatrix4(sprite.matrixWorld);

			return isSphereViewable(_sphere);

		}

		function isSphereViewable(sphere) {

			if (!_frustum.intersectsSphere(sphere)) return false;

			var numPlanes = _clipping.numPlanes;

			if (numPlanes === 0) return true;

			var planes = _this.clippingPlanes,

				center = sphere.center,
				negRad = - sphere.radius,
				i = 0;

			do {

				// out when deeper than radius in the negative halfspace
				if (planes[i].distanceToPoint(center) < negRad) return false;

			} while (++i !== numPlanes);

			return true;

		}

		function projectObject(object, camera) {

			if (object.visible === false) return;

			if (object.layers.test(camera.layers)) {

				if (object instanceof THREE.Light) {

					lights.push(object);

				} else if (object instanceof THREE.Sprite) {

					if (object.frustumCulled === false || isSpriteViewable(object) === true) {

						sprites.push(object);

					}

				} else if (object instanceof THREE.LensFlare) {

					lensFlares.push(object);

				} else if (object instanceof THREE.ImmediateRenderObject) {

					if (_this.sortObjects === true) {

						_vector3.setFromMatrixPosition(object.matrixWorld);
						_vector3.applyProjection(_projScreenMatrix);

					}

					pushRenderItem(object, null, object.material, _vector3.z, null);

				} else if (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points) {

					if (object instanceof THREE.SkinnedMesh) {

						object.skeleton.update();

					}

					if (object.frustumCulled === false || isObjectViewable(object) === true) {

						var material = object.material;

						if (material.visible === true) {

							if (_this.sortObjects === true) {

								_vector3.setFromMatrixPosition(object.matrixWorld);
								_vector3.applyProjection(_projScreenMatrix);

							}

							var geometry = objects.update(object);

							if (material instanceof THREE.MultiMaterial) {

								var groups = geometry.groups;
								var materials = material.materials;

								for (var i = 0, l = groups.length; i < l; i++) {

									var group = groups[i];
									var groupMaterial = materials[group.materialIndex];

									if (groupMaterial.visible === true) {

										pushRenderItem(object, geometry, groupMaterial, _vector3.z, group);

									}

								}

							} else {

								pushRenderItem(object, geometry, material, _vector3.z, null);

							}

						}

					}

				}

			}

			var children = object.children;

			for (var i = 0, l = children.length; i < l; i++) {

				projectObject(children[i], camera);

			}

		}

		function renderObjects(renderList, camera, fog, overrideMaterial) {

			for (var i = 0, l = renderList.length; i < l; i++) {

				var renderItem = renderList[i];

				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
				var group = renderItem.group;

				object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
				object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

				if (object instanceof THREE.ImmediateRenderObject) {

					setMaterial(material);

					var program = setProgram(camera, fog, material, object);

					_currentGeometryProgram = '';

					object.render(function (object) {

						_this.renderBufferImmediate(object, program, material);

					});

				} else {

					_this.renderBufferDirect(camera, fog, geometry, material, object, group);

				}

			}

		}

		function initMaterial(material, fog, object) {

			var materialProperties = properties.get(material);

			var parameters = programCache.getParameters(
				material, _lights, fog, _clipping.numPlanes, object);

			var code = programCache.getProgramCode(material, parameters);

			var program = materialProperties.program;
			var programChange = true;

			if (program === undefined) {

				// new material
				material.addEventListener('dispose', onMaterialDispose);

			} else if (program.code !== code) {

				// changed glsl or parameters
				releaseMaterialProgramReference(material);

			} else if (parameters.shaderID !== undefined) {

				// same glsl and uniform list
				return;

			} else {

				// only rebuild uniform list
				programChange = false;

			}

			if (programChange) {

				if (parameters.shaderID) {

					var shader = THREE.ShaderLib[parameters.shaderID];

					materialProperties.__webglShader = {
						name: material.type,
						uniforms: THREE.UniformsUtils.clone(shader.uniforms),
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader
					};

				} else {

					materialProperties.__webglShader = {
						name: material.type,
						uniforms: material.uniforms,
						vertexShader: material.vertexShader,
						fragmentShader: material.fragmentShader
					};

				}

				material.__webglShader = materialProperties.__webglShader;

				program = programCache.acquireProgram(material, parameters, code);

				materialProperties.program = program;
				material.program = program;

			}

			var attributes = program.getAttributes();

			if (material.morphTargets) {

				material.numSupportedMorphTargets = 0;

				for (var i = 0; i < _this.maxMorphTargets; i++) {

					if (attributes['morphTarget' + i] >= 0) {

						material.numSupportedMorphTargets++;

					}

				}

			}

			if (material.morphNormals) {

				material.numSupportedMorphNormals = 0;

				for (var i = 0; i < _this.maxMorphNormals; i++) {

					if (attributes['morphNormal' + i] >= 0) {

						material.numSupportedMorphNormals++;

					}

				}

			}

			var uniforms = materialProperties.__webglShader.uniforms;

			if (!(material instanceof THREE.ShaderMaterial) &&
				!(material instanceof THREE.RawShaderMaterial) ||
				material.clipping === true) {

				materialProperties.numClippingPlanes = _clipping.numPlanes;
				uniforms.clippingPlanes = _clipping.uniform;

			}

			if (material.lights) {

				// store the light setup it was created for

				materialProperties.lightsHash = _lights.hash;

				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = _lights.ambient;
				uniforms.directionalLights.value = _lights.directional;
				uniforms.spotLights.value = _lights.spot;
				uniforms.pointLights.value = _lights.point;
				uniforms.hemisphereLights.value = _lights.hemi;

				uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
				uniforms.spotShadowMap.value = _lights.spotShadowMap;
				uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
				uniforms.pointShadowMap.value = _lights.pointShadowMap;
				uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;

			}

			var progUniforms = materialProperties.program.getUniforms(),
				uniformsList =
					THREE.WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);

			materialProperties.uniformsList = uniformsList;
			materialProperties.dynamicUniforms =
				THREE.WebGLUniforms.splitDynamic(uniformsList, uniforms);

		}

		function setMaterial(material) {

			if (material.side !== THREE.DoubleSide)
				state.enable(_gl.CULL_FACE);
			else
				state.disable(_gl.CULL_FACE);

			state.setFlipSided(material.side === THREE.BackSide);

			if (material.transparent === true) {

				state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);

			} else {

				state.setBlending(THREE.NoBlending);

			}

			state.setDepthFunc(material.depthFunc);
			state.setDepthTest(material.depthTest);
			state.setDepthWrite(material.depthWrite);
			state.setColorWrite(material.colorWrite);
			state.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);

		}

		function setProgram(camera, fog, material, object) {

			_usedTextureUnits = 0;

			var materialProperties = properties.get(material);

			if (_clippingEnabled) {

				if (_localClippingEnabled || camera !== _currentCamera) {

					var useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					_clipping.setState(
						material.clippingPlanes, material.clipShadows,
						camera, materialProperties, useCache);

				}

				if (materialProperties.numClippingPlanes !== undefined &&
					materialProperties.numClippingPlanes !== _clipping.numPlanes) {

					material.needsUpdate = true;

				}

			}

			if (materialProperties.program === undefined) {

				material.needsUpdate = true;

			}

			if (materialProperties.lightsHash !== undefined &&
				materialProperties.lightsHash !== _lights.hash) {

				material.needsUpdate = true;

			}

			if (material.needsUpdate) {

				initMaterial(material, fog, object);
				material.needsUpdate = false;

			}

			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;

			var program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.__webglShader.uniforms;

			if (program.id !== _currentProgram) {

				_gl.useProgram(program.program);
				_currentProgram = program.id;

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if (material.id !== _currentMaterialId) {

				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if (refreshProgram || camera !== _currentCamera) {

				p_uniforms.set(_gl, camera, 'projectionMatrix');

				if (capabilities.logarithmicDepthBuffer) {

					p_uniforms.setValue(_gl, 'logDepthBufFC',
						2.0 / (Math.log(camera.far + 1.0) / Math.LN2));

				}


				if (camera !== _currentCamera) {

					_currentCamera = camera;

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done

				}

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if (material instanceof THREE.ShaderMaterial ||
					material instanceof THREE.MeshPhongMaterial ||
					material instanceof THREE.MeshStandardMaterial ||
					material.envMap) {

					var uCamPos = p_uniforms.map.cameraPosition;

					if (uCamPos !== undefined) {

						uCamPos.setValue(_gl,
							_vector3.setFromMatrixPosition(camera.matrixWorld));

					}

				}

				if (material instanceof THREE.MeshPhongMaterial ||
					material instanceof THREE.MeshLambertMaterial ||
					material instanceof THREE.MeshBasicMaterial ||
					material instanceof THREE.MeshStandardMaterial ||
					material instanceof THREE.ShaderMaterial ||
					material.skinning) {

					p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);

				}

				p_uniforms.set(_gl, _this, 'toneMappingExposure');
				p_uniforms.set(_gl, _this, 'toneMappingWhitePoint');

			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen

			if (material.skinning) {

				p_uniforms.setOptional(_gl, object, 'bindMatrix');
				p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');

				var skeleton = object.skeleton;

				if (skeleton) {

					if (capabilities.floatVertexTextures && skeleton.useVertexTexture) {

						p_uniforms.set(_gl, skeleton, 'boneTexture');
						p_uniforms.set(_gl, skeleton, 'boneTextureWidth');
						p_uniforms.set(_gl, skeleton, 'boneTextureHeight');

					} else {

						p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');

					}

				}

			}

			if (refreshMaterial) {

				if (material.lights) {

					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);

				}

				// refresh uniforms common to several materials

				if (fog && material.fog) {

					refreshUniformsFog(m_uniforms, fog);

				}

				if (material instanceof THREE.MeshBasicMaterial ||
					material instanceof THREE.MeshLambertMaterial ||
					material instanceof THREE.MeshPhongMaterial ||
					material instanceof THREE.MeshStandardMaterial ||
					material instanceof THREE.MeshDepthMaterial) {

					refreshUniformsCommon(m_uniforms, material);

				}

				// refresh single material specific uniforms

				if (material instanceof THREE.LineBasicMaterial) {

					refreshUniformsLine(m_uniforms, material);

				} else if (material instanceof THREE.LineDashedMaterial) {

					refreshUniformsLine(m_uniforms, material);
					refreshUniformsDash(m_uniforms, material);

				} else if (material instanceof THREE.PointsMaterial) {

					refreshUniformsPoints(m_uniforms, material);

				} else if (material instanceof THREE.MeshLambertMaterial) {

					refreshUniformsLambert(m_uniforms, material);

				} else if (material instanceof THREE.MeshPhongMaterial) {

					refreshUniformsPhong(m_uniforms, material);

				} else if (material instanceof THREE.MeshPhysicalMaterial) {

					refreshUniformsPhysical(m_uniforms, material);

				} else if (material instanceof THREE.MeshStandardMaterial) {

					refreshUniformsStandard(m_uniforms, material);

				} else if (material instanceof THREE.MeshDepthMaterial) {

					if (material.displacementMap) {

						m_uniforms.displacementMap.value = material.displacementMap;
						m_uniforms.displacementScale.value = material.displacementScale;
						m_uniforms.displacementBias.value = material.displacementBias;

					}

				} else if (material instanceof THREE.MeshNormalMaterial) {

					m_uniforms.opacity.value = material.opacity;

				}

				THREE.WebGLUniforms.upload(
					_gl, materialProperties.uniformsList, m_uniforms, _this);

			}


			// common matrices

			p_uniforms.set(_gl, object, 'modelViewMatrix');
			p_uniforms.set(_gl, object, 'normalMatrix');
			p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);


			// dynamic uniforms

			var dynUniforms = materialProperties.dynamicUniforms;

			if (dynUniforms !== null) {

				THREE.WebGLUniforms.evalDynamic(
					dynUniforms, m_uniforms, object, camera);

				THREE.WebGLUniforms.upload(_gl, dynUniforms, m_uniforms, _this);

			}

			return program;

		}

		// Uniforms (refresh uniforms objects)

		function refreshUniformsCommon(uniforms, material) {

			uniforms.opacity.value = material.opacity;

			uniforms.diffuse.value = material.color;

			if (material.emissive) {

				uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);

			}

			uniforms.map.value = material.map;
			uniforms.specularMap.value = material.specularMap;
			uniforms.alphaMap.value = material.alphaMap;

			if (material.aoMap) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map

			var uvScaleMap;

			if (material.map) {

				uvScaleMap = material.map;

			} else if (material.specularMap) {

				uvScaleMap = material.specularMap;

			} else if (material.displacementMap) {

				uvScaleMap = material.displacementMap;

			} else if (material.normalMap) {

				uvScaleMap = material.normalMap;

			} else if (material.bumpMap) {

				uvScaleMap = material.bumpMap;

			} else if (material.roughnessMap) {

				uvScaleMap = material.roughnessMap;

			} else if (material.metalnessMap) {

				uvScaleMap = material.metalnessMap;

			} else if (material.alphaMap) {

				uvScaleMap = material.alphaMap;

			} else if (material.emissiveMap) {

				uvScaleMap = material.emissiveMap;

			}

			if (uvScaleMap !== undefined) {

				// backwards compatibility
				if (uvScaleMap instanceof THREE.WebGLRenderTarget) {

					uvScaleMap = uvScaleMap.texture;

				}

				var offset = uvScaleMap.offset;
				var repeat = uvScaleMap.repeat;

				uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);

			}

			uniforms.envMap.value = material.envMap;

			// don't flip CubeTexture envMaps, flip everything else:
			//  WebGLRenderTargetCube will be flipped for backwards compatibility
			//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
			// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
			uniforms.flipEnvMap.value = (!(material.envMap instanceof THREE.CubeTexture)) ? 1 : - 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;

		}

		function refreshUniformsLine(uniforms, material) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash(uniforms, material) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsPoints(uniforms, material) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * _pixelRatio;
			uniforms.scale.value = _canvas.clientHeight * 0.5;

			uniforms.map.value = material.map;

			if (material.map !== null) {

				var offset = material.map.offset;
				var repeat = material.map.repeat;

				uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);

			}

		}

		function refreshUniformsFog(uniforms, fog) {

			uniforms.fogColor.value = fog.color;

			if (fog instanceof THREE.Fog) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if (fog instanceof THREE.FogExp2) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshUniformsLambert(uniforms, material) {

			if (material.lightMap) {

				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;

			}

			if (material.emissiveMap) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

		}

		function refreshUniformsPhong(uniforms, material) {

			uniforms.specular.value = material.specular;
			uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

			if (material.lightMap) {

				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;

			}

			if (material.emissiveMap) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if (material.bumpMap) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;

			}

			if (material.normalMap) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);

			}

			if (material.displacementMap) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsStandard(uniforms, material) {

			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if (material.roughnessMap) {

				uniforms.roughnessMap.value = material.roughnessMap;

			}

			if (material.metalnessMap) {

				uniforms.metalnessMap.value = material.metalnessMap;

			}

			if (material.lightMap) {

				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;

			}

			if (material.emissiveMap) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if (material.bumpMap) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;

			}

			if (material.normalMap) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);

			}

			if (material.displacementMap) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			if (material.envMap) {

				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;

			}

		}

		function refreshUniformsPhysical(uniforms, material) {

			uniforms.clearCoat.value = material.clearCoat;
			uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

			refreshUniformsStandard(uniforms, material);

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate(uniforms, value) {

			uniforms.ambientLightColor.needsUpdate = value;

			uniforms.directionalLights.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;

		}

		// Lighting

		function setupShadows(lights) {

			var lightShadowsLength = 0;

			for (var i = 0, l = lights.length; i < l; i++) {

				var light = lights[i];

				if (light.castShadow) {

					_lights.shadows[lightShadowsLength++] = light;

				}

			}

			_lights.shadows.length = lightShadowsLength;

		}

		function setupLights(lights, camera) {

			var l, ll, light,
				r = 0, g = 0, b = 0,
				color,
				intensity,
				distance,
				shadowMap,

				viewMatrix = camera.matrixWorldInverse,

				directionalLength = 0,
				pointLength = 0,
				spotLength = 0,
				hemiLength = 0;

			for (l = 0, ll = lights.length; l < ll; l++) {

				light = lights[l];

				color = light.color;
				intensity = light.intensity;
				distance = light.distance;

				shadowMap = (light.shadow && light.shadow.map) ? light.shadow.map.texture : null;

				if (light instanceof THREE.AmbientLight) {

					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;

				} else if (light instanceof THREE.DirectionalLight) {

					var uniforms = lightCache.get(light);

					uniforms.color.copy(light.color).multiplyScalar(light.intensity);
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					_vector3.setFromMatrixPosition(light.target.matrixWorld);
					uniforms.direction.sub(_vector3);
					uniforms.direction.transformDirection(viewMatrix);

					uniforms.shadow = light.castShadow;

					if (light.castShadow) {

						uniforms.shadowBias = light.shadow.bias;
						uniforms.shadowRadius = light.shadow.radius;
						uniforms.shadowMapSize = light.shadow.mapSize;

					}

					_lights.directionalShadowMap[directionalLength] = shadowMap;
					_lights.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
					_lights.directional[directionalLength++] = uniforms;

				} else if (light instanceof THREE.SpotLight) {

					var uniforms = lightCache.get(light);

					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix);

					uniforms.color.copy(color).multiplyScalar(intensity);
					uniforms.distance = distance;

					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					_vector3.setFromMatrixPosition(light.target.matrixWorld);
					uniforms.direction.sub(_vector3);
					uniforms.direction.transformDirection(viewMatrix);

					uniforms.coneCos = Math.cos(light.angle);
					uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
					uniforms.decay = (light.distance === 0) ? 0.0 : light.decay;

					uniforms.shadow = light.castShadow;

					if (light.castShadow) {

						uniforms.shadowBias = light.shadow.bias;
						uniforms.shadowRadius = light.shadow.radius;
						uniforms.shadowMapSize = light.shadow.mapSize;

					}

					_lights.spotShadowMap[spotLength] = shadowMap;
					_lights.spotShadowMatrix[spotLength] = light.shadow.matrix;
					_lights.spot[spotLength++] = uniforms;

				} else if (light instanceof THREE.PointLight) {

					var uniforms = lightCache.get(light);

					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix);

					uniforms.color.copy(light.color).multiplyScalar(light.intensity);
					uniforms.distance = light.distance;
					uniforms.decay = (light.distance === 0) ? 0.0 : light.decay;

					uniforms.shadow = light.castShadow;

					if (light.castShadow) {

						uniforms.shadowBias = light.shadow.bias;
						uniforms.shadowRadius = light.shadow.radius;
						uniforms.shadowMapSize = light.shadow.mapSize;

					}

					_lights.pointShadowMap[pointLength] = shadowMap;

					if (_lights.pointShadowMatrix[pointLength] === undefined) {

						_lights.pointShadowMatrix[pointLength] = new THREE.Matrix4();

					}

					// for point lights we set the shadow matrix to be a translation-only matrix
					// equal to inverse of the light's position
					_vector3.setFromMatrixPosition(light.matrixWorld).negate();
					_lights.pointShadowMatrix[pointLength].identity().setPosition(_vector3);

					_lights.point[pointLength++] = uniforms;

				} else if (light instanceof THREE.HemisphereLight) {

					var uniforms = lightCache.get(light);

					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					uniforms.direction.transformDirection(viewMatrix);
					uniforms.direction.normalize();

					uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
					uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);

					_lights.hemi[hemiLength++] = uniforms;

				}

			}

			_lights.ambient[0] = r;
			_lights.ambient[1] = g;
			_lights.ambient[2] = b;

			_lights.directional.length = directionalLength;
			_lights.spot.length = spotLength;
			_lights.point.length = pointLength;
			_lights.hemi.length = hemiLength;

			_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;

		}

		// GL state setting

		this.setFaceCulling = function (cullFace, frontFaceDirection) {

			state.setCullFace(cullFace);
			state.setFlipSided(frontFaceDirection === THREE.FrontFaceDirectionCW);

		};

		// Textures

		function allocTextureUnit() {

			var textureUnit = _usedTextureUnits;

			if (textureUnit >= capabilities.maxTextures) {

				//console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

			}

			_usedTextureUnits += 1;

			return textureUnit;

		}

		this.allocTextureUnit = allocTextureUnit;

		// this.setTexture2D = setTexture2D;
		this.setTexture2D = (function () {

			var warned = false;

			// backwards compatibility: peel texture.texture
			return function setTexture2D(texture, slot) {

				if (texture instanceof THREE.WebGLRenderTarget) {

					if (!warned) {

						//console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
						warned = true;

					}

					texture = texture.texture;

				}

				textures.setTexture2D(texture, slot);

			};

		}());

		this.setTexture = (function () {

			var warned = false;

			return function setTexture(texture, slot) {

				if (!warned) {

					//console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
					warned = true;

				}

				textures.setTexture2D(texture, slot);

			};

		}());

		this.setTextureCube = (function () {

			var warned = false;

			return function setTextureCube(texture, slot) {

				// backwards compatibility: peel texture.texture
				if (texture instanceof THREE.WebGLRenderTargetCube) {

					if (!warned) {

						//console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
						warned = true;

					}

					texture = texture.texture;

				}

				// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
				// TODO: unify these code paths
				if (texture instanceof THREE.CubeTexture ||
					(Array.isArray(texture.image) && texture.image.length === 6)) {

					// CompressedTexture can have Array in image :/

					// this function alone should take care of cube textures
					textures.setTextureCube(texture, slot);

				} else {

					// assumed: texture property of THREE.WebGLRenderTargetCube

					textures.setTextureCubeDynamic(texture, slot);

				}

			};

		}());

		this.getCurrentRenderTarget = function () {

			return _currentRenderTarget;

		};

		this.setRenderTarget = function (renderTarget) {

			_currentRenderTarget = renderTarget;

			if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {

				textures.setupRenderTarget(renderTarget);

			}

			var isCube = (renderTarget instanceof THREE.WebGLRenderTargetCube);
			var framebuffer;

			if (renderTarget) {

				var renderTargetProperties = properties.get(renderTarget);

				if (isCube) {

					framebuffer = renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];

				} else {

					framebuffer = renderTargetProperties.__webglFramebuffer;

				}

				_currentScissor.copy(renderTarget.scissor);
				_currentScissorTest = renderTarget.scissorTest;

				_currentViewport.copy(renderTarget.viewport);

			} else {

				framebuffer = null;

				_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
				_currentScissorTest = _scissorTest;

				_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);

			}

			if (_currentFramebuffer !== framebuffer) {

				_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
				_currentFramebuffer = framebuffer;

			}

			state.scissor(_currentScissor);
			state.setScissorTest(_currentScissorTest);

			state.viewport(_currentViewport);

			if (isCube) {

				var textureProperties = properties.get(renderTarget.texture);
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);

			}

		};

		this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer) {

			if (renderTarget instanceof THREE.WebGLRenderTarget === false) {

				//console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			var framebuffer = properties.get(renderTarget).__webglFramebuffer;

			if (framebuffer) {

				var restore = false;

				if (framebuffer !== _currentFramebuffer) {

					_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

					restore = true;

				}

				try {

					var texture = renderTarget.texture;

					if (texture.format !== THREE.RGBAFormat && paramThreeToGL(texture.format) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {

						//console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;

					}

					if (texture.type !== THREE.UnsignedByteType &&
						paramThreeToGL(texture.type) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) &&
						!(texture.type === THREE.FloatType && extensions.get('WEBGL_color_buffer_float')) &&
						!(texture.type === THREE.HalfFloatType && extensions.get('EXT_color_buffer_half_float'))) {

						//console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;

					}

					if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {

						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

						if ((x >= 0 && x <= (renderTarget.width - width)) && (y >= 0 && y <= (renderTarget.height - height))) {

							_gl.readPixels(x, y, width, height, paramThreeToGL(texture.format), paramThreeToGL(texture.type), buffer);

						}

					} else {

						//console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

					}

				} finally {

					if (restore) {

						_gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);

					}

				}

			}

		};

		// Map three.js constants to WebGL constants

		function paramThreeToGL(p) {

			var extension;

			if (p === THREE.RepeatWrapping) return _gl.REPEAT;
			if (p === THREE.ClampToEdgeWrapping) return _gl.CLAMP_TO_EDGE;
			if (p === THREE.MirroredRepeatWrapping) return _gl.MIRRORED_REPEAT;

			if (p === THREE.NearestFilter) return _gl.NEAREST;
			if (p === THREE.NearestMipMapNearestFilter) return _gl.NEAREST_MIPMAP_NEAREST;
			if (p === THREE.NearestMipMapLinearFilter) return _gl.NEAREST_MIPMAP_LINEAR;

			if (p === THREE.LinearFilter) return _gl.LINEAR;
			if (p === THREE.LinearMipMapNearestFilter) return _gl.LINEAR_MIPMAP_NEAREST;
			if (p === THREE.LinearMipMapLinearFilter) return _gl.LINEAR_MIPMAP_LINEAR;

			if (p === THREE.UnsignedByteType) return _gl.UNSIGNED_BYTE;
			if (p === THREE.UnsignedShort4444Type) return _gl.UNSIGNED_SHORT_4_4_4_4;
			if (p === THREE.UnsignedShort5551Type) return _gl.UNSIGNED_SHORT_5_5_5_1;
			if (p === THREE.UnsignedShort565Type) return _gl.UNSIGNED_SHORT_5_6_5;

			if (p === THREE.ByteType) return _gl.BYTE;
			if (p === THREE.ShortType) return _gl.SHORT;
			if (p === THREE.UnsignedShortType) return _gl.UNSIGNED_SHORT;
			if (p === THREE.IntType) return _gl.INT;
			if (p === THREE.UnsignedIntType) return _gl.UNSIGNED_INT;
			if (p === THREE.FloatType) return _gl.FLOAT;

			extension = extensions.get('OES_texture_half_float');

			if (extension !== null) {

				if (p === THREE.HalfFloatType) return extension.HALF_FLOAT_OES;

			}

			if (p === THREE.AlphaFormat) return _gl.ALPHA;
			if (p === THREE.RGBFormat) return _gl.RGB;
			if (p === THREE.RGBAFormat) return _gl.RGBA;
			if (p === THREE.LuminanceFormat) return _gl.LUMINANCE;
			if (p === THREE.LuminanceAlphaFormat) return _gl.LUMINANCE_ALPHA;
			if (p === THREE.DepthFormat) return _gl.DEPTH_COMPONENT;

			if (p === THREE.AddEquation) return _gl.FUNC_ADD;
			if (p === THREE.SubtractEquation) return _gl.FUNC_SUBTRACT;
			if (p === THREE.ReverseSubtractEquation) return _gl.FUNC_REVERSE_SUBTRACT;

			if (p === THREE.ZeroFactor) return _gl.ZERO;
			if (p === THREE.OneFactor) return _gl.ONE;
			if (p === THREE.SrcColorFactor) return _gl.SRC_COLOR;
			if (p === THREE.OneMinusSrcColorFactor) return _gl.ONE_MINUS_SRC_COLOR;
			if (p === THREE.SrcAlphaFactor) return _gl.SRC_ALPHA;
			if (p === THREE.OneMinusSrcAlphaFactor) return _gl.ONE_MINUS_SRC_ALPHA;
			if (p === THREE.DstAlphaFactor) return _gl.DST_ALPHA;
			if (p === THREE.OneMinusDstAlphaFactor) return _gl.ONE_MINUS_DST_ALPHA;

			if (p === THREE.DstColorFactor) return _gl.DST_COLOR;
			if (p === THREE.OneMinusDstColorFactor) return _gl.ONE_MINUS_DST_COLOR;
			if (p === THREE.SrcAlphaSaturateFactor) return _gl.SRC_ALPHA_SATURATE;

			extension = extensions.get('WEBGL_compressed_texture_s3tc');

			if (extension !== null) {

				if (p === THREE.RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if (p === THREE.RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if (p === THREE.RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if (p === THREE.RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			}

			extension = extensions.get('WEBGL_compressed_texture_pvrtc');

			if (extension !== null) {

				if (p === THREE.RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if (p === THREE.RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if (p === THREE.RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if (p === THREE.RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			}

			extension = extensions.get('WEBGL_compressed_texture_etc1');

			if (extension !== null) {

				if (p === THREE.RGB_ETC1_Format) return extension.COMPRESSED_RGB_ETC1_WEBGL;

			}

			extension = extensions.get('EXT_blend_minmax');

			if (extension !== null) {

				if (p === THREE.MinEquation) return extension.MIN_EXT;
				if (p === THREE.MaxEquation) return extension.MAX_EXT;

			}

			return 0;

		}

	};

	// File:src/renderers/WebGLRenderTarget.js

	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 * @author Marius Kintel / https://github.com/kintel
	 */

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	THREE.WebGLRenderTarget = function (width, height, options) {

		this.uuid = THREE.Math.generateUUID();

		this.width = width;
		this.height = height;

		this.scissor = new THREE.Vector4(0, 0, width, height);
		this.scissorTest = false;

		this.viewport = new THREE.Vector4(0, 0, width, height);

		options = options || {};

		if (options.minFilter === undefined) options.minFilter = THREE.LinearFilter;

		this.texture = new THREE.Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
		this.depthTexture = null;

	};

	Object.assign(THREE.WebGLRenderTarget.prototype, THREE.EventDispatcher.prototype, {

		setSize: function (width, height) {

			if (this.width !== width || this.height !== height) {

				this.width = width;
				this.height = height;

				this.dispose();

			}

			this.viewport.set(0, 0, width, height);
			this.scissor.set(0, 0, width, height);

		},

		clone: function () {

			return new this.constructor().copy(this);

		},

		copy: function (source) {

			this.width = source.width;
			this.height = source.height;

			this.viewport.copy(source.viewport);

			this.texture = source.texture.clone();

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;

			return this;

		},

		dispose: function () {

			this.dispatchEvent({ type: 'dispose' });

		}

	});

	// File:src/renderers/WebGLRenderTargetCube.js

	/**
	 * @author alteredq / http://alteredqualia.com
	 */

	THREE.WebGLRenderTargetCube = function (width, height, options) {

		THREE.WebGLRenderTarget.call(this, width, height, options);

		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
		this.activeMipMapLevel = 0;

	};

	THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);
	THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

	// File:src/renderers/webgl/WebGLBufferRenderer.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLBufferRenderer = function (_gl, extensions, _infoRender) {

		var mode;

		function setMode(value) {

			mode = value;

		}

		function render(start, count) {

			_gl.drawArrays(mode, start, count);

			_infoRender.calls++;
			_infoRender.vertices += count;
			if (mode === _gl.TRIANGLES) _infoRender.faces += count / 3;

		}

		function renderInstances(geometry) {

			var extension = extensions.get('ANGLE_instanced_arrays');

			if (extension === null) {

				//console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

			var position = geometry.attributes.position;

			var count = 0;

			if (position instanceof THREE.InterleavedBufferAttribute) {

				count = position.data.count;

				extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount);

			} else {

				count = position.count;

				extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount);

			}

			_infoRender.calls++;
			_infoRender.vertices += count * geometry.maxInstancedCount;
			if (mode === _gl.TRIANGLES) _infoRender.faces += geometry.maxInstancedCount * count / 3;

		}

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;

	};

	// File:src/renderers/webgl/WebGLClipping.js

	THREE.WebGLClipping = function () {

		var scope = this,

			globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false,

			plane = new THREE.Plane(),
			viewNormalMatrix = new THREE.Matrix3(),

			uniform = { value: null, needsUpdate: false };

		this.uniform = uniform;
		this.numPlanes = 0;

		this.init = function (planes, enableLocalClipping, camera) {

			var enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;

			localClippingEnabled = enableLocalClipping;

			globalState = projectPlanes(planes, camera, 0);
			numGlobalPlanes = planes.length;

			return enabled;

		};

		this.beginShadows = function () {

			renderingShadows = true;
			projectPlanes(null);

		};

		this.endShadows = function () {

			renderingShadows = false;
			resetGlobalState();

		};

		this.setState = function (planes, clipShadows, camera, cache, fromCache) {

			if (!localClippingEnabled ||
				planes === null || planes.length === 0 ||
				renderingShadows && !clipShadows) {
				// there's no local clipping

				if (renderingShadows) {
					// there's no global clipping

					projectPlanes(null);

				} else {

					resetGlobalState();
				}

			} else {

				var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4,

					dstArray = cache.clippingState || null;

				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes(planes, camera, lGlobal, fromCache);

				for (var i = 0; i !== lGlobal; ++i) {

					dstArray[i] = globalState[i];

				}

				cache.clippingState = dstArray;
				this.numPlanes += nGlobal;

			}


		};

		function resetGlobalState() {

			if (uniform.value !== globalState) {

				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;

			}

			scope.numPlanes = numGlobalPlanes;

		}

		function projectPlanes(planes, camera, dstOffset, skipTransform) {

			var nPlanes = planes !== null ? planes.length : 0,
				dstArray = null;

			if (nPlanes !== 0) {

				dstArray = uniform.value;

				if (skipTransform !== true || dstArray === null) {

					var flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;

					viewNormalMatrix.getNormalMatrix(viewMatrix);

					if (dstArray === null || dstArray.length < flatSize) {

						dstArray = new Float32Array(flatSize);

					}

					for (var i = 0, i4 = dstOffset;
						i !== nPlanes; ++i, i4 += 4) {

						plane.copy(planes[i]).
							applyMatrix4(viewMatrix, viewNormalMatrix);

						plane.normal.toArray(dstArray, i4);
						dstArray[i4 + 3] = plane.constant;

					}

				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;

			}

			scope.numPlanes = nPlanes;
			return dstArray;

		}

	};


	// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLIndexedBufferRenderer = function (_gl, extensions, _infoRender) {

		var mode;

		function setMode(value) {

			mode = value;

		}

		var type, size;

		function setIndex(index) {

			if (index.array instanceof Uint32Array && extensions.get('OES_element_index_uint')) {

				type = _gl.UNSIGNED_INT;
				size = 4;

			} else {

				type = _gl.UNSIGNED_SHORT;
				size = 2;

			}

		}

		function render(start, count) {

			_gl.drawElements(mode, count, type, start * size);

			_infoRender.calls++;
			_infoRender.vertices += count;
			if (mode === _gl.TRIANGLES) _infoRender.faces += count / 3;

		}

		function renderInstances(geometry, start, count) {

			var extension = extensions.get('ANGLE_instanced_arrays');

			if (extension === null) {

				//console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

			extension.drawElementsInstancedANGLE(mode, count, type, start * size, geometry.maxInstancedCount);

			_infoRender.calls++;
			_infoRender.vertices += count * geometry.maxInstancedCount;
			if (mode === _gl.TRIANGLES) _infoRender.faces += geometry.maxInstancedCount * count / 3;
		}

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;

	};

	// File:src/renderers/webgl/WebGLExtensions.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLExtensions = function (gl) {

		var extensions = {};

		this.get = function (name) {

			if (extensions[name] !== undefined) {

				return extensions[name];

			}

			var extension;

			switch (name) {

				case 'WEBGL_depth_texture':
					extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
					break;

				case 'WEBGL_compressed_texture_etc1':
					extension = gl.getExtension('WEBGL_compressed_texture_etc1');
					break;

				default:
					extension = gl.getExtension(name);

			}

			if (extension === null) {

				//console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			extensions[name] = extension;

			return extension;

		};

	};

	// File:src/renderers/webgl/WebGLCapabilities.js

	THREE.WebGLCapabilities = function (gl, extensions, parameters) {

		var maxAnisotropy;

		function getMaxAnisotropy() {

			if (maxAnisotropy !== undefined) return maxAnisotropy;

			var extension = extensions.get('EXT_texture_filter_anisotropic');

			if (extension !== null) {

				maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);

			} else {

				maxAnisotropy = 0;

			}

			return maxAnisotropy;

		}

		function getMaxPrecision(precision) {

			if (precision === 'highp') {

				if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 &&
					gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if (precision === 'mediump') {

				if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 &&
					gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		this.getMaxAnisotropy = getMaxAnisotropy;
		this.getMaxPrecision = getMaxPrecision;

		this.precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;

		this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
		this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
		this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
		this.maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);

		this.maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		this.maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
		this.maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
		this.maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);

		this.vertexTextures = this.maxVertexTextures > 0;
		this.floatFragmentTextures = !!extensions.get('OES_texture_float');
		this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;

		var _maxPrecision = getMaxPrecision(this.precision);

		if (_maxPrecision !== this.precision) {

			//console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
			this.precision = _maxPrecision;

		}

		if (this.logarithmicDepthBuffer) {

			this.logarithmicDepthBuffer = !!extensions.get('EXT_frag_depth');

		}

	};

	// File:src/renderers/webgl/WebGLGeometries.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLGeometries = function (gl, properties, info) {

		var geometries = {};

		function get(object) {

			var geometry = object.geometry;

			if (geometries[geometry.id] !== undefined) {

				return geometries[geometry.id];

			}

			geometry.addEventListener('dispose', onGeometryDispose);

			var buffergeometry;

			if (geometry instanceof THREE.BufferGeometry) {

				buffergeometry = geometry;

			} else if (geometry instanceof THREE.Geometry) {

				if (geometry._bufferGeometry === undefined) {

					geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject(object);

				}

				buffergeometry = geometry._bufferGeometry;

			}

			geometries[geometry.id] = buffergeometry;

			info.memory.geometries++;

			return buffergeometry;

		}

		function onGeometryDispose(event) {

			var geometry = event.target;
			var buffergeometry = geometries[geometry.id];

			if (buffergeometry.index !== null) {

				deleteAttribute(buffergeometry.index);

			}

			deleteAttributes(buffergeometry.attributes);

			geometry.removeEventListener('dispose', onGeometryDispose);

			delete geometries[geometry.id];

			// TODO

			var property = properties.get(geometry);

			if (property.wireframe) {

				deleteAttribute(property.wireframe);

			}

			properties.delete(geometry);

			var bufferproperty = properties.get(buffergeometry);

			if (bufferproperty.wireframe) {

				deleteAttribute(bufferproperty.wireframe);

			}

			properties.delete(buffergeometry);

			//

			info.memory.geometries--;

		}

		function getAttributeBuffer(attribute) {

			if (attribute instanceof THREE.InterleavedBufferAttribute) {

				return properties.get(attribute.data).__webglBuffer;

			}

			return properties.get(attribute).__webglBuffer;

		}

		function deleteAttribute(attribute) {

			var buffer = getAttributeBuffer(attribute);

			if (buffer !== undefined) {

				gl.deleteBuffer(buffer);
				removeAttributeBuffer(attribute);

			}

		}

		function deleteAttributes(attributes) {

			for (var name in attributes) {

				deleteAttribute(attributes[name]);

			}

		}

		function removeAttributeBuffer(attribute) {

			if (attribute instanceof THREE.InterleavedBufferAttribute) {

				properties.delete(attribute.data);

			} else {

				properties.delete(attribute);

			}

		}

		this.get = get;

	};

	// File:src/renderers/webgl/WebGLLights.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLLights = function () {

		var lights = {};

		this.get = function (light) {

			if (lights[light.id] !== undefined) {

				return lights[light.id];

			}

			var uniforms;

			switch (light.type) {

				case 'DirectionalLight':
					uniforms = {
						direction: new THREE.Vector3(),
						color: new THREE.Color(),

						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new THREE.Vector2()
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new THREE.Vector3(),
						direction: new THREE.Vector3(),
						color: new THREE.Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0,

						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new THREE.Vector2()
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new THREE.Vector3(),
						color: new THREE.Color(),
						distance: 0,
						decay: 0,

						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new THREE.Vector2()
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new THREE.Vector3(),
						skyColor: new THREE.Color(),
						groundColor: new THREE.Color()
					};
					break;

			}

			lights[light.id] = uniforms;

			return uniforms;

		};

	};

	// File:src/renderers/webgl/WebGLObjects.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLObjects = function (gl, properties, info) {

		var geometries = new THREE.WebGLGeometries(gl, properties, info);

		//

		function update(object) {

			// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

			var geometry = geometries.get(object);

			if (object.geometry instanceof THREE.Geometry) {

				geometry.updateFromObject(object);

			}

			var index = geometry.index;
			var attributes = geometry.attributes;

			if (index !== null) {

				updateAttribute(index, gl.ELEMENT_ARRAY_BUFFER);

			}

			for (var name in attributes) {

				updateAttribute(attributes[name], gl.ARRAY_BUFFER);

			}

			// morph targets

			var morphAttributes = geometry.morphAttributes;

			for (var name in morphAttributes) {

				var array = morphAttributes[name];

				for (var i = 0, l = array.length; i < l; i++) {

					updateAttribute(array[i], gl.ARRAY_BUFFER);

				}

			}

			return geometry;

		}

		function updateAttribute(attribute, bufferType) {

			var data = (attribute instanceof THREE.InterleavedBufferAttribute) ? attribute.data : attribute;

			var attributeProperties = properties.get(data);

			if (attributeProperties.__webglBuffer === undefined) {

				createBuffer(attributeProperties, data, bufferType);

			} else if (attributeProperties.version !== data.version) {

				updateBuffer(attributeProperties, data, bufferType);

			}

		}

		function createBuffer(attributeProperties, data, bufferType) {

			attributeProperties.__webglBuffer = gl.createBuffer();
			gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);

			var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

			gl.bufferData(bufferType, data.array, usage);

			attributeProperties.version = data.version;

		}

		function updateBuffer(attributeProperties, data, bufferType) {

			gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);

			if (data.dynamic === false || data.updateRange.count === - 1) {

				// Not using update ranges

				gl.bufferSubData(bufferType, 0, data.array);

			} else if (data.updateRange.count === 0) {

				//console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

			} else {

				gl.bufferSubData(bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
					data.array.subarray(data.updateRange.offset, data.updateRange.offset + data.updateRange.count));

				data.updateRange.count = 0; // reset range

			}

			attributeProperties.version = data.version;

		}

		function getAttributeBuffer(attribute) {

			if (attribute instanceof THREE.InterleavedBufferAttribute) {

				return properties.get(attribute.data).__webglBuffer;

			}

			return properties.get(attribute).__webglBuffer;

		}

		function getWireframeAttribute(geometry) {

			var property = properties.get(geometry);

			if (property.wireframe !== undefined) {

				return property.wireframe;

			}

			var indices = [];

			var index = geometry.index;
			var attributes = geometry.attributes;
			var position = attributes.position;

			// //console.time( 'wireframe' );

			if (index !== null) {

				var edges = {};
				var array = index.array;

				for (var i = 0, l = array.length; i < l; i += 3) {

					var a = array[i + 0];
					var b = array[i + 1];
					var c = array[i + 2];

					if (checkEdge(edges, a, b)) indices.push(a, b);
					if (checkEdge(edges, b, c)) indices.push(b, c);
					if (checkEdge(edges, c, a)) indices.push(c, a);

				}

			} else {

				var array = attributes.position.array;

				for (var i = 0, l = (array.length / 3) - 1; i < l; i += 3) {

					var a = i + 0;
					var b = i + 1;
					var c = i + 2;

					indices.push(a, b, b, c, c, a);

				}

			}

			// //console.timeEnd( 'wireframe' );

			var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
			var attribute = new THREE.BufferAttribute(new TypeArray(indices), 1);

			updateAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);

			property.wireframe = attribute;

			return attribute;

		}

		function checkEdge(edges, a, b) {

			if (a > b) {

				var tmp = a;
				a = b;
				b = tmp;

			}

			var list = edges[a];

			if (list === undefined) {

				edges[a] = [b];
				return true;

			} else if (list.indexOf(b) === -1) {

				list.push(b);
				return true;

			}

			return false;

		}

		this.getAttributeBuffer = getAttributeBuffer;
		this.getWireframeAttribute = getWireframeAttribute;

		this.update = update;

	};

	// File:src/renderers/webgl/WebGLProgram.js

	THREE.WebGLProgram = (function () {

		var programIdCount = 0;

		function getEncodingComponents(encoding) {

			switch (encoding) {

				case THREE.LinearEncoding:
					return ['Linear', '( value )'];
				case THREE.sRGBEncoding:
					return ['sRGB', '( value )'];
				case THREE.RGBEEncoding:
					return ['RGBE', '( value )'];
				case THREE.RGBM7Encoding:
					return ['RGBM', '( value, 7.0 )'];
				case THREE.RGBM16Encoding:
					return ['RGBM', '( value, 16.0 )'];
				case THREE.RGBDEncoding:
					return ['RGBD', '( value, 256.0 )'];
				case THREE.GammaEncoding:
					return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
				default:
					throw new Error('unsupported encoding: ' + encoding);

			}

		}

		function getTexelDecodingFunction(functionName, encoding) {

			var components = getEncodingComponents(encoding);
			return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";

		}

		function getTexelEncodingFunction(functionName, encoding) {

			var components = getEncodingComponents(encoding);
			return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";

		}

		function getToneMappingFunction(functionName, toneMapping) {

			var toneMappingName;

			switch (toneMapping) {

				case THREE.LinearToneMapping:
					toneMappingName = "Linear";
					break;

				case THREE.ReinhardToneMapping:
					toneMappingName = "Reinhard";
					break;

				case THREE.Uncharted2ToneMapping:
					toneMappingName = "Uncharted2";
					break;

				case THREE.CineonToneMapping:
					toneMappingName = "OptimizedCineon";
					break;

				default:
					throw new Error('unsupported toneMapping: ' + toneMapping);

			}

			return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";

		}

		function generateExtensions(extensions, parameters, rendererExtensions) {

			extensions = extensions || {};

			var chunks = [
				(extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading) ? '#extension GL_OES_standard_derivatives : enable' : '',
				(extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '',
				(extensions.drawBuffers) && rendererExtensions.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '',
				(extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : '',
			];

			return chunks.filter(filterEmptyLine).join('\n');

		}

		function generateDefines(defines) {

			var chunks = [];

			for (var name in defines) {

				var value = defines[name];

				if (value === false) continue;

				chunks.push('#define ' + name + ' ' + value);

			}

			return chunks.join('\n');

		}

		function fetchAttributeLocations(gl, program, identifiers) {

			var attributes = {};

			var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

			for (var i = 0; i < n; i++) {

				var info = gl.getActiveAttrib(program, i);
				var name = info.name;

				// //console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

				attributes[name] = gl.getAttribLocation(program, name);

			}

			return attributes;

		}

		function filterEmptyLine(string) {

			return string !== '';

		}

		function replaceLightNums(string, parameters) {

			return string
				.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights)
				.replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights)
				.replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights)
				.replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);

		}

		function parseIncludes(string) {

			var pattern = /#include +<([\w\d.]+)>/g;

			function replace(match, include) {

				var replace = THREE.ShaderChunk[include];

				if (replace === undefined) {

					throw new Error('Can not resolve #include <' + include + '>');

				}

				return parseIncludes(replace);

			}

			return string.replace(pattern, replace);

		}

		function unrollLoops(string) {

			var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

			function replace(match, start, end, snippet) {

				var unroll = '';

				for (var i = parseInt(start); i < parseInt(end); i++) {

					unroll += snippet.replace(/\[ i \]/g, '[ ' + i + ' ]');

				}

				return unroll;

			}

			return string.replace(pattern, replace);

		}

		return function WebGLProgram(renderer, code, material, parameters) {

			var gl = renderer.context;

			var extensions = material.extensions;
			var defines = material.defines;

			var vertexShader = material.__webglShader.vertexShader;
			var fragmentShader = material.__webglShader.fragmentShader;

			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

			if (parameters.shadowMapType === THREE.PCFShadowMap) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

			} else if (parameters.shadowMapType === THREE.PCFSoftShadowMap) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

			}

			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
			var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

			if (parameters.envMap) {

				switch (material.envMap.mapping) {

					case THREE.CubeReflectionMapping:
					case THREE.CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;

					case THREE.CubeUVReflectionMapping:
					case THREE.CubeUVRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
						break;

					case THREE.EquirectangularReflectionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;

					case THREE.SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;

				}

				switch (material.envMap.mapping) {

					case THREE.CubeRefractionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;

				}

				switch (material.combine) {

					case THREE.MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;

					case THREE.MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;

					case THREE.AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;

				}

			}

			var gammaFactorDefine = (renderer.gammaFactor > 0) ? renderer.gammaFactor : 1.0;

			// //console.log( 'building new program ' );

			//

			var customExtensions = generateExtensions(extensions, parameters, renderer.extensions);

			var customDefines = generateDefines(defines);

			//

			var program = gl.createProgram();

			var prefixVertex, prefixFragment;

			if (material instanceof THREE.RawShaderMaterial) {

				prefixVertex = [

					customDefines

				].filter(filterEmptyLine).join('\n');

				prefixFragment = [

					customDefines

				].filter(filterEmptyLine).join('\n');

			} else {

				prefixVertex = [

					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',

					'#define SHADER_NAME ' + material.__webglShader.name,

					customDefines,

					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					'#define MAX_BONES ' + parameters.maxBones,

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',

					parameters.flatShading ? '#define FLAT_SHADED' : '',

					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',

					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',

					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',

					'#ifdef USE_COLOR',

					'	attribute vec3 color;',

					'#endif',

					'#ifdef USE_MORPHTARGETS',

					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',

					'	#ifdef USE_MORPHNORMALS',

					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',

					'	#else',

					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',

					'	#endif',

					'#endif',

					'#ifdef USE_SKINNING',

					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',

					'#endif',

					'\n'

				].filter(filterEmptyLine).join('\n');

				prefixFragment = [

					customExtensions,

					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',

					'#define SHADER_NAME ' + material.__webglShader.name,

					customDefines,

					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					(parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
					(parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '',

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',

					parameters.flatShading ? '#define FLAT_SHADED' : '',

					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

					parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',

					parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',

					parameters.envMap && renderer.extensions.get('EXT_shader_texture_lod') ? '#define TEXTURE_LOD_EXT' : '',

					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',

					(parameters.toneMapping !== THREE.NoToneMapping) ? "#define TONE_MAPPING" : '',
					(parameters.toneMapping !== THREE.NoToneMapping) ? THREE.ShaderChunk['tonemapping_pars_fragment'] : '',  // this code is required here because it is used by the toneMapping() function defined below
					(parameters.toneMapping !== THREE.NoToneMapping) ? getToneMappingFunction("toneMapping", parameters.toneMapping) : '',

					(parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding) ? THREE.ShaderChunk['encodings_pars_fragment'] : '', // this code is required here because it is used by the various encoding/decoding function defined below
					parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
					parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
					parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
					parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : '',

					parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',

					'\n'

				].filter(filterEmptyLine).join('\n');

			}

			vertexShader = parseIncludes(vertexShader, parameters);
			vertexShader = replaceLightNums(vertexShader, parameters);

			fragmentShader = parseIncludes(fragmentShader, parameters);
			fragmentShader = replaceLightNums(fragmentShader, parameters);

			if (material instanceof THREE.ShaderMaterial === false) {

				vertexShader = unrollLoops(vertexShader);
				fragmentShader = unrollLoops(fragmentShader);

			}

			var vertexGlsl = prefixVertex + vertexShader;
			var fragmentGlsl = prefixFragment + fragmentShader;

			// console.log( '*VERTEX*', vertexGlsl );
			// console.log( '*FRAGMENT*', fragmentGlsl );

			var glVertexShader = THREE.WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
			var glFragmentShader = THREE.WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);

			gl.attachShader(program, glVertexShader);
			gl.attachShader(program, glFragmentShader);

			// Force a particular attribute to index 0.

			if (material.index0AttributeName !== undefined) {

				gl.bindAttribLocation(program, 0, material.index0AttributeName);

			} else if (parameters.morphTargets === true) {

				// programs with morphTargets displace position out of attribute 0
				gl.bindAttribLocation(program, 0, 'position');

			}

			gl.linkProgram(program);

			var programLog = gl.getProgramInfoLog(program);
			var vertexLog = gl.getShaderInfoLog(glVertexShader);
			var fragmentLog = gl.getShaderInfoLog(glFragmentShader);

			var runnable = true;
			var haveDiagnostics = true;

			// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
			// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

			if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {

				runnable = false;

				//console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

			} else if (programLog !== '') {

				//console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

			} else if (vertexLog === '' || fragmentLog === '') {

				haveDiagnostics = false;

			}

			if (haveDiagnostics) {

				this.diagnostics = {

					runnable: runnable,
					material: material,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				};

			}

			// clean up

			gl.deleteShader(glVertexShader);
			gl.deleteShader(glFragmentShader);

			// set up caching for uniform locations

			var cachedUniforms;

			this.getUniforms = function () {

				if (cachedUniforms === undefined) {

					cachedUniforms =
						new THREE.WebGLUniforms(gl, program, renderer);

				}

				return cachedUniforms;

			};

			// set up caching for attribute locations

			var cachedAttributes;

			this.getAttributes = function () {

				if (cachedAttributes === undefined) {

					cachedAttributes = fetchAttributeLocations(gl, program);

				}

				return cachedAttributes;

			};

			// free resource

			this.destroy = function () {

				gl.deleteProgram(program);
				this.program = undefined;

			};

			// DEPRECATED

			Object.defineProperties(this, {

				uniforms: {
					get: function () {

						//console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
						return this.getUniforms();

					}
				},

				attributes: {
					get: function () {

						//console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
						return this.getAttributes();

					}
				}

			});


			//

			this.id = programIdCount++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;

			return this;

		};

	})();

	// File:src/renderers/webgl/WebGLPrograms.js

	THREE.WebGLPrograms = function (renderer, capabilities) {

		var programs = [];

		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points'
		};

		var parameterNames = [
			"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
			"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
			"roughnessMap", "metalnessMap",
			"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
			"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
			"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
			"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
			"numDirLights", "numPointLights", "numSpotLights", "numHemiLights",
			"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
			"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "depthPacking"
		];


		function allocateBones(object) {

			if (capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture) {

				return 1024;

			} else {

				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				var nVertexUniforms = capabilities.maxVertexUniforms;
				var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);

				var maxBones = nVertexMatrices;

				if (object !== undefined && object instanceof THREE.SkinnedMesh) {

					maxBones = Math.min(object.skeleton.bones.length, maxBones);

					if (maxBones < object.skeleton.bones.length) {

						//console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

					}

				}

				return maxBones;

			}

		}

		function getTextureEncodingFromMap(map, gammaOverrideLinear) {

			var encoding;

			if (!map) {

				encoding = THREE.LinearEncoding;

			} else if (map instanceof THREE.Texture) {

				encoding = map.encoding;

			} else if (map instanceof THREE.WebGLRenderTarget) {

				//console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
				encoding = map.texture.encoding;

			}

			// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
			if (encoding === THREE.LinearEncoding && gammaOverrideLinear) {

				encoding = THREE.GammaEncoding;

			}

			return encoding;

		}

		this.getParameters = function (material, lights, fog, nClipPlanes, object) {

			var shaderID = shaderIDs[material.type];

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			var maxBones = allocateBones(object);
			var precision = renderer.getPrecision();

			if (material.precision !== null) {

				precision = capabilities.getMaxPrecision(material.precision);

				if (precision !== material.precision) {

					//console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

				}

			}

			var currentRenderTarget = renderer.getCurrentRenderTarget();

			var parameters = {

				shaderID: shaderID,

				precision: precision,
				supportsVertexTextures: capabilities.vertexTextures,
				outputEncoding: getTextureEncodingFromMap((!currentRenderTarget) ? null : currentRenderTarget.texture, renderer.gammaOutput),
				map: !!material.map,
				mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
				envMap: !!material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
				envMapCubeUV: (!!material.envMap) && ((material.envMap.mapping === THREE.CubeUVReflectionMapping) || (material.envMap.mapping === THREE.CubeUVRefractionMapping)),
				lightMap: !!material.lightMap,
				aoMap: !!material.aoMap,
				emissiveMap: !!material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
				bumpMap: !!material.bumpMap,
				normalMap: !!material.normalMap,
				displacementMap: !!material.displacementMap,
				roughnessMap: !!material.roughnessMap,
				metalnessMap: !!material.metalnessMap,
				specularMap: !!material.specularMap,
				alphaMap: !!material.alphaMap,

				combine: material.combine,

				vertexColors: material.vertexColors,

				fog: fog,
				useFog: material.fog,
				fogExp: fog instanceof THREE.FogExp2,

				flatShading: material.shading === THREE.FlatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

				skinning: material.skinning,
				maxBones: maxBones,
				useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numHemiLights: lights.hemi.length,

				numClippingPlanes: nClipPlanes,

				shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: renderer.toneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,

				premultipliedAlpha: material.premultipliedAlpha,

				alphaTest: material.alphaTest,
				doubleSided: material.side === THREE.DoubleSide,
				flipSided: material.side === THREE.BackSide,

				depthPacking: (material.depthPacking !== undefined) ? material.depthPacking : false

			};

			return parameters;

		};

		this.getProgramCode = function (material, parameters) {

			var array = [];

			if (parameters.shaderID) {

				array.push(parameters.shaderID);

			} else {

				array.push(material.fragmentShader);
				array.push(material.vertexShader);

			}

			if (material.defines !== undefined) {

				for (var name in material.defines) {

					array.push(name);
					array.push(material.defines[name]);

				}

			}

			for (var i = 0; i < parameterNames.length; i++) {

				array.push(parameters[parameterNames[i]]);

			}

			return array.join();

		};

		this.acquireProgram = function (material, parameters, code) {

			var program;

			// Check if code has been already compiled
			for (var p = 0, pl = programs.length; p < pl; p++) {

				var programInfo = programs[p];

				if (programInfo.code === code) {

					program = programInfo;
					++program.usedTimes;

					break;

				}

			}

			if (program === undefined) {

				program = new THREE.WebGLProgram(renderer, code, material, parameters);
				programs.push(program);

			}

			return program;

		};

		this.releaseProgram = function (program) {

			if (--program.usedTimes === 0) {

				// Remove from unordered set
				var i = programs.indexOf(program);
				programs[i] = programs[programs.length - 1];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		};

		// Exposed for resource monitoring & error feedback via renderer.info:
		this.programs = programs;

	};

	// File:src/renderers/webgl/WebGLProperties.js

	/**
	* @author fordacious / fordacious.github.io
	*/

	THREE.WebGLProperties = function () {

		var properties = {};

		this.get = function (object) {

			var uuid = object.uuid;
			var map = properties[uuid];

			if (map === undefined) {

				map = {};
				properties[uuid] = map;

			}

			return map;

		};

		this.delete = function (object) {

			delete properties[object.uuid];

		};

		this.clear = function () {

			properties = {};

		};

	};

	// File:src/renderers/webgl/WebGLShader.js

	THREE.WebGLShader = (function () {

		function addLineNumbers(string) {

			var lines = string.split('\n');

			for (var i = 0; i < lines.length; i++) {

				lines[i] = (i + 1) + ': ' + lines[i];

			}

			return lines.join('\n');

		}

		return function WebGLShader(gl, type, string) {

			var shader = gl.createShader(type);

			gl.shaderSource(shader, string);
			gl.compileShader(shader);

			if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {

				//console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

			}

			if (gl.getShaderInfoLog(shader) !== '') {

				//console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

			}

			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

			return shader;

		};

	})();

	// File:src/renderers/webgl/WebGLShadowMap.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.WebGLShadowMap = function (_renderer, _lights, _objects) {

		var _gl = _renderer.context,
			_state = _renderer.state,
			_frustum = new THREE.Frustum(),
			_projScreenMatrix = new THREE.Matrix4(),

			_lightShadows = _lights.shadows,

			_shadowMapSize = new THREE.Vector2(),

			_lookTarget = new THREE.Vector3(),
			_lightPositionWorld = new THREE.Vector3(),

			_renderList = [],

			_MorphingFlag = 1,
			_SkinningFlag = 2,

			_NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1,

			_depthMaterials = new Array(_NumberOfMaterialVariants),
			_distanceMaterials = new Array(_NumberOfMaterialVariants),

			_materialCache = {};

		var cubeDirections = [
			new THREE.Vector3(1, 0, 0), new THREE.Vector3(- 1, 0, 0), new THREE.Vector3(0, 0, 1),
			new THREE.Vector3(0, 0, - 1), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, - 1, 0)
		];

		var cubeUps = [
			new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0),
			new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, - 1)
		];

		var cube2DViewPorts = [
			new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),
			new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()
		];

		// init

		var depthMaterialTemplate = new THREE.MeshDepthMaterial();
		depthMaterialTemplate.depthPacking = THREE.RGBADepthPacking;
		depthMaterialTemplate.clipping = true;

		var distanceShader = THREE.ShaderLib["distanceRGBA"];
		var distanceUniforms = THREE.UniformsUtils.clone(distanceShader.uniforms);

		for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {

			var useMorphing = (i & _MorphingFlag) !== 0;
			var useSkinning = (i & _SkinningFlag) !== 0;

			var depthMaterial = depthMaterialTemplate.clone();
			depthMaterial.morphTargets = useMorphing;
			depthMaterial.skinning = useSkinning;

			_depthMaterials[i] = depthMaterial;

			var distanceMaterial = new THREE.ShaderMaterial({
				defines: {
					'USE_SHADOWMAP': ''
				},
				uniforms: distanceUniforms,
				vertexShader: distanceShader.vertexShader,
				fragmentShader: distanceShader.fragmentShader,
				morphTargets: useMorphing,
				skinning: useSkinning,
				clipping: true
			});

			_distanceMaterials[i] = distanceMaterial;

		}

		//

		var scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = THREE.PCFShadowMap;

		this.renderReverseSided = true;
		this.renderSingleSided = true;

		this.render = function (scene, camera) {

			if (scope.enabled === false) return;
			if (scope.autoUpdate === false && scope.needsUpdate === false) return;

			if (_lightShadows.length === 0) return;

			// Set GL state for depth map.
			_state.clearColor(1, 1, 1, 1);
			_state.disable(_gl.BLEND);
			_state.setDepthTest(true);
			_state.setScissorTest(false);

			// render depth map

			var faceCount, isPointLight;

			for (var i = 0, il = _lightShadows.length; i < il; i++) {

				var light = _lightShadows[i];
				var shadow = light.shadow;

				if (shadow === undefined) {

					//console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
					continue;

				}

				var shadowCamera = shadow.camera;

				_shadowMapSize.copy(shadow.mapSize);

				if (light instanceof THREE.PointLight) {

					faceCount = 6;
					isPointLight = true;

					var vpWidth = _shadowMapSize.x;
					var vpHeight = _shadowMapSize.y;

					// These viewports map a cube-map onto a 2D texture with the
					// following orientation:
					//
					//  xzXZ
					//   y Y
					//
					// X - Positive x direction
					// x - Negative x direction
					// Y - Positive y direction
					// y - Negative y direction
					// Z - Positive z direction
					// z - Negative z direction

					// positive X
					cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
					// negative X
					cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
					// positive Z
					cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
					// negative Z
					cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
					// positive Y
					cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
					// negative Y
					cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);

					_shadowMapSize.x *= 4.0;
					_shadowMapSize.y *= 2.0;

				} else {

					faceCount = 1;
					isPointLight = false;

				}

				if (shadow.map === null) {

					var pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };

					shadow.map = new THREE.WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);

					shadowCamera.updateProjectionMatrix();

				}

				if (shadow instanceof THREE.SpotLightShadow) {

					shadow.update(light);

				}

				var shadowMap = shadow.map;
				var shadowMatrix = shadow.matrix;

				_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
				shadowCamera.position.copy(_lightPositionWorld);

				_renderer.setRenderTarget(shadowMap);
				_renderer.clear();

				// render shadow map for each cube face (if omni-directional) or
				// run a single pass if not

				for (var face = 0; face < faceCount; face++) {

					if (isPointLight) {

						_lookTarget.copy(shadowCamera.position);
						_lookTarget.add(cubeDirections[face]);
						shadowCamera.up.copy(cubeUps[face]);
						shadowCamera.lookAt(_lookTarget);

						var vpDimensions = cube2DViewPorts[face];
						_state.viewport(vpDimensions);

					} else {

						_lookTarget.setFromMatrixPosition(light.target.matrixWorld);
						shadowCamera.lookAt(_lookTarget);

					}

					shadowCamera.updateMatrixWorld();
					shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);

					// compute shadow matrix

					shadowMatrix.set(
						0.5, 0.0, 0.0, 0.5,
						0.0, 0.5, 0.0, 0.5,
						0.0, 0.0, 0.5, 0.5,
						0.0, 0.0, 0.0, 1.0
					);

					shadowMatrix.multiply(shadowCamera.projectionMatrix);
					shadowMatrix.multiply(shadowCamera.matrixWorldInverse);

					// update camera matrices and frustum

					_projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
					_frustum.setFromMatrix(_projScreenMatrix);

					// set object matrices & frustum culling

					_renderList.length = 0;

					projectObject(scene, camera, shadowCamera);

					// render shadow map
					// render regular objects

					for (var j = 0, jl = _renderList.length; j < jl; j++) {

						var object = _renderList[j];
						var geometry = _objects.update(object);
						var material = object.material;

						if (material instanceof THREE.MultiMaterial) {

							var groups = geometry.groups;
							var materials = material.materials;

							for (var k = 0, kl = groups.length; k < kl; k++) {

								var group = groups[k];
								var groupMaterial = materials[group.materialIndex];

								if (groupMaterial.visible === true) {

									var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld);
									_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);

								}

							}

						} else {

							var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld);
							_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);

						}

					}

				}

			}

			// Restore GL state.
			var clearColor = _renderer.getClearColor(),
				clearAlpha = _renderer.getClearAlpha();
			_renderer.setClearColor(clearColor, clearAlpha);

			scope.needsUpdate = false;

		};

		function getDepthMaterial(object, material, isPointLight, lightPositionWorld) {

			var geometry = object.geometry;

			var result = null;

			var materialVariants = _depthMaterials;
			var customMaterial = object.customDepthMaterial;

			if (isPointLight) {

				materialVariants = _distanceMaterials;
				customMaterial = object.customDistanceMaterial;

			}

			if (!customMaterial) {

				var useMorphing = geometry.morphTargets !== undefined &&
					geometry.morphTargets.length > 0 && material.morphTargets;

				var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;

				var variantIndex = 0;

				if (useMorphing) variantIndex |= _MorphingFlag;
				if (useSkinning) variantIndex |= _SkinningFlag;

				result = materialVariants[variantIndex];

			} else {

				result = customMaterial;

			}

			if (_renderer.localClippingEnabled &&
				material.clipShadows === true &&
				material.clippingPlanes.length !== 0) {

				// in this case we need a unique material instance reflecting the
				// appropriate state

				var keyA = result.uuid, keyB = material.uuid;

				var materialsForVariant = _materialCache[keyA];

				if (materialsForVariant === undefined) {

					materialsForVariant = {};
					_materialCache[keyA] = materialsForVariant;

				}

				var cachedMaterial = materialsForVariant[keyB];

				if (cachedMaterial === undefined) {

					cachedMaterial = result.clone();
					materialsForVariant[keyB] = cachedMaterial;

				}

				result = cachedMaterial;

			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			var side = material.side;

			if (scope.renderSingleSided && side == THREE.DoubleSide) {

				side = THREE.FrontSide;

			}

			if (scope.renderReverseSided) {

				if (side === THREE.FrontSide) side = THREE.BackSide;
				else if (side === THREE.BackSide) side = THREE.FrontSide;

			}

			result.side = side;

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;

			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if (isPointLight && result.uniforms.lightPos !== undefined) {

				result.uniforms.lightPos.value.copy(lightPositionWorld);

			}

			return result;

		}

		function projectObject(object, camera, shadowCamera) {

			if (object.visible === false) return;

			if (object.layers.test(camera.layers) && (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points)) {

				if (object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject(object) === true)) {

					var material = object.material;

					if (material.visible === true) {

						object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
						_renderList.push(object);

					}

				}

			}

			var children = object.children;

			for (var i = 0, l = children.length; i < l; i++) {

				projectObject(children[i], camera, shadowCamera);

			}

		}

	};

	// File:src/renderers/webgl/WebGLState.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLState = function (gl, extensions, paramThreeToGL) {

		var _this = this;

		this.buffers = {
			color: new THREE.WebGLColorBuffer(gl, this),
			depth: new THREE.WebGLDepthBuffer(gl, this),
			stencil: new THREE.WebGLStencilBuffer(gl, this)
		};

		var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		var newAttributes = new Uint8Array(maxVertexAttributes);
		var enabledAttributes = new Uint8Array(maxVertexAttributes);
		var attributeDivisors = new Uint8Array(maxVertexAttributes);

		var capabilities = {};

		var compressedTextureFormats = null;

		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
		var currentPremultipledAlpha = false;

		var currentFlipSided = null;
		var currentCullFace = null;

		var currentLineWidth = null;

		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;

		var currentScissorTest = null;

		var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);

		var currentTextureSlot = null;
		var currentBoundTextures = {};

		var currentScissor = new THREE.Vector4();
		var currentViewport = new THREE.Vector4();

		function createTexture(type, target, count) {

			var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
			var texture = gl.createTexture();

			gl.bindTexture(type, texture);
			gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

			for (var i = 0; i < count; i++) {

				gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);

			}

			return texture;

		}

		var emptyTextures = {};
		emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
		emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);

		//

		this.init = function () {

			this.clearColor(0, 0, 0, 1);
			this.clearDepth(1);
			this.clearStencil(0);

			this.enable(gl.DEPTH_TEST);
			this.setDepthFunc(THREE.LessEqualDepth);

			this.setFlipSided(false);
			this.setCullFace(THREE.CullFaceBack);
			this.enable(gl.CULL_FACE);

			this.enable(gl.BLEND);
			this.setBlending(THREE.NormalBlending);

		};

		this.initAttributes = function () {

			for (var i = 0, l = newAttributes.length; i < l; i++) {

				newAttributes[i] = 0;

			}

		};

		this.enableAttribute = function (attribute) {

			newAttributes[attribute] = 1;

			if (enabledAttributes[attribute] === 0) {

				gl.enableVertexAttribArray(attribute);
				enabledAttributes[attribute] = 1;

			}

			if (attributeDivisors[attribute] !== 0) {

				var extension = extensions.get('ANGLE_instanced_arrays');

				extension.vertexAttribDivisorANGLE(attribute, 0);
				attributeDivisors[attribute] = 0;

			}

		};

		this.enableAttributeAndDivisor = function (attribute, meshPerAttribute, extension) {

			newAttributes[attribute] = 1;

			if (enabledAttributes[attribute] === 0) {

				gl.enableVertexAttribArray(attribute);
				enabledAttributes[attribute] = 1;

			}

			if (attributeDivisors[attribute] !== meshPerAttribute) {

				extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
				attributeDivisors[attribute] = meshPerAttribute;

			}

		};

		this.disableUnusedAttributes = function () {

			for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {

				if (enabledAttributes[i] !== newAttributes[i]) {

					gl.disableVertexAttribArray(i);
					enabledAttributes[i] = 0;

				}

			}

		};

		this.enable = function (id) {

			if (capabilities[id] !== true) {

				gl.enable(id);
				capabilities[id] = true;

			}

		};

		this.disable = function (id) {

			if (capabilities[id] !== false) {

				gl.disable(id);
				capabilities[id] = false;

			}

		};

		this.getCompressedTextureFormats = function () {

			if (compressedTextureFormats === null) {

				compressedTextureFormats = [];

				if (extensions.get('WEBGL_compressed_texture_pvrtc') ||
					extensions.get('WEBGL_compressed_texture_s3tc') ||
					extensions.get('WEBGL_compressed_texture_etc1')) {

					var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);

					for (var i = 0; i < formats.length; i++) {

						compressedTextureFormats.push(formats[i]);

					}

				}

			}

			return compressedTextureFormats;

		};

		this.setBlending = function (blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {

			if (blending !== THREE.NoBlending) {

				this.enable(gl.BLEND);

			} else {

				this.disable(gl.BLEND);
				currentBlending = blending; // no blending, that is
				return;

			}

			if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {

				if (blending === THREE.AdditiveBlending) {

					if (premultipliedAlpha) {

						gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
						gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);

					} else {

						gl.blendEquation(gl.FUNC_ADD);
						gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

					}

				} else if (blending === THREE.SubtractiveBlending) {

					if (premultipliedAlpha) {

						gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
						gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);

					} else {

						gl.blendEquation(gl.FUNC_ADD);
						gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);

					}

				} else if (blending === THREE.MultiplyBlending) {

					if (premultipliedAlpha) {

						gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
						gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);

					} else {

						gl.blendEquation(gl.FUNC_ADD);
						gl.blendFunc(gl.ZERO, gl.SRC_COLOR);

					}

				} else {

					if (premultipliedAlpha) {

						gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
						gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

					} else {

						gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
						gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

					}

				}

				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;

			}

			if (blending === THREE.CustomBlending) {

				blendEquationAlpha = blendEquationAlpha || blendEquation;
				blendSrcAlpha = blendSrcAlpha || blendSrc;
				blendDstAlpha = blendDstAlpha || blendDst;

				if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {

					gl.blendEquationSeparate(paramThreeToGL(blendEquation), paramThreeToGL(blendEquationAlpha));

					currentBlendEquation = blendEquation;
					currentBlendEquationAlpha = blendEquationAlpha;

				}

				if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {

					gl.blendFuncSeparate(paramThreeToGL(blendSrc), paramThreeToGL(blendDst), paramThreeToGL(blendSrcAlpha), paramThreeToGL(blendDstAlpha));

					currentBlendSrc = blendSrc;
					currentBlendDst = blendDst;
					currentBlendSrcAlpha = blendSrcAlpha;
					currentBlendDstAlpha = blendDstAlpha;

				}

			} else {

				currentBlendEquation = null;
				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendEquationAlpha = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

			}

		};

		// TODO Deprecate

		this.setColorWrite = function (colorWrite) {

			this.buffers.color.setMask(colorWrite);

		};

		this.setDepthTest = function (depthTest) {

			this.buffers.depth.setTest(depthTest);

		};

		this.setDepthWrite = function (depthWrite) {

			this.buffers.depth.setMask(depthWrite);

		};

		this.setDepthFunc = function (depthFunc) {

			this.buffers.depth.setFunc(depthFunc);

		};

		this.setStencilTest = function (stencilTest) {

			this.buffers.stencil.setTest(stencilTest);

		};

		this.setStencilWrite = function (stencilWrite) {

			this.buffers.stencil.setMask(stencilWrite);

		};

		this.setStencilFunc = function (stencilFunc, stencilRef, stencilMask) {

			this.buffers.stencil.setFunc(stencilFunc, stencilRef, stencilMask);

		};

		this.setStencilOp = function (stencilFail, stencilZFail, stencilZPass) {

			this.buffers.stencil.setOp(stencilFail, stencilZFail, stencilZPass);

		};

		//

		this.setFlipSided = function (flipSided) {

			if (currentFlipSided !== flipSided) {

				if (flipSided) {

					gl.frontFace(gl.CW);

				} else {

					gl.frontFace(gl.CCW);

				}

				currentFlipSided = flipSided;

			}

		};

		this.setCullFace = function (cullFace) {

			if (cullFace !== THREE.CullFaceNone) {

				this.enable(gl.CULL_FACE);

				if (cullFace !== currentCullFace) {

					if (cullFace === THREE.CullFaceBack) {

						gl.cullFace(gl.BACK);

					} else if (cullFace === THREE.CullFaceFront) {

						gl.cullFace(gl.FRONT);

					} else {

						gl.cullFace(gl.FRONT_AND_BACK);

					}

				}

			} else {

				this.disable(gl.CULL_FACE);

			}

			currentCullFace = cullFace;

		};

		this.setLineWidth = function (width) {

			if (width !== currentLineWidth) {

				gl.lineWidth(width);

				currentLineWidth = width;

			}

		};

		this.setPolygonOffset = function (polygonOffset, factor, units) {

			if (polygonOffset) {

				this.enable(gl.POLYGON_OFFSET_FILL);

				if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {

					gl.polygonOffset(factor, units);

					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;

				}

			} else {

				this.disable(gl.POLYGON_OFFSET_FILL);

			}

		};

		this.getScissorTest = function () {

			return currentScissorTest;

		};

		this.setScissorTest = function (scissorTest) {

			currentScissorTest = scissorTest;

			if (scissorTest) {

				this.enable(gl.SCISSOR_TEST);

			} else {

				this.disable(gl.SCISSOR_TEST);

			}

		};

		// texture

		this.activeTexture = function (webglSlot) {

			if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;

			if (currentTextureSlot !== webglSlot) {

				gl.activeTexture(webglSlot);
				currentTextureSlot = webglSlot;

			}

		};

		this.bindTexture = function (webglType, webglTexture) {

			if (currentTextureSlot === null) {

				_this.activeTexture();

			}

			var boundTexture = currentBoundTextures[currentTextureSlot];

			if (boundTexture === undefined) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[currentTextureSlot] = boundTexture;

			}

			if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {

				gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		};

		this.compressedTexImage2D = function () {

			try {

				gl.compressedTexImage2D.apply(gl, arguments);

			} catch (error) {

				//console.error( error );

			}

		};

		this.texImage2D = function () {

			try {

				gl.texImage2D.apply(gl, arguments);

			} catch (error) {

				//console.error( error );

			}

		};

		// TODO Deprecate

		this.clearColor = function (r, g, b, a) {

			this.buffers.color.setClear(r, g, b, a);

		};

		this.clearDepth = function (depth) {

			this.buffers.depth.setClear(depth);

		};

		this.clearStencil = function (stencil) {

			this.buffers.stencil.setClear(stencil);

		};

		//

		this.scissor = function (scissor) {

			if (currentScissor.equals(scissor) === false) {

				gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
				currentScissor.copy(scissor);

			}

		};

		this.viewport = function (viewport) {

			if (currentViewport.equals(viewport) === false) {

				gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
				currentViewport.copy(viewport);

			}

		};

		//

		this.reset = function () {

			for (var i = 0; i < enabledAttributes.length; i++) {

				if (enabledAttributes[i] === 1) {

					gl.disableVertexAttribArray(i);
					enabledAttributes[i] = 0;

				}

			}

			capabilities = {};

			compressedTextureFormats = null;

			currentTextureSlot = null;
			currentBoundTextures = {};

			currentBlending = null;

			currentFlipSided = null;
			currentCullFace = null;

			this.buffers.color.reset();
			this.buffers.depth.reset();
			this.buffers.stencil.reset();

		};

	};

	THREE.WebGLColorBuffer = function (gl, state) {

		var locked = false;

		var color = new THREE.Vector4();
		var currentColorMask = null;
		var currentColorClear = new THREE.Vector4();

		this.setMask = function (colorMask) {

			if (currentColorMask !== colorMask && !locked) {

				gl.colorMask(colorMask, colorMask, colorMask, colorMask);
				currentColorMask = colorMask;

			}

		};

		this.setLocked = function (lock) {

			locked = lock;

		};

		this.setClear = function (r, g, b, a) {

			color.set(r, g, b, a);

			if (currentColorClear.equals(color) === false) {

				gl.clearColor(r, g, b, a);
				currentColorClear.copy(color);

			}

		};

		this.reset = function () {

			locked = false;

			currentColorMask = null;
			currentColorClear = new THREE.Vector4();

		};

	};

	THREE.WebGLDepthBuffer = function (gl, state) {

		var locked = false;

		var currentDepthMask = null;
		var currentDepthFunc = null;
		var currentDepthClear = null;

		this.setTest = function (depthTest) {

			if (depthTest) {

				state.enable(gl.DEPTH_TEST);

			} else {

				state.disable(gl.DEPTH_TEST);

			}

		};

		this.setMask = function (depthMask) {

			if (currentDepthMask !== depthMask && !locked) {

				gl.depthMask(depthMask);
				currentDepthMask = depthMask;

			}

		};

		this.setFunc = function (depthFunc) {

			if (currentDepthFunc !== depthFunc) {

				if (depthFunc) {

					switch (depthFunc) {

						case THREE.NeverDepth:

							gl.depthFunc(gl.NEVER);
							break;

						case THREE.AlwaysDepth:

							gl.depthFunc(gl.ALWAYS);
							break;

						case THREE.LessDepth:

							gl.depthFunc(gl.LESS);
							break;

						case THREE.LessEqualDepth:

							gl.depthFunc(gl.LEQUAL);
							break;

						case THREE.EqualDepth:

							gl.depthFunc(gl.EQUAL);
							break;

						case THREE.GreaterEqualDepth:

							gl.depthFunc(gl.GEQUAL);
							break;

						case THREE.GreaterDepth:

							gl.depthFunc(gl.GREATER);
							break;

						case THREE.NotEqualDepth:

							gl.depthFunc(gl.NOTEQUAL);
							break;

						default:

							gl.depthFunc(gl.LEQUAL);

					}

				} else {

					gl.depthFunc(gl.LEQUAL);

				}

				currentDepthFunc = depthFunc;

			}

		};

		this.setLocked = function (lock) {

			locked = lock;

		};

		this.setClear = function (depth) {

			if (currentDepthClear !== depth) {

				gl.clearDepth(depth);
				currentDepthClear = depth;

			}

		};

		this.reset = function () {

			locked = false;

			currentDepthMask = null;
			currentDepthFunc = null;
			currentDepthClear = null;

		};

	};

	THREE.WebGLStencilBuffer = function (gl, state) {

		var locked = false;

		var currentStencilMask = null;
		var currentStencilFunc = null;
		var currentStencilRef = null;
		var currentStencilFuncMask = null;
		var currentStencilFail = null;
		var currentStencilZFail = null;
		var currentStencilZPass = null;
		var currentStencilClear = null;

		this.setTest = function (stencilTest) {

			if (stencilTest) {

				state.enable(gl.STENCIL_TEST);

			} else {

				state.disable(gl.STENCIL_TEST);

			}

		};

		this.setMask = function (stencilMask) {

			if (currentStencilMask !== stencilMask && !locked) {

				gl.stencilMask(stencilMask);
				currentStencilMask = stencilMask;

			}

		};

		this.setFunc = function (stencilFunc, stencilRef, stencilMask) {

			if (currentStencilFunc !== stencilFunc ||
				currentStencilRef !== stencilRef ||
				currentStencilFuncMask !== stencilMask) {

				gl.stencilFunc(stencilFunc, stencilRef, stencilMask);

				currentStencilFunc = stencilFunc;
				currentStencilRef = stencilRef;
				currentStencilFuncMask = stencilMask;

			}

		};

		this.setOp = function (stencilFail, stencilZFail, stencilZPass) {

			if (currentStencilFail !== stencilFail ||
				currentStencilZFail !== stencilZFail ||
				currentStencilZPass !== stencilZPass) {

				gl.stencilOp(stencilFail, stencilZFail, stencilZPass);

				currentStencilFail = stencilFail;
				currentStencilZFail = stencilZFail;
				currentStencilZPass = stencilZPass;

			}

		};

		this.setLocked = function (lock) {

			locked = lock;

		};

		this.setClear = function (stencil) {

			if (currentStencilClear !== stencil) {

				gl.clearStencil(stencil);
				currentStencilClear = stencil;

			}

		};

		this.reset = function () {

			locked = false;

			currentStencilMask = null;
			currentStencilFunc = null;
			currentStencilRef = null;
			currentStencilFuncMask = null;
			currentStencilFail = null;
			currentStencilZFail = null;
			currentStencilZPass = null;
			currentStencilClear = null;

		};

	};

	// File:src/renderers/webgl/WebGLTextures.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLTextures = function (_gl, extensions, state, properties, capabilities, paramThreeToGL, info) {

		var _infoMemory = info.memory;
		var _isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext);

		//

		function clampToMaxSize(image, maxSize) {

			if (image.width > maxSize || image.height > maxSize) {

				// Warning: Scaling through the canvas will only work with images that use
				// premultiplied alpha.

				var scale = maxSize / Math.max(image.width, image.height);

				var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
				canvas.width = Math.floor(image.width * scale);
				canvas.height = Math.floor(image.height * scale);

				var context = canvas.getContext('2d');
				context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);

				//console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

				return canvas;

			}

			return image;

		}

		function isPowerOfTwo(image) {

			return THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height);

		}

		function makePowerOfTwo(image) {

			if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {

				var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
				canvas.width = THREE.Math.nearestPowerOfTwo(image.width);
				canvas.height = THREE.Math.nearestPowerOfTwo(image.height);

				var context = canvas.getContext('2d');
				context.drawImage(image, 0, 0, canvas.width, canvas.height);

				//console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

				return canvas;

			}

			return image;

		}

		function textureNeedsPowerOfTwo(texture) {

			if (texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping) return true;
			if (texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter) return true;

			return false;

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback(f) {

			if (f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter) {

				return _gl.NEAREST;

			}

			return _gl.LINEAR;

		}

		//

		function onTextureDispose(event) {

			var texture = event.target;

			texture.removeEventListener('dispose', onTextureDispose);

			deallocateTexture(texture);

			_infoMemory.textures--;


		}

		function onRenderTargetDispose(event) {

			var renderTarget = event.target;

			renderTarget.removeEventListener('dispose', onRenderTargetDispose);

			deallocateRenderTarget(renderTarget);

			_infoMemory.textures--;

		}

		//

		function deallocateTexture(texture) {

			var textureProperties = properties.get(texture);

			if (texture.image && textureProperties.__image__webglTextureCube) {

				// cube texture

				_gl.deleteTexture(textureProperties.__image__webglTextureCube);

			} else {

				// 2D texture

				if (textureProperties.__webglInit === undefined) return;

				_gl.deleteTexture(textureProperties.__webglTexture);

			}

			// remove all webgl properties
			properties.delete(texture);

		}

		function deallocateRenderTarget(renderTarget) {

			var renderTargetProperties = properties.get(renderTarget);
			var textureProperties = properties.get(renderTarget.texture);

			if (!renderTarget) return;

			if (textureProperties.__webglTexture !== undefined) {

				_gl.deleteTexture(textureProperties.__webglTexture);

			}

			if (renderTarget.depthTexture) {

				renderTarget.depthTexture.dispose();

			}

			if (renderTarget instanceof THREE.WebGLRenderTargetCube) {

				for (var i = 0; i < 6; i++) {

					_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
					if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);

				}

			} else {

				_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
				if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);

			}

			properties.delete(renderTarget.texture);
			properties.delete(renderTarget);

		}

		//



		function setTexture2D(texture, slot) {

			var textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {

				var image = texture.image;

				if (image === undefined) {

					//console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );

				} else if (image.complete === false) {

					//console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );

				} else {

					uploadTexture(textureProperties, texture, slot);
					return;

				}

			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);

		}

		function setTextureCube(texture, slot) {

			var textureProperties = properties.get(texture);

			if (texture.image.length === 6) {

				if (texture.version > 0 && textureProperties.__version !== texture.version) {

					if (!textureProperties.__image__webglTextureCube) {

						texture.addEventListener('dispose', onTextureDispose);

						textureProperties.__image__webglTextureCube = _gl.createTexture();

						_infoMemory.textures++;

					}

					state.activeTexture(_gl.TEXTURE0 + slot);
					state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);

					_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);

					var isCompressed = texture instanceof THREE.CompressedTexture;
					var isDataTexture = texture.image[0] instanceof THREE.DataTexture;

					var cubeImage = [];

					for (var i = 0; i < 6; i++) {

						if (!isCompressed && !isDataTexture) {

							cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);

						} else {

							cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];

						}

					}

					var image = cubeImage[0],
						isPowerOfTwoImage = isPowerOfTwo(image),
						glFormat = paramThreeToGL(texture.format),
						glType = paramThreeToGL(texture.type);

					setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);

					for (var i = 0; i < 6; i++) {

						if (!isCompressed) {

							if (isDataTexture) {

								state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);

							} else {

								state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);

							}

						} else {

							var mipmap, mipmaps = cubeImage[i].mipmaps;

							for (var j = 0, jl = mipmaps.length; j < jl; j++) {

								mipmap = mipmaps[j];

								if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {

									if (state.getCompressedTextureFormats().indexOf(glFormat) > - 1) {

										state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);

									} else {

										//console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()" );

									}

								} else {

									state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);

								}

							}

						}

					}

					if (texture.generateMipmaps && isPowerOfTwoImage) {

						_gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);

					}

					textureProperties.__version = texture.version;

					if (texture.onUpdate) texture.onUpdate(texture);

				} else {

					state.activeTexture(_gl.TEXTURE0 + slot);
					state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);

				}

			}

		}

		function setTextureCubeDynamic(texture, slot) {

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);

		}

		function setTextureParameters(textureType, texture, isPowerOfTwoImage) {

			var extension;

			if (isPowerOfTwoImage) {

				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));

				_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));
				_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));

			} else {

				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);

				if (texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping) {

					//console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

				}

				_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
				_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));

				if (texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter) {

					//console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

				}

			}

			extension = extensions.get('EXT_texture_filter_anisotropic');

			if (extension) {

				if (texture.type === THREE.FloatType && extensions.get('OES_texture_float_linear') === null) return;
				if (texture.type === THREE.HalfFloatType && extensions.get('OES_texture_half_float_linear') === null) return;

				if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {

					_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
					properties.get(texture).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function uploadTexture(textureProperties, texture, slot) {

			if (textureProperties.__webglInit === undefined) {

				textureProperties.__webglInit = true;

				texture.addEventListener('dispose', onTextureDispose);

				textureProperties.__webglTexture = _gl.createTexture();

				_infoMemory.textures++;

			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);

			var image = clampToMaxSize(texture.image, capabilities.maxTextureSize);

			if (textureNeedsPowerOfTwo(texture) && isPowerOfTwo(image) === false) {

				image = makePowerOfTwo(image);

			}

			var isPowerOfTwoImage = isPowerOfTwo(image),
				glFormat = paramThreeToGL(texture.format),
				glType = paramThreeToGL(texture.type);

			setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);

			var mipmap, mipmaps = texture.mipmaps;

			if (texture instanceof THREE.DepthTexture) {

				// populate depth texture with dummy data

				var internalFormat = _gl.DEPTH_COMPONENT;

				if (texture.type === THREE.FloatType) {

					if (!_isWebGL2) throw new Error('Float Depth Texture only supported in WebGL2.0');
					internalFormat = _gl.DEPTH_COMPONENT32F;

				} else if (_isWebGL2) {

					// WebGL 2.0 requires signed internalformat for glTexImage2D
					internalFormat = _gl.DEPTH_COMPONENT16;

				}

				state.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null);

			} else if (texture instanceof THREE.DataTexture) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if (mipmaps.length > 0 && isPowerOfTwoImage) {

					for (var i = 0, il = mipmaps.length; i < il; i++) {

						mipmap = mipmaps[i];
						state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);

					}

					texture.generateMipmaps = false;

				} else {

					state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);

				}

			} else if (texture instanceof THREE.CompressedTexture) {

				for (var i = 0, il = mipmaps.length; i < il; i++) {

					mipmap = mipmaps[i];

					if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {

						if (state.getCompressedTextureFormats().indexOf(glFormat) > - 1) {

							state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);

						} else {

							//console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

						}

					} else {

						state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);

					}

				}

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if (mipmaps.length > 0 && isPowerOfTwoImage) {

					for (var i = 0, il = mipmaps.length; i < il; i++) {

						mipmap = mipmaps[i];
						state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);

					}

					texture.generateMipmaps = false;

				} else {

					state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);

				}

			}

			if (texture.generateMipmaps && isPowerOfTwoImage) _gl.generateMipmap(_gl.TEXTURE_2D);

			textureProperties.__version = texture.version;

			if (texture.onUpdate) texture.onUpdate(texture);

		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {

			var glFormat = paramThreeToGL(renderTarget.texture.format);
			var glType = paramThreeToGL(renderTarget.texture.type);
			state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
			_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
			_gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
			_gl.bindFramebuffer(_gl.FRAMEBUFFER, null);

		}

		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage(renderbuffer, renderTarget) {

			_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);

			if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {

				_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
				_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);

			} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {

				_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
				_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);

			} else {

				// FIXME: We don't support !depth !stencil
				_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);

			}

			_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);

		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture(framebuffer, renderTarget) {

			var isCube = (renderTarget instanceof THREE.WebGLRenderTargetCube);
			if (isCube) throw new Error('Depth Texture with cube render targets is not supported!');

			_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

			if (!(renderTarget.depthTexture instanceof THREE.DepthTexture)) {

				throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');

			}

			// upload an empty depth texture with framebuffer size
			if (!properties.get(renderTarget.depthTexture).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height) {
				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;
			}

			setTexture2D(renderTarget.depthTexture, 0);

			var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
			_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);

		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer(renderTarget) {

			var renderTargetProperties = properties.get(renderTarget);

			var isCube = (renderTarget instanceof THREE.WebGLRenderTargetCube);

			if (renderTarget.depthTexture) {

				if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');

				setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);

			} else {

				if (isCube) {

					renderTargetProperties.__webglDepthbuffer = [];

					for (var i = 0; i < 6; i++) {

						_gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
						renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
						setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);

					}

				} else {

					_gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);

				}

			}

			_gl.bindFramebuffer(_gl.FRAMEBUFFER, null);

		}

		// Set up GL resources for the render target
		function setupRenderTarget(renderTarget) {

			var renderTargetProperties = properties.get(renderTarget);
			var textureProperties = properties.get(renderTarget.texture);

			renderTarget.addEventListener('dispose', onRenderTargetDispose);

			textureProperties.__webglTexture = _gl.createTexture();

			_infoMemory.textures++;

			var isCube = (renderTarget instanceof THREE.WebGLRenderTargetCube);
			var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);

			// Setup framebuffer

			if (isCube) {

				renderTargetProperties.__webglFramebuffer = [];

				for (var i = 0; i < 6; i++) {

					renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();

				}

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			}

			// Setup color buffer

			if (isCube) {

				state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
				setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);

				for (var i = 0; i < 6; i++) {

					setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);

				}

				if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo) _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
				state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);

			} else {

				state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
				setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);

				if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo) _gl.generateMipmap(_gl.TEXTURE_2D);
				state.bindTexture(_gl.TEXTURE_2D, null);

			}

			// Setup depth and stencil buffers

			if (renderTarget.depthBuffer) {

				setupDepthRenderbuffer(renderTarget);

			}

		}

		function updateRenderTargetMipmap(renderTarget) {

			var texture = renderTarget.texture;

			if (texture.generateMipmaps && isPowerOfTwo(renderTarget) &&
				texture.minFilter !== THREE.NearestFilter &&
				texture.minFilter !== THREE.LinearFilter) {

				var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
				var webglTexture = properties.get(texture).__webglTexture;

				state.bindTexture(target, webglTexture);
				_gl.generateMipmap(target);
				state.bindTexture(target, null);

			}

		}

		this.setTexture2D = setTexture2D;
		this.setTextureCube = setTextureCube;
		this.setTextureCubeDynamic = setTextureCubeDynamic;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;

	};

	// File:src/renderers/webgl/WebGLUniforms.js

	/**
	 *
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [renderer] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'renderer' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (renderer factorizations):
	 *
	 * .upload( gl, seq, values, renderer )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 * .splitDynamic( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with dynamic entry and removes them from 'seq'
	 *
	 *
	 * Methods of the top-level container (renderer factorizations):
	 *
	 * .setValue( gl, name, value )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .set( gl, obj, prop )
	 *
	 * 		sets uniform from object and property with same name than uniform
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 *
	 * @author tschw
	 *
	 */

	THREE.WebGLUniforms = (function () { // scope

		var emptyTexture = new THREE.Texture();
		var emptyCubeTexture = new THREE.CubeTexture();

		// --- Base for inner nodes (including the root) ---

		var UniformContainer = function () {

			this.seq = [];
			this.map = {};

		},

			// --- Utilities ---

			// Array Caches (provide typed arrays for temporary by size)

			arrayCacheF32 = [],
			arrayCacheI32 = [],

			uncacheTemporaryArrays = function () {

				arrayCacheF32.length = 0;
				arrayCacheI32.length = 0;

			},

			// Flattening for arrays of vectors and matrices

			flatten = function (array, nBlocks, blockSize) {

				var firstElem = array[0];

				if (firstElem <= 0 || firstElem > 0) return array;
				// unoptimized: ! isNaN( firstElem )
				// see http://jacksondunstan.com/articles/983

				var n = nBlocks * blockSize,
					r = arrayCacheF32[n];

				if (r === undefined) {

					r = new Float32Array(n);
					arrayCacheF32[n] = r;

				}

				if (nBlocks !== 0) {

					firstElem.toArray(r, 0);

					for (var i = 1, offset = 0; i !== nBlocks; ++i) {

						offset += blockSize;
						array[i].toArray(r, offset);

					}

				}

				return r;

			},

			// Texture unit allocation

			allocTexUnits = function (renderer, n) {

				var r = arrayCacheI32[n];

				if (r === undefined) {

					r = new Int32Array(n);
					arrayCacheI32[n] = r;

				}

				for (var i = 0; i !== n; ++i)
					r[i] = renderer.allocTextureUnit();

				return r;

			},

			// --- Setters ---

			// Note: Defining these methods externally, because they come in a bunch
			// and this way their names minify.

			// Single scalar

			setValue1f = function (gl, v) { gl.uniform1f(this.addr, v); },
			setValue1i = function (gl, v) { gl.uniform1i(this.addr, v); },

			// Single float vector (from flat array or THREE.VectorN)

			setValue2fv = function (gl, v) {

				if (v.x === undefined) gl.uniform2fv(this.addr, v);
				else gl.uniform2f(this.addr, v.x, v.y);

			},

			setValue3fv = function (gl, v) {

				if (v.x !== undefined)
					gl.uniform3f(this.addr, v.x, v.y, v.z);
				else if (v.r !== undefined)
					gl.uniform3f(this.addr, v.r, v.g, v.b);
				else
					gl.uniform3fv(this.addr, v);

			},

			setValue4fv = function (gl, v) {

				if (v.x === undefined) gl.uniform4fv(this.addr, v);
				else gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);

			},

			// Single matrix (from flat array or MatrixN)

			setValue2fm = function (gl, v) {

				gl.uniformMatrix2fv(this.addr, false, v.elements || v);

			},

			setValue3fm = function (gl, v) {

				gl.uniformMatrix3fv(this.addr, false, v.elements || v);

			},

			setValue4fm = function (gl, v) {

				gl.uniformMatrix4fv(this.addr, false, v.elements || v);

			},

			// Single texture (2D / Cube)

			setValueT1 = function (gl, v, renderer) {

				var unit = renderer.allocTextureUnit();
				gl.uniform1i(this.addr, unit);
				renderer.setTexture2D(v || emptyTexture, unit);

			},

			setValueT6 = function (gl, v, renderer) {

				var unit = renderer.allocTextureUnit();
				gl.uniform1i(this.addr, unit);
				renderer.setTextureCube(v || emptyCubeTexture, unit);

			},

			// Integer / Boolean vectors or arrays thereof (always flat arrays)

			setValue2iv = function (gl, v) { gl.uniform2iv(this.addr, v); },
			setValue3iv = function (gl, v) { gl.uniform3iv(this.addr, v); },
			setValue4iv = function (gl, v) { gl.uniform4iv(this.addr, v); },

			// Helper to pick the right setter for the singular case

			getSingularSetter = function (type) {

				switch (type) {

					case 0x1406: return setValue1f; // FLOAT
					case 0x8b50: return setValue2fv; // _VEC2
					case 0x8b51: return setValue3fv; // _VEC3
					case 0x8b52: return setValue4fv; // _VEC4

					case 0x8b5a: return setValue2fm; // _MAT2
					case 0x8b5b: return setValue3fm; // _MAT3
					case 0x8b5c: return setValue4fm; // _MAT4

					case 0x8b5e: return setValueT1; // SAMPLER_2D
					case 0x8b60: return setValueT6; // SAMPLER_CUBE

					case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
					case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
					case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
					case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

				}

			},

			// Array of scalars

			setValue1fv = function (gl, v) { gl.uniform1fv(this.addr, v); },
			setValue1iv = function (gl, v) { gl.uniform1iv(this.addr, v); },

			// Array of vectors (flat or from THREE classes)

			setValueV2a = function (gl, v) {

				gl.uniform2fv(this.addr, flatten(v, this.size, 2));

			},

			setValueV3a = function (gl, v) {

				gl.uniform3fv(this.addr, flatten(v, this.size, 3));

			},

			setValueV4a = function (gl, v) {

				gl.uniform4fv(this.addr, flatten(v, this.size, 4));

			},

			// Array of matrices (flat or from THREE clases)

			setValueM2a = function (gl, v) {

				gl.uniformMatrix2fv(this.addr, false, flatten(v, this.size, 4));

			},

			setValueM3a = function (gl, v) {

				gl.uniformMatrix3fv(this.addr, false, flatten(v, this.size, 9));

			},

			setValueM4a = function (gl, v) {

				gl.uniformMatrix4fv(this.addr, false, flatten(v, this.size, 16));

			},

			// Array of textures (2D / Cube)

			setValueT1a = function (gl, v, renderer) {

				var n = v.length,
					units = allocTexUnits(renderer, n);

				gl.uniform1iv(this.addr, units);

				for (var i = 0; i !== n; ++i) {

					renderer.setTexture2D(v[i] || emptyTexture, units[i]);

				}

			},

			setValueT6a = function (gl, v, renderer) {

				var n = v.length,
					units = allocTexUnits(renderer, n);

				gl.uniform1iv(this.addr, units);

				for (var i = 0; i !== n; ++i) {

					renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);

				}

			},


			// Helper to pick the right setter for a pure (bottom-level) array

			getPureArraySetter = function (type) {

				switch (type) {

					case 0x1406: return setValue1fv; // FLOAT
					case 0x8b50: return setValueV2a; // _VEC2
					case 0x8b51: return setValueV3a; // _VEC3
					case 0x8b52: return setValueV4a; // _VEC4

					case 0x8b5a: return setValueM2a; // _MAT2
					case 0x8b5b: return setValueM3a; // _MAT3
					case 0x8b5c: return setValueM4a; // _MAT4

					case 0x8b5e: return setValueT1a; // SAMPLER_2D
					case 0x8b60: return setValueT6a; // SAMPLER_CUBE

					case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
					case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
					case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
					case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

				}

			},

			// --- Uniform Classes ---

			SingleUniform = function SingleUniform(id, activeInfo, addr) {

				this.id = id;
				this.addr = addr;
				this.setValue = getSingularSetter(activeInfo.type);

				// this.path = activeInfo.name; // DEBUG

			},

			PureArrayUniform = function (id, activeInfo, addr) {

				this.id = id;
				this.addr = addr;
				this.size = activeInfo.size;
				this.setValue = getPureArraySetter(activeInfo.type);

				// this.path = activeInfo.name; // DEBUG

			},

			StructuredUniform = function (id) {

				this.id = id;

				UniformContainer.call(this); // mix-in

			};

		StructuredUniform.prototype.setValue = function (gl, value) {

			// Note: Don't need an extra 'renderer' parameter, since samplers
			// are not allowed in structured uniforms.

			var seq = this.seq;

			for (var i = 0, n = seq.length; i !== n; ++i) {

				var u = seq[i];
				u.setValue(gl, value[u.id]);

			}

		};

		// --- Top-level ---

		// Parser - builds up the property tree from the path strings

		var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g,
			// extracts
			// 	- the identifier (member name or array index)
			//  - followed by an optional right bracket (found when array index)
			//  - followed by an optional left bracket or dot (type of subscript)
			//
			// Note: These portions can be read in a non-overlapping fashion and
			// allow straightforward parsing of the hierarchy that WebGL encodes
			// in the uniform names.

			addUniform = function (container, uniformObject) {

				container.seq.push(uniformObject);
				container.map[uniformObject.id] = uniformObject;

			},

			parseUniform = function (activeInfo, addr, container) {

				var path = activeInfo.name,
					pathLength = path.length;

				// reset RegExp object, because of the early exit of a previous run
				RePathPart.lastIndex = 0;

				for (; ;) {

					var match = RePathPart.exec(path),
						matchEnd = RePathPart.lastIndex,

						id = match[1],
						idIsIndex = match[2] === ']',
						subscript = match[3];

					if (idIsIndex) id = id | 0; // convert to integer

					if (subscript === undefined ||
						subscript === '[' && matchEnd + 2 === pathLength) {
						// bare name or "pure" bottom-level array "[0]" suffix

						addUniform(container, subscript === undefined ?
							new SingleUniform(id, activeInfo, addr) :
							new PureArrayUniform(id, activeInfo, addr));

						break;

					} else {
						// step into inner node / create it in case it doesn't exist

						var map = container.map,
							next = map[id];

						if (next === undefined) {

							next = new StructuredUniform(id);
							addUniform(container, next);

						}

						container = next;

					}

				}

			},

			// Root Container

			WebGLUniforms = function WebGLUniforms(gl, program, renderer) {

				UniformContainer.call(this);

				this.renderer = renderer;

				var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

				for (var i = 0; i !== n; ++i) {

					var info = gl.getActiveUniform(program, i),
						path = info.name,
						addr = gl.getUniformLocation(program, path);

					parseUniform(info, addr, this);

				}

			};


		WebGLUniforms.prototype.setValue = function (gl, name, value) {

			var u = this.map[name];

			if (u !== undefined) u.setValue(gl, value, this.renderer);

		};

		WebGLUniforms.prototype.set = function (gl, object, name) {

			var u = this.map[name];

			if (u !== undefined) u.setValue(gl, object[name], this.renderer);

		};

		WebGLUniforms.prototype.setOptional = function (gl, object, name) {

			var v = object[name];

			if (v !== undefined) this.setValue(gl, name, v);

		};


		// Static interface

		WebGLUniforms.upload = function (gl, seq, values, renderer) {

			for (var i = 0, n = seq.length; i !== n; ++i) {

				var u = seq[i],
					v = values[u.id];

				if (v.needsUpdate !== false) {
					// note: always updating when .needsUpdate is undefined

					u.setValue(gl, v.value, renderer);

				}

			}

		};

		WebGLUniforms.seqWithValue = function (seq, values) {

			var r = [];

			for (var i = 0, n = seq.length; i !== n; ++i) {

				var u = seq[i];
				if (u.id in values) r.push(u);

			}

			return r;

		};

		WebGLUniforms.splitDynamic = function (seq, values) {

			var r = null,
				n = seq.length,
				w = 0;

			for (var i = 0; i !== n; ++i) {

				var u = seq[i],
					v = values[u.id];

				if (v && v.dynamic === true) {

					if (r === null) r = [];
					r.push(u);

				} else {

					// in-place compact 'seq', removing the matches
					if (w < i) seq[w] = u;
					++w;

				}

			}

			if (w < n) seq.length = w;

			return r;

		};

		WebGLUniforms.evalDynamic = function (seq, values, object, camera) {

			for (var i = 0, n = seq.length; i !== n; ++i) {

				var v = values[seq[i].id],
					f = v.onUpdateCallback;

				if (f !== undefined) f.call(v, object, camera);

			}

		};

		return WebGLUniforms;

	})();

	// File:src/renderers/webgl/plugins/LensFlarePlugin.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.LensFlarePlugin = function (renderer, flares) {

		var gl = renderer.context;
		var state = renderer.state;

		var vertexBuffer, elementBuffer;
		var shader, program, attributes, uniforms;

		var tempTexture, occlusionTexture;

		function init() {

			var vertices = new Float32Array([
				- 1, - 1, 0, 0,
				1, - 1, 1, 0,
				1, 1, 1, 1,
				- 1, 1, 0, 1
			]);

			var faces = new Uint16Array([
				0, 1, 2,
				0, 2, 3
			]);

			// buffers

			vertexBuffer = gl.createBuffer();
			elementBuffer = gl.createBuffer();

			gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);

			// textures

			tempTexture = gl.createTexture();
			occlusionTexture = gl.createTexture();

			state.bindTexture(gl.TEXTURE_2D, tempTexture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

			state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

			shader = {

				vertexShader: [

					"uniform lowp int renderType;",

					"uniform vec3 screenPosition;",
					"uniform vec2 scale;",
					"uniform float rotation;",

					"uniform sampler2D occlusionMap;",

					"attribute vec2 position;",
					"attribute vec2 uv;",

					"varying vec2 vUV;",
					"varying float vVisibility;",

					"void main() {",

					"vUV = uv;",

					"vec2 pos = position;",

					"if ( renderType == 2 ) {",

					"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

					"vVisibility =        visibility.r / 9.0;",
					"vVisibility *= 1.0 - visibility.g / 9.0;",
					"vVisibility *=       visibility.b / 9.0;",
					"vVisibility *= 1.0 - visibility.a / 9.0;",

					"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
					"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

					"}",

					"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

					"}"

				].join("\n"),

				fragmentShader: [

					"uniform lowp int renderType;",

					"uniform sampler2D map;",
					"uniform float opacity;",
					"uniform vec3 color;",

					"varying vec2 vUV;",
					"varying float vVisibility;",

					"void main() {",

					// pink square

					"if ( renderType == 0 ) {",

					"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

					// restore

					"} else if ( renderType == 1 ) {",

					"gl_FragColor = texture2D( map, vUV );",

					// flare

					"} else {",

					"vec4 texture = texture2D( map, vUV );",
					"texture.a *= opacity * vVisibility;",
					"gl_FragColor = texture;",
					"gl_FragColor.rgb *= color;",

					"}",

					"}"

				].join("\n")

			};

			program = createProgram(shader);

			attributes = {
				vertex: gl.getAttribLocation(program, "position"),
				uv: gl.getAttribLocation(program, "uv")
			};

			uniforms = {
				renderType: gl.getUniformLocation(program, "renderType"),
				map: gl.getUniformLocation(program, "map"),
				occlusionMap: gl.getUniformLocation(program, "occlusionMap"),
				opacity: gl.getUniformLocation(program, "opacity"),
				color: gl.getUniformLocation(program, "color"),
				scale: gl.getUniformLocation(program, "scale"),
				rotation: gl.getUniformLocation(program, "rotation"),
				screenPosition: gl.getUniformLocation(program, "screenPosition")
			};

		}

		/*
		 * Render lens flares
		 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
		 *         reads these back and calculates occlusion.
		 */

		this.render = function (scene, camera, viewport) {

			if (flares.length === 0) return;

			var tempPosition = new THREE.Vector3();

			var invAspect = viewport.w / viewport.z,
				halfViewportWidth = viewport.z * 0.5,
				halfViewportHeight = viewport.w * 0.5;

			var size = 16 / viewport.w,
				scale = new THREE.Vector2(size * invAspect, size);

			var screenPosition = new THREE.Vector3(1, 1, 0),
				screenPositionPixels = new THREE.Vector2(1, 1);

			var validArea = new THREE.Box2();

			validArea.min.set(0, 0);
			validArea.max.set(viewport.z - 16, viewport.w - 16);

			if (program === undefined) {

				init();

			}

			gl.useProgram(program);

			state.initAttributes();
			state.enableAttribute(attributes.vertex);
			state.enableAttribute(attributes.uv);
			state.disableUnusedAttributes();

			// loop through all lens flares to update their occlusion and positions
			// setup gl and common used attribs/uniforms

			gl.uniform1i(uniforms.occlusionMap, 0);
			gl.uniform1i(uniforms.map, 1);

			gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
			gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
			gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);

			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);

			state.disable(gl.CULL_FACE);
			state.setDepthWrite(false);

			for (var i = 0, l = flares.length; i < l; i++) {

				size = 16 / viewport.w;
				scale.set(size * invAspect, size);

				// calc object screen position

				var flare = flares[i];

				tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);

				tempPosition.applyMatrix4(camera.matrixWorldInverse);
				tempPosition.applyProjection(camera.projectionMatrix);

				// setup arrays for gl programs

				screenPosition.copy(tempPosition);

				// horizontal and vertical coordinate of the lower left corner of the pixels to copy

				screenPositionPixels.x = viewport.x + (screenPosition.x * halfViewportWidth) + halfViewportWidth - 8;
				screenPositionPixels.y = viewport.y + (screenPosition.y * halfViewportHeight) + halfViewportHeight - 8;

				// screen cull

				if (validArea.containsPoint(screenPositionPixels) === true) {

					// save current RGB to temp texture

					state.activeTexture(gl.TEXTURE0);
					state.bindTexture(gl.TEXTURE_2D, null);
					state.activeTexture(gl.TEXTURE1);
					state.bindTexture(gl.TEXTURE_2D, tempTexture);
					gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);


					// render pink quad

					gl.uniform1i(uniforms.renderType, 0);
					gl.uniform2f(uniforms.scale, scale.x, scale.y);
					gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);

					state.disable(gl.BLEND);
					state.enable(gl.DEPTH_TEST);

					gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);


					// copy result to occlusionMap

					state.activeTexture(gl.TEXTURE0);
					state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
					gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);


					// restore graphics

					gl.uniform1i(uniforms.renderType, 1);
					state.disable(gl.DEPTH_TEST);

					state.activeTexture(gl.TEXTURE1);
					state.bindTexture(gl.TEXTURE_2D, tempTexture);
					gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);


					// update object positions

					flare.positionScreen.copy(screenPosition);

					if (flare.customUpdateCallback) {

						flare.customUpdateCallback(flare);

					} else {

						flare.updateLensFlares();

					}

					// render flares

					gl.uniform1i(uniforms.renderType, 2);
					state.enable(gl.BLEND);

					for (var j = 0, jl = flare.lensFlares.length; j < jl; j++) {

						var sprite = flare.lensFlares[j];

						if (sprite.opacity > 0.001 && sprite.scale > 0.001) {

							screenPosition.x = sprite.x;
							screenPosition.y = sprite.y;
							screenPosition.z = sprite.z;

							size = sprite.size * sprite.scale / viewport.w;

							scale.x = size * invAspect;
							scale.y = size;

							gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
							gl.uniform2f(uniforms.scale, scale.x, scale.y);
							gl.uniform1f(uniforms.rotation, sprite.rotation);

							gl.uniform1f(uniforms.opacity, sprite.opacity);
							gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);

							state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
							renderer.setTexture2D(sprite.texture, 1);

							gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);

						}

					}

				}

			}

			// restore gl

			state.enable(gl.CULL_FACE);
			state.enable(gl.DEPTH_TEST);
			state.setDepthWrite(true);

			renderer.resetGLState();

		};

		function createProgram(shader) {

			var program = gl.createProgram();

			var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
			var vertexShader = gl.createShader(gl.VERTEX_SHADER);

			var prefix = "precision " + renderer.getPrecision() + " float;\n";

			gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
			gl.shaderSource(vertexShader, prefix + shader.vertexShader);

			gl.compileShader(fragmentShader);
			gl.compileShader(vertexShader);

			gl.attachShader(program, fragmentShader);
			gl.attachShader(program, vertexShader);

			gl.linkProgram(program);

			return program;

		}

	};

	// File:src/renderers/webgl/plugins/SpritePlugin.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SpritePlugin = function (renderer, sprites) {

		var gl = renderer.context;
		var state = renderer.state;

		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;

		var texture;

		// decompose matrixWorld

		var spritePosition = new THREE.Vector3();
		var spriteRotation = new THREE.Quaternion();
		var spriteScale = new THREE.Vector3();

		function init() {

			var vertices = new Float32Array([
				- 0.5, - 0.5, 0, 0,
				0.5, - 0.5, 1, 0,
				0.5, 0.5, 1, 1,
				- 0.5, 0.5, 0, 1
			]);

			var faces = new Uint16Array([
				0, 1, 2,
				0, 2, 3
			]);

			vertexBuffer = gl.createBuffer();
			elementBuffer = gl.createBuffer();

			gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);

			program = createProgram();

			attributes = {
				position: gl.getAttribLocation(program, 'position'),
				uv: gl.getAttribLocation(program, 'uv')
			};

			uniforms = {
				uvOffset: gl.getUniformLocation(program, 'uvOffset'),
				uvScale: gl.getUniformLocation(program, 'uvScale'),

				rotation: gl.getUniformLocation(program, 'rotation'),
				scale: gl.getUniformLocation(program, 'scale'),

				color: gl.getUniformLocation(program, 'color'),
				map: gl.getUniformLocation(program, 'map'),
				opacity: gl.getUniformLocation(program, 'opacity'),

				modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
				projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),

				fogType: gl.getUniformLocation(program, 'fogType'),
				fogDensity: gl.getUniformLocation(program, 'fogDensity'),
				fogNear: gl.getUniformLocation(program, 'fogNear'),
				fogFar: gl.getUniformLocation(program, 'fogFar'),
				fogColor: gl.getUniformLocation(program, 'fogColor'),

				alphaTest: gl.getUniformLocation(program, 'alphaTest')
			};

			var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
			canvas.width = 8;
			canvas.height = 8;

			var context = canvas.getContext('2d');
			context.fillStyle = 'white';
			context.fillRect(0, 0, 8, 8);

			texture = new THREE.Texture(canvas);
			texture.needsUpdate = true;

		}

		this.render = function (scene, camera) {

			if (sprites.length === 0) return;

			// setup gl

			if (program === undefined) {

				init();

			}

			gl.useProgram(program);

			state.initAttributes();
			state.enableAttribute(attributes.position);
			state.enableAttribute(attributes.uv);
			state.disableUnusedAttributes();

			state.disable(gl.CULL_FACE);
			state.enable(gl.BLEND);

			gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
			gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
			gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);

			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);

			gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);

			state.activeTexture(gl.TEXTURE0);
			gl.uniform1i(uniforms.map, 0);

			var oldFogType = 0;
			var sceneFogType = 0;
			var fog = scene.fog;

			if (fog) {

				gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);

				if (fog instanceof THREE.Fog) {

					gl.uniform1f(uniforms.fogNear, fog.near);
					gl.uniform1f(uniforms.fogFar, fog.far);

					gl.uniform1i(uniforms.fogType, 1);
					oldFogType = 1;
					sceneFogType = 1;

				} else if (fog instanceof THREE.FogExp2) {

					gl.uniform1f(uniforms.fogDensity, fog.density);

					gl.uniform1i(uniforms.fogType, 2);
					oldFogType = 2;
					sceneFogType = 2;

				}

			} else {

				gl.uniform1i(uniforms.fogType, 0);
				oldFogType = 0;
				sceneFogType = 0;

			}


			// update positions and sort

			for (var i = 0, l = sprites.length; i < l; i++) {

				var sprite = sprites[i];

				sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
				sprite.z = - sprite.modelViewMatrix.elements[14];

			}

			sprites.sort(painterSortStable);

			// render all sprites

			var scale = [];

			for (var i = 0, l = sprites.length; i < l; i++) {

				var sprite = sprites[i];
				var material = sprite.material;

				gl.uniform1f(uniforms.alphaTest, material.alphaTest);
				gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);

				sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);

				scale[0] = spriteScale.x;
				scale[1] = spriteScale.y;

				var fogType = 0;

				if (scene.fog && material.fog) {

					fogType = sceneFogType;

				}

				if (oldFogType !== fogType) {

					gl.uniform1i(uniforms.fogType, fogType);
					oldFogType = fogType;

				}

				if (material.map !== null) {

					gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
					gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);

				} else {

					gl.uniform2f(uniforms.uvOffset, 0, 0);
					gl.uniform2f(uniforms.uvScale, 1, 1);

				}

				gl.uniform1f(uniforms.opacity, material.opacity);
				gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);

				gl.uniform1f(uniforms.rotation, material.rotation);
				gl.uniform2fv(uniforms.scale, scale);

				state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
				state.setDepthTest(material.depthTest);
				state.setDepthWrite(material.depthWrite);

				if (material.map) {

					renderer.setTexture2D(material.map, 0);

				} else {

					renderer.setTexture2D(texture, 0);

				}

				gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);

			}

			// restore gl

			state.enable(gl.CULL_FACE);

			renderer.resetGLState();

		};

		function createProgram() {

			var program = gl.createProgram();

			var vertexShader = gl.createShader(gl.VERTEX_SHADER);
			var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

			gl.shaderSource(vertexShader, [

				'precision ' + renderer.getPrecision() + ' float;',

				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform float rotation;',
				'uniform vec2 scale;',
				'uniform vec2 uvOffset;',
				'uniform vec2 uvScale;',

				'attribute vec2 position;',
				'attribute vec2 uv;',

				'varying vec2 vUV;',

				'void main() {',

				'vUV = uvOffset + uv * uvScale;',

				'vec2 alignedPosition = position * scale;',

				'vec2 rotatedPosition;',
				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'vec4 finalPosition;',

				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'finalPosition.xy += rotatedPosition;',
				'finalPosition = projectionMatrix * finalPosition;',

				'gl_Position = finalPosition;',

				'}'

			].join('\n'));

			gl.shaderSource(fragmentShader, [

				'precision ' + renderer.getPrecision() + ' float;',

				'uniform vec3 color;',
				'uniform sampler2D map;',
				'uniform float opacity;',

				'uniform int fogType;',
				'uniform vec3 fogColor;',
				'uniform float fogDensity;',
				'uniform float fogNear;',
				'uniform float fogFar;',
				'uniform float alphaTest;',

				'varying vec2 vUV;',

				'void main() {',

				'vec4 texture = texture2D( map, vUV );',

				'if ( texture.a < alphaTest ) discard;',

				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'if ( fogType > 0 ) {',

				'float depth = gl_FragCoord.z / gl_FragCoord.w;',
				'float fogFactor = 0.0;',

				'if ( fogType == 1 ) {',

				'fogFactor = smoothstep( fogNear, fogFar, depth );',

				'} else {',

				'const float LOG2 = 1.442695;',
				'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
				'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

				'}',

				'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

				'}',

				'}'

			].join('\n'));

			gl.compileShader(vertexShader);
			gl.compileShader(fragmentShader);

			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);

			gl.linkProgram(program);

			return program;

		}

		function painterSortStable(a, b) {

			if (a.renderOrder !== b.renderOrder) {

				return a.renderOrder - b.renderOrder;

			} else if (a.z !== b.z) {

				return b.z - a.z;

			} else {

				return b.id - a.id;

			}

		}

	};

	// File:src/Three.Legacy.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	Object.assign(THREE, {
		Face4: function (a, b, c, d, normal, color, materialIndex) {
			//console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
			return new THREE.Face3(a, b, c, normal, color, materialIndex);
		},
		LineStrip: 0,
		LinePieces: 1,
		MeshFaceMaterial: THREE.MultiMaterial,
		PointCloud: function (geometry, material) {
			//console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
			return new THREE.Points(geometry, material);
		},
		Particle: THREE.Sprite,
		ParticleSystem: function (geometry, material) {
			//console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
			return new THREE.Points(geometry, material);
		},
		PointCloudMaterial: function (parameters) {
			//console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
			return new THREE.PointsMaterial(parameters);
		},
		ParticleBasicMaterial: function (parameters) {
			//console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
			return new THREE.PointsMaterial(parameters);
		},
		ParticleSystemMaterial: function (parameters) {
			//console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
			return new THREE.PointsMaterial(parameters);
		},
		Vertex: function (x, y, z) {
			//console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
			return new THREE.Vector3(x, y, z);
		}
	});

	//

	Object.assign(THREE.Box2.prototype, {
		empty: function () {
			//console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();
		},
		isIntersectionBox: function (box) {
			//console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox(box);
		}
	});

	Object.assign(THREE.Box3.prototype, {
		empty: function () {
			//console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();
		},
		isIntersectionBox: function (box) {
			//console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox(box);
		},
		isIntersectionSphere: function (sphere) {
			//console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere(sphere);
		}
	});

	Object.assign(THREE.Matrix3.prototype, {
		multiplyVector3: function (vector) {
			//console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3(this);
		},
		multiplyVector3Array: function (a) {
			//console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array(a);
		}
	});

	Object.assign(THREE.Matrix4.prototype, {
		extractPosition: function (m) {
			//console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition(m);
		},
		setRotationFromQuaternion: function (q) {
			//console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
			return this.makeRotationFromQuaternion(q);
		},
		multiplyVector3: function (vector) {
			//console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
			return vector.applyProjection(this);
		},
		multiplyVector4: function (vector) {
			//console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4(this);
		},
		multiplyVector3Array: function (a) {
			//console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array(a);
		},
		rotateAxis: function (v) {
			//console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
			v.transformDirection(this);
		},
		crossVector: function (vector) {
			//console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4(this);
		},
		translate: function (v) {
			//console.error( 'THREE.Matrix4: .translate() has been removed.' );
		},
		rotateX: function (angle) {
			//console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
		},
		rotateY: function (angle) {
			//console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
		},
		rotateZ: function (angle) {
			//console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
		},
		rotateByAxis: function (axis, angle) {
			//console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
		}
	});

	Object.assign(THREE.Plane.prototype, {
		isIntersectionLine: function (line) {
			//console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
			return this.intersectsLine(line);
		}
	});

	Object.assign(THREE.Quaternion.prototype, {
		multiplyVector3: function (vector) {
			//console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion(this);
		}
	});

	Object.assign(THREE.Ray.prototype, {
		isIntersectionBox: function (box) {
			//console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox(box);
		},
		isIntersectionPlane: function (plane) {
			//console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
			return this.intersectsPlane(plane);
		},
		isIntersectionSphere: function (sphere) {
			//console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere(sphere);
		}
	});

	Object.assign(THREE.Vector3.prototype, {
		setEulerFromRotationMatrix: function () {
			//console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
		},
		setEulerFromQuaternion: function () {
			//console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
		},
		getPositionFromMatrix: function (m) {
			//console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
			return this.setFromMatrixPosition(m);
		},
		getScaleFromMatrix: function (m) {
			//console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
			return this.setFromMatrixScale(m);
		},
		getColumnFromMatrix: function (index, matrix) {
			//console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
			return this.setFromMatrixColumn(matrix, index);
		}
	});

	//

	Object.assign(THREE.Object3D.prototype, {
		getChildByName: function (name) {
			//console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName(name);
		},
		renderDepth: function (value) {
			//console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
		},
		translate: function (distance, axis) {
			//console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis(axis, distance);
		}
	});

	Object.defineProperties(THREE.Object3D.prototype, {
		eulerOrder: {
			get: function () {
				//console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				return this.rotation.order;
			},
			set: function (value) {
				//console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				this.rotation.order = value;
			}
		},
		useQuaternion: {
			get: function () {
				//console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
			},
			set: function (value) {
				//console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
			}
		}
	});

	Object.defineProperties(THREE.LOD.prototype, {
		objects: {
			get: function () {
				//console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
				return this.levels;
			}
		}
	});

	//

	THREE.PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {

		//console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " + "Use .setFocalLength and .filmGauge for a photographic setup." );

		if (filmGauge !== undefined) this.filmGauge = filmGauge;
		this.setFocalLength(focalLength);

	};

	//

	Object.defineProperties(THREE.Light.prototype, {
		onlyShadow: {
			set: function (value) {
				//console.warn( 'THREE.Light: .onlyShadow has been removed.' );
			}
		},
		shadowCameraFov: {
			set: function (value) {
				//console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
				this.shadow.camera.fov = value;
			}
		},
		shadowCameraLeft: {
			set: function (value) {
				//console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
				this.shadow.camera.left = value;
			}
		},
		shadowCameraRight: {
			set: function (value) {
				//console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
				this.shadow.camera.right = value;
			}
		},
		shadowCameraTop: {
			set: function (value) {
				//console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
				this.shadow.camera.top = value;
			}
		},
		shadowCameraBottom: {
			set: function (value) {
				//console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
				this.shadow.camera.bottom = value;
			}
		},
		shadowCameraNear: {
			set: function (value) {
				//console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
				this.shadow.camera.near = value;
			}
		},
		shadowCameraFar: {
			set: function (value) {
				//console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
				this.shadow.camera.far = value;
			}
		},
		shadowCameraVisible: {
			set: function (value) {
				//console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
			}
		},
		shadowBias: {
			set: function (value) {
				//console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
				this.shadow.bias = value;
			}
		},
		shadowDarkness: {
			set: function (value) {
				//console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
			}
		},
		shadowMapWidth: {
			set: function (value) {
				//console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
				this.shadow.mapSize.width = value;
			}
		},
		shadowMapHeight: {
			set: function (value) {
				//console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
				this.shadow.mapSize.height = value;
			}
		}
	});

	//

	Object.defineProperties(THREE.BufferAttribute.prototype, {
		length: {
			get: function () {
				//console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
				return this.array.length;
			}
		}
	});

	Object.assign(THREE.BufferGeometry.prototype, {
		addIndex: function (index) {
			//console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
			this.setIndex(index);
		},
		addDrawCall: function (start, count, indexOffset) {
			if (indexOffset !== undefined) {
				//console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
			}
			//console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
			this.addGroup(start, count);
		},
		clearDrawCalls: function () {
			//console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
			this.clearGroups();
		},
		computeTangents: function () {
			//console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
		},
		computeOffsets: function () {
			//console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
		}
	});

	Object.defineProperties(THREE.BufferGeometry.prototype, {
		drawcalls: {
			get: function () {
				//console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
				return this.groups;
			}
		},
		offsets: {
			get: function () {
				//console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
				return this.groups;
			}
		}
	});

	//

	Object.defineProperties(THREE.Material.prototype, {
		wrapAround: {
			get: function () {
				//console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
			},
			set: function (value) {
				//console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
			}
		},
		wrapRGB: {
			get: function () {
				//console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
				return new THREE.Color();
			}
		}
	});

	Object.defineProperties(THREE.MeshPhongMaterial.prototype, {
		metal: {
			get: function () {
				//console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
				return false;
			},
			set: function (value) {
				//console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
			}
		}
	});

	Object.defineProperties(THREE.ShaderMaterial.prototype, {
		derivatives: {
			get: function () {
				//console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				return this.extensions.derivatives;
			},
			set: function (value) {
				//console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				this.extensions.derivatives = value;
			}
		}
	});

	//

	THREE.EventDispatcher.prototype = Object.assign(Object.create({

		// Note: Extra base ensures these properties are not 'assign'ed.

		constructor: THREE.EventDispatcher,

		apply: function (target) {

			//console.warn( "THREE.EventDispatcher: .apply is deprecated, " + "just inherit or Object.assign the prototype to mix-in." );

			Object.assign(target, this);

		}

	}), THREE.EventDispatcher.prototype);

	//

	Object.assign(THREE.WebGLRenderer.prototype, {
		supportsFloatTextures: function () {
			//console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
			return this.extensions.get('OES_texture_float');
		},
		supportsHalfFloatTextures: function () {
			////console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
			return this.extensions.get('OES_texture_half_float');
		},
		supportsStandardDerivatives: function () {
			//console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
			return this.extensions.get('OES_standard_derivatives');
		},
		supportsCompressedTextureS3TC: function () {
			//console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
			return this.extensions.get('WEBGL_compressed_texture_s3tc');
		},
		supportsCompressedTexturePVRTC: function () {
			//console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
			return this.extensions.get('WEBGL_compressed_texture_pvrtc');
		},
		supportsBlendMinMax: function () {
			//console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
			return this.extensions.get('EXT_blend_minmax');
		},
		supportsVertexTextures: function () {
			return this.capabilities.vertexTextures;
		},
		supportsInstancedArrays: function () {
			//console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
			return this.extensions.get('ANGLE_instanced_arrays');
		},
		enableScissorTest: function (boolean) {
			//console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
			this.setScissorTest(boolean);
		},
		initMaterial: function () {
			//console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
		},
		addPrePlugin: function () {
			//console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
		},
		addPostPlugin: function () {
			//console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
		},
		updateShadowMap: function () {
			//console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
		}
	});

	Object.defineProperties(THREE.WebGLRenderer.prototype, {
		shadowMapEnabled: {
			get: function () {
				return this.shadowMap.enabled;
			},
			set: function (value) {
				//console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
				this.shadowMap.enabled = value;
			}
		},
		shadowMapType: {
			get: function () {
				return this.shadowMap.type;
			},
			set: function (value) {
				//console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
				this.shadowMap.type = value;
			}
		},
		shadowMapCullFace: {
			get: function () {
				return this.shadowMap.cullFace;
			},
			set: function (value) {
				//console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
				this.shadowMap.cullFace = value;
			}
		}
	});

	Object.defineProperties(THREE.WebGLShadowMap.prototype, {
		cullFace: {
			get: function () {
				return this.renderReverseSided ? THREE.CullFaceFront : THREE.CullFaceBack;
			},
			set: function (cullFace) {
				var value = (cullFace !== THREE.CullFaceBack);
				//console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
				this.renderReverseSided = value;
			}
		}
	});

	//

	Object.defineProperties(THREE.WebGLRenderTarget.prototype, {
		wrapS: {
			get: function () {
				//console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				return this.texture.wrapS;
			},
			set: function (value) {
				//console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				this.texture.wrapS = value;
			}
		},
		wrapT: {
			get: function () {
				//console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				return this.texture.wrapT;
			},
			set: function (value) {
				//console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				this.texture.wrapT = value;
			}
		},
		magFilter: {
			get: function () {
				//console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				return this.texture.magFilter;
			},
			set: function (value) {
				//console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				this.texture.magFilter = value;
			}
		},
		minFilter: {
			get: function () {
				//console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				return this.texture.minFilter;
			},
			set: function (value) {
				//console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				this.texture.minFilter = value;
			}
		},
		anisotropy: {
			get: function () {
				//console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				return this.texture.anisotropy;
			},
			set: function (value) {
				//console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				this.texture.anisotropy = value;
			}
		},
		offset: {
			get: function () {
				//console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				return this.texture.offset;
			},
			set: function (value) {
				//console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				this.texture.offset = value;
			}
		},
		repeat: {
			get: function () {
				//console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				return this.texture.repeat;
			},
			set: function (value) {
				//console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				this.texture.repeat = value;
			}
		},
		format: {
			get: function () {
				//console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				return this.texture.format;
			},
			set: function (value) {
				//console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				this.texture.format = value;
			}
		},
		type: {
			get: function () {
				//console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				return this.texture.type;
			},
			set: function (value) {
				//console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				this.texture.type = value;
			}
		},
		generateMipmaps: {
			get: function () {
				//console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				return this.texture.generateMipmaps;
			},
			set: function (value) {
				//console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				this.texture.generateMipmaps = value;
			}
		}
	});

	//

	Object.assign(THREE.Audio.prototype, {
		load: function (file) {
			//console.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );
			var scope = this;
			var audioLoader = new THREE.AudioLoader();
			audioLoader.load(file, function (buffer) {
				scope.setBuffer(buffer);
			});
			return this;
		}
	});

	Object.assign(THREE.AudioAnalyser.prototype, {
		getData: function (file) {
			//console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
			return this.getFrequencyData();
		}
	});

	//

	THREE.GeometryUtils = {

		merge: function (geometry1, geometry2, materialIndexOffset) {

			//console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

			var matrix;

			if (geometry2 instanceof THREE.Mesh) {

				geometry2.matrixAutoUpdate && geometry2.updateMatrix();

				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;

			}

			geometry1.merge(geometry2, matrix, materialIndexOffset);

		},

		center: function (geometry) {

			//console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();

		}

	};

	THREE.ImageUtils = {

		crossOrigin: undefined,

		loadTexture: function (url, mapping, onLoad, onError) {

			//console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

			var loader = new THREE.TextureLoader();
			loader.setCrossOrigin(this.crossOrigin);

			var texture = loader.load(url, onLoad, undefined, onError);

			if (mapping) texture.mapping = mapping;

			return texture;

		},

		loadTextureCube: function (urls, mapping, onLoad, onError) {

			//console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

			var loader = new THREE.CubeTextureLoader();
			loader.setCrossOrigin(this.crossOrigin);

			var texture = loader.load(urls, onLoad, undefined, onError);

			if (mapping) texture.mapping = mapping;

			return texture;

		},

		loadCompressedTexture: function () {

			//console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

		},

		loadCompressedTextureCube: function () {

			//console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

		}

	};

	//

	THREE.Projector = function () {

		//console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

		this.projectVector = function (vector, camera) {

			//console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project(camera);

		};

		this.unprojectVector = function (vector, camera) {

			//console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject(camera);

		};

		this.pickingRay = function (vector, camera) {

			//console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

		};

	};

	//

	THREE.CanvasRenderer = function () {

		//console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

		this.domElement = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
		this.clear = function () { };
		this.render = function () { };
		this.setClearColor = function () { };
		this.setSize = function () { };

	};

	// File:src/extras/CurveUtils.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	THREE.CurveUtils = {

		tangentQuadraticBezier: function (t, p0, p1, p2) {

			return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);

		},

		// Puay Bing, thanks for helping with this derivative!

		tangentCubicBezier: function (t, p0, p1, p2, p3) {

			return - 3 * p0 * (1 - t) * (1 - t) +
				3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +
				6 * t * p2 * (1 - t) - 3 * t * t * p2 +
				3 * t * t * p3;

		},

		tangentSpline: function (t, p0, p1, p2, p3) {

			// To check if my formulas are correct

			var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3  3t^2 + 1
			var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
			var h01 = - 6 * t * t + 6 * t; 	//  2t3 + 3t2
			var h11 = 3 * t * t - 2 * t;	// t3  t2

			return h00 + h10 + h01 + h11;

		},

		// Catmull-Rom

		interpolate: function (p0, p1, p2, p3, t) {

			var v0 = (p2 - p0) * 0.5;
			var v1 = (p3 - p1) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;

		}

	};

	// File:src/extras/SceneUtils.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SceneUtils = {

		createMultiMaterialObject: function (geometry, materials) {

			var group = new THREE.Group();

			for (var i = 0, l = materials.length; i < l; i++) {

				group.add(new THREE.Mesh(geometry, materials[i]));

			}

			return group;

		},

		detach: function (child, parent, scene) {

			child.applyMatrix(parent.matrixWorld);
			parent.remove(child);
			scene.add(child);

		},

		attach: function (child, scene, parent) {

			var matrixWorldInverse = new THREE.Matrix4();
			matrixWorldInverse.getInverse(parent.matrixWorld);
			child.applyMatrix(matrixWorldInverse);

			scene.remove(child);
			parent.add(child);

		}

	};

	// File:src/extras/ShapeUtils.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	THREE.ShapeUtils = {

		// calculate area of the contour polygon

		area: function (contour) {

			var n = contour.length;
			var a = 0.0;

			for (var p = n - 1, q = 0; q < n; p = q++) {

				a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;

			}

			return a * 0.5;

		},

		triangulate: (function () {

			/**
			 * This code is a quick port of code written in C++ which was submitted to
			 * flipcode.com by John W. Ratcliff  // July 22, 2000
			 * See original code and more information here:
			 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
			 *
			 * ported to actionscript by Zevan Rosser
			 * www.actionsnippet.com
			 *
			 * ported to javascript by Joshua Koo
			 * http://www.lab4games.net/zz85/blog
			 *
			 */

			function snip(contour, u, v, w, n, verts) {

				var p;
				var ax, ay, bx, by;
				var cx, cy, px, py;

				ax = contour[verts[u]].x;
				ay = contour[verts[u]].y;

				bx = contour[verts[v]].x;
				by = contour[verts[v]].y;

				cx = contour[verts[w]].x;
				cy = contour[verts[w]].y;

				if (Number.EPSILON > (((bx - ax) * (cy - ay)) - ((by - ay) * (cx - ax)))) return false;

				var aX, aY, bX, bY, cX, cY;
				var apx, apy, bpx, bpy, cpx, cpy;
				var cCROSSap, bCROSScp, aCROSSbp;

				aX = cx - bx; aY = cy - by;
				bX = ax - cx; bY = ay - cy;
				cX = bx - ax; cY = by - ay;

				for (p = 0; p < n; p++) {

					px = contour[verts[p]].x;
					py = contour[verts[p]].y;

					if (((px === ax) && (py === ay)) ||
						((px === bx) && (py === by)) ||
						((px === cx) && (py === cy))) continue;

					apx = px - ax; apy = py - ay;
					bpx = px - bx; bpy = py - by;
					cpx = px - cx; cpy = py - cy;

					// see if p is inside triangle abc

					aCROSSbp = aX * bpy - aY * bpx;
					cCROSSap = cX * apy - cY * apx;
					bCROSScp = bX * cpy - bY * cpx;

					if ((aCROSSbp >= - Number.EPSILON) && (bCROSScp >= - Number.EPSILON) && (cCROSSap >= - Number.EPSILON)) return false;

				}

				return true;

			}

			// takes in an contour array and returns

			return function triangulate(contour, indices) {

				var n = contour.length;

				if (n < 3) return null;

				var result = [],
					verts = [],
					vertIndices = [];

				/* we want a counter-clockwise polygon in verts */

				var u, v, w;

				if (THREE.ShapeUtils.area(contour) > 0.0) {

					for (v = 0; v < n; v++) verts[v] = v;

				} else {

					for (v = 0; v < n; v++) verts[v] = (n - 1) - v;

				}

				var nv = n;

				/*  remove nv - 2 vertices, creating 1 triangle every time */

				var count = 2 * nv;   /* error detection */

				for (v = nv - 1; nv > 2;) {

					/* if we loop, it is probably a non-simple polygon */

					if ((count--) <= 0) {

						//** Triangulate: ERROR - probable bad polygon!

						//throw ( "Warning, unable to triangulate polygon!" );
						//return null;
						// Sometimes warning is fine, especially polygons are triangulated in reverse.
						//console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

						if (indices) return vertIndices;
						return result;

					}

					/* three consecutive vertices in current polygon, <u,v,w> */

					u = v; if (nv <= u) u = 0;     /* previous */
					v = u + 1; if (nv <= v) v = 0;     /* new v    */
					w = v + 1; if (nv <= w) w = 0;     /* next     */

					if (snip(contour, u, v, w, nv, verts)) {

						var a, b, c, s, t;

						/* true names of the vertices */

						a = verts[u];
						b = verts[v];
						c = verts[w];

						/* output Triangle */

						result.push([contour[a],
						contour[b],
						contour[c]]);


						vertIndices.push([verts[u], verts[v], verts[w]]);

						/* remove v from the remaining polygon */

						for (s = v, t = v + 1; t < nv; s++, t++) {

							verts[s] = verts[t];

						}

						nv--;

						/* reset error detection counter */

						count = 2 * nv;

					}

				}

				if (indices) return vertIndices;
				return result;

			}

		})(),

		triangulateShape: function (contour, holes) {

			function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {

				// inOtherPt needs to be collinear to the inSegment
				if (inSegPt1.x !== inSegPt2.x) {

					if (inSegPt1.x < inSegPt2.x) {

						return ((inSegPt1.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt2.x));

					} else {

						return ((inSegPt2.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt1.x));

					}

				} else {

					if (inSegPt1.y < inSegPt2.y) {

						return ((inSegPt1.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt2.y));

					} else {

						return ((inSegPt2.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt1.y));

					}

				}

			}

			function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {

				var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x, seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
				var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x, seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

				var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
				var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

				var limit = seg1dy * seg2dx - seg1dx * seg2dy;
				var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

				if (Math.abs(limit) > Number.EPSILON) {

					// not parallel

					var perpSeg2;
					if (limit > 0) {

						if ((perpSeg1 < 0) || (perpSeg1 > limit)) return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ((perpSeg2 < 0) || (perpSeg2 > limit)) return [];

					} else {

						if ((perpSeg1 > 0) || (perpSeg1 < limit)) return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ((perpSeg2 > 0) || (perpSeg2 < limit)) return [];

					}

					// i.e. to reduce rounding errors
					// intersection at endpoint of segment#1?
					if (perpSeg2 === 0) {

						if ((inExcludeAdjacentSegs) &&
							((perpSeg1 === 0) || (perpSeg1 === limit))) return [];
						return [inSeg1Pt1];

					}
					if (perpSeg2 === limit) {

						if ((inExcludeAdjacentSegs) &&
							((perpSeg1 === 0) || (perpSeg1 === limit))) return [];
						return [inSeg1Pt2];

					}
					// intersection at endpoint of segment#2?
					if (perpSeg1 === 0) return [inSeg2Pt1];
					if (perpSeg1 === limit) return [inSeg2Pt2];

					// return real intersection point
					var factorSeg1 = perpSeg2 / limit;
					return [{
						x: inSeg1Pt1.x + factorSeg1 * seg1dx,
						y: inSeg1Pt1.y + factorSeg1 * seg1dy
					}];

				} else {

					// parallel or collinear
					if ((perpSeg1 !== 0) ||
						(seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy)) return [];

					// they are collinear or degenerate
					var seg1Pt = ((seg1dx === 0) && (seg1dy === 0));	// segment1 is just a point?
					var seg2Pt = ((seg2dx === 0) && (seg2dy === 0));	// segment2 is just a point?
					// both segments are points
					if (seg1Pt && seg2Pt) {

						if ((inSeg1Pt1.x !== inSeg2Pt1.x) ||
							(inSeg1Pt1.y !== inSeg2Pt1.y)) return [];	// they are distinct  points
						return [inSeg1Pt1];                 						// they are the same point

					}
					// segment#1  is a single point
					if (seg1Pt) {

						if (!point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1)) return [];		// but not in segment#2
						return [inSeg1Pt1];

					}
					// segment#2  is a single point
					if (seg2Pt) {

						if (!point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1)) return [];		// but not in segment#1
						return [inSeg2Pt1];

					}

					// they are collinear segments, which might overlap
					var seg1min, seg1max, seg1minVal, seg1maxVal;
					var seg2min, seg2max, seg2minVal, seg2maxVal;
					if (seg1dx !== 0) {

						// the segments are NOT on a vertical line
						if (inSeg1Pt1.x < inSeg1Pt2.x) {

							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

						} else {

							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

						}
						if (inSeg2Pt1.x < inSeg2Pt2.x) {

							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

						} else {

							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

						}

					} else {

						// the segments are on a vertical line
						if (inSeg1Pt1.y < inSeg1Pt2.y) {

							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

						} else {

							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

						}
						if (inSeg2Pt1.y < inSeg2Pt2.y) {

							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

						} else {

							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

						}

					}
					if (seg1minVal <= seg2minVal) {

						if (seg1maxVal < seg2minVal) return [];
						if (seg1maxVal === seg2minVal) {

							if (inExcludeAdjacentSegs) return [];
							return [seg2min];

						}
						if (seg1maxVal <= seg2maxVal) return [seg2min, seg1max];
						return [seg2min, seg2max];

					} else {

						if (seg1minVal > seg2maxVal) return [];
						if (seg1minVal === seg2maxVal) {

							if (inExcludeAdjacentSegs) return [];
							return [seg1min];

						}
						if (seg1maxVal <= seg2maxVal) return [seg1min, seg1max];
						return [seg1min, seg2max];

					}

				}

			}

			function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {

				// The order of legs is important

				// translation of all points, so that Vertex is at (0,0)
				var legFromPtX = inLegFromPt.x - inVertex.x, legFromPtY = inLegFromPt.y - inVertex.y;
				var legToPtX = inLegToPt.x - inVertex.x, legToPtY = inLegToPt.y - inVertex.y;
				var otherPtX = inOtherPt.x - inVertex.x, otherPtY = inOtherPt.y - inVertex.y;

				// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
				var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
				var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;

				if (Math.abs(from2toAngle) > Number.EPSILON) {

					// angle != 180 deg.

					var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
					// //console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

					if (from2toAngle > 0) {

						// main angle < 180 deg.
						return ((from2otherAngle >= 0) && (other2toAngle >= 0));

					} else {

						// main angle > 180 deg.
						return ((from2otherAngle >= 0) || (other2toAngle >= 0));

					}

				} else {

					// angle == 180 deg.
					// //console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
					return (from2otherAngle > 0);

				}

			}


			function removeHoles(contour, holes) {

				var shape = contour.concat(); // work on this shape
				var hole;

				function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {

					// Check if hole point lies within angle around shape point
					var lastShapeIdx = shape.length - 1;

					var prevShapeIdx = inShapeIdx - 1;
					if (prevShapeIdx < 0) prevShapeIdx = lastShapeIdx;

					var nextShapeIdx = inShapeIdx + 1;
					if (nextShapeIdx > lastShapeIdx) nextShapeIdx = 0;

					var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
					if (!insideAngle) {

						// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
						return false;

					}

					// Check if shape point lies within angle around hole point
					var lastHoleIdx = hole.length - 1;

					var prevHoleIdx = inHoleIdx - 1;
					if (prevHoleIdx < 0) prevHoleIdx = lastHoleIdx;

					var nextHoleIdx = inHoleIdx + 1;
					if (nextHoleIdx > lastHoleIdx) nextHoleIdx = 0;

					insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]);
					if (!insideAngle) {

						// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
						return false;

					}

					return true;

				}

				function intersectsShapeEdge(inShapePt, inHolePt) {

					// checks for intersections with shape edges
					var sIdx, nextIdx, intersection;
					for (sIdx = 0; sIdx < shape.length; sIdx++) {

						nextIdx = sIdx + 1; nextIdx %= shape.length;
						intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true);
						if (intersection.length > 0) return true;

					}

					return false;

				}

				var indepHoles = [];

				function intersectsHoleEdge(inShapePt, inHolePt) {

					// checks for intersections with hole edges
					var ihIdx, chkHole,
						hIdx, nextIdx, intersection;
					for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) {

						chkHole = holes[indepHoles[ihIdx]];
						for (hIdx = 0; hIdx < chkHole.length; hIdx++) {

							nextIdx = hIdx + 1; nextIdx %= chkHole.length;
							intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true);
							if (intersection.length > 0) return true;

						}

					}
					return false;

				}

				var holeIndex, shapeIndex,
					shapePt, holePt,
					holeIdx, cutKey, failedCuts = [],
					tmpShape1, tmpShape2,
					tmpHole1, tmpHole2;

				for (var h = 0, hl = holes.length; h < hl; h++) {

					indepHoles.push(h);

				}

				var minShapeIndex = 0;
				var counter = indepHoles.length * 2;
				while (indepHoles.length > 0) {

					counter--;
					if (counter < 0) {

						//console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
						break;

					}

					// search for shape-vertex and hole-vertex,
					// which can be connected without intersections
					for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {

						shapePt = shape[shapeIndex];
						holeIndex = - 1;

						// search for hole which can be reached without intersections
						for (var h = 0; h < indepHoles.length; h++) {

							holeIdx = indepHoles[h];

							// prevent multiple checks
							cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
							if (failedCuts[cutKey] !== undefined) continue;

							hole = holes[holeIdx];
							for (var h2 = 0; h2 < hole.length; h2++) {

								holePt = hole[h2];
								if (!isCutLineInsideAngles(shapeIndex, h2)) continue;
								if (intersectsShapeEdge(shapePt, holePt)) continue;
								if (intersectsHoleEdge(shapePt, holePt)) continue;

								holeIndex = h2;
								indepHoles.splice(h, 1);

								tmpShape1 = shape.slice(0, shapeIndex + 1);
								tmpShape2 = shape.slice(shapeIndex);
								tmpHole1 = hole.slice(holeIndex);
								tmpHole2 = hole.slice(0, holeIndex + 1);

								shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);

								minShapeIndex = shapeIndex;

								// Debug only, to show the selected cuts
								// glob_CutLines.push( [ shapePt, holePt ] );

								break;

							}
							if (holeIndex >= 0) break;		// hole-vertex found

							failedCuts[cutKey] = true;			// remember failure

						}
						if (holeIndex >= 0) break;		// hole-vertex found

					}

				}

				return shape; 			/* shape with no holes */

			}


			var i, il, f, face,
				key, index,
				allPointsMap = {};

			// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

			var allpoints = contour.concat();

			for (var h = 0, hl = holes.length; h < hl; h++) {

				Array.prototype.push.apply(allpoints, holes[h]);

			}

			//console.log( "allpoints",allpoints, allpoints.length );

			// prepare all points map

			for (i = 0, il = allpoints.length; i < il; i++) {

				key = allpoints[i].x + ":" + allpoints[i].y;

				if (allPointsMap[key] !== undefined) {

					//console.warn( "THREE.Shape: Duplicate point", key );

				}

				allPointsMap[key] = i;

			}

			// remove holes by cutting paths to holes and adding them to the shape
			var shapeWithoutHoles = removeHoles(contour, holes);

			var triangles = THREE.ShapeUtils.triangulate(shapeWithoutHoles, false); // True returns indices for points of spooled shape
			//console.log( "triangles",triangles, triangles.length );

			// check all face vertices against all points map

			for (i = 0, il = triangles.length; i < il; i++) {

				face = triangles[i];

				for (f = 0; f < 3; f++) {

					key = face[f].x + ":" + face[f].y;

					index = allPointsMap[key];

					if (index !== undefined) {

						face[f] = index;

					}

				}

			}

			return triangles.concat();

		},

		isClockWise: function (pts) {

			return THREE.ShapeUtils.area(pts) < 0;

		},

		// Bezier Curves formulas obtained from
		// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

		// Quad Bezier Functions

		b2: (function () {

			function b2p0(t, p) {

				var k = 1 - t;
				return k * k * p;

			}

			function b2p1(t, p) {

				return 2 * (1 - t) * t * p;

			}

			function b2p2(t, p) {

				return t * t * p;

			}

			return function b2(t, p0, p1, p2) {

				return b2p0(t, p0) + b2p1(t, p1) + b2p2(t, p2);

			};

		})(),

		// Cubic Bezier Functions

		b3: (function () {

			function b3p0(t, p) {

				var k = 1 - t;
				return k * k * k * p;

			}

			function b3p1(t, p) {

				var k = 1 - t;
				return 3 * k * k * t * p;

			}

			function b3p2(t, p) {

				var k = 1 - t;
				return 3 * k * t * t * p;

			}

			function b3p3(t, p) {

				return t * t * t * p;

			}

			return function b3(t, p0, p1, p2, p3) {

				return b3p0(t, p0) + b3p1(t, p1) + b3p2(t, p2) + b3p3(t, p3);

			};

		})()

	};

	// File:src/extras/core/Curve.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of Curve methods
	 * .getPoint(t), getTangent(t)
	 * .getPointAt(u), getTagentAt(u)
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following classes subclasses THREE.Curve:
	 *
	 * -- 2d classes --
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.CubicBezierCurve
	 * THREE.SplineCurve
	 * THREE.ArcCurve
	 * THREE.EllipseCurve
	 *
	 * -- 3d classes --
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.SplineCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath
	 *
	 **/

	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/

	THREE.Curve = function () {

	};

	THREE.Curve.prototype = {

		constructor: THREE.Curve,

		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]

		getPoint: function (t) {

			//console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
			return null;

		},

		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]

		getPointAt: function (u) {

			var t = this.getUtoTmapping(u);
			return this.getPoint(t);

		},

		// Get sequence of points using getPoint( t )

		getPoints: function (divisions) {

			if (!divisions) divisions = 5;

			var d, pts = [];

			for (d = 0; d <= divisions; d++) {

				pts.push(this.getPoint(d / divisions));

			}

			return pts;

		},

		// Get sequence of points using getPointAt( u )

		getSpacedPoints: function (divisions) {

			if (!divisions) divisions = 5;

			var d, pts = [];

			for (d = 0; d <= divisions; d++) {

				pts.push(this.getPointAt(d / divisions));

			}

			return pts;

		},

		// Get total curve arc length

		getLength: function () {

			var lengths = this.getLengths();
			return lengths[lengths.length - 1];

		},

		// Get list of cumulative segment lengths

		getLengths: function (divisions) {

			if (!divisions) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;

			if (this.cacheArcLengths
				&& (this.cacheArcLengths.length === divisions + 1)
				&& !this.needsUpdate) {

				//console.log( "cached", this.cacheArcLengths );
				return this.cacheArcLengths;

			}

			this.needsUpdate = false;

			var cache = [];
			var current, last = this.getPoint(0);
			var p, sum = 0;

			cache.push(0);

			for (p = 1; p <= divisions; p++) {

				current = this.getPoint(p / divisions);
				sum += current.distanceTo(last);
				cache.push(sum);
				last = current;

			}

			this.cacheArcLengths = cache;

			return cache; // { sums: cache, sum:sum }; Sum is in the last element.

		},

		updateArcLengths: function () {

			this.needsUpdate = true;
			this.getLengths();

		},

		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

		getUtoTmapping: function (u, distance) {

			var arcLengths = this.getLengths();

			var i = 0, il = arcLengths.length;

			var targetArcLength; // The targeted u distance value to get

			if (distance) {

				targetArcLength = distance;

			} else {

				targetArcLength = u * arcLengths[il - 1];

			}

			//var time = Date.now();

			// binary search for the index with largest value smaller than target u distance

			var low = 0, high = il - 1, comparison;

			while (low <= high) {

				i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[i] - targetArcLength;

				if (comparison < 0) {

					low = i + 1;

				} else if (comparison > 0) {

					high = i - 1;

				} else {

					high = i;
					break;

					// DONE

				}

			}

			i = high;

			//console.log('b' , i, low, high, Date.now()- time);

			if (arcLengths[i] === targetArcLength) {

				var t = i / (il - 1);
				return t;

			}

			// we could get finer grain at lengths, or use simple interpolation between two points

			var lengthBefore = arcLengths[i];
			var lengthAfter = arcLengths[i + 1];

			var segmentLength = lengthAfter - lengthBefore;

			// determine where we are between the 'before' and 'after' points

			var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;

			// add that fractional amount to t

			var t = (i + segmentFraction) / (il - 1);

			return t;

		},

		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation

		getTangent: function (t) {

			var delta = 0.0001;
			var t1 = t - delta;
			var t2 = t + delta;

			// Capping in case of danger

			if (t1 < 0) t1 = 0;
			if (t2 > 1) t2 = 1;

			var pt1 = this.getPoint(t1);
			var pt2 = this.getPoint(t2);

			var vec = pt2.clone().sub(pt1);
			return vec.normalize();

		},

		getTangentAt: function (u) {

			var t = this.getUtoTmapping(u);
			return this.getTangent(t);

		}

	};

	// TODO: Transformation for Curves?

	/**************************************************************
	 *	3D Curves
	 **************************************************************/

	// A Factory method for creating new curve subclasses

	THREE.Curve.create = function (constructor, getPointFunc) {

		constructor.prototype = Object.create(THREE.Curve.prototype);
		constructor.prototype.constructor = constructor;
		constructor.prototype.getPoint = getPointFunc;

		return constructor;

	};

	// File:src/extras/core/CurvePath.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	THREE.CurvePath = function () {

		this.curves = [];

		this.autoClose = false; // Automatically closes the path

	};

	THREE.CurvePath.prototype = Object.assign(Object.create(THREE.Curve.prototype), {

		constructor: THREE.CurvePath,

		add: function (curve) {

			this.curves.push(curve);

		},

		closePath: function () {

			// TODO Test
			// and verify for vector3 (needs to implement equals)
			// Add a line curve if start and end of lines are not connected
			var startPoint = this.curves[0].getPoint(0);
			var endPoint = this.curves[this.curves.length - 1].getPoint(1);

			if (!startPoint.equals(endPoint)) {

				this.curves.push(new THREE.LineCurve(endPoint, startPoint));

			}

		},

		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:

		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')

		getPoint: function (t) {

			var d = t * this.getLength();
			var curveLengths = this.getCurveLengths();
			var i = 0;

			// To think about boundaries points.

			while (i < curveLengths.length) {

				if (curveLengths[i] >= d) {

					var diff = curveLengths[i] - d;
					var curve = this.curves[i];

					var u = 1 - diff / curve.getLength();

					return curve.getPointAt(u);

				}

				i++;

			}

			return null;

			// loop where sum != 0, sum > d , sum+1 <d

		},

		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength

		getLength: function () {

			var lens = this.getCurveLengths();
			return lens[lens.length - 1];

		},

		// cacheLengths must be recalculated.
		updateArcLengths: function () {

			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getLengths();

		},

		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.

		getCurveLengths: function () {

			// We use cache values if curves and cache array are same length

			if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {

				return this.cacheLengths;

			}

			// Get length of sub-curve
			// Push sums into cached array

			var lengths = [], sums = 0;

			for (var i = 0, l = this.curves.length; i < l; i++) {

				sums += this.curves[i].getLength();
				lengths.push(sums);

			}

			this.cacheLengths = lengths;

			return lengths;

		},

		/**************************************************************
		 *	Create Geometries Helpers
		 **************************************************************/

		/// Generate geometry from path points (for Line or Points objects)

		createPointsGeometry: function (divisions) {

			var pts = this.getPoints(divisions);
			return this.createGeometry(pts);

		},

		// Generate geometry from equidistant sampling along the path

		createSpacedPointsGeometry: function (divisions) {

			var pts = this.getSpacedPoints(divisions);
			return this.createGeometry(pts);

		},

		createGeometry: function (points) {

			var geometry = new THREE.Geometry();

			for (var i = 0, l = points.length; i < l; i++) {

				var point = points[i];
				geometry.vertices.push(new THREE.Vector3(point.x, point.y, point.z || 0));

			}

			return geometry;

		}

	});

	// File:src/extras/core/Font.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Font = function (data) {

		this.data = data;

	};

	Object.assign(THREE.Font.prototype, {

		generateShapes: function (text, size, divisions) {

			function createPaths(text) {

				var chars = String(text).split('');
				var scale = size / data.resolution;
				var offset = 0;

				var paths = [];

				for (var i = 0; i < chars.length; i++) {

					var ret = createPath(chars[i], scale, offset);
					offset += ret.offset;

					paths.push(ret.path);

				}

				return paths;

			}

			function createPath(c, scale, offset) {

				var glyph = data.glyphs[c] || data.glyphs['?'];

				if (!glyph) return;

				var path = new THREE.Path();

				var pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;
				var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

				if (glyph.o) {

					var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

					for (var i = 0, l = outline.length; i < l;) {

						var action = outline[i++];

						switch (action) {

							case 'm': // moveTo

								x = outline[i++] * scale + offset;
								y = outline[i++] * scale;

								path.moveTo(x, y);

								break;

							case 'l': // lineTo

								x = outline[i++] * scale + offset;
								y = outline[i++] * scale;

								path.lineTo(x, y);

								break;

							case 'q': // quadraticCurveTo

								cpx = outline[i++] * scale + offset;
								cpy = outline[i++] * scale;
								cpx1 = outline[i++] * scale + offset;
								cpy1 = outline[i++] * scale;

								path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);

								laste = pts[pts.length - 1];

								if (laste) {

									cpx0 = laste.x;
									cpy0 = laste.y;

									for (var i2 = 1; i2 <= divisions; i2++) {

										var t = i2 / divisions;
										b2(t, cpx0, cpx1, cpx);
										b2(t, cpy0, cpy1, cpy);

									}

								}

								break;

							case 'b': // bezierCurveTo

								cpx = outline[i++] * scale + offset;
								cpy = outline[i++] * scale;
								cpx1 = outline[i++] * scale + offset;
								cpy1 = outline[i++] * scale;
								cpx2 = outline[i++] * scale + offset;
								cpy2 = outline[i++] * scale;

								path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);

								laste = pts[pts.length - 1];

								if (laste) {

									cpx0 = laste.x;
									cpy0 = laste.y;

									for (var i2 = 1; i2 <= divisions; i2++) {

										var t = i2 / divisions;
										b3(t, cpx0, cpx1, cpx2, cpx);
										b3(t, cpy0, cpy1, cpy2, cpy);

									}

								}

								break;

						}

					}

				}

				return { offset: glyph.ha * scale, path: path };

			}

			//

			if (size === undefined) size = 100;
			if (divisions === undefined) divisions = 4;

			var data = this.data;

			var paths = createPaths(text);
			var shapes = [];

			for (var p = 0, pl = paths.length; p < pl; p++) {

				Array.prototype.push.apply(shapes, paths[p].toShapes());

			}

			return shapes;

		}

	});

	// File:src/extras/core/Path.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 *
	 **/

	THREE.Path = function (points) {

		THREE.CurvePath.call(this);

		this.actions = [];

		if (points) {

			this.fromPoints(points);

		}

	};

	THREE.Path.prototype = Object.assign(Object.create(THREE.CurvePath.prototype), {

		constructor: THREE.Path,

		// TODO Clean up PATH API

		// Create path using straight lines to connect all points
		// - vectors: array of Vector2

		fromPoints: function (vectors) {

			this.moveTo(vectors[0].x, vectors[0].y);

			for (var i = 1, l = vectors.length; i < l; i++) {

				this.lineTo(vectors[i].x, vectors[i].y);

			}

		},

		moveTo: function (x, y) {

			this.actions.push({ action: 'moveTo', args: [x, y] });

		},

		lineTo: function (x, y) {

			var lastargs = this.actions[this.actions.length - 1].args;

			var x0 = lastargs[lastargs.length - 2];
			var y0 = lastargs[lastargs.length - 1];

			var curve = new THREE.LineCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(x, y));
			this.curves.push(curve);

			this.actions.push({ action: 'lineTo', args: [x, y] });

		},

		quadraticCurveTo: function (aCPx, aCPy, aX, aY) {

			var lastargs = this.actions[this.actions.length - 1].args;

			var x0 = lastargs[lastargs.length - 2];
			var y0 = lastargs[lastargs.length - 1];

			var curve = new THREE.QuadraticBezierCurve(
				new THREE.Vector2(x0, y0),
				new THREE.Vector2(aCPx, aCPy),
				new THREE.Vector2(aX, aY)
			);

			this.curves.push(curve);

			this.actions.push({ action: 'quadraticCurveTo', args: [aCPx, aCPy, aX, aY] });

		},

		bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {

			var lastargs = this.actions[this.actions.length - 1].args;

			var x0 = lastargs[lastargs.length - 2];
			var y0 = lastargs[lastargs.length - 1];

			var curve = new THREE.CubicBezierCurve(
				new THREE.Vector2(x0, y0),
				new THREE.Vector2(aCP1x, aCP1y),
				new THREE.Vector2(aCP2x, aCP2y),
				new THREE.Vector2(aX, aY)
			);

			this.curves.push(curve);

			this.actions.push({ action: 'bezierCurveTo', args: [aCP1x, aCP1y, aCP2x, aCP2y, aX, aY] });

		},

		splineThru: function (pts /*Array of Vector*/) {

			var args = Array.prototype.slice.call(arguments);

			var lastargs = this.actions[this.actions.length - 1].args;

			var x0 = lastargs[lastargs.length - 2];
			var y0 = lastargs[lastargs.length - 1];

			var npts = [new THREE.Vector2(x0, y0)];
			Array.prototype.push.apply(npts, pts);

			var curve = new THREE.SplineCurve(npts);
			this.curves.push(curve);

			var lastPoint = pts[pts.length - 1];
			args.push(lastPoint.x);
			args.push(lastPoint.y);

			this.actions.push({ action: 'splineThru', args: args });

		},

		arc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {

			var lastargs = this.actions[this.actions.length - 1].args;
			var x0 = lastargs[lastargs.length - 2];
			var y0 = lastargs[lastargs.length - 1];

			this.absarc(aX + x0, aY + y0, aRadius,
				aStartAngle, aEndAngle, aClockwise);

		},

		absarc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {

			this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);

		},

		ellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {

			var lastargs = this.actions[this.actions.length - 1].args;
			var x0 = lastargs[lastargs.length - 2];
			var y0 = lastargs[lastargs.length - 1];

			this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

		},

		absellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {

			var args = [
				aX, aY,
				xRadius, yRadius,
				aStartAngle, aEndAngle,
				aClockwise,
				aRotation || 0 // aRotation is optional.
			];

			var curve = new THREE.EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
			this.curves.push(curve);

			var lastPoint = curve.getPoint(1);
			args.push(lastPoint.x);
			args.push(lastPoint.y);

			this.actions.push({ action: 'ellipse', args: args });

		},

		getSpacedPoints: function (divisions) {

			if (!divisions) divisions = 40;

			var points = [];

			for (var i = 0; i < divisions; i++) {

				points.push(this.getPoint(i / divisions));

				//if ( !this.getPoint( i / divisions ) ) throw "DIE";

			}

			if (this.autoClose) {

				points.push(points[0]);

			}

			return points;

		},

		getPoints: function (divisions) {

			divisions = divisions || 12;

			var b2 = THREE.ShapeUtils.b2;
			var b3 = THREE.ShapeUtils.b3;

			var points = [];

			var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
				laste, tx, ty;

			for (var i = 0, l = this.actions.length; i < l; i++) {

				var item = this.actions[i];

				var action = item.action;
				var args = item.args;

				switch (action) {

					case 'moveTo':

						points.push(new THREE.Vector2(args[0], args[1]));

						break;

					case 'lineTo':

						points.push(new THREE.Vector2(args[0], args[1]));

						break;

					case 'quadraticCurveTo':

						cpx = args[2];
						cpy = args[3];

						cpx1 = args[0];
						cpy1 = args[1];

						if (points.length > 0) {

							laste = points[points.length - 1];

							cpx0 = laste.x;
							cpy0 = laste.y;

						} else {

							laste = this.actions[i - 1].args;

							cpx0 = laste[laste.length - 2];
							cpy0 = laste[laste.length - 1];

						}

						for (var j = 1; j <= divisions; j++) {

							var t = j / divisions;

							tx = b2(t, cpx0, cpx1, cpx);
							ty = b2(t, cpy0, cpy1, cpy);

							points.push(new THREE.Vector2(tx, ty));

						}

						break;

					case 'bezierCurveTo':

						cpx = args[4];
						cpy = args[5];

						cpx1 = args[0];
						cpy1 = args[1];

						cpx2 = args[2];
						cpy2 = args[3];

						if (points.length > 0) {

							laste = points[points.length - 1];

							cpx0 = laste.x;
							cpy0 = laste.y;

						} else {

							laste = this.actions[i - 1].args;

							cpx0 = laste[laste.length - 2];
							cpy0 = laste[laste.length - 1];

						}


						for (var j = 1; j <= divisions; j++) {

							var t = j / divisions;

							tx = b3(t, cpx0, cpx1, cpx2, cpx);
							ty = b3(t, cpy0, cpy1, cpy2, cpy);

							points.push(new THREE.Vector2(tx, ty));

						}

						break;

					case 'splineThru':

						laste = this.actions[i - 1].args;

						var last = new THREE.Vector2(laste[laste.length - 2], laste[laste.length - 1]);
						var spts = [last];

						var n = divisions * args[0].length;

						spts = spts.concat(args[0]);

						var spline = new THREE.SplineCurve(spts);

						for (var j = 1; j <= n; j++) {

							points.push(spline.getPointAt(j / n));

						}

						break;

					case 'arc':

						var aX = args[0], aY = args[1],
							aRadius = args[2],
							aStartAngle = args[3], aEndAngle = args[4],
							aClockwise = !!args[5];

						var deltaAngle = aEndAngle - aStartAngle;
						var angle;
						var tdivisions = divisions * 2;

						for (var j = 1; j <= tdivisions; j++) {

							var t = j / tdivisions;

							if (!aClockwise) {

								t = 1 - t;

							}

							angle = aStartAngle + t * deltaAngle;

							tx = aX + aRadius * Math.cos(angle);
							ty = aY + aRadius * Math.sin(angle);

							//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

							points.push(new THREE.Vector2(tx, ty));

						}

						//console.log(points);

						break;

					case 'ellipse':

						var aX = args[0], aY = args[1],
							xRadius = args[2],
							yRadius = args[3],
							aStartAngle = args[4], aEndAngle = args[5],
							aClockwise = !!args[6],
							aRotation = args[7];


						var deltaAngle = aEndAngle - aStartAngle;
						var angle;
						var tdivisions = divisions * 2;

						var cos, sin;
						if (aRotation !== 0) {

							cos = Math.cos(aRotation);
							sin = Math.sin(aRotation);

						}

						for (var j = 1; j <= tdivisions; j++) {

							var t = j / tdivisions;

							if (!aClockwise) {

								t = 1 - t;

							}

							angle = aStartAngle + t * deltaAngle;

							tx = aX + xRadius * Math.cos(angle);
							ty = aY + yRadius * Math.sin(angle);

							if (aRotation !== 0) {

								var x = tx, y = ty;

								// Rotate the point about the center of the ellipse.
								tx = (x - aX) * cos - (y - aY) * sin + aX;
								ty = (x - aX) * sin + (y - aY) * cos + aY;

							}

							//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

							points.push(new THREE.Vector2(tx, ty));

						}

						//console.log(points);

						break;

				} // end switch

			}



			// Normalize to remove the closing point by default.
			var lastPoint = points[points.length - 1];
			if (Math.abs(lastPoint.x - points[0].x) < Number.EPSILON &&
				Math.abs(lastPoint.y - points[0].y) < Number.EPSILON)
				points.splice(points.length - 1, 1);

			if (this.autoClose) {

				points.push(points[0]);

			}

			return points;

		},

		toShapes: function (isCCW, noHoles) {

			function extractSubpaths(inActions) {

				var subPaths = [], lastPath = new THREE.Path();

				for (var i = 0, l = inActions.length; i < l; i++) {

					var item = inActions[i];

					var args = item.args;
					var action = item.action;

					if (action === 'moveTo') {

						if (lastPath.actions.length !== 0) {

							subPaths.push(lastPath);
							lastPath = new THREE.Path();

						}

					}

					lastPath[action].apply(lastPath, args);

				}

				if (lastPath.actions.length !== 0) {

					subPaths.push(lastPath);

				}

				// console.log(subPaths);

				return subPaths;

			}

			function toShapesNoHoles(inSubpaths) {

				var shapes = [];

				for (var i = 0, l = inSubpaths.length; i < l; i++) {

					var tmpPath = inSubpaths[i];

					var tmpShape = new THREE.Shape();
					tmpShape.actions = tmpPath.actions;
					tmpShape.curves = tmpPath.curves;

					shapes.push(tmpShape);

				}

				//console.log("shape", shapes);

				return shapes;

			}

			function isPointInsidePolygon(inPt, inPolygon) {

				var polyLen = inPolygon.length;

				// inPt on polygon contour => immediate success    or
				// toggling of inside/outside at every single! intersection point of an edge
				//  with the horizontal line through inPt, left of inPt
				//  not counting lowerY endpoints of edges and whole edges on that line
				var inside = false;
				for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {

					var edgeLowPt = inPolygon[p];
					var edgeHighPt = inPolygon[q];

					var edgeDx = edgeHighPt.x - edgeLowPt.x;
					var edgeDy = edgeHighPt.y - edgeLowPt.y;

					if (Math.abs(edgeDy) > Number.EPSILON) {

						// not parallel
						if (edgeDy < 0) {

							edgeLowPt = inPolygon[q]; edgeDx = - edgeDx;
							edgeHighPt = inPolygon[p]; edgeDy = - edgeDy;

						}
						if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y)) continue;

						if (inPt.y === edgeLowPt.y) {

							if (inPt.x === edgeLowPt.x) return true;		// inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!

						} else {

							var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
							if (perpEdge === 0) return true;		// inPt is on contour ?
							if (perpEdge < 0) continue;
							inside = !inside;		// true intersection left of inPt

						}

					} else {

						// parallel or collinear
						if (inPt.y !== edgeLowPt.y) continue;			// parallel
						// edge lies on the same horizontal line as inPt
						if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) ||
							((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x))) return true;	// inPt: Point on contour !
						// continue;

					}

				}

				return inside;

			}

			var isClockWise = THREE.ShapeUtils.isClockWise;

			var subPaths = extractSubpaths(this.actions);
			if (subPaths.length === 0) return [];

			if (noHoles === true) return toShapesNoHoles(subPaths);


			var solid, tmpPath, tmpShape, shapes = [];

			if (subPaths.length === 1) {

				tmpPath = subPaths[0];
				tmpShape = new THREE.Shape();
				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;
				shapes.push(tmpShape);
				return shapes;

			}

			var holesFirst = !isClockWise(subPaths[0].getPoints());
			holesFirst = isCCW ? !holesFirst : holesFirst;

			// console.log("Holes first", holesFirst);

			var betterShapeHoles = [];
			var newShapes = [];
			var newShapeHoles = [];
			var mainIdx = 0;
			var tmpPoints;

			newShapes[mainIdx] = undefined;
			newShapeHoles[mainIdx] = [];

			for (var i = 0, l = subPaths.length; i < l; i++) {

				tmpPath = subPaths[i];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise(tmpPoints);
				solid = isCCW ? !solid : solid;

				if (solid) {

					if ((!holesFirst) && (newShapes[mainIdx])) mainIdx++;

					newShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };
					newShapes[mainIdx].s.actions = tmpPath.actions;
					newShapes[mainIdx].s.curves = tmpPath.curves;

					if (holesFirst) mainIdx++;
					newShapeHoles[mainIdx] = [];

					//console.log('cw', i);

				} else {

					newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });

					//console.log('ccw', i);

				}

			}

			// only Holes? -> probably all Shapes with wrong orientation
			if (!newShapes[0]) return toShapesNoHoles(subPaths);


			if (newShapes.length > 1) {

				var ambiguous = false;
				var toChange = [];

				for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {

					betterShapeHoles[sIdx] = [];

				}

				for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {

					var sho = newShapeHoles[sIdx];

					for (var hIdx = 0; hIdx < sho.length; hIdx++) {

						var ho = sho[hIdx];
						var hole_unassigned = true;

						for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {

							if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {

								if (sIdx !== s2Idx) toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
								if (hole_unassigned) {

									hole_unassigned = false;
									betterShapeHoles[s2Idx].push(ho);

								} else {

									ambiguous = true;

								}

							}

						}
						if (hole_unassigned) {

							betterShapeHoles[sIdx].push(ho);

						}

					}

				}
				// console.log("ambiguous: ", ambiguous);
				if (toChange.length > 0) {

					// console.log("to change: ", toChange);
					if (!ambiguous) newShapeHoles = betterShapeHoles;

				}

			}

			var tmpHoles;

			for (var i = 0, il = newShapes.length; i < il; i++) {

				tmpShape = newShapes[i].s;
				shapes.push(tmpShape);
				tmpHoles = newShapeHoles[i];

				for (var j = 0, jl = tmpHoles.length; j < jl; j++) {

					tmpShape.holes.push(tmpHoles[j].h);

				}

			}

			//console.log("shape", shapes);

			return shapes;

		}

	});

	// File:src/extras/core/Shape.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/

	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.

	THREE.Shape = function () {

		THREE.Path.apply(this, arguments);

		this.holes = [];

	};

	THREE.Shape.prototype = Object.assign(Object.create(THREE.Path.prototype), {

		constructor: THREE.Shape,

		// Convenience method to return ExtrudeGeometry

		extrude: function (options) {

			return new THREE.ExtrudeGeometry(this, options);

		},

		// Convenience method to return ShapeGeometry

		makeGeometry: function (options) {

			return new THREE.ShapeGeometry(this, options);

		},

		getPointsHoles: function (divisions) {

			var holesPts = [];

			for (var i = 0, l = this.holes.length; i < l; i++) {

				holesPts[i] = this.holes[i].getPoints(divisions);

			}

			return holesPts;

		},

		// Get points of shape and holes (keypoints based on segments parameter)

		extractAllPoints: function (divisions) {

			return {

				shape: this.getPoints(divisions),
				holes: this.getPointsHoles(divisions)

			};

		},

		extractPoints: function (divisions) {

			return this.extractAllPoints(divisions);

		}

	});

	// File:src/extras/curves/LineCurve.js

	/**************************************************************
	 *	Line
	 **************************************************************/

	THREE.LineCurve = function (v1, v2) {

		this.v1 = v1;
		this.v2 = v2;

	};

	THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);
	THREE.LineCurve.prototype.constructor = THREE.LineCurve;

	THREE.LineCurve.prototype.getPoint = function (t) {

		var point = this.v2.clone().sub(this.v1);
		point.multiplyScalar(t).add(this.v1);

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	THREE.LineCurve.prototype.getPointAt = function (u) {

		return this.getPoint(u);

	};

	THREE.LineCurve.prototype.getTangent = function (t) {

		var tangent = this.v2.clone().sub(this.v1);

		return tangent.normalize();

	};

	// File:src/extras/curves/QuadraticBezierCurve.js

	/**************************************************************
	 *	Quadratic Bezier curve
	 **************************************************************/


	THREE.QuadraticBezierCurve = function (v0, v1, v2) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	};

	THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);
	THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


	THREE.QuadraticBezierCurve.prototype.getPoint = function (t) {

		var b2 = THREE.ShapeUtils.b2;

		return new THREE.Vector2(
			b2(t, this.v0.x, this.v1.x, this.v2.x),
			b2(t, this.v0.y, this.v1.y, this.v2.y)
		);

	};


	THREE.QuadraticBezierCurve.prototype.getTangent = function (t) {

		var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;

		return new THREE.Vector2(
			tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x),
			tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y)
		).normalize();

	};

	// File:src/extras/curves/CubicBezierCurve.js

	/**************************************************************
	 *	Cubic Bezier curve
	 **************************************************************/

	THREE.CubicBezierCurve = function (v0, v1, v2, v3) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	};

	THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);
	THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

	THREE.CubicBezierCurve.prototype.getPoint = function (t) {

		var b3 = THREE.ShapeUtils.b3;

		return new THREE.Vector2(
			b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x),
			b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y)
		);

	};

	THREE.CubicBezierCurve.prototype.getTangent = function (t) {

		var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;

		return new THREE.Vector2(
			tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x),
			tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y)
		).normalize();

	};

	// File:src/extras/curves/SplineCurve.js

	/**************************************************************
	 *	Spline curve
	 **************************************************************/

	THREE.SplineCurve = function (points /* array of Vector2 */) {

		this.points = (points == undefined) ? [] : points;

	};

	THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);
	THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

	THREE.SplineCurve.prototype.getPoint = function (t) {

		var points = this.points;
		var point = (points.length - 1) * t;

		var intPoint = Math.floor(point);
		var weight = point - intPoint;

		var point0 = points[intPoint === 0 ? intPoint : intPoint - 1];
		var point1 = points[intPoint];
		var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
		var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];

		var interpolate = THREE.CurveUtils.interpolate;

		return new THREE.Vector2(
			interpolate(point0.x, point1.x, point2.x, point3.x, weight),
			interpolate(point0.y, point1.y, point2.y, point3.y, weight)
		);

	};

	// File:src/extras/curves/EllipseCurve.js

	/**************************************************************
	 *	Ellipse curve
	 **************************************************************/

	THREE.EllipseCurve = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {

		this.aX = aX;
		this.aY = aY;

		this.xRadius = xRadius;
		this.yRadius = yRadius;

		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;

		this.aClockwise = aClockwise;

		this.aRotation = aRotation || 0;

	};

	THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);
	THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

	THREE.EllipseCurve.prototype.getPoint = function (t) {

		var deltaAngle = this.aEndAngle - this.aStartAngle;

		if (deltaAngle < 0) deltaAngle += Math.PI * 2;
		if (deltaAngle > Math.PI * 2) deltaAngle -= Math.PI * 2;

		var angle;

		if (this.aClockwise === true) {

			angle = this.aEndAngle + (1 - t) * (Math.PI * 2 - deltaAngle);

		} else {

			angle = this.aStartAngle + t * deltaAngle;

		}

		var x = this.aX + this.xRadius * Math.cos(angle);
		var y = this.aY + this.yRadius * Math.sin(angle);

		if (this.aRotation !== 0) {

			var cos = Math.cos(this.aRotation);
			var sin = Math.sin(this.aRotation);

			var tx = x, ty = y;

			// Rotate the point about the center of the ellipse.
			x = (tx - this.aX) * cos - (ty - this.aY) * sin + this.aX;
			y = (tx - this.aX) * sin + (ty - this.aY) * cos + this.aY;

		}

		return new THREE.Vector2(x, y);

	};

	// File:src/extras/curves/ArcCurve.js

	/**************************************************************
	 *	Arc curve
	 **************************************************************/

	THREE.ArcCurve = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {

		THREE.EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);

	};

	THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);
	THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

	// File:src/extras/curves/LineCurve3.js

	/**************************************************************
	 *	Line3D
	 **************************************************************/

	THREE.LineCurve3 = THREE.Curve.create(

		function (v1, v2) {

			this.v1 = v1;
			this.v2 = v2;

		},

		function (t) {

			var vector = new THREE.Vector3();

			vector.subVectors(this.v2, this.v1); // diff
			vector.multiplyScalar(t);
			vector.add(this.v1);

			return vector;

		}

	);

	// File:src/extras/curves/QuadraticBezierCurve3.js

	/**************************************************************
	 *	Quadratic Bezier 3D curve
	 **************************************************************/

	THREE.QuadraticBezierCurve3 = THREE.Curve.create(

		function (v0, v1, v2) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		},

		function (t) {

			var b2 = THREE.ShapeUtils.b2;

			return new THREE.Vector3(
				b2(t, this.v0.x, this.v1.x, this.v2.x),
				b2(t, this.v0.y, this.v1.y, this.v2.y),
				b2(t, this.v0.z, this.v1.z, this.v2.z)
			);

		}

	);

	// File:src/extras/curves/CubicBezierCurve3.js

	/**************************************************************
	 *	Cubic Bezier 3D curve
	 **************************************************************/

	THREE.CubicBezierCurve3 = THREE.Curve.create(

		function (v0, v1, v2, v3) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		},

		function (t) {

			var b3 = THREE.ShapeUtils.b3;

			return new THREE.Vector3(
				b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x),
				b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y),
				b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z)
			);

		}

	);

	// File:src/extras/curves/SplineCurve3.js

	/**************************************************************
	 *	Spline 3D curve
	 **************************************************************/


	THREE.SplineCurve3 = THREE.Curve.create(

		function (points /* array of Vector3 */) {

			//console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
			this.points = (points == undefined) ? [] : points;

		},

		function (t) {

			var points = this.points;
			var point = (points.length - 1) * t;

			var intPoint = Math.floor(point);
			var weight = point - intPoint;

			var point0 = points[intPoint == 0 ? intPoint : intPoint - 1];
			var point1 = points[intPoint];
			var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
			var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];

			var interpolate = THREE.CurveUtils.interpolate;

			return new THREE.Vector3(
				interpolate(point0.x, point1.x, point2.x, point3.x, weight),
				interpolate(point0.y, point1.y, point2.y, point3.y, weight),
				interpolate(point0.z, point1.z, point2.z, point3.z, weight)
			);

		}

	);

	// File:src/extras/curves/CatmullRomCurve3.js

	/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */

	THREE.CatmullRomCurve3 = (function () {

		var
			tmp = new THREE.Vector3(),
			px = new CubicPoly(),
			py = new CubicPoly(),
			pz = new CubicPoly();

		/*
		Based on an optimized c++ solution in
		 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
		 - http://ideone.com/NoEbVM
	
		This CubicPoly class could be used for reusing some variables and calculations,
		but for three.js curve use, it could be possible inlined and flatten into a single function call
		which can be placed in CurveUtils.
		*/

		function CubicPoly() {

		}

		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		CubicPoly.prototype.init = function (x0, x1, t0, t1) {

			this.c0 = x0;
			this.c1 = t0;
			this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

		};

		CubicPoly.prototype.initNonuniformCatmullRom = function (x0, x1, x2, x3, dt0, dt1, dt2) {

			// compute tangents when parameterized in [t1,t2]
			var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
			var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			// initCubicPoly
			this.init(x1, x2, t1, t2);

		};

		// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
		CubicPoly.prototype.initCatmullRom = function (x0, x1, x2, x3, tension) {

			this.init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));

		};

		CubicPoly.prototype.calc = function (t) {

			var t2 = t * t;
			var t3 = t2 * t;
			return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

		};

		// Subclass Three.js curve
		return THREE.Curve.create(

			function (p /* array of Vector3 */) {

				this.points = p || [];
				this.closed = false;

			},

			function (t) {

				var points = this.points,
					point, intPoint, weight, l;

				l = points.length;

				if (l < 2) console.log('');

				point = (l - (this.closed ? 0 : 1)) * t;
				intPoint = Math.floor(point);
				weight = point - intPoint;

				if (this.closed) {

					intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;

				} else if (weight === 0 && intPoint === l - 1) {

					intPoint = l - 2;
					weight = 1;

				}

				var p0, p1, p2, p3; // 4 points

				if (this.closed || intPoint > 0) {

					p0 = points[(intPoint - 1) % l];

				} else {

					// extrapolate first point
					tmp.subVectors(points[0], points[1]).add(points[0]);
					p0 = tmp;

				}

				p1 = points[intPoint % l];
				p2 = points[(intPoint + 1) % l];

				if (this.closed || intPoint + 2 < l) {

					p3 = points[(intPoint + 2) % l];

				} else {

					// extrapolate last point
					tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
					p3 = tmp;

				}

				if (this.type === undefined || this.type === 'centripetal' || this.type === 'chordal') {

					// init Centripetal / Chordal Catmull-Rom
					var pow = this.type === 'chordal' ? 0.5 : 0.25;
					var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
					var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
					var dt2 = Math.pow(p2.distanceToSquared(p3), pow);

					// safety check for repeated points
					if (dt1 < 1e-4) dt1 = 1.0;
					if (dt0 < 1e-4) dt0 = dt1;
					if (dt2 < 1e-4) dt2 = dt1;

					px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
					py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
					pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);

				} else if (this.type === 'catmullrom') {

					var tension = this.tension !== undefined ? this.tension : 0.5;
					px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension);
					py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension);
					pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);

				}

				var v = new THREE.Vector3(
					px.calc(weight),
					py.calc(weight),
					pz.calc(weight)
				);

				return v;

			}

		);

	})();

	// File:src/extras/curves/ClosedSplineCurve3.js

	/**************************************************************
	 *	Closed Spline 3D curve
	 **************************************************************/


	THREE.ClosedSplineCurve3 = function (points) {

		//console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );

		THREE.CatmullRomCurve3.call(this, points);
		this.type = 'catmullrom';
		this.closed = true;

	};

	THREE.ClosedSplineCurve3.prototype = Object.create(THREE.CatmullRomCurve3.prototype);

	// File:src/extras/geometries/BoxGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
	 */

	THREE.BoxGeometry = function (width, height, depth, widthSegments, heightSegments, depthSegments) {

		THREE.Geometry.call(this);

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		this.fromBufferGeometry(new THREE.BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
		this.mergeVertices();

	};

	THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);
	THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

	THREE.CubeGeometry = THREE.BoxGeometry;

	// File:src/extras/geometries/BoxBufferGeometry.js

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	THREE.BoxBufferGeometry = function (width, height, depth, widthSegments, heightSegments, depthSegments) {

		THREE.BufferGeometry.call(this);

		this.type = 'BoxBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		var scope = this;

		// segments
		widthSegments = Math.floor(widthSegments) || 1;
		heightSegments = Math.floor(heightSegments) || 1;
		depthSegments = Math.floor(depthSegments) || 1;

		// these are used to calculate buffer length
		var vertexCount = calculateVertexCount(widthSegments, heightSegments, depthSegments);
		var indexCount = calculateIndexCount(widthSegments, heightSegments, depthSegments);

		// buffers
		var indices = new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount);
		var vertices = new Float32Array(vertexCount * 3);
		var normals = new Float32Array(vertexCount * 3);
		var uvs = new Float32Array(vertexCount * 2);

		// offset variables
		var vertexBufferOffset = 0;
		var uvBufferOffset = 0;
		var indexBufferOffset = 0;
		var numberOfVertices = 0;

		// group variables
		var groupStart = 0;

		// build each side of the box geometry
		buildPlane('z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0); // px
		buildPlane('z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1); // nx
		buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
		buildPlane('x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3); // ny
		buildPlane('x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4); // pz
		buildPlane('x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5); // nz

		// build geometry
		this.setIndex(new THREE.BufferAttribute(indices, 1));
		this.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
		this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
		this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));

		// helper functions

		function calculateVertexCount(w, h, d) {

			var vertices = 0;

			// calculate the amount of vertices for each side (plane)
			vertices += (w + 1) * (h + 1) * 2; // xy
			vertices += (w + 1) * (d + 1) * 2; // xz
			vertices += (d + 1) * (h + 1) * 2; // zy

			return vertices;

		}

		function calculateIndexCount(w, h, d) {

			var index = 0;

			// calculate the amount of squares for each side
			index += w * h * 2; // xy
			index += w * d * 2; // xz
			index += d * h * 2; // zy

			return index * 6; // two triangles per square => six vertices per square

		}

		function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {

			var segmentWidth = width / gridX;
			var segmentHeight = height / gridY;

			var widthHalf = width / 2;
			var heightHalf = height / 2;
			var depthHalf = depth / 2;

			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;

			var vertexCounter = 0;
			var groupCount = 0;

			var vector = new THREE.Vector3();

			// generate vertices, normals and uvs

			for (var iy = 0; iy < gridY1; iy++) {

				var y = iy * segmentHeight - heightHalf;

				for (var ix = 0; ix < gridX1; ix++) {

					var x = ix * segmentWidth - widthHalf;

					// set values to correct vector component
					vector[u] = x * udir;
					vector[v] = y * vdir;
					vector[w] = depthHalf;

					// now apply vector to vertex buffer
					vertices[vertexBufferOffset] = vector.x;
					vertices[vertexBufferOffset + 1] = vector.y;
					vertices[vertexBufferOffset + 2] = vector.z;

					// set values to correct vector component
					vector[u] = 0;
					vector[v] = 0;
					vector[w] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer
					normals[vertexBufferOffset] = vector.x;
					normals[vertexBufferOffset + 1] = vector.y;
					normals[vertexBufferOffset + 2] = vector.z;

					// uvs
					uvs[uvBufferOffset] = ix / gridX;
					uvs[uvBufferOffset + 1] = 1 - (iy / gridY);

					// update offsets and counters
					vertexBufferOffset += 3;
					uvBufferOffset += 2;
					vertexCounter += 1;

				}

			}

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for (iy = 0; iy < gridY; iy++) {

				for (ix = 0; ix < gridX; ix++) {

					// indices
					var a = numberOfVertices + ix + gridX1 * iy;
					var b = numberOfVertices + ix + gridX1 * (iy + 1);
					var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
					var d = numberOfVertices + (ix + 1) + gridX1 * iy;

					// face one
					indices[indexBufferOffset] = a;
					indices[indexBufferOffset + 1] = b;
					indices[indexBufferOffset + 2] = d;

					// face two
					indices[indexBufferOffset + 3] = b;
					indices[indexBufferOffset + 4] = c;
					indices[indexBufferOffset + 5] = d;

					// update offsets and counters
					indexBufferOffset += 6;
					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support
			scope.addGroup(groupStart, groupCount, materialIndex);

			// calculate new start value for groups
			groupStart += groupCount;

			// update total number of vertices
			numberOfVertices += vertexCounter;

		}

	};

	THREE.BoxBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
	THREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;

	// File:src/extras/geometries/CircleGeometry.js

	/**
	 * @author hughes
	 */

	THREE.CircleGeometry = function (radius, segments, thetaStart, thetaLength) {

		THREE.Geometry.call(this);

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry(new THREE.CircleBufferGeometry(radius, segments, thetaStart, thetaLength));

	};

	THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
	THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

	// File:src/extras/geometries/CircleBufferGeometry.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.CircleBufferGeometry = function (radius, segments, thetaStart, thetaLength) {

		THREE.BufferGeometry.call(this);

		this.type = 'CircleBufferGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 50;
		segments = segments !== undefined ? Math.max(3, segments) : 8;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		var vertices = segments + 2;

		var positions = new Float32Array(vertices * 3);
		var normals = new Float32Array(vertices * 3);
		var uvs = new Float32Array(vertices * 2);

		// center data is already zero, but need to set a few extras
		normals[2] = 1.0;
		uvs[0] = 0.5;
		uvs[1] = 0.5;

		for (var s = 0, i = 3, ii = 2; s <= segments; s++, i += 3, ii += 2) {

			var segment = thetaStart + s / segments * thetaLength;

			positions[i] = radius * Math.cos(segment);
			positions[i + 1] = radius * Math.sin(segment);

			normals[i + 2] = 1; // normal z

			uvs[ii] = (positions[i] / radius + 1) / 2;
			uvs[ii + 1] = (positions[i + 1] / radius + 1) / 2;

		}

		var indices = [];

		for (var i = 1; i <= segments; i++) {

			indices.push(i, i + 1, 0);

		}

		this.setIndex(new THREE.BufferAttribute(new Uint16Array(indices), 1));
		this.addAttribute('position', new THREE.BufferAttribute(positions, 3));
		this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
		this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));

		this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);

	};

	THREE.CircleBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
	THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;

	// File:src/extras/geometries/CylinderBufferGeometry.js

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	THREE.CylinderBufferGeometry = function (radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {

		THREE.BufferGeometry.call(this);

		this.type = 'CylinderBufferGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		var scope = this;

		radiusTop = radiusTop !== undefined ? radiusTop : 20;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
		height = height !== undefined ? height : 100;

		radialSegments = Math.floor(radialSegments) || 8;
		heightSegments = Math.floor(heightSegments) || 1;

		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
		thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

		// used to calculate buffer length

		var nbCap = 0;

		if (openEnded === false) {

			if (radiusTop > 0) nbCap++;
			if (radiusBottom > 0) nbCap++;

		}

		var vertexCount = calculateVertexCount();
		var indexCount = calculateIndexCount();

		// buffers

		var indices = new THREE.BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
		var vertices = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
		var normals = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
		var uvs = new THREE.BufferAttribute(new Float32Array(vertexCount * 2), 2);

		// helper variables

		var index = 0,
			indexOffset = 0,
			indexArray = [],
			halfHeight = height / 2;

		// group variables
		var groupStart = 0;

		// generate geometry

		generateTorso();

		if (openEnded === false) {

			if (radiusTop > 0) generateCap(true);
			if (radiusBottom > 0) generateCap(false);

		}

		// build geometry

		this.setIndex(indices);
		this.addAttribute('position', vertices);
		this.addAttribute('normal', normals);
		this.addAttribute('uv', uvs);

		// helper functions

		function calculateVertexCount() {

			var count = (radialSegments + 1) * (heightSegments + 1);

			if (openEnded === false) {

				count += ((radialSegments + 1) * nbCap) + (radialSegments * nbCap);

			}

			return count;

		}

		function calculateIndexCount() {

			var count = radialSegments * heightSegments * 2 * 3;

			if (openEnded === false) {

				count += radialSegments * nbCap * 3;

			}

			return count;

		}

		function generateTorso() {

			var x, y;
			var normal = new THREE.Vector3();
			var vertex = new THREE.Vector3();

			var groupCount = 0;

			// this will be used to calculate the normal
			var tanTheta = (radiusBottom - radiusTop) / height;

			// generate vertices, normals and uvs

			for (y = 0; y <= heightSegments; y++) {

				var indexRow = [];

				var v = y / heightSegments;

				// calculate the radius of the current row
				var radius = v * (radiusBottom - radiusTop) + radiusTop;

				for (x = 0; x <= radialSegments; x++) {

					var u = x / radialSegments;

					// vertex
					vertex.x = radius * Math.sin(u * thetaLength + thetaStart);
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * Math.cos(u * thetaLength + thetaStart);
					vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);

					// normal
					normal.copy(vertex);

					// handle special case if radiusTop/radiusBottom is zero

					if ((radiusTop === 0 && y === 0) || (radiusBottom === 0 && y === heightSegments)) {

						normal.x = Math.sin(u * thetaLength + thetaStart);
						normal.z = Math.cos(u * thetaLength + thetaStart);

					}

					normal.setY(Math.sqrt(normal.x * normal.x + normal.z * normal.z) * tanTheta).normalize();
					normals.setXYZ(index, normal.x, normal.y, normal.z);

					// uv
					uvs.setXY(index, u, 1 - v);

					// save index of vertex in respective row
					indexRow.push(index);

					// increase index
					index++;

				}

				// now save vertices of the row in our index array
				indexArray.push(indexRow);

			}

			// generate indices

			for (x = 0; x < radialSegments; x++) {

				for (y = 0; y < heightSegments; y++) {

					// we use the index array to access the correct indices
					var i1 = indexArray[y][x];
					var i2 = indexArray[y + 1][x];
					var i3 = indexArray[y + 1][x + 1];
					var i4 = indexArray[y][x + 1];

					// face one
					indices.setX(indexOffset, i1); indexOffset++;
					indices.setX(indexOffset, i2); indexOffset++;
					indices.setX(indexOffset, i4); indexOffset++;

					// face two
					indices.setX(indexOffset, i2); indexOffset++;
					indices.setX(indexOffset, i3); indexOffset++;
					indices.setX(indexOffset, i4); indexOffset++;

					// update counters
					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support
			scope.addGroup(groupStart, groupCount, 0);

			// calculate new start value for groups
			groupStart += groupCount;

		}

		function generateCap(top) {

			var x, centerIndexStart, centerIndexEnd;

			var uv = new THREE.Vector2();
			var vertex = new THREE.Vector3();

			var groupCount = 0;

			var radius = (top === true) ? radiusTop : radiusBottom;
			var sign = (top === true) ? 1 : - 1;

			// save the index of the first center vertex
			centerIndexStart = index;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for (x = 1; x <= radialSegments; x++) {

				// vertex
				vertices.setXYZ(index, 0, halfHeight * sign, 0);

				// normal
				normals.setXYZ(index, 0, sign, 0);

				// uv
				uv.x = 0.5;
				uv.y = 0.5;

				uvs.setXY(index, uv.x, uv.y);

				// increase index
				index++;

			}

			// save the index of the last center vertex
			centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for (x = 0; x <= radialSegments; x++) {

				var u = x / radialSegments;
				var theta = u * thetaLength + thetaStart;

				var cosTheta = Math.cos(theta);
				var sinTheta = Math.sin(theta);

				// vertex
				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);

				// normal
				normals.setXYZ(index, 0, sign, 0);

				// uv
				uv.x = (cosTheta * 0.5) + 0.5;
				uv.y = (sinTheta * 0.5 * sign) + 0.5;
				uvs.setXY(index, uv.x, uv.y);

				// increase index
				index++;

			}

			// generate indices

			for (x = 0; x < radialSegments; x++) {

				var c = centerIndexStart + x;
				var i = centerIndexEnd + x;

				if (top === true) {

					// face top
					indices.setX(indexOffset, i); indexOffset++;
					indices.setX(indexOffset, i + 1); indexOffset++;
					indices.setX(indexOffset, c); indexOffset++;

				} else {

					// face bottom
					indices.setX(indexOffset, i + 1); indexOffset++;
					indices.setX(indexOffset, i); indexOffset++;
					indices.setX(indexOffset, c); indexOffset++;

				}

				// update counters
				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support
			scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);

			// calculate new start value for groups
			groupStart += groupCount;

		}

	};

	THREE.CylinderBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
	THREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;

	// File:src/extras/geometries/CylinderGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CylinderGeometry = function (radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {

		THREE.Geometry.call(this);

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry(new THREE.CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
		this.mergeVertices();

	};

	THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
	THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

	// File:src/extras/geometries/ConeBufferGeometry.js

	/*
	 * @author: abelnation / http://github.com/abelnation
	 */

	THREE.ConeBufferGeometry = function (
		radius, height,
		radialSegments, heightSegments,
		openEnded, thetaStart, thetaLength) {

		THREE.CylinderBufferGeometry.call(this,
			0, radius, height,
			radialSegments, heightSegments,
			openEnded, thetaStart, thetaLength);

		this.type = 'ConeBufferGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	};

	THREE.ConeBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
	THREE.ConeBufferGeometry.prototype.constructor = THREE.ConeBufferGeometry;

	// File:src/extras/geometries/ConeGeometry.js

	/**
	 * @author abelnation / http://github.com/abelnation
	 */

	THREE.ConeGeometry = function (
		radius, height,
		radialSegments, heightSegments,
		openEnded, thetaStart, thetaLength) {

		THREE.CylinderGeometry.call(this,
			0, radius, height,
			radialSegments, heightSegments,
			openEnded, thetaStart, thetaLength);

		this.type = 'ConeGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	};

	THREE.ConeGeometry.prototype = Object.create(THREE.CylinderGeometry.prototype);
	THREE.ConeGeometry.prototype.constructor = THREE.ConeGeometry;

	// File:src/extras/geometries/EdgesGeometry.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.EdgesGeometry = function (geometry, thresholdAngle) {

		THREE.BufferGeometry.call(this);

		thresholdAngle = (thresholdAngle !== undefined) ? thresholdAngle : 1;

		var thresholdDot = Math.cos(THREE.Math.DEG2RAD * thresholdAngle);

		var edge = [0, 0], hash = {};

		function sortFunction(a, b) {

			return a - b;

		}

		var keys = ['a', 'b', 'c'];

		var geometry2;

		if (geometry instanceof THREE.BufferGeometry) {

			geometry2 = new THREE.Geometry();
			geometry2.fromBufferGeometry(geometry);

		} else {

			geometry2 = geometry.clone();

		}

		geometry2.mergeVertices();
		geometry2.computeFaceNormals();

		var vertices = geometry2.vertices;
		var faces = geometry2.faces;

		for (var i = 0, l = faces.length; i < l; i++) {

			var face = faces[i];

			for (var j = 0; j < 3; j++) {

				edge[0] = face[keys[j]];
				edge[1] = face[keys[(j + 1) % 3]];
				edge.sort(sortFunction);

				var key = edge.toString();

				if (hash[key] === undefined) {

					hash[key] = { vert1: edge[0], vert2: edge[1], face1: i, face2: undefined };

				} else {

					hash[key].face2 = i;

				}

			}

		}

		var coords = [];

		for (var key in hash) {

			var h = hash[key];

			if (h.face2 === undefined || faces[h.face1].normal.dot(faces[h.face2].normal) <= thresholdDot) {

				var vertex = vertices[h.vert1];
				coords.push(vertex.x);
				coords.push(vertex.y);
				coords.push(vertex.z);

				vertex = vertices[h.vert2];
				coords.push(vertex.x);
				coords.push(vertex.y);
				coords.push(vertex.z);

			}

		}

		this.addAttribute('position', new THREE.BufferAttribute(new Float32Array(coords), 3));

	};

	THREE.EdgesGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
	THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;

	// File:src/extras/geometries/ExtrudeGeometry.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
	 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
	 *
	 *  uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/

	THREE.ExtrudeGeometry = function (shapes, options) {

		if (typeof (shapes) === "undefined") {

			shapes = [];
			return;

		}

		THREE.Geometry.call(this);

		this.type = 'ExtrudeGeometry';

		shapes = Array.isArray(shapes) ? shapes : [shapes];

		this.addShapeList(shapes, options);

		this.computeFaceNormals();

		// can't really use automatic vertex normals
		// as then front and back sides get smoothed too
		// should do separate smoothing just for sides

		//this.computeVertexNormals();

		//console.log( "took", ( Date.now() - startTime ) );

	};

	THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
	THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

	THREE.ExtrudeGeometry.prototype.addShapeList = function (shapes, options) {

		var sl = shapes.length;

		for (var s = 0; s < sl; s++) {

			var shape = shapes[s];
			this.addShape(shape, options);

		}

	};

	THREE.ExtrudeGeometry.prototype.addShape = function (shape, options) {

		var amount = options.amount !== undefined ? options.amount : 100;

		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

		var steps = options.steps !== undefined ? options.steps : 1;

		var extrudePath = options.extrudePath;
		var extrudePts, extrudeByPath = false;

		// Use default WorldUVGenerator if no UV generators are specified.
		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

		var splineTube, binormal, normal, position2;
		if (extrudePath) {

			extrudePts = extrudePath.getSpacedPoints(steps);

			extrudeByPath = true;
			bevelEnabled = false; // bevels not supported for path extrusion

			// SETUP TNB variables

			// Reuse TNB from TubeGeomtry for now.
			// TODO1 - have a .isClosed in spline?

			splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);

			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

			binormal = new THREE.Vector3();
			normal = new THREE.Vector3();
			position2 = new THREE.Vector3();

		}

		// Safeguards if bevels are not enabled

		if (!bevelEnabled) {

			bevelSegments = 0;
			bevelThickness = 0;
			bevelSize = 0;

		}

		// Variables initialization

		var ahole, h, hl; // looping of holes
		var scope = this;

		var shapesOffset = this.vertices.length;

		var shapePoints = shape.extractPoints(curveSegments);

		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;

		var reverse = !THREE.ShapeUtils.isClockWise(vertices);

		if (reverse) {

			vertices = vertices.reverse();

			// Maybe we should also check if holes are in the opposite direction, just to be safe ...

			for (h = 0, hl = holes.length; h < hl; h++) {

				ahole = holes[h];

				if (THREE.ShapeUtils.isClockWise(ahole)) {

					holes[h] = ahole.reverse();

				}

			}

			reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

		}


		var faces = THREE.ShapeUtils.triangulateShape(vertices, holes);

		/* Vertices */

		var contour = vertices; // vertices has all points but contour has only points of circumference

		for (h = 0, hl = holes.length; h < hl; h++) {

			ahole = holes[h];

			vertices = vertices.concat(ahole);

		}


		function scalePt2(pt, vec, size) {

			if (!vec) console.error("");

			return vec.clone().multiplyScalar(size).add(pt);

		}

		var b, bs, t, z,
			vert, vlen = vertices.length,
			face, flen = faces.length;


		// Find directions for point movement


		function getBevelVec(inPt, inPrev, inNext) {

			// computes for inPt the corresponding point inPt' on a new contour
			//   shifted by 1 unit (length of normalized vector) to the left
			// if we walk along contour clockwise, this new contour is outside the old one
			//
			// inPt' is the intersection of the two lines parallel to the two
			//  adjacent edges of inPt at a distance of 1 unit on the left side.

			var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

			// good reading for geometry algorithms (here: line-line intersection)
			// http://geomalgorithms.com/a05-_intersect-1.html

			var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
			var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

			var v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);

			// check for collinear edges
			var collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);

			if (Math.abs(collinear0) > Number.EPSILON) {

				// not collinear

				// length of vectors for normalizing

				var v_prev_len = Math.sqrt(v_prev_lensq);
				var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);

				// shift adjacent points by unit vectors to the left

				var ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
				var ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);

				var ptNextShift_x = (inNext.x - v_next_y / v_next_len);
				var ptNextShift_y = (inNext.y + v_next_x / v_next_len);

				// scaling factor for v_prev to intersection point

				var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y -
					(ptNextShift_y - ptPrevShift_y) * v_next_x) /
					(v_prev_x * v_next_y - v_prev_y * v_next_x);

				// vector from inPt to intersection point

				v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
				v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);

				// Don't normalize!, otherwise sharp corners become ugly
				//  but prevent crazy spikes
				var v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
				if (v_trans_lensq <= 2) {

					return new THREE.Vector2(v_trans_x, v_trans_y);

				} else {

					shrink_by = Math.sqrt(v_trans_lensq / 2);

				}

			} else {

				// handle special case of collinear edges

				var direction_eq = false;		// assumes: opposite
				if (v_prev_x > Number.EPSILON) {

					if (v_next_x > Number.EPSILON) {

						direction_eq = true;

					}

				} else {

					if (v_prev_x < - Number.EPSILON) {

						if (v_next_x < - Number.EPSILON) {

							direction_eq = true;

						}

					} else {

						if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {

							direction_eq = true;

						}

					}

				}

				if (direction_eq) {

					// console.log("Warning: lines are a straight sequence");
					v_trans_x = - v_prev_y;
					v_trans_y = v_prev_x;
					shrink_by = Math.sqrt(v_prev_lensq);

				} else {

					// console.log("Warning: lines are a straight spike");
					v_trans_x = v_prev_x;
					v_trans_y = v_prev_y;
					shrink_by = Math.sqrt(v_prev_lensq / 2);

				}

			}

			return new THREE.Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);

		}


		var contourMovements = [];

		for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {

			if (j === il) j = 0;
			if (k === il) k = 0;

			//  (j)---(i)---(k)
			// console.log('i,j,k', i, j , k)

			contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);

		}

		var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

		for (h = 0, hl = holes.length; h < hl; h++) {

			ahole = holes[h];

			oneHoleMovements = [];

			for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {

				if (j === il) j = 0;
				if (k === il) k = 0;

				//  (j)---(i)---(k)
				oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);

			}

			holesMovements.push(oneHoleMovements);
			verticesMovements = verticesMovements.concat(oneHoleMovements);

		}


		// Loop bevelSegments, 1 for the front, 1 for the back

		for (b = 0; b < bevelSegments; b++) {

			//for ( b = bevelSegments; b > 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * (1 - t);

			//z = bevelThickness * t;
			bs = bevelSize * (Math.sin(t * Math.PI / 2)); // curved
			//bs = bevelSize * t; // linear

			// contract shape

			for (i = 0, il = contour.length; i < il; i++) {

				vert = scalePt2(contour[i], contourMovements[i], bs);

				v(vert.x, vert.y, - z);

			}

			// expand holes

			for (h = 0, hl = holes.length; h < hl; h++) {

				ahole = holes[h];
				oneHoleMovements = holesMovements[h];

				for (i = 0, il = ahole.length; i < il; i++) {

					vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

					v(vert.x, vert.y, - z);

				}

			}

		}

		bs = bevelSize;

		// Back facing vertices

		for (i = 0; i < vlen; i++) {

			vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

			if (!extrudeByPath) {

				v(vert.x, vert.y, 0);

			} else {

				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

				normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
				binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);

				position2.copy(extrudePts[0]).add(normal).add(binormal);

				v(position2.x, position2.y, position2.z);

			}

		}

		// Add stepped vertices...
		// Including front facing vertices

		var s;

		for (s = 1; s <= steps; s++) {

			for (i = 0; i < vlen; i++) {

				vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

				if (!extrudeByPath) {

					v(vert.x, vert.y, amount / steps * s);

				} else {

					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

					normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
					binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);

					position2.copy(extrudePts[s]).add(normal).add(binormal);

					v(position2.x, position2.y, position2.z);

				}

			}

		}


		// Add bevel segments planes

		//for ( b = 1; b <= bevelSegments; b ++ ) {
		for (b = bevelSegments - 1; b >= 0; b--) {

			t = b / bevelSegments;
			z = bevelThickness * (1 - t);
			//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
			bs = bevelSize * Math.sin(t * Math.PI / 2);

			// contract shape

			for (i = 0, il = contour.length; i < il; i++) {

				vert = scalePt2(contour[i], contourMovements[i], bs);
				v(vert.x, vert.y, amount + z);

			}

			// expand holes

			for (h = 0, hl = holes.length; h < hl; h++) {

				ahole = holes[h];
				oneHoleMovements = holesMovements[h];

				for (i = 0, il = ahole.length; i < il; i++) {

					vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

					if (!extrudeByPath) {

						v(vert.x, vert.y, amount + z);

					} else {

						v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);

					}

				}

			}

		}

		/* Faces */

		// Top and bottom faces

		buildLidFaces();

		// Sides faces

		buildSideFaces();


		/////  Internal functions

		function buildLidFaces() {

			if (bevelEnabled) {

				var layer = 0; // steps + 1
				var offset = vlen * layer;

				// Bottom faces

				for (i = 0; i < flen; i++) {

					face = faces[i];
					f3(face[2] + offset, face[1] + offset, face[0] + offset);

				}

				layer = steps + bevelSegments * 2;
				offset = vlen * layer;

				// Top faces

				for (i = 0; i < flen; i++) {

					face = faces[i];
					f3(face[0] + offset, face[1] + offset, face[2] + offset);

				}

			} else {

				// Bottom faces

				for (i = 0; i < flen; i++) {

					face = faces[i];
					f3(face[2], face[1], face[0]);

				}

				// Top faces

				for (i = 0; i < flen; i++) {

					face = faces[i];
					f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);

				}

			}

		}

		// Create faces for the z-sides of the shape

		function buildSideFaces() {

			var layeroffset = 0;
			sidewalls(contour, layeroffset);
			layeroffset += contour.length;

			for (h = 0, hl = holes.length; h < hl; h++) {

				ahole = holes[h];
				sidewalls(ahole, layeroffset);

				//, true
				layeroffset += ahole.length;

			}

		}

		function sidewalls(contour, layeroffset) {

			var j, k;
			i = contour.length;

			while (--i >= 0) {

				j = i;
				k = i - 1;
				if (k < 0) k = contour.length - 1;

				//console.log('b', i,j, i-1, k,vertices.length);

				var s = 0, sl = steps + bevelSegments * 2;

				for (s = 0; s < sl; s++) {

					var slen1 = vlen * s;
					var slen2 = vlen * (s + 1);

					var a = layeroffset + j + slen1,
						b = layeroffset + k + slen1,
						c = layeroffset + k + slen2,
						d = layeroffset + j + slen2;

					f4(a, b, c, d, contour, s, sl, j, k);

				}

			}

		}


		function v(x, y, z) {

			scope.vertices.push(new THREE.Vector3(x, y, z));

		}

		function f3(a, b, c) {

			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;

			scope.faces.push(new THREE.Face3(a, b, c, null, null, 0));

			var uvs = uvgen.generateTopUV(scope, a, b, c);

			scope.faceVertexUvs[0].push(uvs);

		}

		function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {

			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
			d += shapesOffset;

			scope.faces.push(new THREE.Face3(a, b, d, null, null, 1));
			scope.faces.push(new THREE.Face3(b, c, d, null, null, 1));

			var uvs = uvgen.generateSideWallUV(scope, a, b, c, d);

			scope.faceVertexUvs[0].push([uvs[0], uvs[1], uvs[3]]);
			scope.faceVertexUvs[0].push([uvs[1], uvs[2], uvs[3]]);

		}

	};

	THREE.ExtrudeGeometry.WorldUVGenerator = {

		generateTopUV: function (geometry, indexA, indexB, indexC) {

			var vertices = geometry.vertices;

			var a = vertices[indexA];
			var b = vertices[indexB];
			var c = vertices[indexC];

			return [
				new THREE.Vector2(a.x, a.y),
				new THREE.Vector2(b.x, b.y),
				new THREE.Vector2(c.x, c.y)
			];

		},

		generateSideWallUV: function (geometry, indexA, indexB, indexC, indexD) {

			var vertices = geometry.vertices;

			var a = vertices[indexA];
			var b = vertices[indexB];
			var c = vertices[indexC];
			var d = vertices[indexD];

			if (Math.abs(a.y - b.y) < 0.01) {

				return [
					new THREE.Vector2(a.x, 1 - a.z),
					new THREE.Vector2(b.x, 1 - b.z),
					new THREE.Vector2(c.x, 1 - c.z),
					new THREE.Vector2(d.x, 1 - d.z)
				];

			} else {

				return [
					new THREE.Vector2(a.y, 1 - a.z),
					new THREE.Vector2(b.y, 1 - b.z),
					new THREE.Vector2(c.y, 1 - c.z),
					new THREE.Vector2(d.y, 1 - d.z)
				];

			}

		}
	};

	// File:src/extras/geometries/ShapeGeometry.js

	/**
	 * @author jonobr1 / http://jonobr1.com
	 *
	 * Creates a one-sided polygonal geometry from a path shape. Similar to
	 * ExtrudeGeometry.
	 *
	 * parameters = {
	 *
	 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
	 *
	 *	material: <int> // material index for front and back faces
	 *	uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/

	THREE.ShapeGeometry = function (shapes, options) {

		THREE.Geometry.call(this);

		this.type = 'ShapeGeometry';

		if (Array.isArray(shapes) === false) shapes = [shapes];

		this.addShapeList(shapes, options);

		this.computeFaceNormals();

	};

	THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
	THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

	/**
	 * Add an array of shapes to THREE.ShapeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShapeList = function (shapes, options) {

		for (var i = 0, l = shapes.length; i < l; i++) {

			this.addShape(shapes[i], options);

		}

		return this;

	};

	/**
	 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShape = function (shape, options) {

		if (options === undefined) options = {};
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

		var material = options.material;
		var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

		//

		var i, l, hole;

		var shapesOffset = this.vertices.length;
		var shapePoints = shape.extractPoints(curveSegments);

		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;

		var reverse = !THREE.ShapeUtils.isClockWise(vertices);

		if (reverse) {

			vertices = vertices.reverse();

			// Maybe we should also check if holes are in the opposite direction, just to be safe...

			for (i = 0, l = holes.length; i < l; i++) {

				hole = holes[i];

				if (THREE.ShapeUtils.isClockWise(hole)) {

					holes[i] = hole.reverse();

				}

			}

			reverse = false;

		}

		var faces = THREE.ShapeUtils.triangulateShape(vertices, holes);

		// Vertices

		for (i = 0, l = holes.length; i < l; i++) {

			hole = holes[i];
			vertices = vertices.concat(hole);

		}

		//

		var vert, vlen = vertices.length;
		var face, flen = faces.length;

		for (i = 0; i < vlen; i++) {

			vert = vertices[i];

			this.vertices.push(new THREE.Vector3(vert.x, vert.y, 0));

		}

		for (i = 0; i < flen; i++) {

			face = faces[i];

			var a = face[0] + shapesOffset;
			var b = face[1] + shapesOffset;
			var c = face[2] + shapesOffset;

			this.faces.push(new THREE.Face3(a, b, c, null, null, material));
			this.faceVertexUvs[0].push(uvgen.generateTopUV(this, a, b, c));

		}

	};

	// File:src/extras/geometries/LatheBufferGeometry.js

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// points - to create a closed torus, one must use a set of points
	//    like so: [ a, b, c, d, a ], see first is the same as last.
	// segments - the number of circumference segments to create
	// phiStart - the starting radian
	// phiLength - the radian (0 to 2PI) range of the lathed section
	//    2PI is a closed lathe, less than 2PI is a portion.

	THREE.LatheBufferGeometry = function (points, segments, phiStart, phiLength) {

		THREE.BufferGeometry.call(this);

		this.type = 'LatheBufferGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = Math.floor(segments) || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || Math.PI * 2;

		// clamp phiLength so it's in range of [ 0, 2PI ]
		phiLength = THREE.Math.clamp(phiLength, 0, Math.PI * 2);

		// these are used to calculate buffer length
		var vertexCount = (segments + 1) * points.length;
		var indexCount = segments * points.length * 2 * 3;

		// buffers
		var indices = new THREE.BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
		var vertices = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
		var uvs = new THREE.BufferAttribute(new Float32Array(vertexCount * 2), 2);

		// helper variables
		var index = 0, indexOffset = 0, base;
		var inversePointLength = 1.0 / (points.length - 1);
		var inverseSegments = 1.0 / segments;
		var vertex = new THREE.Vector3();
		var uv = new THREE.Vector2();
		var i, j;

		// generate vertices and uvs

		for (i = 0; i <= segments; i++) {

			var phi = phiStart + i * inverseSegments * phiLength;

			var sin = Math.sin(phi);
			var cos = Math.cos(phi);

			for (j = 0; j <= (points.length - 1); j++) {

				// vertex
				vertex.x = points[j].x * sin;
				vertex.y = points[j].y;
				vertex.z = points[j].x * cos;
				vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);

				// uv
				uv.x = i / segments;
				uv.y = j / (points.length - 1);
				uvs.setXY(index, uv.x, uv.y);

				// increase index
				index++;

			}

		}

		// generate indices

		for (i = 0; i < segments; i++) {

			for (j = 0; j < (points.length - 1); j++) {

				base = j + i * points.length;

				// indices
				var a = base;
				var b = base + points.length;
				var c = base + points.length + 1;
				var d = base + 1;

				// face one
				indices.setX(indexOffset, a); indexOffset++;
				indices.setX(indexOffset, b); indexOffset++;
				indices.setX(indexOffset, d); indexOffset++;

				// face two
				indices.setX(indexOffset, b); indexOffset++;
				indices.setX(indexOffset, c); indexOffset++;
				indices.setX(indexOffset, d); indexOffset++;

			}

		}

		// build geometry

		this.setIndex(indices);
		this.addAttribute('position', vertices);
		this.addAttribute('uv', uvs);

		// generate normals

		this.computeVertexNormals();

		// if the geometry is closed, we need to average the normals along the seam.
		// because the corresponding vertices are identical (but still have different UVs).

		if (phiLength === Math.PI * 2) {

			var normals = this.attributes.normal.array;
			var n1 = new THREE.Vector3();
			var n2 = new THREE.Vector3();
			var n = new THREE.Vector3();

			// this is the buffer offset for the last line of vertices
			base = segments * points.length * 3;

			for (i = 0, j = 0; i < points.length; i++, j += 3) {

				// select the normal of the vertex in the first line
				n1.x = normals[j + 0];
				n1.y = normals[j + 1];
				n1.z = normals[j + 2];

				// select the normal of the vertex in the last line
				n2.x = normals[base + j + 0];
				n2.y = normals[base + j + 1];
				n2.z = normals[base + j + 2];

				// average normals
				n.addVectors(n1, n2).normalize();

				// assign the new values to both normals
				normals[j + 0] = normals[base + j + 0] = n.x;
				normals[j + 1] = normals[base + j + 1] = n.y;
				normals[j + 2] = normals[base + j + 2] = n.z;

			} // next row

		}

	};

	THREE.LatheBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
	THREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;

	// File:src/extras/geometries/LatheGeometry.js

	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://clara.io
	 */

	// points - to create a closed torus, one must use a set of points
	//    like so: [ a, b, c, d, a ], see first is the same as last.
	// segments - the number of circumference segments to create
	// phiStart - the starting radian
	// phiLength - the radian (0 to 2PI) range of the lathed section
	//    2PI is a closed lathe, less than 2PI is a portion.

	THREE.LatheGeometry = function (points, segments, phiStart, phiLength) {

		THREE.Geometry.call(this);

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		this.fromBufferGeometry(new THREE.LatheBufferGeometry(points, segments, phiStart, phiLength));
		this.mergeVertices();

	};

	THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
	THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

	// File:src/extras/geometries/PlaneGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */

	THREE.PlaneGeometry = function (width, height, widthSegments, heightSegments) {

		THREE.Geometry.call(this);

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		this.fromBufferGeometry(new THREE.PlaneBufferGeometry(width, height, widthSegments, heightSegments));

	};

	THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
	THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

	// File:src/extras/geometries/PlaneBufferGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */

	THREE.PlaneBufferGeometry = function (width, height, widthSegments, heightSegments) {

		THREE.BufferGeometry.call(this);

		this.type = 'PlaneBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		var width_half = width / 2;
		var height_half = height / 2;

		var gridX = Math.floor(widthSegments) || 1;
		var gridY = Math.floor(heightSegments) || 1;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var segment_width = width / gridX;
		var segment_height = height / gridY;

		var vertices = new Float32Array(gridX1 * gridY1 * 3);
		var normals = new Float32Array(gridX1 * gridY1 * 3);
		var uvs = new Float32Array(gridX1 * gridY1 * 2);

		var offset = 0;
		var offset2 = 0;

		for (var iy = 0; iy < gridY1; iy++) {

			var y = iy * segment_height - height_half;

			for (var ix = 0; ix < gridX1; ix++) {

				var x = ix * segment_width - width_half;

				vertices[offset] = x;
				vertices[offset + 1] = - y;

				normals[offset + 2] = 1;

				uvs[offset2] = ix / gridX;
				uvs[offset2 + 1] = 1 - (iy / gridY);

				offset += 3;
				offset2 += 2;

			}

		}

		offset = 0;

		var indices = new ((vertices.length / 3) > 65535 ? Uint32Array : Uint16Array)(gridX * gridY * 6);

		for (var iy = 0; iy < gridY; iy++) {

			for (var ix = 0; ix < gridX; ix++) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * (iy + 1);
				var c = (ix + 1) + gridX1 * (iy + 1);
				var d = (ix + 1) + gridX1 * iy;

				indices[offset] = a;
				indices[offset + 1] = b;
				indices[offset + 2] = d;

				indices[offset + 3] = b;
				indices[offset + 4] = c;
				indices[offset + 5] = d;

				offset += 6;

			}

		}

		this.setIndex(new THREE.BufferAttribute(indices, 1));
		this.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
		this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
		this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));

	};

	THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
	THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

	// File:src/extras/geometries/RingBufferGeometry.js

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	THREE.RingBufferGeometry = function (innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {

		THREE.BufferGeometry.call(this);

		this.type = 'RingBufferGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		innerRadius = innerRadius || 20;
		outerRadius = outerRadius || 50;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
		phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;

		// these are used to calculate buffer length
		var vertexCount = (thetaSegments + 1) * (phiSegments + 1);
		var indexCount = thetaSegments * phiSegments * 2 * 3;

		// buffers
		var indices = new THREE.BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
		var vertices = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
		var normals = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
		var uvs = new THREE.BufferAttribute(new Float32Array(vertexCount * 2), 2);

		// some helper variables
		var index = 0, indexOffset = 0, segment;
		var radius = innerRadius;
		var radiusStep = ((outerRadius - innerRadius) / phiSegments);
		var vertex = new THREE.Vector3();
		var uv = new THREE.Vector2();
		var j, i;

		// generate vertices, normals and uvs

		// values are generate from the inside of the ring to the outside

		for (j = 0; j <= phiSegments; j++) {

			for (i = 0; i <= thetaSegments; i++) {

				segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex
				vertex.x = radius * Math.cos(segment);
				vertex.y = radius * Math.sin(segment);
				vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);

				// normal
				normals.setXYZ(index, 0, 0, 1);

				// uv
				uv.x = (vertex.x / outerRadius + 1) / 2;
				uv.y = (vertex.y / outerRadius + 1) / 2;
				uvs.setXY(index, uv.x, uv.y);

				// increase index
				index++;

			}

			// increase the radius for next row of vertices
			radius += radiusStep;

		}

		// generate indices

		for (j = 0; j < phiSegments; j++) {

			var thetaSegmentLevel = j * (thetaSegments + 1);

			for (i = 0; i < thetaSegments; i++) {

				segment = i + thetaSegmentLevel;

				// indices
				var a = segment;
				var b = segment + thetaSegments + 1;
				var c = segment + thetaSegments + 2;
				var d = segment + 1;

				// face one
				indices.setX(indexOffset, a); indexOffset++;
				indices.setX(indexOffset, b); indexOffset++;
				indices.setX(indexOffset, c); indexOffset++;

				// face two
				indices.setX(indexOffset, a); indexOffset++;
				indices.setX(indexOffset, c); indexOffset++;
				indices.setX(indexOffset, d); indexOffset++;

			}

		}

		// build geometry

		this.setIndex(indices);
		this.addAttribute('position', vertices);
		this.addAttribute('normal', normals);
		this.addAttribute('uv', uvs);

	};

	THREE.RingBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
	THREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;

	// File:src/extras/geometries/RingGeometry.js

	/**
	 * @author Kaleb Murphy
	 */

	THREE.RingGeometry = function (innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {

		THREE.Geometry.call(this);

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry(new THREE.RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));

	};

	THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
	THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;

	// File:src/extras/geometries/SphereGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.SphereGeometry = function (radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {

		THREE.Geometry.call(this);

		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry(new THREE.SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));

	};

	THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
	THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

	// File:src/extras/geometries/SphereBufferGeometry.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * based on THREE.SphereGeometry
	 */

	THREE.SphereBufferGeometry = function (radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {

		THREE.BufferGeometry.call(this);

		this.type = 'SphereBufferGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 50;

		widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
		heightSegments = Math.max(2, Math.floor(heightSegments) || 6);

		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

		var thetaEnd = thetaStart + thetaLength;

		var vertexCount = ((widthSegments + 1) * (heightSegments + 1));

		var positions = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
		var normals = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
		var uvs = new THREE.BufferAttribute(new Float32Array(vertexCount * 2), 2);

		var index = 0, vertices = [], normal = new THREE.Vector3();

		for (var y = 0; y <= heightSegments; y++) {

			var verticesRow = [];

			var v = y / heightSegments;

			for (var x = 0; x <= widthSegments; x++) {

				var u = x / widthSegments;

				var px = - radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
				var py = radius * Math.cos(thetaStart + v * thetaLength);
				var pz = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);

				normal.set(px, py, pz).normalize();

				positions.setXYZ(index, px, py, pz);
				normals.setXYZ(index, normal.x, normal.y, normal.z);
				uvs.setXY(index, u, 1 - v);

				verticesRow.push(index);

				index++;

			}

			vertices.push(verticesRow);

		}

		var indices = [];

		for (var y = 0; y < heightSegments; y++) {

			for (var x = 0; x < widthSegments; x++) {

				var v1 = vertices[y][x + 1];
				var v2 = vertices[y][x];
				var v3 = vertices[y + 1][x];
				var v4 = vertices[y + 1][x + 1];

				if (y !== 0 || thetaStart > 0) indices.push(v1, v2, v4);
				if (y !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(v2, v3, v4);

			}

		}

		this.setIndex(new (positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute)(indices, 1));
		this.addAttribute('position', positions);
		this.addAttribute('normal', normals);
		this.addAttribute('uv', uvs);

		this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);

	};

	THREE.SphereBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
	THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;

	// File:src/extras/geometries/TextGeometry.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  font: <THREE.Font>, // font
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float> // how far from text outline is bevel
	 * }
	 */

	THREE.TextGeometry = function (text, parameters) {

		parameters = parameters || {};

		var font = parameters.font;

		if (font instanceof THREE.Font === false) {

			//console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
			return new THREE.Geometry();

		}

		var shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);

		// translate parameters to ExtrudeGeometry API

		parameters.amount = parameters.height !== undefined ? parameters.height : 50;

		// defaults

		if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
		if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
		if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;

		THREE.ExtrudeGeometry.call(this, shapes, parameters);

		this.type = 'TextGeometry';

	};

	THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);
	THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;

	// File:src/extras/geometries/TorusBufferGeometry.js

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	THREE.TorusBufferGeometry = function (radius, tube, radialSegments, tubularSegments, arc) {

		THREE.BufferGeometry.call(this);

		this.type = 'TorusBufferGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radius = radius || 100;
		tube = tube || 40;
		radialSegments = Math.floor(radialSegments) || 8;
		tubularSegments = Math.floor(tubularSegments) || 6;
		arc = arc || Math.PI * 2;

		// used to calculate buffer length
		var vertexCount = ((radialSegments + 1) * (tubularSegments + 1));
		var indexCount = radialSegments * tubularSegments * 2 * 3;

		// buffers
		var indices = new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount);
		var vertices = new Float32Array(vertexCount * 3);
		var normals = new Float32Array(vertexCount * 3);
		var uvs = new Float32Array(vertexCount * 2);

		// offset variables
		var vertexBufferOffset = 0;
		var uvBufferOffset = 0;
		var indexBufferOffset = 0;

		// helper variables
		var center = new THREE.Vector3();
		var vertex = new THREE.Vector3();
		var normal = new THREE.Vector3();

		var j, i;

		// generate vertices, normals and uvs

		for (j = 0; j <= radialSegments; j++) {

			for (i = 0; i <= tubularSegments; i++) {

				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;

				// vertex
				vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
				vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
				vertex.z = tube * Math.sin(v);

				vertices[vertexBufferOffset] = vertex.x;
				vertices[vertexBufferOffset + 1] = vertex.y;
				vertices[vertexBufferOffset + 2] = vertex.z;

				// this vector is used to calculate the normal
				center.x = radius * Math.cos(u);
				center.y = radius * Math.sin(u);

				// normal
				normal.subVectors(vertex, center).normalize();

				normals[vertexBufferOffset] = normal.x;
				normals[vertexBufferOffset + 1] = normal.y;
				normals[vertexBufferOffset + 2] = normal.z;

				// uv
				uvs[uvBufferOffset] = i / tubularSegments;
				uvs[uvBufferOffset + 1] = j / radialSegments;

				// update offsets
				vertexBufferOffset += 3;
				uvBufferOffset += 2;

			}

		}

		// generate indices

		for (j = 1; j <= radialSegments; j++) {

			for (i = 1; i <= tubularSegments; i++) {

				// indices
				var a = (tubularSegments + 1) * j + i - 1;
				var b = (tubularSegments + 1) * (j - 1) + i - 1;
				var c = (tubularSegments + 1) * (j - 1) + i;
				var d = (tubularSegments + 1) * j + i;

				// face one
				indices[indexBufferOffset] = a;
				indices[indexBufferOffset + 1] = b;
				indices[indexBufferOffset + 2] = d;

				// face two
				indices[indexBufferOffset + 3] = b;
				indices[indexBufferOffset + 4] = c;
				indices[indexBufferOffset + 5] = d;

				// update offset
				indexBufferOffset += 6;

			}

		}

		// build geometry
		this.setIndex(new THREE.BufferAttribute(indices, 1));
		this.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
		this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
		this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));

	};

	THREE.TorusBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
	THREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;

	// File:src/extras/geometries/TorusGeometry.js

	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
	 */

	THREE.TorusGeometry = function (radius, tube, radialSegments, tubularSegments, arc) {

		THREE.Geometry.call(this);

		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		this.fromBufferGeometry(new THREE.TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));

	};

	THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
	THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

	// File:src/extras/geometries/TorusKnotBufferGeometry.js

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * see: http://www.blackpawn.com/texts/pqtorus/
	 */
	THREE.TorusKnotBufferGeometry = function (radius, tube, tubularSegments, radialSegments, p, q) {

		THREE.BufferGeometry.call(this);

		this.type = 'TorusKnotBufferGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		radius = radius || 100;
		tube = tube || 40;
		tubularSegments = Math.floor(tubularSegments) || 64;
		radialSegments = Math.floor(radialSegments) || 8;
		p = p || 2;
		q = q || 3;

		// used to calculate buffer length
		var vertexCount = ((radialSegments + 1) * (tubularSegments + 1));
		var indexCount = radialSegments * tubularSegments * 2 * 3;

		// buffers
		var indices = new THREE.BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
		var vertices = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
		var normals = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
		var uvs = new THREE.BufferAttribute(new Float32Array(vertexCount * 2), 2);

		// helper variables
		var i, j, index = 0, indexOffset = 0;

		var vertex = new THREE.Vector3();
		var normal = new THREE.Vector3();
		var uv = new THREE.Vector2();

		var P1 = new THREE.Vector3();
		var P2 = new THREE.Vector3();

		var B = new THREE.Vector3();
		var T = new THREE.Vector3();
		var N = new THREE.Vector3();

		// generate vertices, normals and uvs

		for (i = 0; i <= tubularSegments; ++i) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

			var u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve(u, p, q, radius, P1);
			calculatePositionOnCurve(u + 0.01, p, q, radius, P2);

			// calculate orthonormal basis

			T.subVectors(P2, P1);
			N.addVectors(P2, P1);
			B.crossVectors(T, N);
			N.crossVectors(B, T);

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for (j = 0; j <= radialSegments; ++j) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				var v = j / radialSegments * Math.PI * 2;
				var cx = - tube * Math.cos(v);
				var cy = tube * Math.sin(v);

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

				vertex.x = P1.x + (cx * N.x + cy * B.x);
				vertex.y = P1.y + (cx * N.y + cy * B.y);
				vertex.z = P1.z + (cx * N.z + cy * B.z);

				// vertex
				vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
				normal.subVectors(vertex, P1).normalize();
				normals.setXYZ(index, normal.x, normal.y, normal.z);

				// uv
				uv.x = i / tubularSegments;
				uv.y = j / radialSegments;
				uvs.setXY(index, uv.x, uv.y);

				// increase index
				index++;

			}

		}

		// generate indices

		for (j = 1; j <= tubularSegments; j++) {

			for (i = 1; i <= radialSegments; i++) {

				// indices
				var a = (radialSegments + 1) * (j - 1) + (i - 1);
				var b = (radialSegments + 1) * j + (i - 1);
				var c = (radialSegments + 1) * j + i;
				var d = (radialSegments + 1) * (j - 1) + i;

				// face one
				indices.setX(indexOffset, a); indexOffset++;
				indices.setX(indexOffset, b); indexOffset++;
				indices.setX(indexOffset, d); indexOffset++;

				// face two
				indices.setX(indexOffset, b); indexOffset++;
				indices.setX(indexOffset, c); indexOffset++;
				indices.setX(indexOffset, d); indexOffset++;

			}

		}

		// build geometry

		this.setIndex(indices);
		this.addAttribute('position', vertices);
		this.addAttribute('normal', normals);
		this.addAttribute('uv', uvs);

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve(u, p, q, radius, position) {

			var cu = Math.cos(u);
			var su = Math.sin(u);
			var quOverP = q / p * u;
			var cs = Math.cos(quOverP);

			position.x = radius * (2 + cs) * 0.5 * cu;
			position.y = radius * (2 + cs) * su * 0.5;
			position.z = radius * Math.sin(quOverP) * 0.5;

		}

	};

	THREE.TorusKnotBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
	THREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;

	// File:src/extras/geometries/TorusKnotGeometry.js

	/**
	 * @author oosmoxiecode
	 */

	THREE.TorusKnotGeometry = function (radius, tube, tubularSegments, radialSegments, p, q, heightScale) {

		THREE.Geometry.call(this);

		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		//if( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

		this.fromBufferGeometry(new THREE.TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
		this.mergeVertices();

	};

	THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);
	THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

	// File:src/extras/geometries/TubeGeometry.js

	/**
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 *
	 * Modified from the TorusKnotGeometry by @oosmoxiecode
	 *
	 * Creates a tube which extrudes along a 3d spline
	 *
	 * Uses parallel transport frames as described in
	 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	 */

	THREE.TubeGeometry = function (path, segments, radius, radialSegments, closed, taper) {

		THREE.Geometry.call(this);

		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			segments: segments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed,
			taper: taper
		};

		segments = segments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;
		taper = taper || THREE.TubeGeometry.NoTaper;

		var grid = [];

		var scope = this,

			tangent,
			normal,
			binormal,

			numpoints = segments + 1,

			u, v, r,

			cx, cy,
			pos, pos2 = new THREE.Vector3(),
			i, j,
			ip, jp,
			a, b, c, d,
			uva, uvb, uvc, uvd;

		var frames = new THREE.TubeGeometry.FrenetFrames(path, segments, closed),
			tangents = frames.tangents,
			normals = frames.normals,
			binormals = frames.binormals;

		// proxy internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;

		function vert(x, y, z) {

			return scope.vertices.push(new THREE.Vector3(x, y, z)) - 1;

		}

		// construct the grid

		for (i = 0; i < numpoints; i++) {

			grid[i] = [];

			u = i / (numpoints - 1);

			pos = path.getPointAt(u);

			tangent = tangents[i];
			normal = normals[i];
			binormal = binormals[i];

			r = radius * taper(u);

			for (j = 0; j < radialSegments; j++) {

				v = j / radialSegments * 2 * Math.PI;

				cx = - r * Math.cos(v); // TODO: Hack: Negating it so it faces outside.
				cy = r * Math.sin(v);

				pos2.copy(pos);
				pos2.x += cx * normal.x + cy * binormal.x;
				pos2.y += cx * normal.y + cy * binormal.y;
				pos2.z += cx * normal.z + cy * binormal.z;

				grid[i][j] = vert(pos2.x, pos2.y, pos2.z);

			}

		}


		// construct the mesh

		for (i = 0; i < segments; i++) {

			for (j = 0; j < radialSegments; j++) {

				ip = (closed) ? (i + 1) % segments : i + 1;
				jp = (j + 1) % radialSegments;

				a = grid[i][j];		// *** NOT NECESSARILY PLANAR ! ***
				b = grid[ip][j];
				c = grid[ip][jp];
				d = grid[i][jp];

				uva = new THREE.Vector2(i / segments, j / radialSegments);
				uvb = new THREE.Vector2((i + 1) / segments, j / radialSegments);
				uvc = new THREE.Vector2((i + 1) / segments, (j + 1) / radialSegments);
				uvd = new THREE.Vector2(i / segments, (j + 1) / radialSegments);

				this.faces.push(new THREE.Face3(a, b, d));
				this.faceVertexUvs[0].push([uva, uvb, uvd]);

				this.faces.push(new THREE.Face3(b, c, d));
				this.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);

			}

		}

		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
	THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;

	THREE.TubeGeometry.NoTaper = function (u) {

		return 1;

	};

	THREE.TubeGeometry.SinusoidalTaper = function (u) {

		return Math.sin(Math.PI * u);

	};

	// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
	THREE.TubeGeometry.FrenetFrames = function (path, segments, closed) {

		var normal = new THREE.Vector3(),

			tangents = [],
			normals = [],
			binormals = [],

			vec = new THREE.Vector3(),
			mat = new THREE.Matrix4(),

			numpoints = segments + 1,
			theta,
			smallest,

			tx, ty, tz,
			i, u;


		// expose internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;

		// compute the tangent vectors for each segment on the path

		for (i = 0; i < numpoints; i++) {

			u = i / (numpoints - 1);

			tangents[i] = path.getTangentAt(u);
			tangents[i].normalize();

		}

		initialNormal3();

		/*
		function initialNormal1(lastBinormal) {
			// fixed start binormal. Has dangers of 0 vectors
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
			normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
		}
	
		function initialNormal2() {
	
			// This uses the Frenet-Serret formula for deriving binormal
			var t2 = path.getTangentAt( epsilon );
	
			normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
			binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );
	
			normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	
		}
		*/

		function initialNormal3() {

			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the smallest tangent xyz component

			normals[0] = new THREE.Vector3();
			binormals[0] = new THREE.Vector3();
			smallest = Number.MAX_VALUE;
			tx = Math.abs(tangents[0].x);
			ty = Math.abs(tangents[0].y);
			tz = Math.abs(tangents[0].z);

			if (tx <= smallest) {

				smallest = tx;
				normal.set(1, 0, 0);

			}

			if (ty <= smallest) {

				smallest = ty;
				normal.set(0, 1, 0);

			}

			if (tz <= smallest) {

				normal.set(0, 0, 1);

			}

			vec.crossVectors(tangents[0], normal).normalize();

			normals[0].crossVectors(tangents[0], vec);
			binormals[0].crossVectors(tangents[0], normals[0]);

		}


		// compute the slowly-varying normal and binormal vectors for each segment on the path

		for (i = 1; i < numpoints; i++) {

			normals[i] = normals[i - 1].clone();

			binormals[i] = binormals[i - 1].clone();

			vec.crossVectors(tangents[i - 1], tangents[i]);

			if (vec.length() > Number.EPSILON) {

				vec.normalize();

				theta = Math.acos(THREE.Math.clamp(tangents[i - 1].dot(tangents[i]), - 1, 1)); // clamp for floating pt errors

				normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));

			}

			binormals[i].crossVectors(tangents[i], normals[i]);

		}


		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if (closed) {

			theta = Math.acos(THREE.Math.clamp(normals[0].dot(normals[numpoints - 1]), - 1, 1));
			theta /= (numpoints - 1);

			if (tangents[0].dot(vec.crossVectors(normals[0], normals[numpoints - 1])) > 0) {

				theta = - theta;

			}

			for (i = 1; i < numpoints; i++) {

				// twist a little...
				normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
				binormals[i].crossVectors(tangents[i], normals[i]);

			}

		}

	};

	// File:src/extras/geometries/PolyhedronGeometry.js

	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.PolyhedronGeometry = function (vertices, indices, radius, detail) {

		THREE.Geometry.call(this);

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		radius = radius || 1;
		detail = detail || 0;

		var that = this;

		for (var i = 0, l = vertices.length; i < l; i += 3) {

			prepare(new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));

		}

		var p = this.vertices;

		var faces = [];

		for (var i = 0, j = 0, l = indices.length; i < l; i += 3, j++) {

			var v1 = p[indices[i]];
			var v2 = p[indices[i + 1]];
			var v3 = p[indices[i + 2]];

			faces[j] = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()]);

		}

		var centroid = new THREE.Vector3();

		for (var i = 0, l = faces.length; i < l; i++) {

			subdivide(faces[i], detail);

		}


		// Handle case when face straddles the seam

		for (var i = 0, l = this.faceVertexUvs[0].length; i < l; i++) {

			var uvs = this.faceVertexUvs[0][i];

			var x0 = uvs[0].x;
			var x1 = uvs[1].x;
			var x2 = uvs[2].x;

			var max = Math.max(x0, x1, x2);
			var min = Math.min(x0, x1, x2);

			if (max > 0.9 && min < 0.1) {

				// 0.9 is somewhat arbitrary

				if (x0 < 0.2) uvs[0].x += 1;
				if (x1 < 0.2) uvs[1].x += 1;
				if (x2 < 0.2) uvs[2].x += 1;

			}

		}


		// Apply radius

		for (var i = 0, l = this.vertices.length; i < l; i++) {

			this.vertices[i].multiplyScalar(radius);

		}


		// Merge vertices

		this.mergeVertices();

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);


		// Project vector onto sphere's surface

		function prepare(vector) {

			var vertex = vector.normalize().clone();
			vertex.index = that.vertices.push(vertex) - 1;

			// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

			var u = azimuth(vector) / 2 / Math.PI + 0.5;
			var v = inclination(vector) / Math.PI + 0.5;
			vertex.uv = new THREE.Vector2(u, 1 - v);

			return vertex;

		}


		// Approximate a curved face with recursively sub-divided triangles.

		function make(v1, v2, v3) {

			var face = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()]);
			that.faces.push(face);

			centroid.copy(v1).add(v2).add(v3).divideScalar(3);

			var azi = azimuth(centroid);

			that.faceVertexUvs[0].push([
				correctUV(v1.uv, v1, azi),
				correctUV(v2.uv, v2, azi),
				correctUV(v3.uv, v3, azi)
			]);

		}


		// Analytically subdivide a face to the required detail level.

		function subdivide(face, detail) {

			var cols = Math.pow(2, detail);
			var a = prepare(that.vertices[face.a]);
			var b = prepare(that.vertices[face.b]);
			var c = prepare(that.vertices[face.c]);
			var v = [];

			// Construct all of the vertices for this subdivision.

			for (var i = 0; i <= cols; i++) {

				v[i] = [];

				var aj = prepare(a.clone().lerp(c, i / cols));
				var bj = prepare(b.clone().lerp(c, i / cols));
				var rows = cols - i;

				for (var j = 0; j <= rows; j++) {

					if (j === 0 && i === cols) {

						v[i][j] = aj;

					} else {

						v[i][j] = prepare(aj.clone().lerp(bj, j / rows));

					}

				}

			}

			// Construct all of the faces.

			for (var i = 0; i < cols; i++) {

				for (var j = 0; j < 2 * (cols - i) - 1; j++) {

					var k = Math.floor(j / 2);

					if (j % 2 === 0) {

						make(
							v[i][k + 1],
							v[i + 1][k],
							v[i][k]
						);

					} else {

						make(
							v[i][k + 1],
							v[i + 1][k + 1],
							v[i + 1][k]
						);

					}

				}

			}

		}


		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth(vector) {

			return Math.atan2(vector.z, - vector.x);

		}


		// Angle above the XZ plane.

		function inclination(vector) {

			return Math.atan2(- vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));

		}


		// Texture fixing helper. Spheres have some odd behaviours.

		function correctUV(uv, vector, azimuth) {

			if ((azimuth < 0) && (uv.x === 1)) uv = new THREE.Vector2(uv.x - 1, uv.y);
			if ((vector.x === 0) && (vector.z === 0)) uv = new THREE.Vector2(azimuth / 2 / Math.PI + 0.5, uv.y);
			return uv.clone();

		}


	};

	THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
	THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

	// File:src/extras/geometries/DodecahedronGeometry.js

	/**
	 * @author Abe Pazos / https://hamoid.com
	 */

	THREE.DodecahedronGeometry = function (radius, detail) {

		var t = (1 + Math.sqrt(5)) / 2;
		var r = 1 / t;

		var vertices = [

			// (1, 1, 1)
			- 1, - 1, - 1, - 1, - 1, 1,
			- 1, 1, - 1, - 1, 1, 1,
			1, - 1, - 1, 1, - 1, 1,
			1, 1, - 1, 1, 1, 1,

			// (0, 1/, )
			0, - r, - t, 0, - r, t,
			0, r, - t, 0, r, t,

			// (1/, , 0)
			- r, - t, 0, - r, t, 0,
			r, - t, 0, r, t, 0,

			// (, 0, 1/)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];

		var indices = [
			3, 11, 7, 3, 7, 15, 3, 15, 13,
			7, 19, 17, 7, 17, 6, 7, 6, 15,
			17, 4, 8, 17, 8, 10, 17, 10, 6,
			8, 0, 16, 8, 16, 2, 8, 2, 10,
			0, 12, 1, 0, 1, 18, 0, 18, 16,
			6, 10, 2, 6, 2, 13, 6, 13, 15,
			2, 16, 18, 2, 18, 3, 2, 3, 13,
			18, 1, 9, 18, 9, 11, 18, 11, 3,
			4, 14, 12, 4, 12, 0, 4, 0, 8,
			11, 9, 5, 11, 5, 19, 11, 19, 7,
			19, 5, 14, 19, 14, 4, 19, 4, 17,
			1, 12, 14, 1, 14, 5, 1, 5, 9
		];

		THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.DodecahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
	THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

	// File:src/extras/geometries/IcosahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.IcosahedronGeometry = function (radius, detail) {

		var t = (1 + Math.sqrt(5)) / 2;

		var vertices = [
			- 1, t, 0, 1, t, 0, - 1, - t, 0, 1, - t, 0,
			0, - 1, t, 0, 1, t, 0, - 1, - t, 0, 1, - t,
			t, 0, - 1, t, 0, 1, - t, 0, - 1, - t, 0, 1
		];

		var indices = [
			0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11,
			1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8,
			3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
			4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
		];

		THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.IcosahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
	THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

	// File:src/extras/geometries/OctahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.OctahedronGeometry = function (radius, detail) {

		var vertices = [
			1, 0, 0, - 1, 0, 0, 0, 1, 0, 0, - 1, 0, 0, 0, 1, 0, 0, - 1
		];

		var indices = [
			0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2
		];

		THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.OctahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
	THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

	// File:src/extras/geometries/TetrahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.TetrahedronGeometry = function (radius, detail) {

		var vertices = [
			1, 1, 1, - 1, - 1, 1, - 1, 1, - 1, 1, - 1, - 1
		];

		var indices = [
			2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1
		];

		THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.TetrahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
	THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

	// File:src/extras/geometries/ParametricGeometry.js

	/**
	 * @author zz85 / https://github.com/zz85
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 *
	 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
	 *
	 */

	THREE.ParametricGeometry = function (func, slices, stacks) {

		THREE.Geometry.call(this);

		this.type = 'ParametricGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		var verts = this.vertices;
		var faces = this.faces;
		var uvs = this.faceVertexUvs[0];

		var i, j, p;
		var u, v;

		var sliceCount = slices + 1;

		for (i = 0; i <= stacks; i++) {

			v = i / stacks;

			for (j = 0; j <= slices; j++) {

				u = j / slices;

				p = func(u, v);
				verts.push(p);

			}

		}

		var a, b, c, d;
		var uva, uvb, uvc, uvd;

		for (i = 0; i < stacks; i++) {

			for (j = 0; j < slices; j++) {

				a = i * sliceCount + j;
				b = i * sliceCount + j + 1;
				c = (i + 1) * sliceCount + j + 1;
				d = (i + 1) * sliceCount + j;

				uva = new THREE.Vector2(j / slices, i / stacks);
				uvb = new THREE.Vector2((j + 1) / slices, i / stacks);
				uvc = new THREE.Vector2((j + 1) / slices, (i + 1) / stacks);
				uvd = new THREE.Vector2(j / slices, (i + 1) / stacks);

				faces.push(new THREE.Face3(a, b, d));
				uvs.push([uva, uvb, uvd]);

				faces.push(new THREE.Face3(b, c, d));
				uvs.push([uvb.clone(), uvc, uvd.clone()]);

			}

		}

		// console.log(this);

		// magic bullet
		// var diff = this.mergeVertices();
		// console.log('removed ', diff, ' vertices by merging');

		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
	THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

	// File:src/extras/geometries/WireframeGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.WireframeGeometry = function (geometry) {

		THREE.BufferGeometry.call(this);

		var edge = [0, 0], hash = {};

		function sortFunction(a, b) {

			return a - b;

		}

		var keys = ['a', 'b', 'c'];

		if (geometry instanceof THREE.Geometry) {

			var vertices = geometry.vertices;
			var faces = geometry.faces;
			var numEdges = 0;

			// allocate maximal size
			var edges = new Uint32Array(6 * faces.length);

			for (var i = 0, l = faces.length; i < l; i++) {

				var face = faces[i];

				for (var j = 0; j < 3; j++) {

					edge[0] = face[keys[j]];
					edge[1] = face[keys[(j + 1) % 3]];
					edge.sort(sortFunction);

					var key = edge.toString();

					if (hash[key] === undefined) {

						edges[2 * numEdges] = edge[0];
						edges[2 * numEdges + 1] = edge[1];
						hash[key] = true;
						numEdges++;

					}

				}

			}

			var coords = new Float32Array(numEdges * 2 * 3);

			for (var i = 0, l = numEdges; i < l; i++) {

				for (var j = 0; j < 2; j++) {

					var vertex = vertices[edges[2 * i + j]];

					var index = 6 * i + 3 * j;
					coords[index + 0] = vertex.x;
					coords[index + 1] = vertex.y;
					coords[index + 2] = vertex.z;

				}

			}

			this.addAttribute('position', new THREE.BufferAttribute(coords, 3));

		} else if (geometry instanceof THREE.BufferGeometry) {

			if (geometry.index !== null) {

				// Indexed BufferGeometry

				var indices = geometry.index.array;
				var vertices = geometry.attributes.position;
				var groups = geometry.groups;
				var numEdges = 0;

				if (groups.length === 0) {

					geometry.addGroup(0, indices.length);

				}

				// allocate maximal size
				var edges = new Uint32Array(2 * indices.length);

				for (var o = 0, ol = groups.length; o < ol; ++o) {

					var group = groups[o];

					var start = group.start;
					var count = group.count;

					for (var i = start, il = start + count; i < il; i += 3) {

						for (var j = 0; j < 3; j++) {

							edge[0] = indices[i + j];
							edge[1] = indices[i + (j + 1) % 3];
							edge.sort(sortFunction);

							var key = edge.toString();

							if (hash[key] === undefined) {

								edges[2 * numEdges] = edge[0];
								edges[2 * numEdges + 1] = edge[1];
								hash[key] = true;
								numEdges++;

							}

						}

					}

				}

				var coords = new Float32Array(numEdges * 2 * 3);

				for (var i = 0, l = numEdges; i < l; i++) {

					for (var j = 0; j < 2; j++) {

						var index = 6 * i + 3 * j;
						var index2 = edges[2 * i + j];

						coords[index + 0] = vertices.getX(index2);
						coords[index + 1] = vertices.getY(index2);
						coords[index + 2] = vertices.getZ(index2);

					}

				}

				this.addAttribute('position', new THREE.BufferAttribute(coords, 3));

			} else {

				// non-indexed BufferGeometry

				var vertices = geometry.attributes.position.array;
				var numEdges = vertices.length / 3;
				var numTris = numEdges / 3;

				var coords = new Float32Array(numEdges * 2 * 3);

				for (var i = 0, l = numTris; i < l; i++) {

					for (var j = 0; j < 3; j++) {

						var index = 18 * i + 6 * j;

						var index1 = 9 * i + 3 * j;
						coords[index + 0] = vertices[index1];
						coords[index + 1] = vertices[index1 + 1];
						coords[index + 2] = vertices[index1 + 2];

						var index2 = 9 * i + 3 * ((j + 1) % 3);
						coords[index + 3] = vertices[index2];
						coords[index + 4] = vertices[index2 + 1];
						coords[index + 5] = vertices[index2 + 2];

					}

				}

				this.addAttribute('position', new THREE.BufferAttribute(coords, 3));

			}

		}

	};

	THREE.WireframeGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
	THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;

	// File:src/extras/helpers/AxisHelper.js

	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AxisHelper = function (size) {

		size = size || 1;

		var vertices = new Float32Array([
			0, 0, 0, size, 0, 0,
			0, 0, 0, 0, size, 0,
			0, 0, 0, 0, 0, size
		]);

		var colors = new Float32Array([
			1, 0, 0, 1, 0.6, 0,
			0, 1, 0, 0.6, 1, 0,
			0, 0, 1, 0, 0.6, 1
		]);

		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
		geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));

		var material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });

		THREE.LineSegments.call(this, geometry, material);

	};

	THREE.AxisHelper.prototype = Object.create(THREE.LineSegments.prototype);
	THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

	// File:src/extras/helpers/ArrowHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://clara.io
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */

	THREE.ArrowHelper = (function () {

		var lineGeometry = new THREE.BufferGeometry();
		lineGeometry.addAttribute('position', new THREE.Float32Attribute([0, 0, 0, 0, 1, 0], 3));

		var coneGeometry = new THREE.CylinderBufferGeometry(0, 0.5, 1, 5, 1);
		coneGeometry.translate(0, - 0.5, 0);

		return function ArrowHelper(dir, origin, length, color, headLength, headWidth) {

			// dir is assumed to be normalized

			THREE.Object3D.call(this);

			if (color === undefined) color = 0xffff00;
			if (length === undefined) length = 1;
			if (headLength === undefined) headLength = 0.2 * length;
			if (headWidth === undefined) headWidth = 0.2 * headLength;

			this.position.copy(origin);

			this.line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({ color: color }));
			this.line.matrixAutoUpdate = false;
			this.add(this.line);

			this.cone = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({ color: color }));
			this.cone.matrixAutoUpdate = false;
			this.add(this.cone);

			this.setDirection(dir);
			this.setLength(length, headLength, headWidth);

		};

	}());

	THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
	THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

	THREE.ArrowHelper.prototype.setDirection = (function () {

		var axis = new THREE.Vector3();
		var radians;

		return function setDirection(dir) {

			// dir is assumed to be normalized

			if (dir.y > 0.99999) {

				this.quaternion.set(0, 0, 0, 1);

			} else if (dir.y < - 0.99999) {

				this.quaternion.set(1, 0, 0, 0);

			} else {

				axis.set(dir.z, 0, - dir.x).normalize();

				radians = Math.acos(dir.y);

				this.quaternion.setFromAxisAngle(axis, radians);

			}

		};

	}());

	THREE.ArrowHelper.prototype.setLength = function (length, headLength, headWidth) {

		if (headLength === undefined) headLength = 0.2 * length;
		if (headWidth === undefined) headWidth = 0.2 * headLength;

		this.line.scale.set(1, Math.max(0, length - headLength), 1);
		this.line.updateMatrix();

		this.cone.scale.set(headWidth, headLength, headWidth);
		this.cone.position.y = length;
		this.cone.updateMatrix();

	};

	THREE.ArrowHelper.prototype.setColor = function (color) {

		this.line.material.color.copy(color);
		this.cone.material.color.copy(color);

	};

	// File:src/extras/helpers/BoxHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BoxHelper = function (object, color) {

		if (color === undefined) color = 0xffff00;

		var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
		var positions = new Float32Array(8 * 3);

		var geometry = new THREE.BufferGeometry();
		geometry.setIndex(new THREE.BufferAttribute(indices, 1));
		geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));

		THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({ color: color }));

		if (object !== undefined) {

			this.update(object);

		}

	};

	THREE.BoxHelper.prototype = Object.create(THREE.LineSegments.prototype);
	THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

	THREE.BoxHelper.prototype.update = (function () {

		var box = new THREE.Box3();

		return function update(object) {

			if (object instanceof THREE.Box3) {

				box.copy(object);

			} else {

				box.setFromObject(object);

			}

			if (box.isEmpty()) return;

			var min = box.min;
			var max = box.max;

			/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/
	
			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			var position = this.geometry.attributes.position;
			var array = position.array;

			array[0] = max.x; array[1] = max.y; array[2] = max.z;
			array[3] = min.x; array[4] = max.y; array[5] = max.z;
			array[6] = min.x; array[7] = min.y; array[8] = max.z;
			array[9] = max.x; array[10] = min.y; array[11] = max.z;
			array[12] = max.x; array[13] = max.y; array[14] = min.z;
			array[15] = min.x; array[16] = max.y; array[17] = min.z;
			array[18] = min.x; array[19] = min.y; array[20] = min.z;
			array[21] = max.x; array[22] = min.y; array[23] = min.z;

			position.needsUpdate = true;

			this.geometry.computeBoundingSphere();

		};

	})();

	// File:src/extras/helpers/BoundingBoxHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	// a helper to show the world-axis-aligned bounding box for an object

	THREE.BoundingBoxHelper = function (object, hex) {

		var color = (hex !== undefined) ? hex : 0x888888;

		this.object = object;

		this.box = new THREE.Box3();

		THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: color, wireframe: true }));

	};

	THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
	THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

	THREE.BoundingBoxHelper.prototype.update = function () {

		this.box.setFromObject(this.object);

		this.box.size(this.scale);

		this.box.center(this.position);

	};

	// File:src/extras/helpers/CameraHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */

	THREE.CameraHelper = function (camera) {

		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial({ color: 0xffffff, vertexColors: THREE.FaceColors });

		var pointMap = {};

		// colors

		var hexFrustum = 0xffaa00;
		var hexCone = 0xff0000;
		var hexUp = 0x00aaff;
		var hexTarget = 0xffffff;
		var hexCross = 0x333333;

		// near

		addLine("n1", "n2", hexFrustum);
		addLine("n2", "n4", hexFrustum);
		addLine("n4", "n3", hexFrustum);
		addLine("n3", "n1", hexFrustum);

		// far

		addLine("f1", "f2", hexFrustum);
		addLine("f2", "f4", hexFrustum);
		addLine("f4", "f3", hexFrustum);
		addLine("f3", "f1", hexFrustum);

		// sides

		addLine("n1", "f1", hexFrustum);
		addLine("n2", "f2", hexFrustum);
		addLine("n3", "f3", hexFrustum);
		addLine("n4", "f4", hexFrustum);

		// cone

		addLine("p", "n1", hexCone);
		addLine("p", "n2", hexCone);
		addLine("p", "n3", hexCone);
		addLine("p", "n4", hexCone);

		// up

		addLine("u1", "u2", hexUp);
		addLine("u2", "u3", hexUp);
		addLine("u3", "u1", hexUp);

		// target

		addLine("c", "t", hexTarget);
		addLine("p", "c", hexCross);

		// cross

		addLine("cn1", "cn2", hexCross);
		addLine("cn3", "cn4", hexCross);

		addLine("cf1", "cf2", hexCross);
		addLine("cf3", "cf4", hexCross);

		function addLine(a, b, hex) {

			addPoint(a, hex);
			addPoint(b, hex);

		}

		function addPoint(id, hex) {

			geometry.vertices.push(new THREE.Vector3());
			geometry.colors.push(new THREE.Color(hex));

			if (pointMap[id] === undefined) {

				pointMap[id] = [];

			}

			pointMap[id].push(geometry.vertices.length - 1);

		}

		THREE.LineSegments.call(this, geometry, material);

		this.camera = camera;
		if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	};

	THREE.CameraHelper.prototype = Object.create(THREE.LineSegments.prototype);
	THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

	THREE.CameraHelper.prototype.update = function () {

		var geometry, pointMap;

		var vector = new THREE.Vector3();
		var camera = new THREE.Camera();

		function setPoint(point, x, y, z) {

			vector.set(x, y, z).unproject(camera);

			var points = pointMap[point];

			if (points !== undefined) {

				for (var i = 0, il = points.length; i < il; i++) {

					geometry.vertices[points[i]].copy(vector);

				}

			}

		}

		return function update() {

			geometry = this.geometry;
			pointMap = this.pointMap;

			var w = 1, h = 1;

			// we need just camera projection matrix
			// world matrix must be identity

			camera.projectionMatrix.copy(this.camera.projectionMatrix);

			// center / target

			setPoint("c", 0, 0, - 1);
			setPoint("t", 0, 0, 1);

			// near

			setPoint("n1", - w, - h, - 1);
			setPoint("n2", w, - h, - 1);
			setPoint("n3", - w, h, - 1);
			setPoint("n4", w, h, - 1);

			// far

			setPoint("f1", - w, - h, 1);
			setPoint("f2", w, - h, 1);
			setPoint("f3", - w, h, 1);
			setPoint("f4", w, h, 1);

			// up

			setPoint("u1", w * 0.7, h * 1.1, - 1);
			setPoint("u2", - w * 0.7, h * 1.1, - 1);
			setPoint("u3", 0, h * 2, - 1);

			// cross

			setPoint("cf1", - w, 0, 1);
			setPoint("cf2", w, 0, 1);
			setPoint("cf3", 0, - h, 1);
			setPoint("cf4", 0, h, 1);

			setPoint("cn1", - w, 0, - 1);
			setPoint("cn2", w, 0, - 1);
			setPoint("cn3", 0, - h, - 1);
			setPoint("cn4", 0, h, - 1);

			geometry.verticesNeedUpdate = true;

		};

	}();

	// File:src/extras/helpers/DirectionalLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.DirectionalLightHelper = function (light, size) {

		THREE.Object3D.call(this);

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		if (size === undefined) size = 1;

		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute('position', new THREE.Float32Attribute([
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3));

		var material = new THREE.LineBasicMaterial({ fog: false });

		this.add(new THREE.Line(geometry, material));

		geometry = new THREE.BufferGeometry();
		geometry.addAttribute('position', new THREE.Float32Attribute([0, 0, 0, 0, 0, 1], 3));

		this.add(new THREE.Line(geometry, material));

		this.update();

	};

	THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
	THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

	THREE.DirectionalLightHelper.prototype.dispose = function () {

		var lightPlane = this.children[0];
		var targetLine = this.children[1];

		lightPlane.geometry.dispose();
		lightPlane.material.dispose();
		targetLine.geometry.dispose();
		targetLine.material.dispose();

	};

	THREE.DirectionalLightHelper.prototype.update = function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var v3 = new THREE.Vector3();

		return function update() {

			v1.setFromMatrixPosition(this.light.matrixWorld);
			v2.setFromMatrixPosition(this.light.target.matrixWorld);
			v3.subVectors(v2, v1);

			var lightPlane = this.children[0];
			var targetLine = this.children[1];

			lightPlane.lookAt(v3);
			lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);

			targetLine.lookAt(v3);
			targetLine.scale.z = v3.length();

		};

	}();

	// File:src/extras/helpers/EdgesHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @param object THREE.Mesh whose geometry will be used
	 * @param hex line color
	 * @param thresholdAngle the minimum angle (in degrees),
	 * between the face normals of adjacent faces,
	 * that is required to render an edge. A value of 10 means
	 * an edge is only rendered if the angle is at least 10 degrees.
	 */

	THREE.EdgesHelper = function (object, hex, thresholdAngle) {

		var color = (hex !== undefined) ? hex : 0xffffff;

		THREE.LineSegments.call(this, new THREE.EdgesGeometry(object.geometry, thresholdAngle), new THREE.LineBasicMaterial({ color: color }));

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	};

	THREE.EdgesHelper.prototype = Object.create(THREE.LineSegments.prototype);
	THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

	// File:src/extras/helpers/FaceNormalsHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.FaceNormalsHelper = function (object, size, hex, linewidth) {

		// FaceNormalsHelper only supports THREE.Geometry

		this.object = object;

		this.size = (size !== undefined) ? size : 1;

		var color = (hex !== undefined) ? hex : 0xffff00;

		var width = (linewidth !== undefined) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if (objGeometry instanceof THREE.Geometry) {

			nNormals = objGeometry.faces.length;

		} else {

			//console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

		}

		//

		var geometry = new THREE.BufferGeometry();

		var positions = new THREE.Float32Attribute(nNormals * 2 * 3, 3);

		geometry.addAttribute('position', positions);

		THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({ color: color, linewidth: width }));

		//

		this.matrixAutoUpdate = false;
		this.update();

	};

	THREE.FaceNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype);
	THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

	THREE.FaceNormalsHelper.prototype.update = (function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var normalMatrix = new THREE.Matrix3();

		return function update() {

			this.object.updateMatrixWorld(true);

			normalMatrix.getNormalMatrix(this.object.matrixWorld);

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			var vertices = objGeometry.vertices;

			var faces = objGeometry.faces;

			var idx = 0;

			for (var i = 0, l = faces.length; i < l; i++) {

				var face = faces[i];

				var normal = face.normal;

				v1.copy(vertices[face.a])
					.add(vertices[face.b])
					.add(vertices[face.c])
					.divideScalar(3)
					.applyMatrix4(matrixWorld);

				v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);

				position.setXYZ(idx, v1.x, v1.y, v1.z);

				idx = idx + 1;

				position.setXYZ(idx, v2.x, v2.y, v2.z);

				idx = idx + 1;

			}

			position.needsUpdate = true;

			return this;

		};

	}());

	// File:src/extras/helpers/GridHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.GridHelper = function (size, step, color1, color2) {

		color1 = new THREE.Color(color1 !== undefined ? color1 : 0x444444);
		color2 = new THREE.Color(color2 !== undefined ? color2 : 0x888888);

		var vertices = [];
		var colors = [];

		for (var i = - size, j = 0; i <= size; i += step) {

			vertices.push(- size, 0, i, size, 0, i);
			vertices.push(i, 0, - size, i, 0, size);

			var color = i === 0 ? color1 : color2;

			color.toArray(colors, j); j += 3;
			color.toArray(colors, j); j += 3;
			color.toArray(colors, j); j += 3;
			color.toArray(colors, j); j += 3;

		}

		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute('position', new THREE.Float32Attribute(vertices, 3));
		geometry.addAttribute('color', new THREE.Float32Attribute(colors, 3));

		var material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });

		THREE.LineSegments.call(this, geometry, material);

	};

	THREE.GridHelper.prototype = Object.create(THREE.LineSegments.prototype);
	THREE.GridHelper.prototype.constructor = THREE.GridHelper;

	THREE.GridHelper.prototype.setColors = function () {

		//console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

	};

	// File:src/extras/helpers/HemisphereLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.HemisphereLightHelper = function (light, sphereSize) {

		THREE.Object3D.call(this);

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.colors = [new THREE.Color(), new THREE.Color()];

		var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);
		geometry.rotateX(- Math.PI / 2);

		for (var i = 0, il = 8; i < il; i++) {

			geometry.faces[i].color = this.colors[i < 4 ? 0 : 1];

		}

		var material = new THREE.MeshBasicMaterial({ vertexColors: THREE.FaceColors, wireframe: true });

		this.lightSphere = new THREE.Mesh(geometry, material);
		this.add(this.lightSphere);

		this.update();

	};

	THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
	THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

	THREE.HemisphereLightHelper.prototype.dispose = function () {

		this.lightSphere.geometry.dispose();
		this.lightSphere.material.dispose();

	};

	THREE.HemisphereLightHelper.prototype.update = function () {

		var vector = new THREE.Vector3();

		return function update() {

			this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
			this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);

			this.lightSphere.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
			this.lightSphere.geometry.colorsNeedUpdate = true;

		};

	}();

	// File:src/extras/helpers/PointLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.PointLightHelper = function (light, sphereSize) {

		this.light = light;
		this.light.updateMatrixWorld();

		var geometry = new THREE.SphereBufferGeometry(sphereSize, 4, 2);
		var material = new THREE.MeshBasicMaterial({ wireframe: true, fog: false });
		material.color.copy(this.light.color).multiplyScalar(this.light.intensity);

		THREE.Mesh.call(this, geometry, material);

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
	
		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
	
		var d = light.distance;
	
		if ( d === 0.0 ) {
	
			this.lightDistance.visible = false;
	
		} else {
	
			this.lightDistance.scale.set( d, d, d );
	
		}
	
		this.add( this.lightDistance );
		*/

	};

	THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
	THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

	THREE.PointLightHelper.prototype.dispose = function () {

		this.geometry.dispose();
		this.material.dispose();

	};

	THREE.PointLightHelper.prototype.update = function () {

		this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);

		/*
		var d = this.light.distance;
	
		if ( d === 0.0 ) {
	
			this.lightDistance.visible = false;
	
		} else {
	
			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );
	
		}
		*/

	};

	// File:src/extras/helpers/SkeletonHelper.js

	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.SkeletonHelper = function (object) {

		this.bones = this.getBoneList(object);

		var geometry = new THREE.Geometry();

		for (var i = 0; i < this.bones.length; i++) {

			var bone = this.bones[i];

			if (bone.parent instanceof THREE.Bone) {

				geometry.vertices.push(new THREE.Vector3());
				geometry.vertices.push(new THREE.Vector3());
				geometry.colors.push(new THREE.Color(0, 0, 1));
				geometry.colors.push(new THREE.Color(0, 1, 0));

			}

		}

		geometry.dynamic = true;

		var material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true });

		THREE.LineSegments.call(this, geometry, material);

		this.root = object;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();

	};


	THREE.SkeletonHelper.prototype = Object.create(THREE.LineSegments.prototype);
	THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

	THREE.SkeletonHelper.prototype.getBoneList = function (object) {

		var boneList = [];

		if (object instanceof THREE.Bone) {

			boneList.push(object);

		}

		for (var i = 0; i < object.children.length; i++) {

			boneList.push.apply(boneList, this.getBoneList(object.children[i]));

		}

		return boneList;

	};

	THREE.SkeletonHelper.prototype.update = function () {

		var geometry = this.geometry;

		var matrixWorldInv = new THREE.Matrix4().getInverse(this.root.matrixWorld);

		var boneMatrix = new THREE.Matrix4();

		var j = 0;

		for (var i = 0; i < this.bones.length; i++) {

			var bone = this.bones[i];

			if (bone.parent instanceof THREE.Bone) {

				boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
				geometry.vertices[j].setFromMatrixPosition(boneMatrix);

				boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
				geometry.vertices[j + 1].setFromMatrixPosition(boneMatrix);

				j += 2;

			}

		}

		geometry.verticesNeedUpdate = true;

		geometry.computeBoundingSphere();

	};

	// File:src/extras/helpers/SpotLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.SpotLightHelper = function (light) {

		THREE.Object3D.call(this);

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		var geometry = new THREE.BufferGeometry();

		var positions = [
			0, 0, 0, 0, 0, 1,
			0, 0, 0, 1, 0, 1,
			0, 0, 0, - 1, 0, 1,
			0, 0, 0, 0, 1, 1,
			0, 0, 0, 0, - 1, 1
		];

		for (var i = 0, j = 1, l = 32; i < l; i++, j++) {

			var p1 = (i / l) * Math.PI * 2;
			var p2 = (j / l) * Math.PI * 2;

			positions.push(
				Math.cos(p1), Math.sin(p1), 1,
				Math.cos(p2), Math.sin(p2), 1
			);

		}

		geometry.addAttribute('position', new THREE.Float32Attribute(positions, 3));

		var material = new THREE.LineBasicMaterial({ fog: false });

		this.cone = new THREE.LineSegments(geometry, material);
		this.add(this.cone);

		this.update();

	};

	THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
	THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

	THREE.SpotLightHelper.prototype.dispose = function () {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	};

	THREE.SpotLightHelper.prototype.update = function () {

		var vector = new THREE.Vector3();
		var vector2 = new THREE.Vector3();

		return function update() {

			var coneLength = this.light.distance ? this.light.distance : 1000;
			var coneWidth = coneLength * Math.tan(this.light.angle);

			this.cone.scale.set(coneWidth, coneWidth, coneLength);

			vector.setFromMatrixPosition(this.light.matrixWorld);
			vector2.setFromMatrixPosition(this.light.target.matrixWorld);

			this.cone.lookAt(vector2.sub(vector));

			this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);

		};

	}();

	// File:src/extras/helpers/VertexNormalsHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.VertexNormalsHelper = function (object, size, hex, linewidth) {

		this.object = object;

		this.size = (size !== undefined) ? size : 1;

		var color = (hex !== undefined) ? hex : 0xff0000;

		var width = (linewidth !== undefined) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if (objGeometry instanceof THREE.Geometry) {

			nNormals = objGeometry.faces.length * 3;

		} else if (objGeometry instanceof THREE.BufferGeometry) {

			nNormals = objGeometry.attributes.normal.count;

		}

		//

		var geometry = new THREE.BufferGeometry();

		var positions = new THREE.Float32Attribute(nNormals * 2 * 3, 3);

		geometry.addAttribute('position', positions);

		THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({ color: color, linewidth: width }));

		//

		this.matrixAutoUpdate = false;

		this.update();

	};

	THREE.VertexNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype);
	THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

	THREE.VertexNormalsHelper.prototype.update = (function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var normalMatrix = new THREE.Matrix3();

		return function update() {

			var keys = ['a', 'b', 'c'];

			this.object.updateMatrixWorld(true);

			normalMatrix.getNormalMatrix(this.object.matrixWorld);

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			if (objGeometry instanceof THREE.Geometry) {

				var vertices = objGeometry.vertices;

				var faces = objGeometry.faces;

				var idx = 0;

				for (var i = 0, l = faces.length; i < l; i++) {

					var face = faces[i];

					for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {

						var vertex = vertices[face[keys[j]]];

						var normal = face.vertexNormals[j];

						v1.copy(vertex).applyMatrix4(matrixWorld);

						v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);

						position.setXYZ(idx, v1.x, v1.y, v1.z);

						idx = idx + 1;

						position.setXYZ(idx, v2.x, v2.y, v2.z);

						idx = idx + 1;

					}

				}

			} else if (objGeometry instanceof THREE.BufferGeometry) {

				var objPos = objGeometry.attributes.position;

				var objNorm = objGeometry.attributes.normal;

				var idx = 0;

				// for simplicity, ignore index and drawcalls, and render every normal

				for (var j = 0, jl = objPos.count; j < jl; j++) {

					v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);

					v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));

					v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);

					position.setXYZ(idx, v1.x, v1.y, v1.z);

					idx = idx + 1;

					position.setXYZ(idx, v2.x, v2.y, v2.z);

					idx = idx + 1;

				}

			}

			position.needsUpdate = true;

			return this;

		};

	}());

	// File:src/extras/helpers/WireframeHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.WireframeHelper = function (object, hex) {

		var color = (hex !== undefined) ? hex : 0xffffff;

		THREE.LineSegments.call(this, new THREE.WireframeGeometry(object.geometry), new THREE.LineBasicMaterial({ color: color }));

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	};

	THREE.WireframeHelper.prototype = Object.create(THREE.LineSegments.prototype);
	THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

	// File:src/extras/objects/ImmediateRenderObject.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.ImmediateRenderObject = function (material) {

		THREE.Object3D.call(this);

		this.material = material;
		this.render = function (renderCallback) { };

	};

	THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);
	THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

	// File:src/extras/objects/MorphBlendMesh.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.MorphBlendMesh = function (geometry, material) {

		THREE.Mesh.call(this, geometry, material);

		this.animationsMap = {};
		this.animationsList = [];

		// prepare default animation
		// (all frames played together in 1 second)

		var numFrames = this.geometry.morphTargets.length;

		var name = "__default";

		var startFrame = 0;
		var endFrame = numFrames - 1;

		var fps = numFrames / 1;

		this.createAnimation(name, startFrame, endFrame, fps);
		this.setAnimationWeight(name, 1);

	};

	THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);
	THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

	THREE.MorphBlendMesh.prototype.createAnimation = function (name, start, end, fps) {

		var animation = {

			start: start,
			end: end,

			length: end - start + 1,

			fps: fps,
			duration: (end - start) / fps,

			lastFrame: 0,
			currentFrame: 0,

			active: false,

			time: 0,
			direction: 1,
			weight: 1,

			directionBackwards: false,
			mirroredLoop: false

		};

		this.animationsMap[name] = animation;
		this.animationsList.push(animation);

	};

	THREE.MorphBlendMesh.prototype.autoCreateAnimations = function (fps) {

		var pattern = /([a-z]+)_?(\d+)/i;

		var firstAnimation, frameRanges = {};

		var geometry = this.geometry;

		for (var i = 0, il = geometry.morphTargets.length; i < il; i++) {

			var morph = geometry.morphTargets[i];
			var chunks = morph.name.match(pattern);

			if (chunks && chunks.length > 1) {

				var name = chunks[1];

				if (!frameRanges[name]) frameRanges[name] = { start: Infinity, end: - Infinity };

				var range = frameRanges[name];

				if (i < range.start) range.start = i;
				if (i > range.end) range.end = i;

				if (!firstAnimation) firstAnimation = name;

			}

		}

		for (var name in frameRanges) {

			var range = frameRanges[name];
			this.createAnimation(name, range.start, range.end, fps);

		}

		this.firstAnimation = firstAnimation;

	};

	THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (name) {

		var animation = this.animationsMap[name];

		if (animation) {

			animation.direction = 1;
			animation.directionBackwards = false;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (name) {

		var animation = this.animationsMap[name];

		if (animation) {

			animation.direction = - 1;
			animation.directionBackwards = true;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationFPS = function (name, fps) {

		var animation = this.animationsMap[name];

		if (animation) {

			animation.fps = fps;
			animation.duration = (animation.end - animation.start) / animation.fps;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationDuration = function (name, duration) {

		var animation = this.animationsMap[name];

		if (animation) {

			animation.duration = duration;
			animation.fps = (animation.end - animation.start) / animation.duration;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationWeight = function (name, weight) {

		var animation = this.animationsMap[name];

		if (animation) {

			animation.weight = weight;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationTime = function (name, time) {

		var animation = this.animationsMap[name];

		if (animation) {

			animation.time = time;

		}

	};

	THREE.MorphBlendMesh.prototype.getAnimationTime = function (name) {

		var time = 0;

		var animation = this.animationsMap[name];

		if (animation) {

			time = animation.time;

		}

		return time;

	};

	THREE.MorphBlendMesh.prototype.getAnimationDuration = function (name) {

		var duration = - 1;

		var animation = this.animationsMap[name];

		if (animation) {

			duration = animation.duration;

		}

		return duration;

	};

	THREE.MorphBlendMesh.prototype.playAnimation = function (name) {

		var animation = this.animationsMap[name];

		if (animation) {

			animation.time = 0;
			animation.active = true;

		} else {

			//console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

		}

	};

	THREE.MorphBlendMesh.prototype.stopAnimation = function (name) {

		var animation = this.animationsMap[name];

		if (animation) {

			animation.active = false;

		}

	};

	THREE.MorphBlendMesh.prototype.update = function (delta) {

		for (var i = 0, il = this.animationsList.length; i < il; i++) {

			var animation = this.animationsList[i];

			if (!animation.active) continue;

			var frameTime = animation.duration / animation.length;

			animation.time += animation.direction * delta;

			if (animation.mirroredLoop) {

				if (animation.time > animation.duration || animation.time < 0) {

					animation.direction *= - 1;

					if (animation.time > animation.duration) {

						animation.time = animation.duration;
						animation.directionBackwards = true;

					}

					if (animation.time < 0) {

						animation.time = 0;
						animation.directionBackwards = false;

					}

				}

			} else {

				animation.time = animation.time % animation.duration;

				if (animation.time < 0) animation.time += animation.duration;

			}

			var keyframe = animation.start + THREE.Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
			var weight = animation.weight;

			if (keyframe !== animation.currentFrame) {

				this.morphTargetInfluences[animation.lastFrame] = 0;
				this.morphTargetInfluences[animation.currentFrame] = 1 * weight;

				this.morphTargetInfluences[keyframe] = 0;

				animation.lastFrame = animation.currentFrame;
				animation.currentFrame = keyframe;

			}

			var mix = (animation.time % frameTime) / frameTime;

			if (animation.directionBackwards) mix = 1 - mix;

			if (animation.currentFrame !== animation.lastFrame) {

				this.morphTargetInfluences[animation.currentFrame] = mix * weight;
				this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;

			} else {

				this.morphTargetInfluences[animation.currentFrame] = weight;

			}

		}

	};


	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mr.doob / http://mrdoob.com/
	 */

	var Detector = {

		canvas: !!window.CanvasRenderingContext2D,
		webgl: (function () {

			try {

				var canvas = document.createElement('canvas'); return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));

			} catch (e) {

				return false;

			}

		})(),
		workers: !!window.Worker,
		fileapi: window.File && window.FileReader && window.FileList && window.Blob,

		getWebGLErrorMessage: function () {

			var element = document.createElement('div');
			element.id = 'webgl-error-message';
			element.style.fontFamily = 'monospace';
			element.style.fontSize = '13px';
			element.style.fontWeight = 'normal';
			element.style.textAlign = 'center';
			element.style.background = '#fff';
			element.style.color = '#000';
			element.style.padding = '1.5em';
			element.style.width = '400px';
			element.style.margin = '5em auto 0';

			if (!this.webgl) {

				element.innerHTML = window.WebGLRenderingContext ? [
					'Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />',
					'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'
				].join('\n') : [
					'Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>',
					'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'
				].join('\n');

			}

			return element;

		},

		addGetWebGLMessage: function (parameters) {

			var parent, id, element;

			parameters = parameters || {};

			parent = parameters.parent !== undefined ? parameters.parent : document.body;
			id = parameters.id !== undefined ? parameters.id : 'oldie';

			element = Detector.getWebGLErrorMessage();
			element.id = id;

			parent.appendChild(element);

		}

	};

	// browserify support
	if (typeof module === 'object') {

		module.exports = Detector;

	}

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Based on Nvidia Cg tutorial
	 */

	THREE.FresnelShader = {

		uniforms: {

			"mRefractionRatio": { value: 1.02 },
			"mFresnelBias": { value: 0.1 },
			"mFresnelPower": { value: 2.0 },
			"mFresnelScale": { value: 1.0 },
			"tCube": { value: null }

		},

		vertexShader: [

			"uniform float mRefractionRatio;",
			"uniform float mFresnelBias;",
			"uniform float mFresnelScale;",
			"uniform float mFresnelPower;",

			"varying vec3 vReflect;",
			"varying vec3 vRefract[3];",
			"varying float vReflectionFactor;",

			"void main() {",

			"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
			"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",

			"vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );",

			"vec3 I = worldPosition.xyz - cameraPosition;",

			"vReflect = reflect( I, worldNormal );",
			"vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );",
			"vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );",
			"vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );",
			"vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );",

			"gl_Position = projectionMatrix * mvPosition;",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform samplerCube tCube;",

			"varying vec3 vReflect;",
			"varying vec3 vRefract[3];",
			"varying float vReflectionFactor;",

			"void main() {",

			"vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",
			"vec4 refractedColor = vec4( 1.0 );",

			"refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;",
			"refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;",
			"refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;",

			"gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );",

			"}"

		].join("\n")

	};

	/*
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.DDSLoader = function () {

		this._parser = THREE.DDSLoader.parse;

	};

	THREE.DDSLoader.prototype = Object.create(THREE.CompressedTextureLoader.prototype);
	THREE.DDSLoader.prototype.constructor = THREE.DDSLoader;

	THREE.DDSLoader.parse = function (buffer, loadMipmaps) {

		var dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };

		// Adapted from @toji's DDS utils
		// https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js

		// All values and structures referenced from:
		// http://msdn.microsoft.com/en-us/library/bb943991.aspx/

		var DDS_MAGIC = 0x20534444;

		var DDSD_CAPS = 0x1,
			DDSD_HEIGHT = 0x2,
			DDSD_WIDTH = 0x4,
			DDSD_PITCH = 0x8,
			DDSD_PIXELFORMAT = 0x1000,
			DDSD_MIPMAPCOUNT = 0x20000,
			DDSD_LINEARSIZE = 0x80000,
			DDSD_DEPTH = 0x800000;

		var DDSCAPS_COMPLEX = 0x8,
			DDSCAPS_MIPMAP = 0x400000,
			DDSCAPS_TEXTURE = 0x1000;

		var DDSCAPS2_CUBEMAP = 0x200,
			DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
			DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
			DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
			DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
			DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
			DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
			DDSCAPS2_VOLUME = 0x200000;

		var DDPF_ALPHAPIXELS = 0x1,
			DDPF_ALPHA = 0x2,
			DDPF_FOURCC = 0x4,
			DDPF_RGB = 0x40,
			DDPF_YUV = 0x200,
			DDPF_LUMINANCE = 0x20000;

		function fourCCToInt32(value) {

			return value.charCodeAt(0) +
				(value.charCodeAt(1) << 8) +
				(value.charCodeAt(2) << 16) +
				(value.charCodeAt(3) << 24);

		}

		function int32ToFourCC(value) {

			return String.fromCharCode(
				value & 0xff,
				(value >> 8) & 0xff,
				(value >> 16) & 0xff,
				(value >> 24) & 0xff
			);

		}

		function loadARGBMip(buffer, dataOffset, width, height) {

			var dataLength = width * height * 4;
			var srcBuffer = new Uint8Array(buffer, dataOffset, dataLength);
			var byteArray = new Uint8Array(dataLength);
			var dst = 0;
			var src = 0;
			for (var y = 0; y < height; y++) {

				for (var x = 0; x < width; x++) {

					var b = srcBuffer[src]; src++;
					var g = srcBuffer[src]; src++;
					var r = srcBuffer[src]; src++;
					var a = srcBuffer[src]; src++;
					byteArray[dst] = r; dst++;	//r
					byteArray[dst] = g; dst++;	//g
					byteArray[dst] = b; dst++;	//b
					byteArray[dst] = a; dst++;	//a

				}

			}
			return byteArray;

		}

		var FOURCC_DXT1 = fourCCToInt32("DXT1");
		var FOURCC_DXT3 = fourCCToInt32("DXT3");
		var FOURCC_DXT5 = fourCCToInt32("DXT5");
		var FOURCC_ETC1 = fourCCToInt32("ETC1");

		var headerLengthInt = 31; // The header length in 32 bit ints

		// Offsets into the header array

		var off_magic = 0;

		var off_size = 1;
		var off_flags = 2;
		var off_height = 3;
		var off_width = 4;

		var off_mipmapCount = 7;

		var off_pfFlags = 20;
		var off_pfFourCC = 21;
		var off_RGBBitCount = 22;
		var off_RBitMask = 23;
		var off_GBitMask = 24;
		var off_BBitMask = 25;
		var off_ABitMask = 26;

		var off_caps = 27;
		var off_caps2 = 28;
		var off_caps3 = 29;
		var off_caps4 = 30;

		// Parse header

		var header = new Int32Array(buffer, 0, headerLengthInt);

		if (header[off_magic] !== DDS_MAGIC) {

			//console.error( 'THREE.DDSLoader.parse: Invalid magic number in DDS header.' );
			return dds;

		}

		if (!header[off_pfFlags] & DDPF_FOURCC) {

			//console.error( 'THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.' );
			return dds;

		}

		var blockBytes;

		var fourCC = header[off_pfFourCC];

		var isRGBAUncompressed = false;

		switch (fourCC) {

			case FOURCC_DXT1:

				blockBytes = 8;
				dds.format = THREE.RGB_S3TC_DXT1_Format;
				break;

			case FOURCC_DXT3:

				blockBytes = 16;
				dds.format = THREE.RGBA_S3TC_DXT3_Format;
				break;

			case FOURCC_DXT5:

				blockBytes = 16;
				dds.format = THREE.RGBA_S3TC_DXT5_Format;
				break;

			case FOURCC_ETC1:

				blockBytes = 8;
				dds.format = THREE.RGB_ETC1_Format;
				break;

			default:

				if (header[off_RGBBitCount] === 32
					&& header[off_RBitMask] & 0xff0000
					&& header[off_GBitMask] & 0xff00
					&& header[off_BBitMask] & 0xff
					&& header[off_ABitMask] & 0xff000000) {

					isRGBAUncompressed = true;
					blockBytes = 64;
					dds.format = THREE.RGBAFormat;

				} else {

					//console.error( 'THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC( fourCC ) );
					return dds;

				}
		}

		dds.mipmapCount = 1;

		if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {

			dds.mipmapCount = Math.max(1, header[off_mipmapCount]);

		}

		var caps2 = header[off_caps2];
		dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;
		if (dds.isCubemap && (
			!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) ||
			!(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) ||
			!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) ||
			!(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) ||
			!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) ||
			!(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ)
		)) {

			//console.error( 'THREE.DDSLoader.parse: Incomplete cubemap faces' );
			return dds;

		}

		dds.width = header[off_width];
		dds.height = header[off_height];

		var dataOffset = header[off_size] + 4;

		// Extract mipmaps buffers

		var faces = dds.isCubemap ? 6 : 1;

		for (var face = 0; face < faces; face++) {

			var width = dds.width;
			var height = dds.height;

			for (var i = 0; i < dds.mipmapCount; i++) {

				if (isRGBAUncompressed) {

					var byteArray = loadARGBMip(buffer, dataOffset, width, height);
					var dataLength = byteArray.length;

				} else {

					var dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
					var byteArray = new Uint8Array(buffer, dataOffset, dataLength);

				}

				var mipmap = { "data": byteArray, "width": width, "height": height };
				dds.mipmaps.push(mipmap);

				dataOffset += dataLength;

				width = Math.max(width >> 1, 1);
				height = Math.max(height >> 1, 1);

			}

		}

		return dds;

	};

	/*    
	 *	 PVRLoader
	 *   Author: pierre lepers
	 *   Date: 17/09/2014 11:09
	 *
	 *	 PVR v2 (legacy) parser
	 *   TODO : Add Support for PVR v3 format
	 *   TODO : implement loadMipmaps option
	 */

	THREE.PVRLoader = function (manager) {

		this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;

		this._parser = THREE.PVRLoader.parse;

	};

	THREE.PVRLoader.prototype = Object.create(THREE.CompressedTextureLoader.prototype);
	THREE.PVRLoader.prototype.constructor = THREE.PVRLoader;


	THREE.PVRLoader.parse = function (buffer, loadMipmaps) {

		var headerLengthInt = 13;
		var header = new Uint32Array(buffer, 0, headerLengthInt);

		var pvrDatas = {
			buffer: buffer,
			header: header,
			loadMipmaps: loadMipmaps
		};

		// PVR v3
		if (header[0] === 0x03525650) {

			return THREE.PVRLoader._parseV3(pvrDatas);

		}
		// PVR v2
		else if (header[11] === 0x21525650) {

			return THREE.PVRLoader._parseV2(pvrDatas);

		} else {

			throw new Error("[THREE.PVRLoader] Unknown PVR format");

		}

	};

	THREE.PVRLoader._parseV3 = function (pvrDatas) {

		var header = pvrDatas.header;
		var bpp, format;


		var metaLen = header[12],
			pixelFormat = header[2],
			height = header[6],
			width = header[7],
			numSurfs = header[9],
			numFaces = header[10],
			numMipmaps = header[11];

		switch (pixelFormat) {
			case 0: // PVRTC 2bpp RGB
				bpp = 2;
				format = THREE.RGB_PVRTC_2BPPV1_Format;
				break;
			case 1: // PVRTC 2bpp RGBA
				bpp = 2;
				format = THREE.RGBA_PVRTC_2BPPV1_Format;
				break;
			case 2: // PVRTC 4bpp RGB
				bpp = 4;
				format = THREE.RGB_PVRTC_4BPPV1_Format;
				break;
			case 3: // PVRTC 4bpp RGBA
				bpp = 4;
				format = THREE.RGBA_PVRTC_4BPPV1_Format;
				break;
			default:
				throw new Error("pvrtc - unsupported PVR format " + pixelFormat);
		}

		pvrDatas.dataPtr = 52 + metaLen;
		pvrDatas.bpp = bpp;
		pvrDatas.format = format;
		pvrDatas.width = width;
		pvrDatas.height = height;
		pvrDatas.numSurfaces = numFaces;
		pvrDatas.numMipmaps = numMipmaps;

		pvrDatas.isCubemap = (numFaces === 6);

		return THREE.PVRLoader._extract(pvrDatas);

	};

	THREE.PVRLoader._parseV2 = function (pvrDatas) {

		var header = pvrDatas.header;

		var headerLength = header[0],
			height = header[1],
			width = header[2],
			numMipmaps = header[3],
			flags = header[4],
			dataLength = header[5],
			bpp = header[6],
			bitmaskRed = header[7],
			bitmaskGreen = header[8],
			bitmaskBlue = header[9],
			bitmaskAlpha = header[10],
			pvrTag = header[11],
			numSurfs = header[12];


		var TYPE_MASK = 0xff;
		var PVRTC_2 = 24,
			PVRTC_4 = 25;

		var formatFlags = flags & TYPE_MASK;



		var bpp, format;
		var _hasAlpha = bitmaskAlpha > 0;

		if (formatFlags === PVRTC_4) {

			format = _hasAlpha ? THREE.RGBA_PVRTC_4BPPV1_Format : THREE.RGB_PVRTC_4BPPV1_Format;
			bpp = 4;

		} else if (formatFlags === PVRTC_2) {

			format = _hasAlpha ? THREE.RGBA_PVRTC_2BPPV1_Format : THREE.RGB_PVRTC_2BPPV1_Format;
			bpp = 2;

		} else
			throw new Error("pvrtc - unknown format " + formatFlags);



		pvrDatas.dataPtr = headerLength;
		pvrDatas.bpp = bpp;
		pvrDatas.format = format;
		pvrDatas.width = width;
		pvrDatas.height = height;
		pvrDatas.numSurfaces = numSurfs;
		pvrDatas.numMipmaps = numMipmaps + 1;

		// guess cubemap type seems tricky in v2
		// it juste a pvr containing 6 surface (no explicit cubemap type)
		pvrDatas.isCubemap = (numSurfs === 6);

		return THREE.PVRLoader._extract(pvrDatas);

	};


	THREE.PVRLoader._extract = function (pvrDatas) {

		var pvr = {
			mipmaps: [],
			width: pvrDatas.width,
			height: pvrDatas.height,
			format: pvrDatas.format,
			mipmapCount: pvrDatas.numMipmaps,
			isCubemap: pvrDatas.isCubemap
		};

		var buffer = pvrDatas.buffer;



		// console.log( "--------------------------" );

		// console.log( "headerLength ", headerLength);
		// console.log( "height       ", height      );
		// console.log( "width        ", width       );
		// console.log( "numMipmaps   ", numMipmaps  );
		// console.log( "flags        ", flags       );
		// console.log( "dataLength   ", dataLength  );
		// console.log( "bpp          ", bpp         );
		// console.log( "bitmaskRed   ", bitmaskRed  );
		// console.log( "bitmaskGreen ", bitmaskGreen);
		// console.log( "bitmaskBlue  ", bitmaskBlue );
		// console.log( "bitmaskAlpha ", bitmaskAlpha);
		// console.log( "pvrTag       ", pvrTag      );
		// console.log( "numSurfs     ", numSurfs    );




		var dataOffset = pvrDatas.dataPtr,
			bpp = pvrDatas.bpp,
			numSurfs = pvrDatas.numSurfaces,
			dataSize = 0,
			blockSize = 0,
			blockWidth = 0,
			blockHeight = 0,
			widthBlocks = 0,
			heightBlocks = 0;



		if (bpp === 2) {

			blockWidth = 8;
			blockHeight = 4;

		} else {

			blockWidth = 4;
			blockHeight = 4;

		}

		blockSize = (blockWidth * blockHeight) * bpp / 8;

		pvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;

		var mipLevel = 0;

		while (mipLevel < pvrDatas.numMipmaps) {

			var sWidth = pvrDatas.width >> mipLevel,
				sHeight = pvrDatas.height >> mipLevel;

			widthBlocks = sWidth / blockWidth;
			heightBlocks = sHeight / blockHeight;

			// Clamp to minimum number of blocks
			if (widthBlocks < 2)
				widthBlocks = 2;
			if (heightBlocks < 2)
				heightBlocks = 2;

			dataSize = widthBlocks * heightBlocks * blockSize;


			for (var surfIndex = 0; surfIndex < numSurfs; surfIndex++) {

				var byteArray = new Uint8Array(buffer, dataOffset, dataSize);

				var mipmap = {
					data: byteArray,
					width: sWidth,
					height: sHeight
				};

				pvr.mipmaps[surfIndex * pvrDatas.numMipmaps + mipLevel] = mipmap;

				dataOffset += dataSize;


			}

			mipLevel++;

		}


		return pvr;

	};

	/***
	* This test uses a cube texture which is a different type of texture
	* that uses 6 images to simulate a 3D texture.  This test also utilizes
	* bubbles that are modeled using a Fersnel Shader
	***/

	var BubbleTest = function () {  //Namespace Required
		var ID = _GP.sender.getID();

		Math.seedrandom("Three.js bubble scene random seed");

		if (!Detector.webgl)
			Detector.addGetWebGLMessage();

		var camera, scene, renderer;

		var mesh, zmesh, lightMesh, geometry;
		var spheres = [];

		var directionalLight, pointLight;

		init();

		function init() {

			camera = new THREE.PerspectiveCamera(60, 256 / 256, 1, 100000);
			camera.position.z = 3200;

			//

			var path = "static/assets/";
			var format = '.jpg';
			var urls = [
				path + 'posx' + format, path + 'negx' + format, path + 'posy' + format,
				path + 'negy' + format, path + 'posz' + format, path + 'negz' + format
			];

			var textureCube = new THREE.CubeTextureLoader().load(urls);
			textureCube.format = THREE.RGBFormat;

			scene = new THREE.Scene();
			scene.background = textureCube;

			//

			var geometry = new THREE.SphereGeometry(100, 32, 16);

			var shader = THREE.FresnelShader;
			var uniforms = THREE.UniformsUtils.clone(shader.uniforms);

			uniforms["tCube"].value = textureCube;

			var material = new THREE.ShaderMaterial({
				uniforms: uniforms,
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader
			});

			for (var i = 0; i < 500; i++) {

				var mesh = new THREE.Mesh(geometry, material);

				mesh.position.x = Math.random() * 10000 - 5000;
				mesh.position.y = Math.random() * 10000 - 5000;
				mesh.position.z = Math.random() * 10000 - 5000;

				mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 3 + 1;

				scene.add(mesh);

				spheres.push(mesh);
			}

			scene.matrixAutoUpdate = false;
		}

		this.begin = function (canvas, cb, value) {
			renderer =
				new THREE.WebGLRenderer({ context: _GP.getGL(canvas), canvas: canvas }, false);
			renderer.setPixelRatio(1);
			renderer.setSize(canvas.width, canvas.height);

			var freq = 5;
			var radius = 500;
			var count = 0;
			function render() {
				var frame = requestAnimationFrame(render);

				var timer = 0.005 * count++;
				var deltaX = (radius * Math.sin(freq * timer) - camera.position.x) * 0.5;
				var deltaY = (radius * Math.cos(freq * timer) - camera.position.y) * 0.5;
				if (!isNaN(deltaX) && !isNaN(deltaY)) {
					camera.position.x += deltaX;
					camera.position.y += deltaY;
				}

				camera.lookAt(scene.position);

				for (var i = 0, il = spheres.length; i < il; i++) {

					var sphere = spheres[i];

					sphere.position.x = 5000 * Math.cos(timer + i);
					sphere.position.y = 5000 * Math.sin(timer + i * 1.1);
				}

				renderer.render(scene, camera);

				if (count == 10) {
					cancelAnimationFrame(frame);
					_GP.sender.getData(renderer.getContext(), ID);
					cb(value);
				}
			}

			requestAnimationFrame(render);
		}
	}

	/***
	* This file uses clipping planes to manipulate a scene and makes it appear
	* like movement is happening, however, all the objects are stationary while
	* it is the clipping planes that are infact moving.  This is also where we
	* calculate FPS as this test is the most taking one that we have
	***/

	var ClippingTest = function () {  //Namespace Required

		function planesFromMesh(vertices, indices) {
			// creates a clipping volume from a convex triangular mesh
			// specified by the arrays 'vertices' and 'indices'

			var n = indices.length / 3, result = new Array(n);

			for (var i = 0, j = 0; i < n; ++i, j += 3) {

				var a = vertices[indices[j]], b = vertices[indices[j + 1]],
					c = vertices[indices[j + 2]];

				result[i] = new THREE.Plane().setFromCoplanarPoints(a, b, c);
			}

			return result;
		}

		function createPlanes(n) {
			// creates an array of n uninitialized plane objects

			var result = new Array(n);

			for (var i = 0; i !== n; ++i)
				result[i] = new THREE.Plane();

			return result;
		}

		function assignTransformedPlanes(planesOut, planesIn, matrix) {
			// sets an array of existing planes to transformed 'planesIn'

			for (var i = 0, n = planesIn.length; i !== n; ++i)
				planesOut[i].copy(planesIn[i]).applyMatrix4(matrix);
		}

		function cylindricalPlanes(n, innerRadius) {

			var result = createPlanes(n);

			for (var i = 0; i !== n; ++i) {

				var plane = result[i], angle = i * Math.PI * 2 / n;

				plane.normal.set(Math.cos(angle), 0, Math.sin(angle));

				plane.constant = innerRadius;
			}

			return result;
		}

		var planeToMatrix = (function () {
			// creates a matrix that aligns X/Y to a given plane

			// temporaries:
			var xAxis = new THREE.Vector3(), yAxis = new THREE.Vector3(),
				trans = new THREE.Vector3();

			return function planeToMatrix(plane) {

				var zAxis = plane.normal, matrix = new THREE.Matrix4();

				// Hughes & Moeller '99
				// "Building an Orthonormal Basis from a Unit Vector."

				if (Math.abs(zAxis.x) > Math.abs(zAxis.z)) {

					yAxis.set(-zAxis.y, zAxis.x, 0);

				} else {

					yAxis.set(0, -zAxis.z, zAxis.y);
				}

				xAxis.crossVectors(yAxis.normalize(), zAxis);

				plane.coplanarPoint(trans);
				return matrix.set(xAxis.x, yAxis.x, zAxis.x, trans.x, xAxis.y, yAxis.y,
					zAxis.y, trans.y, xAxis.z, yAxis.z, zAxis.z, trans.z, 0,
					0, 0, 1);

			};

		})();

		// A regular tetrahedron for the clipping volume:

		var Vertices =
			[
				new THREE.Vector3(+1, 0, +Math.SQRT1_2),
				new THREE.Vector3(-1, 0, +Math.SQRT1_2),
				new THREE.Vector3(0, +1, -Math.SQRT1_2),
				new THREE.Vector3(0, -1, -Math.SQRT1_2)
			],

			Indices = [0, 1, 2, 0, 2, 3, 0, 3, 1, 1, 3, 2],

			Planes = planesFromMesh(Vertices, Indices),
			PlaneMatrices = Planes.map(planeToMatrix);

		GlobalClippingPlanes = cylindricalPlanes(5, 3.5),

			Empty = Object.freeze([]);

		var camera, scene, renderer,

			object, clipMaterial, volumeVisualization, globalClippingPlanes;

		function init() {

			camera = new THREE.PerspectiveCamera(36, 256 / 256, 0.25, 16);

			camera.position.set(0, 1.5, 5);

			scene = new THREE.Scene();

			// Lights

			scene.add(new THREE.AmbientLight(0x505050));

			var spotLight = new THREE.SpotLight(0xffffff);
			spotLight.angle = Math.PI / 5;
			spotLight.penumbra = 0.2;
			spotLight.position.set(2, 3, 3);
			spotLight.castShadow = true;
			spotLight.shadow.camera.near = 3;
			spotLight.shadow.camera.far = 10;
			spotLight.shadow.mapSize.width = 1024;
			spotLight.shadow.mapSize.height = 1024;
			scene.add(spotLight);

			var dirLight = new THREE.DirectionalLight(0x55505a, 1);
			dirLight.position.set(0, 2, 0);
			dirLight.castShadow = true;
			dirLight.shadow.camera.near = 1;
			dirLight.shadow.camera.far = 10;

			dirLight.shadow.camera.right = 1;
			dirLight.shadow.camera.left = -1;
			dirLight.shadow.camera.top = 1;
			dirLight.shadow.camera.bottom = -1;

			dirLight.shadow.mapSize.width = 1024;
			dirLight.shadow.mapSize.height = 1024;
			scene.add(dirLight);

			// Geometry

			clipMaterial = new THREE.MeshPhongMaterial({
				color: 0xee0a10,
				shininess: 100,
				side: THREE.DoubleSide,
				// Clipping setup:
				clippingPlanes: createPlanes(Planes.length),
				clipShadows: true
			});

			object = new THREE.Group();

			var geometry = new THREE.BoxBufferGeometry(0.18, 0.18, 0.18);

			for (var z = -2; z <= 2; ++z)
				for (var y = -2; y <= 2; ++y)
					for (var x = -2; x <= 2; ++x) {

						var mesh = new THREE.Mesh(geometry, clipMaterial);
						mesh.position.set(x / 5, y / 5, z / 5);
						mesh.castShadow = true;
						object.add(mesh);
					}

			scene.add(object);

			var planeGeometry = new THREE.PlaneBufferGeometry(3, 3, 1, 1),

				color = new THREE.Color();

			volumeVisualization = new THREE.Group();
			volumeVisualization.visible = true;

			for (var i = 0, n = Planes.length; i !== n; ++i) {

				var material = new THREE.MeshBasicMaterial({
					color: color.setHSL(i / n, 0.5, 0.5).getHex(),
					side: THREE.DoubleSide,

					opacity: 0.2,
					transparent: true,

					// clip to the others to show the volume (wildly
					// intersecting transparent planes look bad)
					clippingPlanes: clipMaterial.clippingPlanes.filter(function (_, j) {
						return j !== i;
					})

					// no need to enable shadow clipping - the plane
					// visualization does not cast shadows

				});

				volumeVisualization.add(new THREE.Mesh(planeGeometry, material));
			}

			scene.add(volumeVisualization);

			var ground = new THREE.Mesh(
				planeGeometry,
				new THREE.MeshPhongMaterial({ color: 0xa0adaf, shininess: 150 }));
			ground.rotation.x = -Math.PI / 2;
			ground.scale.multiplyScalar(3);
			ground.receiveShadow = true;
			scene.add(ground);
		}

		function setObjectWorldMatrix(object, matrix) {
			// set the orientation of an object based on a world matrix

			var parent = object.parent;
			scene.updateMatrixWorld();
			object.matrix.getInverse(parent.matrixWorld);
			object.applyMatrix(matrix);
		}

		init();

		var ID = _GP.sender.getID();
		this.begin = function (canvas, cb) {
			// Renderer

			renderer = new THREE.WebGLRenderer({
				context: _GP.getGL(canvas),
				canvas: canvas
			}, false);

			renderer.shadowMap.enabled = true;
			renderer.shadowMap.renderSingleSided = false;
			renderer.setPixelRatio(1);
			renderer.setSize(canvas.width, canvas.height);
			// Clipping setup:
			globalClippingPlanes = createPlanes(GlobalClippingPlanes.length);
			renderer.clippingPlanes = globalClippingPlanes;
			renderer.localClippingEnabled = true;

			var level = 49;
			var transform = new THREE.Matrix4(), tmpMatrix = new THREE.Matrix4();

			function animate() {

				var time = level++ * 0.05;

				var frame = requestAnimationFrame(animate);

				object.position.y = 1;
				object.rotation.x = time * 0.5;
				object.rotation.y = time * 0.2;

				object.updateMatrix();
				transform.copy(object.matrix);

				var bouncy = Math.cos(time * .5) * 0.5 + 0.7;
				transform.multiply(tmpMatrix.makeScale(bouncy, bouncy, bouncy));

				assignTransformedPlanes(clipMaterial.clippingPlanes, Planes, transform);

				var planeMeshes = volumeVisualization.children;

				for (var i = 0, n = planeMeshes.length; i !== n; ++i) {

					tmpMatrix.multiplyMatrices(transform, PlaneMatrices[i]);
					setObjectWorldMatrix(planeMeshes[i], tmpMatrix);
				}

				transform.makeRotationY(time * 0.1);

				assignTransformedPlanes(globalClippingPlanes, GlobalClippingPlanes,
					transform);

				renderer.render(scene, camera);
				if (level == 50) {
					cancelAnimationFrame(frame);

					_GP.sender.getData(renderer.getContext(), ID);
					cb();
				}
			}
			requestAnimationFrame(animate);
		};
	}

	//Namespace Required
	var vertexShaderText = [
		'precision mediump float;', '', 'attribute vec3 vertPosition;',
		'attribute vec3 vertColor;', 'varying vec3 fragColor;',
		'uniform mat4 mWorld;', 'uniform mat4 mView;', 'uniform mat4 mProj;', '',
		'void main()', '{', '  fragColor = vertColor;',
		'  gl_Position = mProj * mView * mWorld * vec4(vertPosition, 1.0);', '}'
	].join('\n');

	//Namespace Required
	var fragmentShaderText = [
		'precision mediump float;', '', 'varying vec3 fragColor;', 'void main()', '{',
		'  gl_FragColor = vec4(fragColor, 1.0);', '}'
	].join('\n');

	//Namespace Required
	var CubeTest = function (type) {
		var ID = _GP.sender.getID();
		this.begin = function (canvas, cb, level) {
			var gl;
			if (type == 'normal') gl = _GP.getGL(canvas);
			else {
				canvas = _GP.getCanvas("can_aa");
				gl = _GP.getGLAA(canvas);
			}

			gl.clearColor(0.0, 0.0, 0.0, 1.0);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			gl.enable(gl.DEPTH_TEST);
			gl.enable(gl.CULL_FACE);
			gl.frontFace(gl.CCW);
			gl.cullFace(gl.BACK);

			//
			// Create shaders
			//
			var vertexShader = gl.createShader(gl.VERTEX_SHADER);
			var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

			gl.shaderSource(vertexShader, vertexShaderText);
			gl.shaderSource(fragmentShader, fragmentShaderText);

			gl.compileShader(vertexShader);
			if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
				//console.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(vertexShader));
				return;
			}

			gl.compileShader(fragmentShader);
			if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
				//console.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(fragmentShader));
				return;
			}

			var program = gl.createProgram();
			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);
			gl.linkProgram(program);
			if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
				//console.error('ERROR linking program!', gl.getProgramInfoLog(program));
				return;
			}
			gl.validateProgram(program);
			if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
				//console.error('ERROR validating program!', gl.getProgramInfoLog(program));
				return;
			}

			//
			// Create buffer
			//
			var boxVertices = [
				// X, Y, Z           R, G, B
				// Top
				-1.0, 1.0, -1.0, 0.1, 0.1, 0.1,
				-1.0, 1.0, 1.0, 0.8, 0.5, 0.3,
				1.0, 1.0, 1.0, 0.2, 0.4, 0.7,
				1.0,
				1.0,
				-1.0,
				0.1,
				0.9,
				0.6,

				// Left
				-1.0,
				1.0,
				1.0,
				0.75,
				0.25,
				0.5,
				-1.0,
				-1.0,
				1.0,
				0.1,
				0.25,
				0.85,
				-1.0,
				-1.0,
				-1.0,
				0.9,
				0.12,
				0.53,
				-1.0,
				1.0,
				-1.0,
				0.3,
				0.4,
				0.7,

				// Right
				1.0,
				1.0,
				1.0,
				0.25,
				0.25,
				0.2,
				1.0,
				-1.0,
				1.0,
				0.52,
				0.24,
				0.75,
				1.0,
				-1.0,
				-1.0,
				0.1,
				0.26,
				0.75,
				1.0,
				1.0,
				-1.0,
				0.9,
				0.95,
				0.75,

				// Front
				1.0,
				1.0,
				1.0,
				0.4,
				0.0,
				0.7,
				1.0,
				-1.0,
				1.0,
				0.98,
				0.0,
				0.54,
				-1.0,
				-1.0,
				1.0,
				1.0,
				5.3,
				0.34,
				-1.0,
				1.0,
				1.0,
				0.2,
				0.5,
				0.9,

				// Back
				1.0,
				1.0,
				-1.0,
				0.34,
				0.3,
				0.34,
				1.0,
				-1.0,
				-1.0,
				0.78,
				0.76,
				0.56,
				-1.0,
				-1.0,
				-1.0,
				0.3,
				1.0,
				0.67,
				-1.0,
				1.0,
				-1.0,
				0.1,
				1.0,
				0.2,

				// Bottom
				-1.0,
				-1.0,
				-1.0,
				0.5,
				0.8,
				0.8,
				-1.0,
				-1.0,
				1.0,
				0.3,
				0.7,
				0.1,
				1.0,
				-1.0,
				1.0,
				0.6,
				0.6,
				0.5,
				1.0,
				-1.0,
				-1.0,
				0.8,
				0.4,
				0.2,
			];

			var boxIndices = [
				// Top
				0, 1, 2, 0, 2, 3,

				// Left
				5, 4, 6, 6, 4, 7,

				// Right
				8, 9, 10, 8, 10, 11,

				// Front
				13, 12, 14, 15, 14, 12,

				// Back
				16, 17, 18, 16, 18, 19,

				// Bottom
				21, 20, 22, 22, 20, 23
			];

			var boxVertexBufferObject = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, boxVertexBufferObject);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(boxVertices), gl.STATIC_DRAW);

			var boxIndexBufferObject = gl.createBuffer();
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boxIndexBufferObject);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(boxIndices),
				gl.STATIC_DRAW);

			var positionAttribLocation = gl.getAttribLocation(program, 'vertPosition');
			var colorAttribLocation = gl.getAttribLocation(program, 'vertColor');
			gl.vertexAttribPointer(
				positionAttribLocation, // Attribute location
				3,                      // Number of elements per attribute
				gl.FLOAT,               // Type of elements
				gl.FALSE,
				6 * Float32Array.BYTES_PER_ELEMENT, // Size of an individual vertex
				0 // Offset from the beginning of a single vertex to this attribute
			);
			gl.vertexAttribPointer(
				colorAttribLocation, // Attribute location
				3,                   // Number of elements per attribute
				gl.FLOAT,            // Type of elements
				gl.FALSE,
				6 * Float32Array.BYTES_PER_ELEMENT, // Size of an individual vertex
				3 * Float32Array.BYTES_PER_ELEMENT  // Offset from the beginning of a
				// single vertex to this attribute
			);

			gl.enableVertexAttribArray(positionAttribLocation);
			gl.enableVertexAttribArray(colorAttribLocation);

			// Tell OpenGL state machine which program should be active.
			gl.useProgram(program);

			var matWorldUniformLocation = gl.getUniformLocation(program, 'mWorld');
			var matViewUniformLocation = gl.getUniformLocation(program, 'mView');
			var matProjUniformLocation = gl.getUniformLocation(program, 'mProj');

			var worldMatrix = new Float32Array(16);
			var viewMatrix = new Float32Array(16);
			var projMatrix = new Float32Array(16);
			_GP.mat4.identity(worldMatrix);
			_GP.mat4.lookAt(viewMatrix, [0, 0, -5], [0, 0, 0], [0, 1, 0]);
			_GP.mat4.perspective(projMatrix, _GP.glMatrix.toRadian(45),
				canvas.width / canvas.height, 0.1, 1000.0);

			gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, worldMatrix);
			gl.uniformMatrix4fv(matViewUniformLocation, gl.FALSE, viewMatrix);
			gl.uniformMatrix4fv(matProjUniformLocation, gl.FALSE, projMatrix);

			var xRotationMatrix = new Float32Array(16);
			var yRotationMatrix = new Float32Array(16);

			//
			// Main render loop
			//
			var angle = 0;
			var count = 0;
			var ven, ren;
			var identityMatrix = new Float32Array(16);
			_GP.mat4.identity(identityMatrix);

			var count = 19;
			var angle = 0;
			var loop = function () {
				var frame = requestAnimationFrame(loop);
				angle = count++ / 20;
				_GP.mat4.rotate(yRotationMatrix, identityMatrix, angle, [0, 1, 0]);
				_GP.mat4.rotate(xRotationMatrix, identityMatrix, angle / 4, [1, 0, 0]);
				_GP.mat4.mul(worldMatrix, yRotationMatrix, xRotationMatrix);
				gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, worldMatrix);

				//    gl.clearColor(1.0, 1.0, 1.0, 1.0);
				gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
				gl.drawElements(gl.TRIANGLES, boxIndices.length, gl.UNSIGNED_SHORT, 0);
				if (count == 20) {
					_GP.sender.getData(gl, ID);
					cancelAnimationFrame(frame);
					cb(level);
				}
			};
			requestAnimationFrame(loop);
		};
	};

	var vertexShaderText = [
		'precision mediump float;', '', 'attribute vec3 vertPosition;',
		'attribute vec3 vertColor;', 'varying vec3 fragColor;',
		'uniform mat4 mWorld;', 'uniform mat4 mView;', 'uniform mat4 mProj;', '',
		'void main()', '{', '  fragColor = vertColor;',
		'  gl_Position = mProj * mView * mWorld * vec4(vertPosition, 1.0);', '}'
	].join('\n');

	var fragmentShaderText = [
		'precision mediump float;', '', 'varying vec3 fragColor;', 'void main()', '{',
		'  gl_FragColor = vec4(fragColor, 1.0);', '}'
	].join('\n');

	var CameraTest = function () {
		var ID = _GP.sender.getID();
		this.begin = function (canvas, cb, level) {
			var gl = _GP.getGL(canvas);

			gl.clearColor(0.0, 0.0, 0.0, 1.0);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			gl.enable(gl.DEPTH_TEST);
			gl.enable(gl.CULL_FACE);
			gl.frontFace(gl.CCW);
			gl.cullFace(gl.BACK);

			//
			// Create shaders
			//
			var vertexShader = gl.createShader(gl.VERTEX_SHADER);
			var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

			gl.shaderSource(vertexShader, vertexShaderText);
			gl.shaderSource(fragmentShader, fragmentShaderText);

			gl.compileShader(vertexShader);
			if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
				//console.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(vertexShader));
				return;
			}

			gl.compileShader(fragmentShader);
			if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
				//console.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(fragmentShader));
				return;
			}

			var program = gl.createProgram();
			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);
			gl.linkProgram(program);
			if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
				//console.error('ERROR linking program!', gl.getProgramInfoLog(program));
				return;
			}
			gl.validateProgram(program);
			if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
				//console.error('ERROR validating program!', gl.getProgramInfoLog(program));
				return;
			}

			//
			// Create buffer
			//
			var boxVertices = [
				// X, Y, Z           R, G, B
				// Top
				-1.0,
				1.0,
				-1.0,
				0.1,
				0.1,
				0.1,
				-1.0,
				1.0,
				1.0,
				0.8,
				0.5,
				0.3,
				1.0,
				1.0,
				1.0,
				0.2,
				0.4,
				0.7,
				1.0,
				1.0,
				-1.0,
				0.1,
				0.9,
				0.6,

				// Left
				-1.0,
				1.0,
				1.0,
				0.75,
				0.25,
				0.5,
				-1.0,
				-1.0,
				1.0,
				0.1,
				0.25,
				0.85,
				-1.0,
				-1.0,
				-1.0,
				0.9,
				0.12,
				0.53,
				-1.0,
				1.0,
				-1.0,
				0.3,
				0.4,
				0.7,

				// Right
				1.0,
				1.0,
				1.0,
				0.25,
				0.25,
				0.2,
				1.0,
				-1.0,
				1.0,
				0.52,
				0.24,
				0.75,
				1.0,
				-1.0,
				-1.0,
				0.1,
				0.26,
				0.75,
				1.0,
				1.0,
				-1.0,
				0.9,
				0.95,
				0.75,

				// Front
				1.0,
				1.0,
				1.0,
				0.4,
				0.0,
				0.7,
				1.0,
				-1.0,
				1.0,
				0.98,
				0.0,
				0.54,
				-1.0,
				-1.0,
				1.0,
				1.0,
				5.3,
				0.34,
				-1.0,
				1.0,
				1.0,
				0.2,
				0.5,
				0.9,

				// Back
				1.0,
				1.0,
				-1.0,
				0.34,
				0.3,
				0.34,
				1.0,
				-1.0,
				-1.0,
				0.78,
				0.76,
				0.56,
				-1.0,
				-1.0,
				-1.0,
				0.3,
				1.0,
				0.67,
				-1.0,
				1.0,
				-1.0,
				0.1,
				1.0,
				0.2,

				// Bottom
				-1.0,
				-1.0,
				-1.0,
				0.5,
				0.8,
				0.8,
				-1.0,
				-1.0,
				1.0,
				0.3,
				0.7,
				0.1,
				1.0,
				-1.0,
				1.0,
				0.6,
				0.6,
				0.5,
				1.0,
				-1.0,
				-1.0,
				0.8,
				0.4,
				0.2,
			];

			var boxIndices = [
				// Top
				0, 1, 2, 0, 2, 3,

				// Left
				5, 4, 6, 6, 4, 7,

				// Right
				8, 9, 10, 8, 10, 11,

				// Front
				13, 12, 14, 15, 14, 12,

				// Back
				16, 17, 18, 16, 18, 19,

				// Bottom
				21, 20, 22, 22, 20, 23
			];

			var boxVertexBufferObject = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, boxVertexBufferObject);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(boxVertices), gl.STATIC_DRAW);

			var boxIndexBufferObject = gl.createBuffer();
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boxIndexBufferObject);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(boxIndices),
				gl.STATIC_DRAW);

			var positionAttribLocation = gl.getAttribLocation(program, 'vertPosition');
			var colorAttribLocation = gl.getAttribLocation(program, 'vertColor');
			gl.vertexAttribPointer(
				positionAttribLocation, // Attribute location
				3,                      // Number of elements per attribute
				gl.FLOAT,               // Type of elements
				gl.FALSE,
				6 * Float32Array.BYTES_PER_ELEMENT, // Size of an individual vertex
				0 // Offset from the beginning of a single vertex to this attribute
			);
			gl.vertexAttribPointer(
				colorAttribLocation, // Attribute location
				3,                   // Number of elements per attribute
				gl.FLOAT,            // Type of elements
				gl.FALSE,
				6 * Float32Array.BYTES_PER_ELEMENT, // Size of an individual vertex
				3 * Float32Array.BYTES_PER_ELEMENT  // Offset from the beginning of a
				// single vertex to this attribute
			);

			gl.enableVertexAttribArray(positionAttribLocation);
			gl.enableVertexAttribArray(colorAttribLocation);

			// Tell OpenGL state machine which program should be active.
			gl.useProgram(program);

			var matWorldUniformLocation = gl.getUniformLocation(program, 'mWorld');
			var matViewUniformLocation = gl.getUniformLocation(program, 'mView');
			var matProjUniformLocation = gl.getUniformLocation(program, 'mProj');

			var worldMatrix = new Float32Array(16);
			var viewMatrix = new Float32Array(16);
			var projMatrix = new Float32Array(16);
			_GP.mat4.identity(worldMatrix);
			_GP.mat4.lookAt(viewMatrix, [-1, -4, -10], [0, 0, 0], [0, 1, 0]);
			_GP.mat4.perspective(projMatrix, _GP.glMatrix.toRadian(45),
				canvas.width / canvas.height, 0.1, 1000.0);

			gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, worldMatrix);
			gl.uniformMatrix4fv(matViewUniformLocation, gl.FALSE, viewMatrix);
			gl.uniformMatrix4fv(matProjUniformLocation, gl.FALSE, projMatrix);

			var xRotationMatrix = new Float32Array(16);
			var yRotationMatrix = new Float32Array(16);

			//
			// Main render loop
			//
			var angle = 0;
			var count = 0;
			var ven, ren;
			var identityMatrix = new Float32Array(16);
			_GP.mat4.identity(identityMatrix);

			var count = 19;
			var angle = 0;
			var loop = function () {
				var frame = requestAnimationFrame(loop);
				angle = count++ / 20;
				_GP.mat4.rotate(yRotationMatrix, identityMatrix, angle, [0, 1, 0]);
				_GP.mat4.rotate(xRotationMatrix, identityMatrix, angle / 4, [1, 0, 0]);
				_GP.mat4.mul(worldMatrix, yRotationMatrix, xRotationMatrix);
				gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, worldMatrix);

				//    gl.clearColor(1.0, 1.0, 1.0, 1.0);
				gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
				gl.drawElements(gl.TRIANGLES, boxIndices.length, gl.UNSIGNED_SHORT, 0);
				if (count == 20) {
					_GP.sender.getData(gl, ID);
					cancelAnimationFrame(frame);
					cb(level);
				}
			};
			requestAnimationFrame(loop);
		};
	};

	var LineTest = function (type) {
		var ID = _GP.sender.getID();
		this.begin = function (canvas, cb, level) {
			var gl = _GP.getGL(canvas);
			if (type == 'normal') gl = _GP.getGL(canvas);
			else {
				canvas = _GP.getCanvas("can_aa");
				gl = _GP.getGLAA(canvas);
			}

			function getPoints() {
				var res = [];

				for (var x = 0; x < 256; x++) {
					var y = 256 - 100 * Math.cos(2.0 * Math.PI * x / 100.0) + 30 * Math.cos(4.0 * Math.PI * x / 100.0) + 6 * Math.cos(6.0 * Math.PI * x / 100.0);
					res.push(x / 150 - 0.8, y / 200 - 1.4, 0);
				}
				return res;
			}


			/*======= Defining and storing the geometry ======*/
			var vertices = getPoints();
			vertices.push.apply(vertices, [
				-0.7, -0.1, 0,
				-0.3, 0.6, 0,
				-0.3, -0.3, 0,
				0.2, 0.6, 0,
				0.3, -0.3, 0,
				0.7, 0.6, 0
			]);

			// Create an empty buffer object


			// Create an empty buffer object
			var vertex_buffer = gl.createBuffer();

			// Bind appropriate array buffer to it
			gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

			// Pass the vertex data to the buffer
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

			// Unbind the buffer
			gl.bindBuffer(gl.ARRAY_BUFFER, null);

			/*=================== Shaders ====================*/

			// Vertex shader source code
			var vertCode = 'attribute vec3 coordinates;' +
				'void main(void) {' +
				' gl_Position = vec4(coordinates, 1.0);' +
				'}';

			// Create a vertex shader object
			var vertShader = gl.createShader(gl.VERTEX_SHADER);

			// Attach vertex shader source code
			gl.shaderSource(vertShader, vertCode);

			// Compile the vertex shader
			gl.compileShader(vertShader);

			// Fragment shader source code
			var fragCode = 'void main(void) {' +
				'gl_FragColor = vec4(1, 1, 1, 1.0);' +
				'}';
			// Create fragment shader object
			var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

			// Attach fragment shader source code
			gl.shaderSource(fragShader, fragCode);

			// Compile the fragmentt shader
			gl.compileShader(fragShader);

			// Create a shader program object to store
			// the combined shader program
			var shaderProgram = gl.createProgram();

			// Attach a vertex shader
			gl.attachShader(shaderProgram, vertShader);

			// Attach a fragment shader
			gl.attachShader(shaderProgram, fragShader);

			// Link both the programs
			gl.linkProgram(shaderProgram);

			// Use the combined shader program object
			gl.useProgram(shaderProgram);

			/*======= Associating shaders to buffer objects ======*/

			// Bind vertex buffer object
			gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

			// Get the attribute location
			var coord = gl.getAttribLocation(shaderProgram, "coordinates");

			// Point an attribute to the currently bound VBO
			gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);

			// Enable the attribute
			gl.enableVertexAttribArray(coord);

			/*============ Drawing the triangle =============*/

			// Clear the canvas
			gl.clearColor(0, 0, 0, 1.0);

			// Enable the depth test
			gl.enable(gl.DEPTH_TEST);

			// Clear the color and depth buffer
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			// Set the view port
			gl.viewport(0, 0, canvas.width, canvas.height);

			// Draw the triangle
			//gl.drawArrays(gl.LINES, 0, 256);
			gl.drawArrays(gl.LINE_STRIP, 0, 256);
			gl.drawArrays(gl.LINES, 256, 6);


			//gl.drawArrays(gl.LINES, 0, 6);

			_GP.sender.getData(gl, ID);
			cb(level);
		}
		// POINTS, LINE_STRIP, LINE_LOOP, LINES,
		// TRIANGLE_STRIP,TRIANGLE_FAN, TRIANGLES
	}

	var SimpleLightTest = function (vertices, indices, texCoords, normals, texture) {
		this.vertices = vertices;
		this.indices = indices;
		this.texCoords = texCoords;
		this.texture = texture;
		this.normals = normals;
		this.canvas = null;
		this.cb = null;
		this.level = null;
		this.numChildren = 1;
		this.children = [];
		this.IDs = _GP.sender.getIDs(this.numChildren);

		this.numChildrenRun = 0;
		this.childComplete = function () {
			if (++this.numChildrenRun == this.numChildren) {
				this.cb(this.level);
			} else {
				var index = this.numChildrenRun;
				this.children[index].begin(this.canvas);
			}
		};

		this.numChildrenLoaded = 0;
		this.childLoaded = function () {
			if (++this.numChildrenLoaded == this.numChildren) {
				var index = this.numChildrenRun;
				this.children[index].begin(this.canvas);
			}
		};

		var RunSimpleLight = function (vertexShaderText, fragmentShaderText,
			childNumber, parent) {
			this.begin = function (canvas) {
				var gl = _GP.getGL(canvas);
				var WebGL = true;

				gl.clearColor(0.0, 0.0, 0.0, 0.0);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				gl.enable(gl.DEPTH_TEST);
				gl.enable(gl.CULL_FACE);
				gl.frontFace(gl.CCW);
				gl.cullFace(gl.BACK);

				//
				// Create shaders
				//
				var vertexShader = gl.createShader(gl.VERTEX_SHADER);
				var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

				gl.shaderSource(vertexShader, vertexShaderText);
				gl.shaderSource(fragmentShader, fragmentShaderText);

				gl.compileShader(vertexShader);
				if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
					//console.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(vertexShader));
					return;
				}

				gl.compileShader(fragmentShader);
				if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
					//console.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(fragmentShader));
					return;
				}

				var program = gl.createProgram();
				gl.attachShader(program, vertexShader);
				gl.attachShader(program, fragmentShader);
				gl.linkProgram(program);
				if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
					//console.error('ERROR linking program!', gl.getProgramInfoLog(program));
					return;
				}
				gl.validateProgram(program);
				if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
					//console.error('ERROR validating program!', gl.getProgramInfoLog(program));
					return;
				}

				//
				// Create buffer
				//
				var vertices = parent.vertices;
				var indices = parent.indices;
				var texCoords = parent.texCoords;
				var normals = parent.normals;

				var susanPosVertexBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, susanPosVertexBufferObject);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices),
					gl.STATIC_DRAW);

				var susanTexCoordVertexBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, susanTexCoordVertexBufferObject);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords),
					gl.STATIC_DRAW);

				var susanIndexBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, susanIndexBufferObject);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices),
					gl.STATIC_DRAW);

				var susanNormalBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, susanNormalBufferObject);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

				gl.bindBuffer(gl.ARRAY_BUFFER, susanPosVertexBufferObject);
				var positionAttribLocation =
					gl.getAttribLocation(program, 'vertPosition');
				gl.vertexAttribPointer(
					positionAttribLocation, // Attribute location
					3,                      // Number of elements per attribute
					gl.FLOAT,               // Type of elements
					gl.FALSE,
					3 * Float32Array.BYTES_PER_ELEMENT, // Size of an individual vertex
					0 // Offset from the beginning of a single vertex to this attribute
				);
				gl.enableVertexAttribArray(positionAttribLocation);

				gl.bindBuffer(gl.ARRAY_BUFFER, susanTexCoordVertexBufferObject);
				var texCoordAttribLocation =
					gl.getAttribLocation(program, 'vertTexCoord');
				gl.vertexAttribPointer(
					texCoordAttribLocation, // Attribute location
					2,                      // Number of elements per attribute
					gl.FLOAT,               // Type of elements
					gl.FALSE,
					2 * Float32Array.BYTES_PER_ELEMENT, // Size of an individual vertex
					0);
				gl.enableVertexAttribArray(texCoordAttribLocation);

				gl.bindBuffer(gl.ARRAY_BUFFER, susanNormalBufferObject);
				var normalAttribLocation = gl.getAttribLocation(program, 'vertNormal');
				gl.vertexAttribPointer(normalAttribLocation, 3, gl.FLOAT, gl.TRUE,
					3 * Float32Array.BYTES_PER_ELEMENT, 0);
				gl.enableVertexAttribArray(normalAttribLocation);

				//
				// Create texture
				//
				var tex = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, tex);
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE,
					parent.texture);
				gl.bindTexture(gl.TEXTURE_2D, null);

				// Tell OpenGL state machine which program should be active.
				gl.useProgram(program);

				var matWorldUniformLocation = gl.getUniformLocation(program, 'mWorld');
				var matViewUniformLocation = gl.getUniformLocation(program, 'mView');
				var matProjUniformLocation = gl.getUniformLocation(program, 'mProj');

				var worldMatrix = new Float32Array(16);
				var viewMatrix = new Float32Array(16);
				var projMatrix = new Float32Array(16);
				_GP.mat4.identity(worldMatrix);
				// mat4.lookAt(viewMatrix, [0, 0, -8], [0, 0, 0], [0, 1, 0]);

				_GP.mat4.lookAt(viewMatrix, [0, 0, -7], [0, 0, 0], [0, 1, 0]);

				_GP.mat4.perspective(projMatrix, _GP.glMatrix.toRadian(45),
					canvas.width / canvas.height, 0.1, 1000.0);

				gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, worldMatrix);
				gl.uniformMatrix4fv(matViewUniformLocation, gl.FALSE, viewMatrix);
				gl.uniformMatrix4fv(matProjUniformLocation, gl.FALSE, projMatrix);

				var xRotationMatrix = new Float32Array(16);
				var yRotationMatrix = new Float32Array(16);

				//
				// Lighting information
				//
				gl.useProgram(program);

				var ambientUniformLocation =
					gl.getUniformLocation(program, 'ambientLightIntensity');
				var sunlightDirUniformLocation =
					gl.getUniformLocation(program, 'sun.direction');
				var sunlightIntUniformLocation =
					gl.getUniformLocation(program, 'sun.color');

				gl.uniform3f(ambientUniformLocation, 0.3, 0.3, 0.3);
				gl.uniform3f(sunlightDirUniformLocation, 3.0, 4.0, -2.0);
				gl.uniform3f(sunlightIntUniformLocation, 2, 2, 2);

				//
				// Main render loop
				//
				var angle = 0;
				var count = 49;
				var identityMatrix = new Float32Array(16);
				_GP.mat4.identity(identityMatrix);
				gl.enable(gl.DEPTH_TEST);
				var loop = function () {
					var frame = requestAnimationFrame(loop);
					angle = count++ / 20;
					_GP.mat4.rotate(yRotationMatrix, identityMatrix, angle, [0, 1, 0]);
					_GP.mat4.rotate(xRotationMatrix, identityMatrix, angle / 4, [1, 0, 0]);
					_GP.mat4.mul(worldMatrix, yRotationMatrix, xRotationMatrix);
					gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, worldMatrix);

					gl.clearColor(0.0, 0.0, 0.0, 1.0);
					gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);

					gl.bindTexture(gl.TEXTURE_2D, tex);
					gl.activeTexture(gl.TEXTURE0);

					gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

					if (count == 50) {
						cancelAnimationFrame(frame);
						_GP.sender.getData(gl, parent.IDs[childNumber]);
						parent.childComplete();
					}
				};
				requestAnimationFrame(loop);
			};
		};

		this.begin = function (canvas, cb, level) {
			this.canvas = canvas;
			this.cb = cb;
			this.level = level;
			var root = 'static/assets/'
			loadTextResource(root + 'shader_slight.vs.glsl', function (vsErr, vsText, self) {
				if (vsErr) {
					//alert('Fatal error getting vertex shader (see console)');
					//console.error(vsErr);
				} else {
					loadTextResource(
						root + 'shader_slight.fs.glsl', function (fsErr, fsText, self) {
							if (fsErr) {
								//alert('Fatal error getting fragment shader (see console)');
								////console.error(fsErr);
							} else {
								self.children.push(new RunSimpleLight(vsText, fsText, 0, self));
								self.childLoaded();
							}
						}, self);
				}
			}, this);

		};
	};

	var MoreLightTest = function (vertices, indices, texCoords, normals, texture) {
		this.vertices = vertices;
		this.indices = indices;
		this.texCoords = texCoords;
		this.texture = texture;
		this.normals = normals;
		this.canvas = null;
		this.cb = null;
		this.level = null;
		this.numChildren = 3;
		this.children = [];
		this.IDs = _GP.sender.getIDs(this.numChildren);

		this.numChildrenRun = 0;
		this.childComplete = function () {
			if (++this.numChildrenRun == this.numChildren) {
				this.cb();
			} else {
				var index = this.numChildrenRun;
				this.children[index].begin(this.canvas);
			}
		};

		this.numChildrenLoaded = 0;
		this.childLoaded = function () {
			if (++this.numChildrenLoaded == this.numChildren) {
				var index = this.numChildrenRun;
				this.children[index].begin(this.canvas);
			}
		};

		var RunMoreLight = function (vertexShaderText, fragmentShaderText, ID,
			parent) {
			this.begin = function (canvas) {
				var gl;
				if (ID == 1) {
					canvas = _GP.getCanvas("can_aa");
					gl = _GP.getGLAA(canvas);
				} else gl = _GP.getGL(canvas);
				var WebGL = true;

				gl.clearColor(0.0, 0.0, 0.0, 0.0);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				gl.enable(gl.DEPTH_TEST);
				gl.enable(gl.CULL_FACE);
				gl.frontFace(gl.CCW);
				gl.cullFace(gl.BACK);

				//
				// Create shaders
				//
				var vertexShader = gl.createShader(gl.VERTEX_SHADER);
				var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

				gl.shaderSource(vertexShader, vertexShaderText);
				gl.shaderSource(fragmentShader, fragmentShaderText);

				gl.compileShader(vertexShader);
				if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
					//console.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(vertexShader));
					return;
				}

				gl.compileShader(fragmentShader);
				if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
					//console.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(fragmentShader));
					return;
				}

				var program = gl.createProgram();
				gl.attachShader(program, vertexShader);
				gl.attachShader(program, fragmentShader);
				gl.linkProgram(program);
				if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
					//console.error('ERROR linking program!', gl.getProgramInfoLog(program));
					return;
				}
				gl.validateProgram(program);
				if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
					//console.error('ERROR validating program!', gl.getProgramInfoLog(program));
					return;
				}

				//
				// Create buffer
				//
				var vertices = parent.vertices
				var indices = parent.indices;
				var texCoords = parent.texCoords;
				var normals = parent.normals;

				var susanPosVertexBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, susanPosVertexBufferObject);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices),
					gl.STATIC_DRAW);

				var susanTexCoordVertexBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, susanTexCoordVertexBufferObject);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords),
					gl.STATIC_DRAW);

				var susanIndexBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, susanIndexBufferObject);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices),
					gl.STATIC_DRAW);

				var susanNormalBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, susanNormalBufferObject);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

				gl.bindBuffer(gl.ARRAY_BUFFER, susanPosVertexBufferObject);
				var positionAttribLocation =
					gl.getAttribLocation(program, 'vertPosition');
				gl.vertexAttribPointer(
					positionAttribLocation, // Attribute location
					3,                      // Number of elements per attribute
					gl.FLOAT,               // Type of elements
					gl.FALSE,
					3 * Float32Array.BYTES_PER_ELEMENT, // Size of an individual vertex
					0 // Offset from the beginning of a single vertex to this attribute
				);
				gl.enableVertexAttribArray(positionAttribLocation);

				gl.bindBuffer(gl.ARRAY_BUFFER, susanTexCoordVertexBufferObject);
				var texCoordAttribLocation =
					gl.getAttribLocation(program, 'vertTexCoord');
				gl.vertexAttribPointer(
					texCoordAttribLocation, // Attribute location
					2,                      // Number of elements per attribute
					gl.FLOAT,               // Type of elements
					gl.FALSE,
					2 * Float32Array.BYTES_PER_ELEMENT, // Size of an individual vertex
					0);
				gl.enableVertexAttribArray(texCoordAttribLocation);

				gl.bindBuffer(gl.ARRAY_BUFFER, susanNormalBufferObject);
				var normalAttribLocation = gl.getAttribLocation(program, 'vertNormal');
				gl.vertexAttribPointer(normalAttribLocation, 3, gl.FLOAT, gl.TRUE,
					3 * Float32Array.BYTES_PER_ELEMENT, 0);
				gl.enableVertexAttribArray(normalAttribLocation);

				//
				// Create texture
				//
				var tex = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, tex);
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE,
					parent.texture);
				gl.bindTexture(gl.TEXTURE_2D, null);

				// Tell OpenGL state machine which program should be active.
				gl.useProgram(program);

				var matWorldUniformLocation = gl.getUniformLocation(program, 'mWorld');
				var matViewUniformLocation = gl.getUniformLocation(program, 'mView');
				var matProjUniformLocation = gl.getUniformLocation(program, 'mProj');

				var worldMatrix = new Float32Array(16);
				var viewMatrix = new Float32Array(16);
				var projMatrix = new Float32Array(16);
				_GP.mat4.identity(worldMatrix);
				_GP.mat4.lookAt(viewMatrix, [0, 0, -7], [0, 0, 0], [0, 1, 0]);

				_GP.mat4.perspective(projMatrix, _GP.glMatrix.toRadian(45),
					canvas.width / canvas.height, 0.1, 1000.0);

				gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, worldMatrix);
				gl.uniformMatrix4fv(matViewUniformLocation, gl.FALSE, viewMatrix);
				gl.uniformMatrix4fv(matProjUniformLocation, gl.FALSE, projMatrix);

				var xRotationMatrix = new Float32Array(16);
				var yRotationMatrix = new Float32Array(16);

				//
				// Lighting information
				//
				gl.useProgram(program);

				var ambientUniformLocation =
					gl.getUniformLocation(program, 'ambientLightIntensity');
				var sunlightDirUniformLocation =
					gl.getUniformLocation(program, 'sun.direction');
				var sunlightDiffuse = gl.getUniformLocation(program, 'sun.diffuse');
				var sunlightSpecular = gl.getUniformLocation(program, 'sun.specular');

				gl.uniform3f(ambientUniformLocation, 0.3, 0.3, 0.3);
				gl.uniform3f(sunlightDirUniformLocation, 0.8, -0.8, -0.8);
				gl.uniform3f(sunlightDiffuse, 0.75, 0.75, 1.0);
				gl.uniform3f(sunlightSpecular, 0.8, 0.8, 0.8);

				//
				// Main render loop
				//
				var identityMatrix = new Float32Array(16);
				_GP.mat4.identity(identityMatrix);
				var angle = 0;
				var count = 49;
				var end = 51;
				if (ID == 2) {
					count = 98;
					end = 100;
				}
				var ven, ren;
				var identityMatrix = new Float32Array(16);
				_GP.mat4.identity(identityMatrix);
				gl.enable(gl.DEPTH_TEST);
				var loop = function () {
					var frame = requestAnimationFrame(loop);
					angle = count++ / 20;
					_GP.mat4.rotate(yRotationMatrix, identityMatrix, angle, [0, 1, 0]);
					_GP.mat4.rotate(xRotationMatrix, identityMatrix, angle / 4, [1, 0, 0]);
					_GP.mat4.mul(worldMatrix, yRotationMatrix, xRotationMatrix);
					gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, worldMatrix);

					gl.clearColor(0.0, 0.0, 0.0, 1.0);
					gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
					gl.bindTexture(gl.TEXTURE_2D, tex);
					gl.activeTexture(gl.TEXTURE0);
					gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

					if (count == end) {
						cancelAnimationFrame(frame);
						_GP.sender.getData(gl, parent.IDs[ID]);
						parent.childComplete();
					}

				};
				requestAnimationFrame(loop);
			};
		};

		this.begin = function (canvas, cb) {
			this.canvas = canvas;
			this.cb = cb;
			var root = 'static/assets/'
			loadTextResource(root + 'shader_mlight.vs.glsl', function (vsErr, vsText, self) {
				if (vsErr) {
					//alert('Fatal error getting vertex shader (see //console)');
					//console.error(vsErr);
				} else {
					loadTextResource(
						root + 'shader_mlight.fs.glsl', function (fsErr, fsText, self) {
							if (fsErr) {
								//alert('Fatal error getting fragment shader (see ////console)');
								//console.error(fsErr);
							} else {
								self.children.push(new RunMoreLight(vsText, fsText, 0, self));
								self.childLoaded();
								self.children.push(new RunMoreLight(vsText, fsText, 1, self));
								self.childLoaded();
								self.children.push(new RunMoreLight(vsText, fsText, 2, self));
								self.childLoaded();
							}
						}, self);
				}
			}, this);

		};
	};

	var TwoTexturesMoreLightTest = function (vertices, indices, texCoords, normals, texture1, texture2) {
		this.vertices = vertices;
		this.indices = indices;
		this.texCoords = texCoords;
		this.texture1 = texture1;
		this.texture2 = texture2;
		this.normals = normals;
		this.canvas = null;
		this.cb = null;
		this.level = null;
		this.numChildren = 1;
		this.children = [];
		this.IDs = _GP.sender.getIDs(this.numChildren);

		this.numChildrenRun = 0;
		this.childComplete = function () {
			if (++this.numChildrenRun == this.numChildren) {
				this.cb();
			} else {
				var index = this.numChildrenRun;
				this.children[index].begin(this.canvas);
			}
		};

		this.numChildrenLoaded = 0;
		this.childLoaded = function () {
			if (++this.numChildrenLoaded == this.numChildren) {
				var index = this.numChildrenRun;
				this.children[index].begin(this.canvas);
			}
		};

		var RunTwoTexturesMoreLight = function (vertexShaderText, fragmentShaderText, ID,
			parent) {
			this.begin = function (canvas) {
				var gl = _GP.getGL(canvas);
				var WebGL = true;

				gl.clearColor(0.0, 0.0, 0.0, 0.0);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				gl.enable(gl.DEPTH_TEST);
				gl.enable(gl.CULL_FACE);
				gl.frontFace(gl.CCW);
				gl.cullFace(gl.BACK);

				//
				// Create shaders
				//
				var vertexShader = gl.createShader(gl.VERTEX_SHADER);
				var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

				gl.shaderSource(vertexShader, vertexShaderText);
				gl.shaderSource(fragmentShader, fragmentShaderText);

				gl.compileShader(vertexShader);
				if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
					//console.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(vertexShader));
					return;
				}

				gl.compileShader(fragmentShader);
				if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
					//console.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(fragmentShader));
					return;
				}

				var program = gl.createProgram();
				gl.attachShader(program, vertexShader);
				gl.attachShader(program, fragmentShader);
				gl.linkProgram(program);
				if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
					//console.error('ERROR linking program!', gl.getProgramInfoLog(program));
					return;
				}
				gl.validateProgram(program);
				if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
					//console.error('ERROR validating program!', gl.getProgramInfoLog(program));
					return;
				}

				//
				// Create buffer
				//
				var vertices = parent.vertices
				var indices = parent.indices;
				var texCoords = parent.texCoords;
				var normals = parent.normals;

				var susanPosVertexBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, susanPosVertexBufferObject);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices),
					gl.STATIC_DRAW);

				var susanTexCoordVertexBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, susanTexCoordVertexBufferObject);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords),
					gl.STATIC_DRAW);

				var susanIndexBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, susanIndexBufferObject);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices),
					gl.STATIC_DRAW);

				var susanNormalBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, susanNormalBufferObject);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

				gl.bindBuffer(gl.ARRAY_BUFFER, susanPosVertexBufferObject);
				var positionAttribLocation =
					gl.getAttribLocation(program, 'vertPosition');
				gl.vertexAttribPointer(
					positionAttribLocation, // Attribute location
					3,                      // Number of elements per attribute
					gl.FLOAT,               // Type of elements
					gl.FALSE,
					3 * Float32Array.BYTES_PER_ELEMENT, // Size of an individual vertex
					0 // Offset from the beginning of a single vertex to this attribute
				);
				gl.enableVertexAttribArray(positionAttribLocation);

				gl.bindBuffer(gl.ARRAY_BUFFER, susanTexCoordVertexBufferObject);
				var texCoordAttribLocation =
					gl.getAttribLocation(program, 'vertTexCoord');
				gl.vertexAttribPointer(
					texCoordAttribLocation, // Attribute location
					2,                      // Number of elements per attribute
					gl.FLOAT,               // Type of elements
					gl.FALSE,
					2 * Float32Array.BYTES_PER_ELEMENT, // Size of an individual vertex
					0);
				gl.enableVertexAttribArray(texCoordAttribLocation);

				gl.bindBuffer(gl.ARRAY_BUFFER, susanNormalBufferObject);
				var normalAttribLocation = gl.getAttribLocation(program, 'vertNormal');
				gl.vertexAttribPointer(normalAttribLocation, 3, gl.FLOAT, gl.TRUE,
					3 * Float32Array.BYTES_PER_ELEMENT, 0);
				gl.enableVertexAttribArray(normalAttribLocation);

				//
				// Create texture
				//
				var textures = [];
				var tex = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, tex);
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE,
					parent.texture1);
				textures.push(tex);

				var tex1 = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, tex1);
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE,
					parent.texture2);
				textures.push(tex1);

				// Tell OpenGL state machine which program should be active.
				gl.useProgram(program);

				var matWorldUniformLocation = gl.getUniformLocation(program, 'mWorld');
				var matViewUniformLocation = gl.getUniformLocation(program, 'mView');
				var matProjUniformLocation = gl.getUniformLocation(program, 'mProj');

				var worldMatrix = new Float32Array(16);
				var viewMatrix = new Float32Array(16);
				var projMatrix = new Float32Array(16);
				_GP.mat4.identity(worldMatrix);
				_GP.mat4.lookAt(viewMatrix, [0, 0, -7], [0, 0, 0], [0, 1, 0]);

				_GP.mat4.perspective(projMatrix, _GP.glMatrix.toRadian(45),
					canvas.width / canvas.height, 0.1, 1000.0);

				gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, worldMatrix);
				gl.uniformMatrix4fv(matViewUniformLocation, gl.FALSE, viewMatrix);
				gl.uniformMatrix4fv(matProjUniformLocation, gl.FALSE, projMatrix);

				var xRotationMatrix = new Float32Array(16);
				var yRotationMatrix = new Float32Array(16);

				//
				// Lighting information
				//
				gl.useProgram(program);

				var ambientUniformLocation =
					gl.getUniformLocation(program, 'ambientLightIntensity');
				var sunlightDirUniformLocation =
					gl.getUniformLocation(program, 'sun.direction');
				var sunlightDiffuse = gl.getUniformLocation(program, 'sun.diffuse');
				var sunlightSpecular = gl.getUniformLocation(program, 'sun.specular');

				var u_texture1 = gl.getUniformLocation(program, 'image0');
				var u_texture2 = gl.getUniformLocation(program, 'image1');

				gl.uniform3f(ambientUniformLocation, 0.3, 0.3, 0.3);
				gl.uniform3f(sunlightDirUniformLocation, 0.8, -0.8, -0.8);
				gl.uniform3f(sunlightDiffuse, 0.75, 0.75, 1.0);
				gl.uniform3f(sunlightSpecular, 0.8, 0.8, 0.8);

				gl.uniform1i(u_texture1, 0);  // texture unit 0
				gl.uniform1i(u_texture2, 1);  // texture unit 1))

				//
				// Main render loop
				//
				var identityMatrix = new Float32Array(16);
				_GP.mat4.identity(identityMatrix);
				var angle = 0;
				var count = 45;
				var ven, ren;
				var identityMatrix = new Float32Array(16);
				_GP.mat4.identity(identityMatrix);
				gl.enable(gl.DEPTH_TEST);
				var loop = function () {
					var frame = requestAnimationFrame(loop);
					angle = count++ / 20;
					_GP.mat4.rotate(yRotationMatrix, identityMatrix, angle, [0, 1, 0]);
					_GP.mat4.rotate(xRotationMatrix, identityMatrix, angle / 4, [1, 0, 0]);
					_GP.mat4.mul(worldMatrix, yRotationMatrix, xRotationMatrix);
					gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, worldMatrix);

					gl.clearColor(0.0, 0.0, 0.0, 1.0);
					gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);

					gl.bindTexture(gl.TEXTURE_2D, textures[0]);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, textures[1]);
					gl.activeTexture(gl.TEXTURE1);
					gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

					if (count == 55) {
						cancelAnimationFrame(frame);
						_GP.sender.getData(gl, parent.IDs[ID]);
						parent.childComplete();
					}

				};
				requestAnimationFrame(loop);
			};
		};

		this.begin = function (canvas, cb) {
			this.canvas = canvas;
			this.cb = cb;
			var root = 'static/assets/'
			loadTextResource(root + 'shader_2_tex.vs.glsl', function (vsErr, vsText, self) {
				if (vsErr) {
					//alert('Fatal error getting vertex shader (see console)');
					//console.error(vsErr);
				} else {
					loadTextResource(
						root + 'shader_2_tex.fs.glsl', function (fsErr, fsText, self) {
							if (fsErr) {
								//alert('Fatal error getting fragment shader (see console)');
								//console.error(fsErr);
							} else {
								self.children.push(new RunTwoTexturesMoreLight(vsText, fsText, 0, self));
								self.childLoaded();
							}
						}, self);
				}
			}, this);

		};
	};

	var TransparentTest = function (vertices, indices, texCoords, normals, texture) {
		this.vertices = vertices;
		this.indices = indices;
		this.texCoords = texCoords;
		this.texture = texture;
		this.normals = normals;
		this.canvas = null;
		this.cb = null;
		this.level = null;
		this.numChildren = 8;
		this.children = [];
		this.IDs = _GP.sender.getIDs(this.numChildren);
		this.numChildrenRun = 0;
		this.childComplete = function () {
			if (++this.numChildrenRun == this.numChildren) {
				this.cb(this.level);
			} else {
				var index = this.numChildrenRun;
				this.children[index].begin(this.canvas);
			}
		};

		this.numChildrenLoaded = 0;
		this.childLoaded = function () {
			if (++this.numChildrenLoaded == this.numChildren) {
				var index = this.numChildrenRun;
				this.children[index].begin(this.canvas);
			}
		};
		var RunTransparent = function (vertexShaderText, fragmentShaderText, alp, childNumber, parent) {
			this.begin = function (canvas) {
				var gl;
				if (childNumber == 10) {
					canvas = _GP.getCanvas("can_aa");
					gl = _GP.getGLAA(canvas);
				} else gl = _GP.getGL(canvas);
				var WebGL = true;

				gl.clearColor(0.0, 0.0, 0.0, 0.0);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				gl.enable(gl.DEPTH_TEST);
				gl.enable(gl.CULL_FACE);
				gl.frontFace(gl.CCW);
				gl.cullFace(gl.BACK);

				//
				// Create shaders
				//
				var vertexShader = gl.createShader(gl.VERTEX_SHADER);
				var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

				gl.shaderSource(vertexShader, vertexShaderText);
				gl.shaderSource(fragmentShader, fragmentShaderText);

				gl.compileShader(vertexShader);
				if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
					//console.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(vertexShader));
					return;
				}

				gl.compileShader(fragmentShader);
				if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
					//console.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(fragmentShader));
					return;
				}

				var program = gl.createProgram();
				gl.attachShader(program, vertexShader);
				gl.attachShader(program, fragmentShader);
				gl.linkProgram(program);
				if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
					//console.error('ERROR linking program!', gl.getProgramInfoLog(program));
					return;
				}
				gl.validateProgram(program);
				if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
					//console.error('ERROR validating program!', gl.getProgramInfoLog(program));
					return;
				}

				//
				// Create buffer
				//
				var vertices = parent.vertices;
				var indices = parent.indices;
				var texCoords = parent.texCoords;
				var normals = parent.normals;

				var susanPosVertexBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, susanPosVertexBufferObject);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

				var susanTexCoordVertexBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, susanTexCoordVertexBufferObject);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);

				var susanIndexBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, susanIndexBufferObject);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

				var susanNormalBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, susanNormalBufferObject);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

				gl.bindBuffer(gl.ARRAY_BUFFER, susanPosVertexBufferObject);
				var positionAttribLocation = gl.getAttribLocation(program, 'vertPosition');
				gl.vertexAttribPointer(
					positionAttribLocation, // Attribute location
					3, // Number of elements per attribute
					gl.FLOAT, // Type of elements
					gl.FALSE,
					3 * Float32Array.BYTES_PER_ELEMENT, // Size of an individual vertex
					0 // Offset from the beginning of a single vertex to this attribute
				);
				gl.enableVertexAttribArray(positionAttribLocation);

				gl.bindBuffer(gl.ARRAY_BUFFER, susanTexCoordVertexBufferObject);
				var texCoordAttribLocation = gl.getAttribLocation(program, 'vertTexCoord');
				gl.vertexAttribPointer(
					texCoordAttribLocation, // Attribute location
					2, // Number of elements per attribute
					gl.FLOAT, // Type of elements
					gl.FALSE,
					2 * Float32Array.BYTES_PER_ELEMENT, // Size of an individual vertex
					0
				);
				gl.enableVertexAttribArray(texCoordAttribLocation);

				gl.bindBuffer(gl.ARRAY_BUFFER, susanNormalBufferObject);
				var normalAttribLocation = gl.getAttribLocation(program, 'vertNormal');
				gl.vertexAttribPointer(
					normalAttribLocation,
					3, gl.FLOAT,
					gl.TRUE,
					3 * Float32Array.BYTES_PER_ELEMENT,
					0
				);
				gl.enableVertexAttribArray(normalAttribLocation);

				//
				// Create texture
				//
				var tex = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, tex);
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texImage2D(
					gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,
					gl.UNSIGNED_BYTE,
					parent.texture
				);
				gl.bindTexture(gl.TEXTURE_2D, null);

				// Tell OpenGL state machine which program should be active.
				gl.useProgram(program);

				var matWorldUniformLocation = gl.getUniformLocation(program, 'mWorld');
				var matViewUniformLocation = gl.getUniformLocation(program, 'mView');
				var matProjUniformLocation = gl.getUniformLocation(program, 'mProj');

				var worldMatrix = new Float32Array(16);
				var viewMatrix = new Float32Array(16);
				var projMatrix = new Float32Array(16);
				_GP.mat4.identity(worldMatrix);
				_GP.mat4.lookAt(viewMatrix, [0, 0, -7], [0, 0, 0], [0, 1, 0]);

				_GP.mat4.perspective(projMatrix, _GP.glMatrix.toRadian(45), canvas.width / canvas.height, 0.1, 1000.0);

				gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, worldMatrix);
				gl.uniformMatrix4fv(matViewUniformLocation, gl.FALSE, viewMatrix);
				gl.uniformMatrix4fv(matProjUniformLocation, gl.FALSE, projMatrix);

				var xRotationMatrix = new Float32Array(16);
				var yRotationMatrix = new Float32Array(16);

				//
				// Lighting information
				//
				gl.useProgram(program);

				var ambientUniformLocation = gl.getUniformLocation(program, 'ambientLightIntensity');
				var sunlightDirUniformLocation = gl.getUniformLocation(program, 'sun.direction');
				var sunlightDiffuse = gl.getUniformLocation(program, 'sun.diffuse');
				var sunlightSpecular = gl.getUniformLocation(program, 'sun.specular');
				var uAlpha = gl.getUniformLocation(program, 'uAlpha');

				gl.uniform3f(ambientUniformLocation, 0.3, 0.3, 0.3);
				gl.uniform3f(sunlightDirUniformLocation, 0.8, -0.8, -0.8);
				gl.uniform3f(sunlightDiffuse, 0.75, 0.75, 1.0);
				gl.uniform3f(sunlightSpecular, 0.8, 0.8, 0.8);
				gl.uniform1f(uAlpha, alp / 100);

				//
				// Main render loop
				//
				var identityMatrix = new Float32Array(16);
				_GP.mat4.identity(identityMatrix);
				var angle = 0;
				var count = 45;
				var ven, ren;
				var identityMatrix = new Float32Array(16);
				_GP.mat4.identity(identityMatrix);
				gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
				gl.disable(gl.DEPTH_TEST);
				gl.enable(gl.BLEND);
				gl.clearColor(0.0, 0.0, 0.0, 1.0);
				gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
				//ctx.font = "48px";
				var loop = function () {
					var frame = requestAnimationFrame(loop);
					angle = count++ / 20;
					_GP.mat4.rotate(yRotationMatrix, identityMatrix, angle, [0, 1, 0]);
					_GP.mat4.rotate(xRotationMatrix, identityMatrix, -1.5, [1, 0, 0]);
					_GP.mat4.mul(worldMatrix, yRotationMatrix, xRotationMatrix);
					gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, worldMatrix);

					gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
					gl.bindTexture(gl.TEXTURE_2D, tex);
					gl.activeTexture(gl.TEXTURE0);
					gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
					//ctx.fillText("Hello world", 9, 50);

					if (count == 50) {
						cancelAnimationFrame(frame);
						_GP.sender.getData(gl, parent.IDs[childNumber]);
						parent.childComplete();
					}
				};
				requestAnimationFrame(loop);
			};
		};

		this.begin = function (canvas, cb, level) {
			this.canvas = canvas;
			this.cb = cb;
			this.level = level;
			var root = 'static/assets/'
			loadTextResource(root + 'shader_trans.vs.glsl', function (vsErr, vsText, self) {
				if (vsErr) {
					//alert('Fatal error getting vertex shader (see console)');
					//console.error(vsErr);
				} else {
					loadTextResource(root + 'shader_trans.fs.glsl', function (fsErr, fsText, self) {
						if (fsErr) {
							//alert('Fatal error getting fragment shader (see console)');
							//console.error(fsErr);
						} else {
							self.children.push(new RunTransparent(vsText, fsText, 100, 0, self));
							self.childLoaded();
							self.children.push(new RunTransparent(vsText, fsText, 9, 1, self));
							self.childLoaded();
							self.children.push(new RunTransparent(vsText, fsText, 10, 2, self));
							self.childLoaded();
							self.children.push(new RunTransparent(vsText, fsText, 11, 3, self));
							self.childLoaded();
							self.children.push(new RunTransparent(vsText, fsText, 50, 4, self));
							self.childLoaded();
							self.children.push(new RunTransparent(vsText, fsText, 79, 5, self));
							self.childLoaded();
							self.children.push(new RunTransparent(vsText, fsText, 80, 6, self));
							self.childLoaded();
							self.children.push(new RunTransparent(vsText, fsText, 81, 7, self));
							self.childLoaded();
						}
					}, self);
				}
			}, this);
		};
	};

	/***
	* This test plays video in preferably a webm format and draws it to a
	* canvas using a 2d context and a webgl context.  This is testing how
	* the decompression of the video container is implemented.  This is more
	* than likely something that is controlled by a browser.
	* There are 3 videos that can be played depending on what the browser supports:
	* webm video created from .png using ffmpeg:
	*   ffmpeg -loop 1 -i rainbow.png -c:v libvpx -vframes 10 -r 30 -pix_fmt yuv422p
	*-crf 4 rainbow.webm
	* high quality mp4 created from .png using ffmpeg:
	*   ffmpeg -loop 1 -i rainbow.png -c:v libx264 -vframes 10 -r 30 -pix_fmt
	*yuv420p -crf 4 rainbow.mp4
	* standard mp4 created using iMovie exported to high quality
	***/

	var VideoCollector =
		function (webmVid, mp4Vid, id) {
			var numFrames = 2;
			this.IDs = _GP.sender.getIDs(numFrames * 2);

			this.ctxID = 0;
			this.glID = 1;
			this.ctxHashes = new Set();
			this.glHashes = new Set();
			this.ctxMode = true;
			this.cb = null;
			this.ctx = null;
			this.gl = null;
			this.vx_ptr = null;
			this.vx = null;
			this.tex = null;
			this.ix = null;
			this.startGL = function () {
				var glCan = $('<canvas width="256" height="256"></canvas>')
					.appendTo($('#test_canvases'))[0];
				this.gl = _GP.getGL(glCan);

				this.gl.enable(this.gl.BLEND);
				this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);

				var vs = this.gl.createShader(this.gl.VERTEX_SHADER);
				this.gl.shaderSource(
					vs,
					"attribute vec2 vx;varying vec2 tx;void main(){gl_Position=vec4(vx.x*2.0-1.0,1.0-vx.y*2.0,0,1);tx=vx;}");
				this.gl.compileShader(vs);

				var ps = this.gl.createShader(this.gl.FRAGMENT_SHADER);
				this.gl.shaderSource(
					ps,
					"precision mediump float;uniform sampler2D sm;varying vec2 tx;void main(){gl_FragColor=texture2D(sm,tx);}");
				this.gl.compileShader(ps);

				var shader = this.gl.createProgram();
				this.gl.attachShader(shader, vs);
				this.gl.attachShader(shader, ps);
				this.gl.linkProgram(shader);
				this.gl.useProgram(shader);

				this.vx_ptr = this.gl.getAttribLocation(shader, "vx");
				this.gl.enableVertexAttribArray(this.vx_ptr);
				this.gl.uniform1i(this.gl.getUniformLocation(shader, "sm"), 0);

				this.vx = this.gl.createBuffer();
				this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vx);
				this.gl.bufferData(this.gl.ARRAY_BUFFER,
					new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
					this.gl.STATIC_DRAW);

				this.ix = this.gl.createBuffer();
				this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.ix);
				this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,
					new Uint16Array([0, 1, 2, 0, 2, 3]),
					this.gl.STATIC_DRAW);

				this.tex = this.gl.createTexture();
				this.gl.bindTexture(this.gl.TEXTURE_2D, this.tex);
				this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0,
					this.gl.RGBA, this.gl.UNSIGNED_BYTE,
					new Uint8Array([255, 0, 0, 255]));
				this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T,
					this.gl.CLAMP_TO_EDGE);
				this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S,
					this.gl.CLAMP_TO_EDGE);
				this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER,
					this.gl.LINEAR);
				this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER,
					this.gl.LINEAR);
			};

			var ctxCanvas = $('<canvas width="256" height="256"></canvas>')
				.appendTo($('#test_canvases'))[0];
			this.ctx = ctxCanvas.getContext('2d');
			this.startGL();

			this.collector = function () {
				if (++this.count % 3 == 2) {
					if (this.collected[0] < numFrames) {
						var status = _GP.sender.getDataFromCanvas(this.ctx, this.IDs[this.ctxID]);
						if (status) {
							this.ctxHashes.add(status);
							if (this.ctxHashes.length > this.collected[0]) {
								++this.collected[0]
								this.ctxID += 2;
							}
						}
						if (this.count > 24) {
							++this.collected[0]
							this.ctxID += 2;
						}
					}

					if (this.collected[1] < numFrames) {
						var status = _GP.sender.getData(this.gl, this.IDs[this.glID]);
						if (status) {
							this.glHashes.add(status);
							if (this.glHashes.length > this.collected[1]) {
								++this.collected[1]
								this.glID += 2;
							}
						}
						if (this.count > 24) {
							++this.collected[1]
							this.glID += 2;
						}
					}
					if (this.collected[1] == numFrames && this.collected[0] == numFrames) {
						this.video[0].pause();
						cancelAnimationFrame(this.frame);
						this.cb();
						++this.collected[1];
					}
				}
			}

			this.begin = function (cb) {
				this.cb = cb;

				this.video = $('<video/>').appendTo($('body'));
				this.video.addClass("hidden-vid");
				$('<source src="' + webmVid + '" type="video/webm"/>').appendTo(this.video);
				$('<source src="' + mp4Vid + '" type="video/mp4"/>').appendTo(this.video);
				$('<source src="./video/backup.mp4" type="video/mp4"/>')
					.appendTo(this.video);
				this.video.prop('loop', true);
				this.video.prop('autoplay', true);
				this.video.on('play', { self: this }, function (event) {
					var self = event.data.self;
					drawVid(256, 256, this, self);
				});
				this.video.prop('muted', true);
				this.count = 0, this.collected = [0, 0];

				this.video.on('timeupdate', { self: this }, function (event) {
					var self = event.data.self;
					// self.collector();

					// $("#" + self.counterName).text(self.level);
				});

				// Render loop
				function drawVid(w, h, vid, self) {
					self.frame =
						requestAnimationFrame(function () { drawVid(w, h, vid, self); });
					var vidH = 9 / 16 * w;
					var offset = (h - vidH) / 2.0;
					self.ctx.drawImage(vid, 0, offset, w, vidH);

					self.gl.viewport(0, offset, w, vidH);
					self.gl.clear(self.gl.COLOR_BUFFER_BIT);
					self.gl.activeTexture(self.gl.TEXTURE0);
					self.gl.bindTexture(self.gl.TEXTURE_2D, self.tex);
					self.gl.texImage2D(self.gl.TEXTURE_2D, 0, self.gl.RGB, self.gl.RGB,
						self.gl.UNSIGNED_BYTE, vid);
					self.gl.bindBuffer(self.gl.ARRAY_BUFFER, self.vx);
					self.gl.vertexAttribPointer(self.vx_ptr, 2, self.gl.FLOAT, false, 0, 0);

					self.gl.bindBuffer(self.gl.ELEMENT_ARRAY_BUFFER, self.ix);
					self.gl.drawElements(self.gl.TRIANGLES, 6, self.gl.UNSIGNED_SHORT, 0);
					self.collector();
				}
			}
		}

	// Document on ready jquery shortcut
	var VideoTest = function () {

		var vidCollector =
			new VideoCollector("./video/rainbow.webm", "./video/rainbow.mp4", 0);

		this.begin = function (cb) { vidCollector.begin(cb); }
	};

	var CanvasTest = function () {
		canvasData = "Not supported";
		canvas = $("<canvas height='60' width='400'></canvas>")[0];
		canvasContext = canvas.getContext("2d");
		canvas.style.display = "inline";
		canvasContext.textBaseline = "alphabetic";
		canvasContext.fillStyle = "#f60";
		canvasContext.fillRect(125, 1, 62, 20);
		canvasContext.fillStyle = "#069";
		canvasContext.font = "11pt no-real-font-123";
		canvasContext.fillText("Cwm fjordbank glyphs vext quiz, \ud83d\ude03", 2, 15);
		canvasContext.fillStyle = "rgba(102, 204, 0, 0.7)";
		canvasContext.font = "18pt Arial";
		canvasContext.fillText("Cwm fjordbank glyphs vext quiz, \ud83d\ude03", 4, 45);
		canvasData = canvas.toDataURL();
		return canvasData;
	}

	var TextureTest = function (vertices, indices, texCoords, texture) {
		this.vertices = vertices;
		this.indices = indices;
		this.texCoords = texCoords;
		this.texture = texture;
		this.canvas = null;
		this.cb = null;
		this.level = null;
		this.numChildren = 1;
		this.children = [];
		this.numChildrenRun = 0;
		this.IDs = _GP.sender.getIDs(this.numChildren);
		this.childComplete = function () {
			if (++this.numChildrenRun == this.numChildren) {
				this.cb();
			} else {
				var index = this.numChildrenRun;
				this.children[index].begin(this.canvas);
			}
		};
		this.numChildrenLoaded = 0;
		this.childLoaded = function () {
			if (++this.numChildrenLoaded == this.numChildren) {
				var index = this.numChildrenRun;
				this.children[index].begin(this.canvas);
			}
		};

		var RunTexture = function (vertexShaderText, fragmentShaderText, ID, parent) {
			this.begin = function (canvas) {
				var gl = _GP.getGL(canvas);
				var WebGL = true;

				gl.clearColor(0.0, 0.0, 0.0, 0.0);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				gl.enable(gl.DEPTH_TEST);
				gl.enable(gl.CULL_FACE);
				gl.frontFace(gl.CCW);
				gl.cullFace(gl.BACK);

				//
				// Create shaders
				//
				var vertexShader = gl.createShader(gl.VERTEX_SHADER);
				var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

				gl.shaderSource(vertexShader, vertexShaderText);
				gl.shaderSource(fragmentShader, fragmentShaderText);

				gl.compileShader(vertexShader);
				if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
					//console.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(vertexShader));
					return;
				}

				gl.compileShader(fragmentShader);
				if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
					//console.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(fragmentShader));
					return;
				}

				var program = gl.createProgram();
				gl.attachShader(program, vertexShader);
				gl.attachShader(program, fragmentShader);
				gl.linkProgram(program);
				if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
					//console.error('ERROR linking program!', gl.getProgramInfoLog(program));
					return;
				}
				gl.validateProgram(program);
				if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
					//console.error('ERROR validating program!', gl.getProgramInfoLog(program));
					return;
				}

				//
				// Create buffer
				//

				var allVertices = parent.vertices;
				var allIndices = parent.indices;
				var allTexCoords = parent.texCoords;

				var allPosVertexBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, allPosVertexBufferObject);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allVertices),
					gl.STATIC_DRAW);

				var allTexCoordVertexBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, allTexCoordVertexBufferObject);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allTexCoords),
					gl.STATIC_DRAW);

				var allIndexBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, allIndexBufferObject);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(allIndices),
					gl.STATIC_DRAW);

				gl.bindBuffer(gl.ARRAY_BUFFER, allPosVertexBufferObject);
				var positionAttribLocation =
					gl.getAttribLocation(program, 'vertPosition');
				gl.vertexAttribPointer(
					positionAttribLocation, // Attribute location
					3,                      // Number of elements per attribute
					gl.FLOAT,               // Type of elements
					gl.FALSE,
					3 * Float32Array.BYTES_PER_ELEMENT, // Size of an individual vertex
					0 // Offset from the beginning of a single vertex to this attribute
				);
				gl.enableVertexAttribArray(positionAttribLocation);

				gl.bindBuffer(gl.ARRAY_BUFFER, allTexCoordVertexBufferObject);
				var texCoordAttribLocation =
					gl.getAttribLocation(program, 'vertTexCoord');
				gl.vertexAttribPointer(
					texCoordAttribLocation, // Attribute location
					2,                      // Number of elements per attribute
					gl.FLOAT,               // Type of elements
					gl.FALSE,
					2 * Float32Array.BYTES_PER_ELEMENT, // Size of an individual vertex
					0);
				gl.enableVertexAttribArray(texCoordAttribLocation);

				//
				// Create texture
				//
				var tex = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, tex);
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE,
					parent.texture);
				gl.bindTexture(gl.TEXTURE_2D, null);

				// Tell OpenGL state machine which program should be active.
				gl.useProgram(program);

				var matWorldUniformLocation = gl.getUniformLocation(program, 'mWorld');
				var matViewUniformLocation = gl.getUniformLocation(program, 'mView');
				var matProjUniformLocation = gl.getUniformLocation(program, 'mProj');

				var worldMatrix = new Float32Array(16);
				var viewMatrix = new Float32Array(16);
				var projMatrix = new Float32Array(16);
				_GP.mat4.identity(worldMatrix);
				_GP.mat4.lookAt(viewMatrix, [0, 0, -7], [0, 0, 0], [0, 1, 0]);

				_GP.mat4.perspective(projMatrix, _GP.glMatrix.toRadian(45),
					canvas.width / canvas.height, 0.1, 1000.0);

				gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, worldMatrix);
				gl.uniformMatrix4fv(matViewUniformLocation, gl.FALSE, viewMatrix);
				gl.uniformMatrix4fv(matProjUniformLocation, gl.FALSE, projMatrix);

				var xRotationMatrix = new Float32Array(16);
				var yRotationMatrix = new Float32Array(16);

				//
				// Main render loop
				//
				var identityMatrix = new Float32Array(16);
				_GP.mat4.identity(identityMatrix);
				var angle = 0;
				var count = 45;
				var identityMatrix = new Float32Array(16);

				_GP.mat4.identity(identityMatrix);
				gl.enable(gl.DEPTH_TEST);
				var loop = function () {
					var frame = requestAnimationFrame(loop);
					angle = count++ / 20;
					_GP.mat4.rotate(yRotationMatrix, identityMatrix, angle, [0, 1, 0]);
					_GP.mat4.rotate(xRotationMatrix, identityMatrix, angle / 4, [1, 0, 0]);
					_GP.mat4.mul(worldMatrix, yRotationMatrix, xRotationMatrix);
					gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, worldMatrix);

					gl.clearColor(0.0, 0.0, 0.0, 1.0);
					gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);

					gl.bindTexture(gl.TEXTURE_2D, tex);
					gl.activeTexture(gl.TEXTURE0);
					gl.drawElements(gl.TRIANGLES, allIndices.length, gl.UNSIGNED_SHORT, 0);
					if (count == 50) {
						cancelAnimationFrame(frame);
						_GP.sender.getData(gl, parent.IDs[ID]);
						parent.childComplete();
					}
				};
				requestAnimationFrame(loop);
			};
		};

		this.begin = function (canvas, cb) {
			this.canvas = canvas;
			this.cb = cb;
			var root = 'static/assets/'
			loadTextResource(root + 'shader_tex.vs.glsl', function (vsErr, vsText, self) {
				if (vsErr) {
					//alert('Fatal error getting vertex shader (see //console)');
					//console.error(vsErr);
				} else {
					loadTextResource(
						root + 'shader_tex.fs.glsl', function (fsErr, fsText, self) {
							if (fsErr) {
								//alert('Fatal error getting fragment shader (see //console)');
								//console.error(fsErr);
							} else {
								self.children.push(new RunTexture(vsText, fsText, 0, self));
								self.childLoaded();
							}
						}, self);
				}
			}, this);
		};
	};

	// Generated by CoffeeScript 1.10.0

	/*
	Compressed Texture Test
	This test use two different formats of compressed textures to test how
	the GPU decompress the textures (and which formats it supports).  Compressed
	textures differ from normal textures as webgl cannot decompress them and
	thus the raw byte values are sent directly to the GPU for decompression
	This makes use of a variety of different webgl compressed texture extensions
	 */

	(function () {

		_GP.CompressedTextureTest = (function () {
			var DDSTest, PVRTest, delta, geometry, startX, startY, textureRoot, xStop;

			textureRoot = 'static/assets';

			geometry = new THREE.BoxGeometry(150, 150, 150);

			startX = -400;

			xStop = Math.abs(startX);

			startY = -200;

			delta = 250;

			DDSTest = (function () {
				function DDSTest(id) {
					var cubemap1, cubemap2, cubemap3, i, len, loader, map1, map2, map3, map4, map5, map6, mat, mesh, ref, x, y;
					this.id = id;
					this.camera = new THREE.PerspectiveCamera(60, 1, 1, 2000);
					this.camera.position.z = 1000;
					this.scene = new THREE.Scene();

					/*
					This is how compressed textures are supposed to be used:
				    
					DXT1 - RGB - opaque textures
					DXT3 - RGBA - transparent textures with sharp alpha transitions
					DXT5 - RGBA - transparent textures with full alpha range
					 */
					this.materials = [];
					loader = new THREE.DDSLoader();
					map1 = loader.load(textureRoot + "/disturb_dxt1_nomip.dds");
					map1.minFilter = map1.magFilter = THREE.LinearFilter;
					map1.anisotropy = 4;
					map2 = loader.load(textureRoot + "/disturb_dxt1_mip.dds");
					map2.anisotropy = 4;
					map3 = loader.load(textureRoot + "/hepatica_dxt3_mip.dds");
					map3.anisotropy = 4;
					map4 = loader.load(textureRoot + "/explosion_dxt5_mip.dds");
					map4.anisotropy = 4;
					map5 = loader.load(textureRoot + "/disturb_argb_nomip.dds");
					map5.minFilter = map5.magFilter = THREE.LinearFilter;
					map5.anisotropy = 4;
					map6 = loader.load(textureRoot + "/disturb_argb_mip.dds");
					map6.anisotropy = 4;
					cubemap1 = loader.load(textureRoot + "/Mountains.dds", (function (_this) {
						return function (texture) {
							texture.magFilter = THREE.LinearFilter;
							texture.minFilter = THREE.LinearFilter;
							texture.mapping = THREE.CubeReflectionMapping;
							return _this.materials[0].needsUpdate = true;
						};
					})(this));
					cubemap2 = loader.load(textureRoot + "/Mountains_argb_mip.dds", (function (_this) {
						return function (texture) {
							texture.magFilter = THREE.LinearFilter;
							texture.minFilter = THREE.LinearFilter;
							texture.mapping = THREE.CubeReflectionMapping;
							return _this.materials[1].needsUpdate = true;
						};
					})(this));
					cubemap3 = loader.load(textureRoot + "/Mountains_argb_nomip.dds", (function (_this) {
						return function (texture) {
							texture.magFilter = THREE.LinearFilter;
							texture.minFilter = THREE.LinearFilter;
							texture.mapping = THREE.CubeReflectionMapping;
							return _this.materials[2].needsUpdate = true;
						};
					})(this));
					this.materials.push(new THREE.MeshBasicMaterial({
						map: map1,
						envMap: cubemap1
					}));
					this.materials.push(new THREE.MeshBasicMaterial({
						envMap: cubemap2
					}));
					this.materials.push(new THREE.MeshBasicMaterial({
						envMap: cubemap3
					}));
					this.materials.push(new THREE.MeshBasicMaterial({
						map: map2
					}));
					this.materials.push(new THREE.MeshBasicMaterial({
						map: map3,
						alphaTest: 0.5,
						side: THREE.DoubleSide
					}));
					this.materials.push(new THREE.MeshBasicMaterial({
						map: map4,
						side: THREE.DoubleSide,
						blending: THREE.AdditiveBlending,
						depthTest: false,
						transparent: true
					}));
					this.materials.push(new THREE.MeshBasicMaterial({
						map: map5
					}));
					this.materials.push(new THREE.MeshBasicMaterial({
						map: map6
					}));
					this.meshes = [];
					x = startX;
					y = startY;
					ref = this.materials;
					for (i = 0, len = ref.length; i < len; i++) {
						mat = ref[i];
						mesh = new THREE.Mesh(geometry, mat);
						mesh.position.x = x;
						mesh.position.y = y;
						this.scene.add(mesh);
						this.meshes.push(mesh);
						x += delta;
						if (x > xStop) {
							y += delta;
							x = startX;
						}
					}
				}

				DDSTest.prototype.begin = function (canvas, cb) {
					var animate;
					this.cb = cb;
					this.renderer = new THREE.WebGLRenderer({
						context: _GP.getGL(canvas),
						canvas: canvas
					}, false);
					this.renderer.setClearColor('#050505');
					this.renderer.setPixelRatio(1);
					this.renderer.setSize(canvas.width, canvas.height);
					this.counter = 0;
					animate = (function (_this) {
						return function () {
							var frame, i, len, mesh, ref, time;
							frame = raf(animate);
							time = _this.counter++ * 0.01;
							ref = _this.meshes;
							for (i = 0, len = ref.length; i < len; i++) {
								mesh = ref[i];
								mesh.rotation.x = time;
								mesh.rotation.y = time;
							}
							_this.renderer.render(_this.scene, _this.camera);
							if (_this.counter === 10) {
								__gpcaf(frame);
								_GP.sender.getData(_this.renderer.getContext(), _this.id);
								return _this.cb();
							}
						};
					})(this);
					return raf(animate);
				};

				return DDSTest;

			})();

			PVRTest = (function () {
				function PVRTest(id) {
					var disturb_2bpp_rgb, disturb_4bpp_rgb, disturb_4bpp_rgb_mips, disturb_4bpp_rgb_v3, flare_2bpp_rgba, flare_4bpp_rgba, i, len, loader, mat, mesh, park3_cube_mip_2bpp_rgb_v3, park3_cube_nomip_4bpp_rgb, ref, x, y;
					this.id = id;
					this.camera = new THREE.PerspectiveCamera(60, 1, 1, 2000);
					this.camera.position.z = 1500;
					this.scene = new THREE.Scene();
					this.materials = [];
					loader = new THREE.PVRLoader();
					disturb_4bpp_rgb = loader.load(textureRoot + "/disturb_4bpp_rgb.pvr");
					disturb_4bpp_rgb_v3 = loader.load(textureRoot + "/disturb_4bpp_rgb_v3.pvr");
					disturb_4bpp_rgb_mips = loader.load(textureRoot + "/disturb_4bpp_rgb_mips.pvr");
					disturb_2bpp_rgb = loader.load(textureRoot + "/disturb_2bpp_rgb.pvr");
					flare_4bpp_rgba = loader.load(textureRoot + "/flare_4bpp_rgba.pvr");
					flare_2bpp_rgba = loader.load(textureRoot + "/flare_2bpp_rgba.pvr");
					park3_cube_nomip_4bpp_rgb = loader.load(textureRoot + "/park3_cube_nomip_4bpp_rgb.pvr", (function (_this) {
						return function (texture) {
							texture.magFilter = THREE.LinearFilter;
							texture.minFilter = THREE.LinearFilter;
							texture.mapping = THREE.CubeReflectionMapping;
							return _this.meshes[0].needsUpdate = true;
						};
					})(this));
					park3_cube_mip_2bpp_rgb_v3 = loader.load(textureRoot + "/park3_cube_mip_2bpp_rgb_v3.pvr", (function (_this) {
						return function (texture) {
							texture.magFilter = THREE.LinearFilter;
							texture.minFilter = THREE.LinearFilter;
							texture.mapping = THREE.CubeReflectionMapping;
							return _this.meshes[1].needsUpdate = true;
						};
					})(this));
					disturb_2bpp_rgb.minFilter = disturb_2bpp_rgb.magFilter = flare_4bpp_rgba.minFilter = flare_4bpp_rgba.magFilter = disturb_4bpp_rgb.minFilter = disturb_4bpp_rgb.magFilter = disturb_4bpp_rgb_v3.minFilter = disturb_4bpp_rgb_v3.magFilter = flare_2bpp_rgba.minFilter = flare_2bpp_rgba.magFilter = THREE.LinearFilter;
					this.materials.push(new THREE.MeshBasicMaterial({
						envMap: park3_cube_nomip_4bpp_rgb
					}));
					this.materials.push(new THREE.MeshBasicMaterial({
						envMap: park3_cube_mip_2bpp_rgb_v3
					}));
					this.materials.push(new THREE.MeshBasicMaterial({
						map: disturb_4bpp_rgb
					}));
					this.materials.push(new THREE.MeshBasicMaterial({
						map: disturb_4bpp_rgb_mips
					}));
					this.materials.push(new THREE.MeshBasicMaterial({
						map: disturb_2bpp_rgb
					}));
					this.materials.push(new THREE.MeshBasicMaterial({
						map: flare_4bpp_rgba,
						side: THREE.DoubleSide,
						depthTest: false,
						transparent: true
					}));
					this.materials.push(new THREE.MeshBasicMaterial({
						map: flare_2bpp_rgba,
						side: THREE.DoubleSide,
						depthTest: false,
						transparent: true
					}));
					this.materials.push(new THREE.MeshBasicMaterial({
						map: disturb_4bpp_rgb_v3
					}));
					this.meshes = [];
					x = startX;
					y = startY;
					ref = this.materials;
					for (i = 0, len = ref.length; i < len; i++) {
						mat = ref[i];
						mesh = new THREE.Mesh(geometry, mat);
						mesh.position.x = x;
						mesh.position.y = y;
						this.scene.add(mesh);
						this.meshes.push(mesh);
						x += delta;
						if (x > xStop) {
							y += delta;
							x = startX;
						}
					}
				}

				PVRTest.prototype.begin = function (canvas, cb) {
					var animate;
					this.cb = cb;
					this.renderer = new THREE.WebGLRenderer({
						context: _GP.getGL(canvas),
						canvas: canvas
					}, false);
					this.renderer.setClearColor('#050505');
					this.renderer.setPixelRatio(1);
					this.renderer.setSize(canvas.width, canvas.height);
					this.counter = 0;
					animate = (function (_this) {
						return function () {
							var frame, i, len, mesh, ref, time;
							frame = raf(animate);
							time = _this.counter++ * 0.001;
							ref = _this.meshes;
							for (i = 0, len = ref.length; i < len; i++) {
								mesh = ref[i];
								mesh.rotation.x = time;
								mesh.rotation.y = time;
							}
							_this.renderer.render(_this.scene, _this.camera);
							if (_this.counter === 10) {
								__gpcaf(frame);
								_GP.sender.getData(_this.renderer.getContext(), _this.id);
								return _this.cb();
							}
						};
					})(this);
					return raf(animate);
				};

				return PVRTest;

			})();

			function CompressedTextureTest() {
				if (!Detector.webgl) {
					Detector.addGetWebGLMessage();
				}
				this.tests = [];
				this.tests.push(new DDSTest(_GP.sender.getID()));
				this.tests.push(new PVRTest(_GP.sender.getID()));
			}

			CompressedTextureTest.prototype.begin = function (canvas1, cb) {
				var tester;
				this.canvas = canvas1;
				this.cb = cb;
				this.index = 0;
				tester = (function (_this) {
					return function () {
						if (_this.index === _this.tests.length) {
							return _this.cb();
						} else {
							return _this.tests[_this.index++].begin(_this.canvas, tester);
						}
					};
				})(this);
				return tester();
			};

			return CompressedTextureTest;

		})();

	}).call(this);

	// Generated by CoffeeScript 1.10.0
	(function () {

		var Loader, root;

		root = typeof exports !== "undefined" && exports !== null ? exports : this;

		_GP.createCopyButton = function (text, home) {
			var clipboard;
			clipboard = new Clipboard('.btn');
			clipboard.on('success', function (e) {
				var trigger;
				e.clearSelection();
				trigger = $(e.trigger);
				if (trigger.attr('data-toggle') === 'tooltip') {
					trigger.attr('data-original-title', "Coppied").tooltip('fixTitle').tooltip('show');
					return setTimeout(function () {
						return trigger.tooltip('hide');
					}, 1000);
				}
			});
			clipboard.on('error', function (e) {
				var trigger;
				trigger = $(e.trigger);
				if (trigger.attr('data-toggle') === 'tooltip') {
					trigger.attr('data-original-title', "Press Cmd+C to copy").tooltip('fixTitle').tooltip('show');
					return setTimeout(function () {
						return trigger.tooltip('hide');
					}, 3000);
				}
			});
			return $("<button type='button' class='btn btn-default' data-clipboard-action='copy' data-clipboard-text='" + text + "' data-toggle='tooltip' data-trigger='manual' data-placement='auto' data-html='true' >Copy</button>").tooltip().appendTo($(home));
		};

		_GP.mobileAndTabletCheck = function () {
			return (function (a) {
				if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) {
					return true;
				} else {
					return false;
				}
			})(navigator.userAgent || navigator.vendor || window.opera);
		};

		Loader = (function () {
			function Loader() {
				var colorName, colorName1, simpleName, susanName;
				this.parseURL();
				//this.checkID();
				this.numberOfAssets = 0;
				this.numLoaded = 0;
				susanName = 'static/assets/Susan.json';
				simpleName = 'static/assets/simple.json';
				colorName = 'static/assets/color.png';
				colorName1 = 'static/assets/color2.png';
				this.loadJSONResource(susanName, (function (_this) {
					return function (err, susanModel) {
						_this.susanModel = susanModel;
						if (err) {
							//alert('error getting susan model');
							//console.log(err);
						} else {
							_this.assetLoaded();
						}
						return true;
					};
				})(this));
				this.loadJSONResource(simpleName, (function (_this) {
					return function (err, simpleModel) {
						_this.simpleModel = simpleModel;
						if (err) {
							//alert('error getting simpleModel');
							//console.log(err);
						} else {
							_this.assetLoaded();
						}
						return true;
					};
				})(this));
				this.loadImage(colorName, (function (_this) {
					return function (err, texture) {
						_this.texture = texture;
						if (err) {
							//alert('error getting color.png');
							//console.log(err);
						} else {
							_this.assetLoaded();
						}
						return true;
					};
				})(this));
				this.loadImage(colorName1, (function (_this) {
					return function (err, texture1) {
						_this.texture1 = texture1;
						if (err) {
							//alert('error getting colors.png');
							//console.log(err);
						} else {
							_this.assetLoaded();
						}
						return true;
					};
				})(this));
			}

			Loader.prototype.parseURL = function () {
				var c, j, len, ref, seq;
				this.url = document.URL;
				this.parser = document.createElement('a');
				this.parser.href = this.url;
				this.commands = this.parser.search;
				this.requests = {};
				if (this.commands) {
					ref = this.commands.slice(1).split('&');
					for (j = 0, len = ref.length; j < len; j++) {
						c = ref[j];
						seq = c.split('=');
						this.requests[seq[0]] = seq[1];
					}
				}
				return root.requests = this.requests;
			};

			Loader.prototype.assetLoaded = function () {
				this.numLoaded++;
				if (this.numLoaded === this.numberOfAssets) {
					return this.beginTests();
				}
			};

			Loader.prototype.loadTextResource = function (url, callback) {
				var request;
				++this.numberOfAssets;
				request = new XMLHttpRequest();
				request.open('GET', url + "?please-dont-cache=" + (Math.random()), true);
				request.onload = function () {
					if (request.status < 200 || request.status > 299) {
						return callback("Error: HTTP Status " + request.status + " on resource " + url);
					} else {
						return callback(null, request.responseText);
					}
				};
				request.send();
				return true;
			};

			Loader.prototype.loadImage = function (url, callback) {
				var image;
				++this.numberOfAssets;
				image = new Image();
				image.onload = function () {
					return callback(null, image);
				};
				image.src = url;
				return true;
			};

			Loader.prototype.loadJSONResource = function (url, callback) {
				this.loadTextResource(url, function (err, result) {
					var e, error;
					if (err) {
						return callback(err);
					} else {
						try {
							return callback(null, JSON.parse(result));
						} catch (error) {
							e = error;
							return callback(e);
						}
					}
				});
				return true;
			};

			Loader.prototype.beginTests = function () {
				var Tester, canvasContainer, d, i, index, j, k, l, len, maxFirst, postProgress, ref, ref1, ref2, ref3, ref4, ref5, sender, test, vert;
				this.susanVertices = this.susanModel.meshes[0].vertices;
				this.susanIndices = [].concat.apply([], this.susanModel.meshes[0].faces);
				this.susanTexCoords = this.susanModel.meshes[0].texturecoords[0];
				this.susanNormals = this.susanModel.meshes[0].normals;
				this.simpleVertices = (function () {
					var j, len, ref, results;
					ref = this.simpleModel.meshes[0].vertices;
					results = [];
					for (j = 0, len = ref.length; j < len; j++) {
						vert = ref[j];
						results.push(vert / 20.0);
					}
					return results;
				}).call(this);
				this.simpleIndices = [].concat.apply([], this.simpleModel.meshes[0].faces);
				this.simpleTexCoords = this.simpleModel.meshes[0].texturecoords[0];
				this.simpleNormals = this.simpleModel.meshes[0].normals;
				this.combinedVertices = new Array(this.simpleIndices.length + this.susanIndices.length);
				for (i = j = 0, ref = this.susanVertices.length; j < ref; i = j += 3) {
					this.combinedVertices[i + 0] = this.susanVertices[i + 0];
					this.combinedVertices[i + 1] = this.susanVertices[i + 1] + 1.3;
					this.combinedVertices[i + 2] = this.susanVertices[i + 2];
				}
				for (i = k = 0, ref1 = this.simpleVertices.length; k < ref1; i = k += 3) {
					this.combinedVertices[i + 0 + this.susanVertices.length] = this.simpleVertices[i + 0];
					this.combinedVertices[i + 1 + this.susanVertices.length] = this.simpleVertices[i + 1] - 1.3;
					this.combinedVertices[i + 2 + this.susanVertices.length] = this.simpleVertices[i + 2];
				}
				this.combinedIndices = new Array(this.simpleIndices.length + this.susanIndices.length);
				[].splice.apply(this.combinedIndices, [0, this.susanIndices.length - 0].concat(ref2 = this.susanIndices)), ref2;
				maxFirst = this.susanIndices.reduce(function (a, b) {
					return Math.max(a, b);
				});
				[].splice.apply(this.combinedIndices, [(ref3 = this.susanIndices.length), this.combinedIndices.length - ref3].concat(ref4 = (function () {
					var l, len, ref5, results;
					ref5 = this.simpleIndices;
					results = [];
					for (l = 0, len = ref5.length; l < len; l++) {
						index = ref5[l];
						results.push(index + 1 + maxFirst);
					}
					return results;
				}).call(this))), ref4;
				this.combinedTexCoords = this.susanTexCoords.concat(this.simpleTexCoords);
				this.combinedNormals = this.susanNormals.concat(this.simpleNormals);
				this.testList = [];
				_GP.sender = sender = new Sender();
				this.testList.push(new CubeTest('normal'));
				this.testList.push(new CubeTest('aa'));
				this.testList.push(new CameraTest());
				this.testList.push(new LineTest('normal'));
				this.testList.push(new LineTest('aa'));
				this.testList.push(new TextureTest(this.susanVertices, this.susanIndices, this.susanTexCoords, this.texture));
				this.testList.push(new TextureTest(this.combinedVertices, this.combinedIndices, this.combinedTexCoords, this.texture));
				this.testList.push(new SimpleLightTest(this.susanVertices, this.susanIndices, this.susanTexCoords, this.susanNormals, this.texture));
				this.testList.push(new SimpleLightTest(this.combinedVertices, this.combinedIndices, this.combinedTexCoords, this.combinedNormals, this.texture));
				this.testList.push(new MoreLightTest(this.combinedVertices, this.combinedIndices, this.combinedTexCoords, this.combinedNormals, this.texture));
				this.testList.push(new TwoTexturesMoreLightTest(this.combinedVertices, this.combinedIndices, this.combinedTexCoords, this.combinedNormals, this.texture, this.texture1));
				this.testList.push(new TransparentTest(this.combinedVertices, this.combinedIndices, this.combinedTexCoords, this.combinedNormals, this.texture));
				this.testList.push(new LightingTest());
				this.testList.push(new ClippingTest());
				this.testList.push(new BubbleTest());
				this.testList.push(new _GP.CompressedTextureTest());
				this.testList.push(new _GP.ShadowTest());
				this.asyncTests = [];
				_GP.sender.finalized = true;
				this.numberOfTests = this.testList.length + this.asyncTests.length;
				this.numComplete = 0;
				postProgress = (function (_this) {
					return function () {
						progress(++_this.numComplete / _this.numberOfTests * 90.0);
						if (_this.numComplete === _this.numberOfTests) {
							if (_this.requests['demo'] === "True") {
								$('body canvas').remove();
							}
							return _GP.sender.sendData();
						}
					};
				})(this);
				d = 256;
				Tester = (function () {
					function Tester(testList, dest) {
						var testDone;
						this.testList = testList;
						this.canvas = $("<canvas width='" + d + "' height='" + d + "'/>").appendTo(dest)[0];
						this.numTestsComplete = 0;
						testDone = (function (_this) {
							return function () {
								_this.numTestsComplete++;
								postProgress();
								if (_this.numTestsComplete < _this.testList.length) {
									return _this.testList[_this.numTestsComplete].begin(_this.canvas, testDone);
								}
							};
						})(this);
						this.testList[0].begin(this.canvas, testDone);
					}

					return Tester;

				})();
				canvasContainer = this.requests['demo'] === "True" ? $('body') : $('#test_canvases');
				$("<canvas id='can_aa' width='" + d + "' height='" + d + "'/>").appendTo(canvasContainer);
				new Tester(this.testList, canvasContainer);
				ref5 = this.asyncTests;
				for (l = 0, len = ref5.length; l < len; l++) {
					test = ref5[l];
					test.begin(postProgress);
				}
				return true;
			};

			return Loader;

		})();

		$(function () {
			var loader;
			return loader = new Loader();
		});

	}).call(this);

	// Generated by CoffeeScript 1.10.0

	/*
	This test uses a depth texture to do shadow mapping
	A depth texture uses the webgl float texture extension and the webgl
	depth texture extensions.  This is testing whether those extensions exist
	and how they are implemented on the GPU
	 */

	(function () {
		_GP.ShadowTest = (function () {
			function ShadowTest() {
				this.id = _GP.sender.getID();
			}

			ShadowTest.prototype.begin = function (canvas, cb) {
				var Filter, boxFilter, camDist, camPitch, camProj, camRot, camView, counter, cubeGeom, depth, displayShader, downsample256, downsample512, draw, drawCamera, drawLight, drawScene, error, error1, floatExt, gl, lightDepthTexture, lightFramebuffer, lightProj, lightRot, lightShader, lightView, model, offset, planeGeom, quad;
				this.cb = cb;
				try {
					gl = new _GP.WebGLFramework(canvas, {
						antialias: false,
						preserveDrawingBuffer: true,
						willReadFrequently: false,
						depth: true
					}).depthTest();
					floatExt = gl.getFloatExtension({
						require: ['renderable', 'filterable'],
						prefer: ['single', 'half']
					});
					gl.getExt('OES_standard_derivatives');
				} catch (error1) {
					error = error1;
					//console.log(error);
					return;
				}
				cubeGeom = gl.drawable(_GP.meshes.cube);
				planeGeom = gl.drawable(_GP.meshes.plane(50));
				quad = gl.drawable(_GP.meshes.quad);
				displayShader = gl.shader({
					common: "//essl\nvarying vec3 vWorldNormal; varying vec4 vWorldPosition;\nuniform mat4 camProj, camView;\nuniform mat4 lightProj, lightView; uniform mat3 lightRot;\nuniform mat4 model;",
					vertex: "//essl\nattribute vec3 position, normal;\n\nvoid main(){\n    vWorldNormal = normal;\n    vWorldPosition = model * vec4(position, 1.0);\n    gl_Position = camProj * camView * vWorldPosition;\n}",
					fragment: "//essl\nuniform sampler2D sLightDepth;\n\nfloat linstep(float low, float high, float v){\n    return clamp((v-low)/(high-low), 0.0, 1.0);\n}\n\nfloat VSM(sampler2D depths, vec2 uv, float compare){\n    vec2 moments = texture2D(depths, uv).xy;\n    float p = smoothstep(compare-0.02, compare, moments.x);\n    float variance = max(moments.y - moments.x*moments.x, -0.001);\n    float d = compare - moments.x;\n    float p_max = linstep(0.2, 1.0, variance / (variance + d*d));\n    return clamp(max(p, p_max), 0.0, 1.0);\n}\n\nfloat attenuation(vec3 dir){\n    float dist = length(dir);\n    float radiance = 1.0/(1.0+pow(dist/10.0, 2.0));\n    return clamp(radiance*10.0, 0.0, 1.0);\n}\n\nfloat influence(vec3 normal, float coneAngle){\n    float minConeAngle = ((360.0-coneAngle-10.0)/360.0)*PI;\n    float maxConeAngle = ((360.0-coneAngle)/360.0)*PI;\n    return smoothstep(minConeAngle, maxConeAngle, acos(normal.z));\n}\n\nfloat lambert(vec3 surfaceNormal, vec3 lightDirNormal){\n    return max(0.0, dot(surfaceNormal, lightDirNormal));\n}\n\nvec3 skyLight(vec3 normal){\n    return vec3(smoothstep(0.0, PI, PI-acos(normal.y)))*0.4;\n}\n\nvec3 gamma(vec3 color){\n    return pow(color, vec3(2.2));\n}\n\nvoid main(){\n    vec3 worldNormal = normalize(vWorldNormal);\n\n    vec3 camPos = (camView * vWorldPosition).xyz;\n    vec3 lightPos = (lightView * vWorldPosition).xyz;\n    vec3 lightPosNormal = normalize(lightPos);\n    vec3 lightSurfaceNormal = lightRot * worldNormal;\n    vec4 lightDevice = lightProj * vec4(lightPos, 1.0);\n    vec2 lightDeviceNormal = lightDevice.xy/lightDevice.w;\n    vec2 lightUV = lightDeviceNormal*0.5+0.5;\n\n    // shadow calculation\n    float lightDepth2 = clamp(length(lightPos)/40.0, 0.0, 1.0);\n    float illuminated = VSM(sLightDepth, lightUV, lightDepth2);\n\n    vec3 excident = (\n        skyLight(worldNormal) +\n        lambert(lightSurfaceNormal, -lightPosNormal) *\n        influence(lightPosNormal, 55.0) *\n        attenuation(lightPos) *\n        illuminated\n    );\n    gl_FragColor = vec4(gamma(excident), 1.0);\n}"
				});
				lightShader = gl.shader({
					common: "//essl\nvarying vec3 vWorldNormal; varying vec4 vWorldPosition;\nuniform mat4 lightProj, lightView; uniform mat3 lightRot;\nuniform mat4 model;",
					vertex: "//essl\nattribute vec3 position, normal;\n\nvoid main(){\n    vWorldNormal = normal;\n    vWorldPosition = model * vec4(position, 1.0);\n    gl_Position = lightProj * lightView * vWorldPosition;\n}",
					fragment: "//essl\n#extension GL_OES_standard_derivatives : enable\nvoid main(){\n    vec3 worldNormal = normalize(vWorldNormal);\n    vec3 lightPos = (lightView * vWorldPosition).xyz;\n    float depth = clamp(length(lightPos)/40.0, 0.0, 1.0);\n    float dx = dFdx(depth);\n    float dy = dFdy(depth);\n    gl_FragColor = vec4(depth, pow(depth, 2.0) + 0.25*(dx*dx + dy*dy), 0.0, 1.0);\n}"
				});
				lightDepthTexture = gl.texture({
					type: floatExt.type,
					channels: 'rgba'
				}).bind().setSize(1024, 1024).linear().clampToEdge();
				lightFramebuffer = gl.framebuffer().bind().color(lightDepthTexture).depth().unbind();
				Filter = (function () {
					function Filter(size, filter) {
						this.size = size;
						this.output = gl.texture({
							type: floatExt.type,
							channels: 'rgba'
						}).bind().setSize(this.size, this.size).linear().clampToEdge();
						this.framebuffer = gl.framebuffer().bind().color(this.output).unbind();
						this.shader = gl.shader({
							common: "//essl\nvarying vec2 texcoord;",
							vertex: "//essl\nattribute vec2 position;\n\nvoid main(){\n    texcoord = position*0.5+0.5;\n    gl_Position = vec4(position, 0.0, 1.0);\n}",
							fragment: "//essl\nuniform vec2 viewport;\nuniform sampler2D source;\n\nvec3 get(float x, float y){\n    vec2 off = vec2(x, y);\n    return texture2D(source, texcoord+off/viewport).rgb;\n}\nvec3 get(int x, int y){\n    vec2 off = vec2(x, y);\n    return texture2D(source, texcoord+off/viewport).rgb;\n}\nvec3 filter(){\n    " + filter + "\n}\nvoid main(){\n    gl_FragColor = vec4(filter(), 1.0);\n}"
						});
					}

					Filter.prototype.bind = function (unit) {
						return this.output.bind(unit);
					};

					Filter.prototype.apply = function (source) {
						this.framebuffer.bind();
						gl.viewport(0, 0, this.size, this.size);
						this.shader.use().vec2('viewport', this.size, this.size).sampler('source', source).draw(quad);
						return this.framebuffer.unbind();
					};

					return Filter;

				})();
				downsample512 = new Filter(512, "//essl\nreturn get(0.0, 0.0);");
				downsample256 = new Filter(256, "//essl\nreturn get(0.0, 0.0);");
				boxFilter = new Filter(256, "//essl\nvec3 result = vec3(0.0);\nfor(int x=-1; x<=1; x++){\n    for(int y=-1; y<=1; y++){\n        result += get(x,y);\n    }\n}\nreturn result/9.0;");
				camProj = gl.mat4();
				camView = gl.mat4();
				lightProj = gl.mat4().perspective({
					fov: 60
				}, 1, {
					near: 0.01,
					far: 100
				});
				lightView = gl.mat4().trans(0, 0, -6).rotatex(30).rotatey(110);
				lightRot = gl.mat3().fromMat4Rot(lightView);
				model = gl.mat4();
				counter = -Math.PI * 0.1;
				offset = 0;
				camDist = 10;
				camRot = 55;
				camPitch = 41;
				depth = 0;
				drawScene = function (shader) {
					return shader.mat4('model', model.ident().trans(0, 0, 0)).draw(planeGeom).mat4('model', model.ident().trans(0, 1 + offset, 0)).draw(cubeGeom).mat4('model', model.ident().trans(5, 1, -1)).draw(cubeGeom);
				};
				drawLight = function () {
					lightFramebuffer.bind();
					gl.viewport(0, 0, lightDepthTexture.width, lightDepthTexture.height).clearColor(1, 1, 1, 1).clearDepth(1).cullFace('back');
					lightShader.use().mat4('lightView', lightView).mat4('lightProj', lightProj).mat3('lightRot', lightRot);
					drawScene(lightShader);
					lightFramebuffer.unbind();
					downsample512.apply(lightDepthTexture);
					downsample256.apply(downsample512);
					return boxFilter.apply(downsample256);
				};
				drawCamera = function () {
					gl.adjustSize().viewport().cullFace('back').clearColor(0, 0, 0, 0).clearDepth(1);
					camProj.perspective({
						fov: 60,
						aspect: gl.aspect,
						near: 0.01,
						far: 100
					});
					camView.ident().trans(0, -1, -camDist).rotatex(camPitch).rotatey(camRot);
					displayShader.use().mat4('camProj', camProj).mat4('camView', camView).mat4('lightView', lightView).mat4('lightProj', lightProj).mat3('lightRot', lightRot).sampler('sLightDepth', boxFilter);
					return drawScene(displayShader);
				};
				draw = function () {
					drawLight();
					return drawCamera();
				};
				draw();
				return gl.animationInterval((function (_this) {
					return function (frame) {
						offset = 1 + Math.sin(counter);
						counter += 1 / 10;
						draw();
						if (depth++ === 5) {
							__gpcaf(frame);
							_GP.sender.getData(gl.getContext(), _this.id);
							return _this.cb();
						}
					};
				})(this));
			};

			return ShadowTest;

		})();

	}).call(this);

	var font_list = ['Segoe WP', 'FreeMono', 'Heiti TC Light', 'VNI-Kun', 'Liberation Serif', 'Dotum', 'ML-TTVeenaHeavy', 'Brandon Grotesque Light', 'Adobe Hebrew Italic', 'MMa Etc Bold', 'Toledo', 'Ubuntu Mono derivative Powerline', 'Hannotate TC Regular', 'Droid Sans Thai', 'Cambria Italic', 'Abadi MT Condensed Extra Bold', 'Barrio', 'ML-TTVishu', 'MMa VariableB S', 'BurigangaSushreeOMJ', 'Pegypta', 'Avenir Next Condensed', 'TitilliumText22L-Bold', 'Corbel Bold Italic', '.VnCourier New', 'Trajan Pro 3 Bold', 'Futura LT Condensed Light', 'FML-TTAmbili', 'dbldwrsw', 'PingFang HK Light', 'Soho Gothic Pro Italic', 'Tele-Marines', 'Cronos Pro', 'Noto Sans Brahmi', 'HANA', 'VNI Times', 'Rakesly El', 'WP MultinationalA Roman', 'HGSHeiseiKakugothictaiW5', 'Avenir Next W1G Medium', 'Segoe UI Semibold', 'Cambria Bold Italic', 'Futura Std Book', 'New Renex Terminal', 'HGSHeiseiKakugothictaiW9', 'KufiStandardGK Regular', 'VNI-Bodon-Poster', 'eurb9', 'MrsEavesRoman', 'WP Greek Century', 'STIXNonUnicode', 'Songti SC Bold', 'Kaushan Script', 'OpenSymbol', 'FML-TTJyotsna', 'EngraverTime', 'Charter Black Italic', 'Arno Pro', 'Tahoma Negreta', 'Century Schoolbook L', 'Circular Std Book Italic', 'Tall Boy 3D', 'Egyptian710 BT', 'ML-NILA03', 'ML-NILA02', 'ML-NILA01', 'Petrucci', 'Waseem Regular', 'ML-NILA06', 'ML-NILA05', 'NORMAL', 'eusm8', 'Z@R120A.tmp', 'Gulim', 'cmtcsc10', 'Merriweather Italic', '.VnSouthernH', 'Lantinghei TC Heavy', 'Bangla Sangam MN', 'C-Medium', 'Nightclub BTN UltraCn', 'GoraiOMJ', 'Avenir Next Ultra Light', 'Myanmar Sangam MN', 'Matisse ITC', 'Droid Sans Mono Dotted for Powerline', 'Optima Italic', 'TitilliumText22L-Regular', 'Sketch Rockwell', 'MelodBold', 'cmsl10', 'Zapfino', 'cmsl12', 'Linux Libertine Display O', 'Manorama', 'DecoType Naskh Special', 'Caviar Dreams Bold Italic', 'Sauce Code Powerline', 'Courier New CE', 'BurigangaSushreeMJ', 'Aileron', 'Hiragino Sans', 'Smooth', 'MMCenturyOldGreek', 'Microsoft NeoGothic', 'Atzur', 'GLYPHICONS Halflings', 'Trattatello', 'LT-TM-Lakshman', 'Playbill', 'TeX Gyre Chorus', 'Myriad Pro SemiCondensed', 'Marlett', 'Open Sans Extrabold', 'Chaparral Pro Bold', 'GrilledCheese BTN Cn', 'Bitstream Charter', 'Noto Sans Tai Viet', 'Georgia Pro SemiBold', 'Rotis Sans Serif Std 56 Italic', 'ITF Devanagari Marathi Demi', 'Avenir Next W1G Thin', 'Priori Serif OT', 'Times Bold Italic', 'BurigangaKamalaOMJ', 'Literation Mono Powerline Italic', 'Quickpen', 'AR BONNIE', 'Caviar Dreams', 'Avenir Roman', 'Pujeeta', 'Deepak', 'cmmi12', 'FML-TTSankara', 'Bookman Old Style Italic', '.VnArial', 'Antonio', 'Linowrite', 'GFS Gazis', 'FordLineDraw', 'ConcursoItalian BTN Wide', 'MMa CenturySS', 'Laksaman', 'Segoe Marker', 'Monotype Sorts', 'Bienhoa', 'Noto Sans Syriac Eastern', 'Caviar Dreams Bold', 'MMa Arrow Bold Italic', 'Diavlo Black', 'Garamond', 'Proxima Nova', 'BhairabOMJ', 'WP Phonetic', 'Myriad Pro', 'VNI-Fato', 'Myriad Pro Bold', 'MMVariableF Bold', 'Julius Sans One', 'EuroRoman', 'cmcsc9', 'cmcsc8', 'LaurenScript', 'VNI-Commerce', 'Freebooter Script', 'Math5', 'Party LET', '.VnHelvetIns', 'American Typewriter', 'Roboto Mono Bold Italic for Powerline', 'Vineta BT', 'ML-TTPooram', 'MMa Extra Bold', 'Quangngai', 'MT Extra', 'TAM', 'Terminal Greek 737 (437G)', 'TITUS Cyberbit Basic', 'Kalakaumudi', 'Adobe Gurmukhi', 'HanziPen SC', 'cmff10', 'Praxis', 'FML-TTVishu', 'Microsoft MHei', 'VNI Greece', 'Sukhumvit Set Semi Bold', 'Swiss 721 Roman', 'Soho Gothic Pro Ultra Italic', 'STLiti', 'Marquisette BTN Light', 'Arimo Bold Italic for Powerline', 'ML-TTJaya', 'eusm9', 'Simplified Arabic', 'Kohinoor Devanagari Light', 'MS PMincho', 'Century Gothic Italic', 'HariSree', 'MyriadPro-Semibold', 'IPAexGothic', 'MS Reference Serif', 'eusm7', 'HelveticaNeueLT Pro 97 BlkCn', 'Quicksand Bold', 'Yu Mincho', 'VNI-Murray', 'ChandrabatiMJ', 'Sitka Banner', 'MMCenturyOldGreek Italic', '.VnCommercial ScriptH', 'Interstate-Regular', 'Arimo Bold Italic', 'Latienne Pro', 'TAC-Valluvar', 'FML-Nanditha', 'MMa VariableF Bold', 'Tekton Pro Bold', 'Noto Serif', 'AmdtSymbols', 'Euclid Symbol', 'Songti SC Regular', 'Cambria Bold', 'Leelawadee', 'Meslo LG S DZ Regular for Powerline', 'Nexa Light', 'Party LET Plain:1.0', 'Minion Pro SmBd', 'AV-Font-Kan1', 'Clarendon Cn BT', 'Yu Mincho Demibold', 'Hypatia Sans Pro Semibold', 'Consolas', 'Seravek Bold Italic', 'Nightclub BTN Cn', 'Myriad Arabic Italic', 'Charter Roman', 'spinwerad', 'Gill Sans Nova Cond Ultra Bold', 'KG Corner of the Sky', 'DecoType Naskh Extensions', 'MLB-TTAmbili', 'YuMincho ', 'Futura LT Light', 'Latin Modern Roman', 'Gotham Narrow Black Italic', 'DIN-Light', 'VNI-Top', 'DotumChe', 'Giolinh', 'Muna Black', 'Apple Boy BTN', 'Clarendon BT', 'DINPro-Light', 'Playfair Display SC Black', 'Quixley LET', 'MMa Pascal Bold', 'Interstate-Light', 'American Typewriter Condensed Bold', 'Skia Condensed', 'Latienne Pro Bold', 'lcircle10', 'ML-IndulekhaHeavy', 'Source Serif Pro Semibold', 'Tamburo', 'Halong', 'Normande Italic', 'VNI-Book', 'MMa Extra Italic', 'Heavy', 'MMBinary', 'PondAllRounder', 'Euphemia UCAS Bold', 'Avenir Book Oblique', 'HP Simplified Light', 'HGSHeiseiKakugothictaiW3', 'Gill Sans Light', 'VNI-Garam', 'AlekyaMedium', 'Hebar', 'Stone Sans Sem ITC TT', 'DV1-TTYogesh', 'Adobe Arabic', 'Rosewood Std Regular', 'Marquisette BTN Lined', 'Gotham Book', 'Sukhumvit Set Medium', '.VnTeknicalH', 'Z@R1762.tmp', 'MMa Gauss Bold', 'Avenir Next Condensed Demi Bold', 'Trebuchet MS Bold Italic', 'TlwgMono', 'Avenir Next W1G Bold', 'Flubber', 'Opus Figured Bass', 'Futura LT Heavy Oblique', 'Hiragino Mincho ProN', 'Nova Oval', 'Bangla MN', 'Opus Function Symbols', 'Microsoft JhengHei Light', 'STIXSizeOneSym', 'Magic School Two', 'Type Embellishments One LET Embellishments One LET Plain:1.0', 'Avenir Next Heavy', 'Sylfaen', 'Palatino Bold', 'Rockwell Extra Bold', 'Candara Italic', 'Gujarati MT Bold', 'Vinhan', '.VnBahamasBH', 'SaiVrishin', 'AR ESSENCE', 'Frankfurter Venetian TT', 'Gillius ADF Cd', 'Mishafi Gold', 'System Font Medium', 'Roboto Mono Medium for Powerline', 'SF Distant Galaxy', 'Monotype.com', 'MMTextBook Bold', 'Gill Sans MT Italic', 'Tlwg Typewriter', 'Soho Gothic Pro ExtraBold', 'Gill Sans Ultra Bold', 'STIXSizeTwoSym-Bold', 'BaluBrush', 'System Font Bold', 'Roboto Light Italic', 'Times New Roman (Arabic)', 'Maestro Wide', 'Bickham Script Pro 3 Semibold', 'STXingkai', 'Annie BTN', 'AtraiOMJ', 'Aileron SemiBold', 'cmsy7', 'Bookshelf Symbol 3', 'Orator Std', 'Swis721 BdCnOul BT', 'Proxima Nova Bold', 'Shree Devanagari 714 Bold Italic', 'WP MultinationalA Helve', 'Noto Sans', 'Lucida Sans Italic', 'Phosphate Solid', 'Damascus', 'DengXian Light', 'Notram', 'Bordeaux Roman Bold LET Plain', 'Lantinghei SC Heavy', 'MMa CenturyS Italic', 'Noto Sans Phoenician', 'System Font', 'ADMUI3Sm', 'Shree Devanagari 714 Italic', 'kroeger 06', 'Belfast Light SF', 'KacstBook', 'PingFang SC Thin', 'Humanst521 BT', 'Futura Condensed Medium', 'WP Japanese', 'Hiragino Kaku Gothic Std W8', 'GaneshBold', 'Open Sans Italic', 'Aileron Bold', 'Euphemia UCAS', '.VnFreeH', 'Swis721 BlkOul BT', '.VnRevueH', 'Freehand521 BT', 'MMa Arrow Italic', 'Opus Chords Sans Condensed', 'OR-TTSarala', 'Montserrat Black', 'VNI-Avo', 'System Font Medium P4', 'VNI-GlabXb', 'HarvestItal', 'MMa VariableA S', 'Segoe WP Black', 'Courier10 BT', '.VnLincolnH', 'eusb5', 'Marker Felt Thin', 'KacstTitleL', 'HelveticaNeueLT Pro 107 XBlkCn', 'IBM3270', 'MLB-TTIndulekha', 'PujeetaItalic', 'Bookman Old Style Bold', 'Latin Modern Sans', 'ELEGANCE', 'GhorautraMJ', 'MMExtra Bold', 'Rockwell Nova Cond', 'Minion Pro Cond', 'Brandon Grotesque Medium', 'HGHeiseiKakugothictaiW9', 'Euphemia UCAS Italic', '.VnUniverseH', 'Avenir Book', 'ZapfHumnst Ult BT', 'Diwani Simple Striped', 'Myriad Pro Bold SemiCondensed', 'Raleway SemiBold Italic', 'Z@R1751.tmp', 'Hypatia Sans Pro Black', 'linew10', '.VnCooperH', 'Adobe Ming Std', 'BlairMdITC TT Medium', 'Levenim MT', 'Ravie', 'FML-TTIndulekhaHeavy', 'Ruach LET', 'ML-TTJyothy', 'Brush Script MT', 'Latin Modern Mono Prop', 'ML-NILA04', 'TeX Gyre Pagella', 'Roboto Slab', 'eurb7', 'PFFuelPro-Regular', 'eurb5', 'MMGreek Bold', 'Oswald Stencil Bold', 'Georgia Bold', 'Noto Serif Thai', 'Selena', 'Perpetua Titling MT Bold', 'ColdSpaghetti BTN', 'Courier Oblique', 'Dosis Medium', 'Canter Bold Shadow', 'St Marie Thin', 'FML-TTGopika', 'STIXIntegralsSm-Bold', 'MMEtc Italic', 'CHANL', 'Yu Gothic UI', 'KacstNaskh', 'VNI-Palatin', 'GFS Porson', 'ML-TTAswathi', 'Myriad Pro Condensed Italic', 'Avenir Next Italic', 'WP ArabicScript Sihafa', 'Euclid Symbol Bold', 'Myriad Pro Semibold Condensed', 'PT Bold Broken', 'Goudy Old Style Bold', 'Racing Sans One', 'Bentham', 'Gotham Book Italic', 'Asimov', 'Avenir Next W1G Light', 'Ashwariya', 'Berlin Sans FB Demi', 'Myriad Pro Light Italic', 'VNI Helve Condense', 'Songti TC Regular', 'Verdana Italic', 'Nexa XBold Italic', 'Source Sans Pro', 'Dingbats', 'Synchro LET', 'OCR-A II', 'Deneane', 'MMExtra Bold Italic', 'Wellfleet', 'Jazz LET Plain:1.0', 'STIXIntegralsSm-Regular', 'MMa CenturyK', 'Javanese Text', 'Nova Script', 'Arial Hebrew Bold', 'PCMyungjo Regular', 'Bhuma', 'MMa CenturyS', 'Quicksand Dash', 'Gloucester MT Extra Condensed', 'Montserrat Bold', 'Jokerman Alts LET', 'Floraless', 'SF Compact Rounded Semibold', 'URW Gothic L', 'BadaBoom BB', 'Microsoft YaHei', 'Cantarell Oblique', 'Brush Script MT Italic', 'Raanana Bold', '.VnArialH', 'IPAPGothic', 'BN-TTDurga', 'Times New Roman', 'WP MultinationalB Courier', 'Germanica', 'Paralucent Demi Bold Italic', 'Proxima Nova Soft Medium', 'Myriad Hebrew Bold', 'Telugu MN Bold', 'WP MathA', 'Proxima Nova Condensed Light Italic', 'IDAutomationPDF417n5', 'Algerian', 'Times New Roman Greek', 'FML-TTKaumudi', 'SF Compact Rounded Bold', 'Tinos Bold Italic for Powerline', 'Lantinghei TC', 'Stylus BT', 'Soho Gothic Pro Medium', 'Microsoft Tai Le', 'Broken Planewing', 'MMa Relation Bold Italic', 'MMCenturyNew Bold Italic', 'Droid Sans Ethiopic', '3M Circular TT Bold', 'IDAutomationPDF417n2', 'Lato Black Italic', 'Liberation Sans', 'Sofia', 'Paralucent Light Italic', 'Geeza Pro', 'Dancing Script', 'DholeshwariMJ', 'eufm10', 'Century Schoolbook', 'Palatino Linotype Bold', 'Candy Round BTN', '12x10', 'Rupee Foradian', 'SchoolHouse Cursive B', 'Stone Sans Sem ITC TT Semi', 'Coda', 'Sneakerhead BTN Condensed', 'Merriweather Light Italic', 'Academy Engraved LET', 'System Font Ultralight', 'Akshar Unicode', 'Helvetica', 'Lato Italic', 'Kohinoor Bangla Medium', 'ChandrabatiMatraOMJ', 'Futura LT Bold', 'Helvetica Bold', 'Batang', 'Arvo', 'Coolvetica', 'Gill Sans MT Ext Condensed Bold', 'AR BLANCA', 'PingFang HK Regular', 'Arial Narrow Italic', 'cmtex9', 'cmtex8', 'Chalkboard SE', 'Fren', 'MMa Negate S', 'Minion Pro Medium Italic', 'Meiryo UI', 'SWED', 'ITF Devanagari Marathi Light', 'athletic', 'Pointedly Mad', 'Farsi Simple Outline', 'Yuppy TC', 'Noto Sans Lao UI', '.VnShelley Allegro', 'Quinhon', 'Courier Bold', 'Carrois Gothic SC', 'FangSong', 'PT Serif Bold Italic', 'ML-TTKanika', 'Avenir Next W1G Regular', 'GrilledCheese BTN Toasted', 'QuiverItal', 'Kanalisirung', 'FML-TTJaya', 'HelveticaNeueLT Pro 53 Ex', 'Cut Me Out', 'Khmer MN Bold', 'Skia Light', 'Garamond Italic', 'GothicG', 'Autour One', 'Opus PlainChords', 'Symbol Tiger', 'Lucida Fax Demibold', 'Athelas', 'Linux Libertine Initials O', 'STIXIntegralsUp-Bold', 'MMa VariableD SS', 'VNI-Aztek', 'MLW-TTKarthika', 'ML-TTChithira', 'Superclarendon Regular', 'Z@R185D.tmp', '.VnPresent', 'Snell Roundhand', 'MMa Etc Italic', 'ADMUI3Lg', 'Brandon Grotesque Black', 'Avenir Next Condensed Italic', 'Circular Std Black', 'Futura LT Extra Bold Oblique', 'KanchanOMJ', 'cmcsc10', '.VnCommercial Script', 'Segoe UI', 'Mathilde', 'GangaSagarMJ', 'Nunito Light', 'Code39AzaleaRegular3', 'Code39AzaleaRegular2', 'MMa Variable', 'STIXSizeTwoSym-Regular', 'Arabic Transparent', 'Kufi Extended Outline', 'Myriad Pro Bold SemiExtended Italic', 'Titillium Thin Italic', 'Aileron Heavy', 'Noto Serif Lao', 'Web Serveroff', 'Gautami', 'Sauce Code Powerline Bold', 'Yuanti TC Bold', 'Noto Sans Bamum', 'Calisto MT Italic', 'Myriad Arabic Bold Italic', 'uni 05', 'Noto Sans Runic', 'Sue Ellen Francisco', 'Hiragino Mincho Pro', 'GENUINE', 'FML-TTVarsha', 'Lucida Grande', 'Playfair Display SC Black Italic', 'Avenir Heavy Oblique', 'GaneshExtraBold', 'MMa CenturySS Bold', 'STIXSizeThreeSym-Bold', 'Kozuka Gothic Pro', 'KalegongaMJ', 'Lucida Sans Typewriter Regular', 'Judson', 'YuMincho  36p Kana Demibold', 'FML-TTVisakham', 'Trade Gothic LT Std Condensed No. 18 Oblique', 'Myriad Pro Semibold SemiCondensed', 'Segoe UI Emoji', 'Ubuntu Mono', 'Traditional Arabic', 'ChitraOMJ', 'DejaVu Sans Mono Bold Oblique for Powerline', 'Noto Sans Avestan', 'Piranesi It BT', 'PrimaSans BT', 'Mshtakan Oblique', 'Adamsky SF', 'Roboto Thin', 'Reklame Script Regular', 'Lato Regular', 'Myriad Arabic', 'Vollkorn Bold', 'New Peninim MT Inclined', 'HGHangle', 'Desdemona', 'KievitPro-Regular', 'Arno Pro Smbd SmText', 'Rotis Sans Serif Std 55 Regular', 'SimSun', 'Gill Sans Bold', 'Euclid Bold', 'Charter Black', '.VnMysticalH', 'Rakesly Ul', 'Vogue-ExtraBold', 'ITAN', 'Mishafi Regular', '.VnRevue', 'Mishafi', 'Old Antic Decorative', 'Sukhumvit Set Light', 'Photoshop Small', 'Pristina', 'TAU-Kambar', 'Magic School One', 'Trajan Pro 3', 'Corbel', 'Rage Italic LET', 'Constantia', 'Gill Sans MT Condensed', 'cmfib8', 'Xirod', 'Euphemia', 'Nimbus Sans L', 'Sacred Geometry', 'ELANGO-TML-Panchali-Normal', 'Georgia', 'Gill Sans MT Bold', 'Droid Sans Hebrew', 'CL', 'MMa Extra SS', 'HelveticaNeueLT Pro 75 BdOu', 'FML-TTAswathi', 'NATURALBORN', 'Pleasantly Plump', 'Blackletter686 BT', 'Bodoni MT Poster Compressed', 'Yuppy SC Regular', 'Arno Pro Smbd', 'Engl', 'Times New Roman Cyr', 'Gill Sans MT Bold Italic', 'Myriad Pro Light SemiCondensed', 'YuMincho Demibold', 'Canter Light', 'Broadway Copyist Text Ext', 'Marquisette BTN', 'Nova Cut', 'Rumburak', 'PT Bold Heading', 'TeX Gyre Termes', 'Dollar', 'System Font Regular', 'SWItalc', 'Noto Sans Devanagari', 'AV-Font-Hin1', 'DejaVu Sans Condensed', 'Huxley Titling', 'Roboto Bold', 'Noto Sans Cypriot', 'HelveticaNeueLT Pro 25 UltLt', 'Distant Galaxy', 'Nueva Std Italic', 'SWItalt', 'HELTERSKELTER', 'Adobe Gothic Std', 'Avenir Next W1G Italic', 'KacstTitle', 'Symap', 'Utsaah', 'Ancuu', 'cmmib7', 'Chaparral Pro Italic', 'STIXGeneral-BoldItalic', 'MMNegate Bold Italic', 'Birch Std', 'Silom', 'Futura Light BT', 'Felix Titling', 'Leelawadee UI', 'Proxy 7', 'Proxy 6', 'Proxy 5', 'Proxy 4', 'Proxy 3', 'MT Extra Tiger', 'Proxy 1', 'Clarendon Hv BT', 'Lantinghei TC Demibold', 'Stone Sans ITC TT Bold', 'Accord SF', 'Book Antiqua Italic', 'ML-TTNarmadaExBold', 'Proxy 9', 'Proxy 8', 'Bodoni MT', 'Bookman Old Style', 'Futura Medium BT', 'YuMincho', 'Lucida Blackletter', 'Noto Sans Gujarati', 'Z@R13D5.tmp', 'Belfast SF', 'Yu Gothic UI Light', 'Noto Sans Linear B', 'kroeger 05', 'Myriad Pro Semibold Condensed Italic', 'Futura Condensed ExtraBold', 'Roboto Regular', 'Broadway BT', 'LeviBrush', 'Verdana Pro Cond Black', 'Segoe Script', 'Bebas Neue Light', 'Yuanti SC', 'Futura Std Medium Condensed', 'Diwan Thuluth', 'EngraverTextH', 'cmmi10', 'HelveticaNeueLT Pro 47 LtCn', 'Verdana Bold Italic', 'Proxima Nova Rg', 'Lucida Fax Regular', 'System Font Medium Italic', 'Didot Bold', 'Hack Bold Italic', 'Segoe UI Light', 'Lucida Fax', 'HelveticaNeueLT Std', 'Segoe WP Semibold', 'Constantia Bold', 'Futura LT Medium Oblique', 'VNI-Univer', 'TAM-Shree800', 'EngraverTextT', 'Baby Kruffy', 'David Transparent', 'Calibri', 'HGSHeiseiMinchotaiW3', 'Fira Mono Medium for Powerline', 'Perpetua Titling MT', 'PT Sans Narrow Bold', 'header 08', 'Mesquite Std', 'HucklebuckJF', 'MANDELA', 'KacstArt', 'MMa Arrow S', 'Gridnik', 'Adobe Gurmukhi Bold', 'Noto Sans Lao', 'cmsy10orig', 'Asana Math', 'Adobe Caslon Pro Semibold Italic', '.VnPresentH', '.VnClarendonH', 'Lao MN Bold', 'Titillium Thin', 'Vivian', 'RomanD', 'ISOCP2', 'Logo3Mv3tt', 'MS Gothic', 'QTOptimum Bold', 'Baghdad', 'Cantarell Bold', 'Myriad Pro SemiExt', 'American Typewriter Light', 'Avenir Next W1G Thin Italic', 'Libian SC', 'Sitka Small', 'Noto Sans Saurashtra', 'Averia Sans', 'Interstate-Bold', 'Tw Cen MT Bold', 'wgl4', 'Bank Gothic', 'eusb10', 'AlekyaThin', 'Gujarati Sangam MN', 'HelveticaNeueLT Pro 65 Md', 'SaiIndira', 'Gill Sans', 'IrisUPC', 'RomanS', 'MMa CenturyKS Bold Italic', '58', 'VNtimes new roman', 'MMa Binary Italic', '55', 'Holiday Springs BTN', '57', 'Roboto Mono Thin for Powerline', '51', 'Adobe Gothic Std B', '52', 'HelveticaNeueLT Std Cn', 'Noto Sans Gurmukhi', 'PT Mono Bold', 'Bastion', 'FML-TTChithira', '54', 'Lohit Tamil', 'Yellowtail', 'VNI-Helve', 'Diwani Simple Outline 2', 'ML-TTIndulekha', 'Incised901 Ct BT', ('cursive', 'monospace', 'serif', 'sans-serif', 'fantasy', 'default', 'Arial', 'Arial Black', 'Arial Narrow', 'Arial Rounded MT Bold', 'Bookman Old Style', 'Bradley Hand ITC', 'Century', 'Century Gothic', 'Comic Sans MS', 'Courier', 'Courier New', 'Georgia', 'Gentium', 'Impact', 'King', 'Lucida Console', 'Lalit', 'Modena', 'Monotype Corsiva', 'Papyrus', 'Tahoma', 'TeX', 'Times', 'Times New Roman', 'Trebuchet MS', 'Verdana', 'Verona'), '56', 'Calligraffitti', 'Eurostile Bold', 'Rockwell Nova Extra Bold', 'Gill Sans Italic', 'Nyala', 'SF Compact Rounded Regular', 'System', 'SWMeteo', 'GothicI', 'Chewy', '53', 'Lato Thin', 'TeX Gyre Bonum', 'URW Bookman L', 'Hannotate SC Regular', 'ElegantIcons', 'MMa CenturyK Italic', 'GROBOLD', 'Bookshelf Symbol 2', 'PingFang TC Light', 'Playfair Display SC', 'Century Schoolbook Bold', 'Apple SD Gothic Neo UltraLight', 'Napa SF', 'cnefonts', 'STIXIntegralsUp', 'Corsiva Hebrew Bold', 'Zapfino Extra LT Ligatures', 'Stencil Std', 'Type Embellishments One LET', 'Iowan Old Style Bold', 'Lucida Sans Typewriter Bold Oblique', 'Myriad Pro Regular', 'Bell Gothic Std Bold', 'Bodoni 72 Oldstyle Bold', 'IchamotiOMJ', 'AV-Font-Ben1', 'STIXGeneral', 'Gujarati Sangam MN Bold', 'Adobe Caslon Pro Semibold', 'Mallige', 'VNI-Bazooka', 'Perpetua Bold', 'Roboto Condensed Italic', 'MMa Etc Bold Italic', 'Avenir Black Oblique', 'Muli Light Italic', 'Padauk Book', 'PT Mono', 'Museo Sans 300', 'Browallia New', 'Code39AzaleaRegular1', 'STIXSizeOneSym-Bold', 'MMExtra Italic', 'Rundkursiv', 'Times New Roman Bold Italic', 'Calisto MT', 'OldDreadfulNo7 BT', 'Bitstream Vera Serif', 'Cousine Italic for Powerline', 'Freehand', 'Roboto Italic', 'Droid Serif', 'Lato Thin Italic', 'MMCenturyOld', 'VAGRounded BT', 'Digital Readout Upright', 'Noto Sans Glagolitic', 'Old Antic Outline', 'Bickham Script Pro 3 Bold', 'AlternateGothic2 BT', 'Enliven', 'Kohinoor Telugu Medium', 'ESTO', 'Noto Sans Lisu', 'Smarty Pants BTN', 'Syastro', 'Microsoft JhengHei', 'WP TypographicSymbols', 'Kristi', 'Hoefler Text Ornaments', 'Courier New CYR', 'Albany AMT', 'Granjon Bold', 'Inconsolata', 'Sorts Mill Goudy', 'MMa VariableC S', 'cmbsy6', 'Noto Sans Osmanya', 'Farsi Simple Bold', 'GreekS', 'cmbsy7', '.VnKoalaH', 'DhonooOMJ', 'Niagara Solid', 'cmbsy8', 'Euclid Math One Bold', 'Swiss 721', 'Ubuntu', 'GreekC', 'VNI-Bandit', 'URW Palladio L', 'YuMincho  36p Kana', 'Sanpya', 'MMa GreekSS', 'eufm9', 'AvantGarde Md BT', 'Weibei TC', 'Myriad Pro Black SemiExtended Italic', 'Bebas Neue Book', 'Menlo Bold Italic', 'eufm5', 'Soho Gothic Pro Thin Italic', 'NBP Informa FiveThree', 'Noto Serif Armenian', 'DejaVu Sans Mono Bold for Powerline', 'Trade Gothic LT Std Oblique', '.VnBook-Antiqua', 'Humanst521 XBd BT', 'Diavlo Bold', 'WP CyrillicA', 'WP CyrillicB', 'ITF Devanagari Medium', 'Franklin Gothic Medium', 'FML-TTChithiraHeavy', 'ML-TTDevika', 'Superclarendon Light', 'balonez fantasia', 'Sitka Text', 'Tw Cen MT Condensed Extra Bold', 'Skia Black', 'cmbx12', 'ML-TTKamini', 'Alegreya Sans SC', 'Linux Libertine Display G', 'Italic', 'PT Sans Bold', 'Opus Special Extra', 'Ebrima', 'Gurmukhi Sangam MN', 'FML-TTOnam', 'ML-TTRevathi', 'Hiragino Mincho Pro W3', 'BongshaiMJ', 'Adobe Hebrew', 'Heiti SC', 'Optima ExtraBlack', 'Hiragino Mincho Pro W6', 'Kundli English', 'Luminari', ' 20', 'Courier MM Screenwriter Italic', 'HelveticaNeue MediumCond', 'Swiss 721 Extended', 'cmmi8', 'GFS Didot Classic', 'Myriad Pro Light Condensed', 'PoetsenOne', 'Helvetica Neue Light', 'monooge 05', 'cmmi7', 'cmmi6', 'cmmi5', 'Tiger Expert', 'Latin Modern Mono Caps', 'Learning Curve Pro', 'RamuScriptMedium', 'Source Sans Pro Semibold Italic', 'cmmib10', 'KabinLightDB Bold', 'ParvathiThin', 'Belwe Bd BT', 'DV-TTYogesh', 'Russel Write TT', 'DINPro-Black', 'GaneshBlack', 'Carbon Block', 'Romantic', 'Valerie Hand', 'Harrington Bold', 'Bauer Bodoni Std 1 Roman', 'AV-Font-Symbol', 'Papyrus', 'Palatino Bold Italic', 'Nanum Brush Script', 'Noto Sans Egyptian Hieroglyphs', 'Paralucent ExtraLight Italic', 'Proxima Nova Semibold', 'SF Slapstick Comic Shaded Oblique', 'Prestige Elite Std Bold', 'FML-TTVaisali', 'ITF Devanagari Marathi Medium', 'Arial Hebrew Scholar', 'Lohit Gujarati', 'FML-TTChandrika', 'Calisto MT Bold Italic', 'SignPainter-HouseScript Semibold', 'MS Serif', 'Nirmala UI', 'Hiragino Kaku Gothic ProN W6', 'HelveticaNeueLT Pro 57 Cn', 'Hiragino Kaku Gothic ProN W3', 'Skia Light Condensed', 'LT-ET-Ramya', 'WenQuanYi Micro Hei Mono', 'ML-TTAshtamudi', 'Bank Gothic Light', 'EngraverFontExtras', 'Swiss 721 Condensed', 'PT Sans Caption', 'Georgia Pro Cond Black', 'Noto Sans Tifinagh', 'Latin Modern Roman Demi', 'News Gothic MT', 'Open Sans Semibold Italic', 'Snell Roundhand Bold', 'VNI-Stylus', 'GaneshNarrow', 'Gotham', 'DhorolaOMJ', 'Elephant', 'Seravek Bold', 'mixtapeMike', 'Pacifico', 'Perpetua Bold Italic', 'Gayathri', 'MMa Variable Bold', 'Kannada Sangam MN', 'croissant sandwich', 'TSCu', 'CSongGB18030C-Light', 'Nixie One', 'Myriad Pro Black Italic', 'TG Termes Math', 'Kaiti TC Regular', '0', 'Bree Serif', 'C-MediumHWL', 'YuGothic Medium', 'System Font Bold Italic G3', 'ML-TTOnam', 'Trocchi', 'Noto Sans Kharoshthi', 'Gill Sans Nova Cond', 'Abril Fatface', '36p Kana Medium', 'cmdunh10', 'Merriweather Bold', 'MMa Fermat Bold', 'MMa CenturyK Bold', 'TitilliumText22L-Thin', 'TLUrdu', 'MLB-TTAswathi', 'Rocket Arabic Fixed', 'American Typewriter Condensed Light', 'John Handy LET', 'Gill Sans SemiBold', 'Tuyenduc', 'System Font Semibold Italic', 'Nexa Thin Italic', 'MMExtra', 'VNI-Park', 'Gen W01 Light', 'Futura Heavy Oblique', 'SymbolProp BT', 'Cantarell Regular', 'FML-Leela', 'Avenir Next W1G Heavy', 'STIXIntegralsUpSm', 'KalindiMJ', 'Garamond Premr Pro', 'msam9', 'HelveticaNeueLT Std Blk Cn', 'Lato Hairline', 'KG Neatly Printed', 'Proxima Nova Semibold Italic', 'Gravur Condensed Light', 'Webdunia', 'msam7', 'Times New Roman TUR', 'msam5', 'SHELMAN', 'Banmai Times', 'Bodoni 72 Oldstyle Book', 'Dosis', 'Museo Sans 100', 'Roboto Slab Regular', 'Al Nile', 'Gravity', 'LT-TM-Barani', 'Cochin Bold Italic', 'Opus', 'ML-TTChithiraHeavy', 'Rockwell Italic', 'HanziPen TC Bold', 'A Sensible Armadillo', 'Hack Italic', 'Terminator Two', 'HelveticaNeueLT Std UltLt Cn', 'Noto Sans Cuneiform', 'Yu Mincho Light', 'Gill Sans MT', 'News Gothic MT Bold', 'Avenir Next Regular', 'Ubuntu Light', 'Rouge Script', 'SWLink', 'Kalinga', 'ML-TTGuruvayur', 'Lato Bold', 'IPAexMincho', 'Chalkboard Bold', 'ABSALOM', 'Sigmar', 'Museo 500 Regular', 'Stone Sans ITC TT', 'Franklin Gothic Medium Cond', 'Geeza Pro Bold', 'Ml', 'Khmer OS', 'Futura Std Medium', 'SC', 'HelveticaNeueLT Std UltLt Ext', 'Incised901 Nd BT', 'ML-TTMangalaExBold', 'Arial Nova Cond', 'Droid Sans Fallback', 'Noto Sans Carian', 'CommercialScript BT', 'Roboto Condensed', 'Kokonor Regular', 'Kievit Offc Pro', 'Arial Hebrew Scholar Bold', 'FML-TTGuruvayur', 'Nexa Black Italic', 'Garamond Premr Pro Smbd', 'ML-TTSruthy', 'WP MathExtendedA', 'PT Sans Bold Italic', 'CSongGB18030C-LightHWL', 'Finale Copyist Text Ext', 'Kohinoor Bangla Light', 'eusm6', 'Sinhala MN', 'Soho Gothic Pro Regular', 'Open Sans Bold Italic', 'eusm5', 'Herculanum', 'ML1-TTAswathi', 'BhagirathiOMJ', 'PilGi', 'Adobe Garamond Pro Bold', 'Titillium', 'DecoType Naskh Variants', 'Wawati TC', 'Kozuka Gothic Pro R', 'BaluBold', 'SketchFlow Print', 'Opus Percussion', '.VnTeknical', 'Sniglet', 'Noto Sans Hanunoo', 'Lingoes Unicode', 'Sketch Block', 'Lato Semibold', 'Kozuka Gothic Pro B', 'Verdana Pro', 'Kozuka Gothic Pro M', 'Kozuka Gothic Pro L', 'Kozuka Gothic Pro H', 'Bodoni 72', 'VNI-Swiss-Condense', 'Book Antiqua', 'Roboto Mono for Powerline', 'SF Slapstick Comic Shaded', 'Mukti Narrow', 'Baskerville Bold Italic', '.VnArial NarrowH', 'Opus Metronome', 'Xingkai SC Light', 'Gotham Bold', 'Tiger', 'VNI-Awchon', 'Accent SF', 'Baron Neue Italic', 'Boogaloo', 'Finale AlphaNotes', 'Optima Regular', 'Apple Braille Pinpoint 8 Dot', 'IPAPMincho', 'Blackout', 'Noto Sans Old Turkic', 'Calibri Italic', 'SWRomnt', 'Edwardian Script ITC', 'MaestroTimes', 'Open Sans Light', 'SWRomns', 'Tsukushi B Round Gothic Bold', 'NanumMyeongjo Bold', 'VNI-DesdemonaU', 'Avenir Next Demi Bold Italic', 'Telugu Sangam MN', 'MMSchoolRD Bold', 'SWRomnc', 'Baoli SC', 'Leitura Display Roman', 'Savoye LET Plain:1.0', 'DIN-RegularAlternate', 'Hiragino Kaku Gothic ProN', 'HeadLineA Regular', 'Charter', 'KacstPen', 'header 17', 'Hiragino Kaku Gothic Pro W3', 'Hiragino Maru Gothic ProN', 'Adobe Naskh', 'RUMA', 'Liberation Sans Narrow', 'Corbel Bold', 'Noto Sans Tai Le', 'Valluvan', 'Soho Gothic Pro Thin', 'Modena printed', 'News Gothic MT Alt 5', 'Avenir Next Condensed Bold Italic', 'VNI-Centur', 'Avenir Next Condensed Medium', 'Palatino Linotype', 'STIXSizeFourSym-Bold', 'TAMElango', 'cmsltt10', 'Letter Gothic Std Slanted', 'Noto Sans Coptic', 'Firenze SF', 'Six Caps', 'Fira Mono', 'MS Mincho', 'Malayalam Sangam MN', 'Kohinoor Devanagari Semibold', 'Rockwell Nova', 'Chalkboard', 'Biko', 'Gurmukhi MN Bold', 'IguanaLover BTN', 'Curlz MT', 'Induction', 'FML-TTNarmadaExBold', 'Walter', 'DokChampa', 'CAC Champagne', 'Ubuntu Mono derivative Powerline Italic', '.VnVogueH', 'Myriad Pro Black', 'cnefont', 'Helvetica Neue Italic', 'Onyx', 'HERMAN', '1', 'standard 07', 'Myanmar Text', 'Deepa', 'Shree Devanagari 714', 'Balthazar', 'Klee Demibold', 'standard 09', 'Geeza Pro Regular', 'Cinema Gothic BTN Shadow', 'PT Simple Bold Ruled', 'IRIS', 'Myriad Web Pro Condensed', 'VNI-Bauhaus', 'LuzSans-Light', 'Futura Medium Oblique', 'Kailasa Bold', 'Smudger Alts LET', 'Chiller', 'VNI-Standout', 'Noto Sans Thai UI', 'eurm10', 'MMa Etc S', 'Corporate', 'Detente', 'Oriya Sangam MN', 'Adobe Devanagari Bold Italic', 'Sinhala MN Bold', 'Linux Biolinum O', 'HelveticaNeueLT Pro 27 UltLtCn', 'Jazz LET', 'Linux Biolinum G', 'Airstream', 'AR DECODE', 'Alien Encounters', 'VNI-Wide Latin', 'Tlwg Mono', 'eurm8', 'fox in the snow', 'eurm6', 'eurm7', 'Euclid', 'eurm5', 'PMingLiU-ExtB', 'Noto Sans CJK SC', 'Perpetua Titling MT Light', 'Swis721 Ex BT', 'Roboto Mono Thin Italic for Powerline', 'Garamond Premier Pro', 'gargi', 'Futura Light Condensed BT', 'Museo 700 Regular', 'Placard MT Condensed', 'Euro Sign', 'Persia BT', 'Circular Std Medium', 'Nexa Book Italic', 'Hoefler Text', 'TakaoPGothic', 'Dutch 801 Roman', 'Waverly', 'ML-TTPeriyar', 'Trade Gothic LT Std Light Oblique', 'PT Bold Dusky', 'Ayuthaya', 'Tw Cen MT Bold Italic', 'GentiumAlt', 'Damascus Regular', 'Hiragino Mincho ProN W6', 'Shruti', 'Devanagari Sangam MN', 'Hiragino Mincho ProN W3', 'Z@R1774.tmp', 'Avenir Next Condensed Medium Italic', 'Opus Japanese Chords', 'Noto Sans Thai', 'Adobe Caslon Pro', 'Apple Chancery', 'Kannada MN', '.VnVogue', 'Nobile', 'New Peninim MT Bold', 'Meiryo Italic', 'Roboto Mono Italic for Powerline', 'GFS Complutum', 'Verdana Pro Cond SemiBold', 'Augusta', 'Lucida Sans', 'Old Antic Outline Shaded', 'Harrington', 'Malayalam Sangam MN Bold', 'DS Crystal', 'Purisa', 'Adobe Hebrew Bold Italic', 'Iowan Old Style Black', 'Razer Header Regular', 'Monospac821 BT', 'Kohinoor Devanagari', 'Diwan Kufi Regular', 'Droid Sans Japanese', 'Lucida Fax Demibold Italic', 'Minion Pro Bold Italic', 'Marion Italic', 'Raleway ExtraLight', 'ArhialkhanMJ', 'Gungsuh', 'VNI-Souvir', 'Thonburi', 'Skia', 'Kaiti TC', 'Umpush', 'Candy Round BTN Cond Lt', 'ML-TTThunchan', 'BorhalMJ', 'PingFang TC Regular', 'Futura Medium', 'System Font Semibold', 'Roboto Slab Bold', 'Fanwood', 'Muli Light', 'Raisin des Sables', 'DFMaruGothic-Md', 'Al Bayan Bold', 'Noto Sans Mongolian', 'Apple Symbols', 'Muli Italic', 'Z@R1828.tmp', 'Source Sans Pro Bold', 'NanumGothic', 'MMRelation Italic', 'Noto Sans New Tai Lue', 'RaghuMalayalam', 'LetterOMatic!', 'Seravek Light', 'Baskerville Bold', 'MMGreek Bold Italic', 'QumpellkaNo12', 'GFS Olga', 'Times Italic', 'Futura Book BT', 'Glockenspiel', 'MS Reference Specialty', 'KanchanMJ', 'EngraverFontSet', 'MMa Binary', 'BN Jinx', 'Nova Flat', 'Yeseva One', 'Bauer Bodoni Std 1 Bold Italic', 'Kohinoor Telugu Semibold', 'TeX Gyre Heros', 'Georgia Pro Cond SemiBold', 'MMa Variable2 S', 'Inconsolata-g for Powerline', 'Simple Bold Jut Out', 'JLS Space GothicR NC', 'Circular Std Medium Italic', 'ML-TTAparna', 'Damascus Semi Bold', 'Opus Roman Chords', 'MS Dialog Light', 'MMa Negate', 'Chaparral Pro Light', 'Opus Note Names', 'Symbol Tiger Expert', 'SWComp', 'Cooper Std Black', 'JazzText', 'Langdon', 'FML-Mohini', 'Proxima Nova Regular Italic', 'Raleway ExtraBold Italic', 'cmtt12', 'DejaVu Sans Mono Oblique for Powerline', 'HUNTSON', 'Cantho', 'SWMusic', 'GENISO', 'Parchment', 'STHupo', 'Pricedown', 'Geotype TT', 'schoenecker 10', 'Photoshop Large', 'JACKIE', 'Averia', 'Granjon Roman', 'Bookshelf Symbol 7', 'Code39AzaleaNarrow1', 'Andong', 'Code39AzaleaNarrow3', 'Code39AzaleaNarrow2', 'Nexa Black', 'FML-TTPeriyar', 'Pirate', 'Formata Medium Condensed', 'Minerva', 'Futura LT Book', 'Kozuka Mincho Pro', 'LittleLordFontleroy', 'Tamil Sangam MN', 'Adobe Song Std L', 'SWIsop2', 'SWIsop3', 'STIXIntegralsSm', 'SWIsop1', 'Lao UI', 'Pothana2000', 'TAU-Valluvar', 'FML-TTLeela', 'BOUTON International Symbols', 'FontAwesome', 'Menlo Italic', 'MMa TextBook', 'Gothic720 BT', 'EucrosiaUPC', 'SF Slapstick Comic Bold', 'Gabriola', 'QuickType II Condensed', 'Bodoni 72 Oldstyle Book Italic', '.Vn3DH', 'HelveticaNeueLT Std Bold Outln', 'Lohit Punjabi', 'Kaiti SC Black', 'HKSCS-ExtB', 'Modern No', 'Blackmoor LET Plain:2.0', 'MMa Century Bold Italic', 'Code39AzaleaWide3', 'Code39AzaleaWide2', 'Code39AzaleaWide1', '19', 'Phatdiem', 'David', 'ML-TTAyilyamBold', 'Avinor', 'Adobe Devanagari', 'Al Tarikh Regular', 'Zolano Sans BTN', 'Drivebye 2', 'Drivebye 3', 'Ultra', 'Drivebye 1', 'Drivebye 4', 'Sneakerhead BTN Shadow', 'Songti SC Black', 'Radha', 'MMa Relation S', 'Ventilla Script', 'eufm8', 'Stone Sans OS ITC TT Bold', 'GFS Solomos', '.VnCentury Schoolbook', 'Nexa Thin', 'Bordeaux Roman Bold LET Plain:1.0', 'Euclid Math Two', 'EngraverTextNCS', 'Meiryo Bold Italic', 'Cooper Std Black Italic', 'DynameBlackSSK', 'GaneshThin', 'LTHYSZK', 'Noto Sans Hebrew', 'AnjaliOldLipi', 'Meslo LG M Regular for Powerline', 'Silent Reaction', 'VNI-Free', 'Montserrat Extra Bold', 'Avenir Next', 'Apple Braille Pinpoint 6 Dot', 'CommercialPi BT', 'CopprplGoth BT', 'GJ-TTAvantika', 'monofur bold for Powerline', 'Arial (Arabic)', 'Courier Std', 'FML-TTSwathyBold', 'Avenir Oblique', 'eufm6', 'SuperFrench', 'Montserrat', 'Copperplate Gothic Bold', 'Gillius ADF No2 Cd', 'Lantinghei SC Demibold', 'Gill Sans Nova Light', 'HGHeiseiMinchotaiW3', 'Lato Black', 'Rod Transparent', 'Malayalam MN Bold', 'Euclid Fraktur Bold', 'VNI-Boston Black', 'ML-TTLeela', 'INSPECTIONXPERT GDT FRAMES', 'Bebas Neue Thin', 'mry', 'eufm7', 'SWMap', 'Proxima Nova Condensed Light', 'cmbxti10', 'Nexa Regular', 'Lucida Bright Demibold Italic', 'Optima LT Std', 'Georgia Pro Black', 'Titillium Semibold Italic', 'ParkAvenue BT', 'Franklin Gothic Medium Italic', 'PujeetaNarrow', 'Daclac', 'Xpress Heavy SF', 'Tibetan Machine Uni', 'DecoType Naskh Swashes', 'Arial Narrow', 'MMa TextBook Bold Italic', 'Titillium Thin Upright', 'Roland', '.VnCooper', 'Stephen', 'Kino MT', 'HelvLight', 'Eurostile', 'Shonar Bangla', 'Helvetica Neue Thin', 'Orator Std Slanted', 'cmvtt10', 'MMCenturyNew Italic', 'DIN-Regular', 'Futura Book Oblique', 'Hack Regular', 'Nanum Gothic', 'SaiMeera', 'Apple SD Gothic Neo Thin', 'Source Code Pro ExtraLight', 'Myriad Pro Light SemiCond', 'Bank Gothic Medium', 'Swis721 Blk BT', 'Cambria Math', 'ChitraMJ', 'MS Dialog', 'Kokonor', 'ChitraSMJ', 'monofur for Powerline', 'Samathwa', 'Adobe Myungjo Std M', 'ML-TTVarsha', 'MMTextBookB Italic', 'AV-Font-Mal1', 'VN-NTime', 'MMa Extra Bold Italic', 'Paralucent Extra Light', 'Grand Hotel', 'MMRelation Bold', 'NanumMyeongjo', 'cmssdc10', 'Z@R183A.tmp', 'MMa Negate Italic', 'VNI-Harrington', 'Kruti Astro', 'DYMObvba', 'System Font Heavy', 'cmtt9', 'Avenir Next W1G Demi Italic', '.VnBook-AntiquaH', 'La Bamba LET', 'Rage Italic', 'MMa Fraktur', 'Parisian BT', 'University Roman Alts LET', 'Lobster', 'Ideal Sans Book', 'Lucida Grande Bold', 'MMa VariableC Bold', 'MMa Binary Bold', 'Fixedsys', 'Adobe Naskh Medium', 'Vemana2000', 'Opus Special', '.VnSouthern', 'Swis721 BT', 'ITF Devanagari Marathi', 'PT Sans Narrow', 'FML-TTRohini', '.VnMemorandum', 'Siyam Rupali ANSI', 'Segoe UI Semilight', 'Rock Salt', 'Santa Fe LET Plain:1.0', 'ParvathiBold', 'Superclarendon', 'STIXIntegralsUpD-Regular', 'Salilam', 'Canter Bold', 'FML-TTBeckalBold', 'STIXIntegralsUp-Regular', 'MMCenturyNew', 'Georgia Pro Cond Light', 'Arial Italic', 'Nueva Std Bold Condensed', 'Latin Modern Math', 'FreeSans', 'SAS Monospace Bold', 'Tarzan', 'STIX', 'VnTimes', 'Typewriter', 'Arial TUR', 'Urvasi', 'Meslo LG L Regular for Powerline', 'Sans', 'cmr5', 'ML-TTSuparna', 'HelveticaNeueLT Pro 35 Th', 'Lato Medium', 'Futura Std Bold Condensed', 'Trade Gothic LT Std Bold Oblique', 'Thorndale AMT', 'Sitka Display', 'Complex', 'Bobcat', 'Kaiti TC Bold', 'Hansen', 'Rosewood Std', 'VNI-DOS Sample Font', 'Noto Sans Tagbanwa', 'Razer Header Light', 'MS Sans Serif', 'Maestro Percussion', 'Western Bang Bang', 'Shorelines Script Bold', 'Myriad Pro Bold Condensed Italic', 'Kohinoor Telugu Bold', 'SF Movie Poster', 'Harlow Solid Italic', 'Brandon Grotesque Bold', 'lettau 06', 'Z@R123A.tmp', 'Linux Libertine Mono O', 'Giadinh', 'Yuanti SC Bold', 'Rakesly Rg', 'Accanthis ADF Std No3', 'HooglyMJ', 'Nunito', 'HelveticaNeueLT Std Med', 'Helvetica Neue Condensed Bold', 'MMCenturyNew Bold', 'WP Arabic Sihafa', 'Archicoco', 'Realvirtue', 'MMa VariableA Bold', 'MMVariableA', 'Nimbus Roman No9 L', 'MMVariableC', 'MMVariableB', '64', 'MMVariableD', '66', 'MMVariableF', '68', 'FML-TTAparna', 'ML-TTGauriHeavy', 'Chess Maya', 'Special Elite', 'Courier New TUR', 'Kozuka Mincho Pro L', 'Minion Pro Bold Cond Italic', 'VISCII Sample Font', 'Montserrat Semi Bold', 'BriLliant', 'LIVINGWELL', 'MMa Variable S', 'VNI-Jamai', 'FML-TTSabari', 'Binhlong', 'AtraiMJ', 'TeamViewer10', 'TeamViewer11', 'Broadway Copyist Text', 'GoraiMJ', 'American Typewriter Condensed', 'HGSHeiseiMinchotaiW9', 'Seravek Medium Italic', 'Belwe Cn BT', 'Abadi MT Condensed Light', 'Vanilla', 'WP Greek Helve', 'Trocchi Bold', 'Khmer MN', 'Roboto Condensed Regular', 'TitilliumText22L-Light', 'Nexa Bold Italic', 'cmss9', 'cmss8', 'IMG Symbols', 'ML-TTBhavana', 'Aldhabi', 'Weibei SC Bold', 'MMVariable2', 'AL Cinderella', 'Consolas Bold Italic', 'Monoton', 'Z@R16FD.tmp', 'Gill Sans Bold Italic', 'Khanhoa', 'MMVariableD Bold', 'Charter Bold Italic', 'AnandapatraCMJ', 'UniversalMath1 BT', 'Janaranjani', 'TeamViewer9', 'Days Regular', 'Times New Roman CE', 'Futura Bold Oblique', 'VNI-Korin', 'msbm5', 'HelveticaNeueLT Pro 23 UltLtEx', 'Spirituality', 'Sitka Heading', 'KasseFLF', 'TeX Gyre Heros Cn', 'GoudyHandtooled BT', 'Bebas Neue Bold', 'Henny Penny', 'JugantorMJ', 'Trebuchet MS Bold', 'Raleway Thin Italic', 'Lucida Bright Demibold', 'Prestige Elite Std', 'HGMinchoL', 'SonicCutThru Hv BT', 'BuiltTitlingRg-BoldItalic', 'Bickham Script Pro 3', '.VnBodoni', 'Jazz', 'MYingHei', 'Muna', 'Lato', 'Minisystem', 'BurigangaMJ', 'Hoefler Text Black Italic', 'Andale Sans for VST', 'Diavlo Book', '.VnArabia', 'Big Caslon Medium', 'Titillium Semibold', 'Mishafi Gold Regular', 'Qaskin Black Personal Use', 'cmssbx10', 'Oxygen', 'msbm7', 'cmmi9', 'Aileron Light', 'KacstOffice', 'Libian SC Regular', 'IMG Baby', 'Humanist', 'Montserrat Hairline', 'euex9', 'euex7', 'Courier 10 Pitch', 'ML-TTMadhaviExBold', 'AR DESTINE', 'Shree-Mal-0502', 'FML-TTAathira', 'cmbxsl10', 'FML-Indulekha', 'PingFang SC Ultralight', 'FML-Sruthy', 'FML-TTGauriHeavy', 'Adobe Fan Heiti Std B', 'Avenir Heavy', 'cmex8', 'Hiragino Sans GB W6', 'STIXIntegralsUpD', 'line10', 'Futura LT Condensed Bold Oblique', 'Admisi Display SSi', 'cmex7', 'Casual', 'CASMIRA', '.VnLucida sans', 'STIXGeneral-Regular', 'Nueva Std Bold Condensed Italic', 'HGPHeiseiMinchotaiW9', 'Klee Medium', 'Accord Heavy SF', 'MMCenturyOld Italic', 'STIXNonUnicode-Italic', 'Fira Mono Bold for Powerline', 'Hadong', 'Apple Color Emoji', 'ML-TTAathira', '3ds Light', 'AR DARLING', 'Bifurk', 'Palace Script MT', 'NanumGothic ExtraBold', 'Baghdad Regular', 'FML-TTThunchan', 'Vodafone Rg', 'GFS Neohellenic', 'Quicksand', 'Times New Roman Bold', 'PingFang TC Medium', 'Technic', 'Adobe Kaiti Std R', 'HGPHeiseiMinchotaiW3', 'Gen W01', 'HelveticaNeueLT Std Lt Ext', '.VnPark', 'Avenir Next W1G Bold Italic', 'Roboto Black', 'New Renex Special Graphics', 'Brush Script Std', 'Segoe UI Historic', 'DejaVu Sans', 'Krungthep', 'ML-TTKala', 'Kohinoor Devanagari Demi', 'VNI-Hobo', 'GangaMJ', 'FML-TTRevathi', 'Sauce Code Powerline Semibold', 'Open Sans Bold', 'WP MultinationalA Courier', 'MMa CenturySS Bold Italic', 'Kohinoor Telugu', 'Bodoni 72 Smallcaps', 'VNI-StageCoach', 'HanziPen TC Regular', 'Agency FB', 'Reginet', 'Helvetica Neue Medium Italic', 'Helvetica Neue Condensed Black', 'ML-TTAnakha', 'Yuanti TC Light', '65', 'Avenir Next Bold Italic', 'GF Zemen Unicode', 'Ice kingdom', 'Santa Fe LET', 'Gotham Narrow Book', 'Army', 'Latin Modern Sans Quotation', 'Moonbeam', '67', 'Microsoft YaHei UI Light', 'Bell MT Italic', 'Myriad Arabic Bold', 'Lohit Bengali', 'Lato Hairline Italic', 'AppleGothic', 'Titan One', 'Lantinghei SC', 'Myriad Pro Black Condensed', 'Orator Std Medium', 'Kozuka Gothic Pro EL', 'Hollywood Hills', 'Tekton Pro Cond', 'Franklin Gothic Book Italic', 'ANDROID ROBOT', 'Diwan Kufi', 'Dutch801 Rm BT', 'future', 'Divya', 'Tlwg Typo', 'Xingkai SC', 'Open Sans', 'SutonnyMJ', 'Source Code Pro Semibold', 'Neo Sans Pro Light', 'FML-TTMalavika', 'Proxima Nova Condensed', 'Myriad Pro Black SemiExtended', 'cmtt8', 'Paralucent Demi Bold', '3M Circular TT Light', 'VNI-Tubes', 'HelveticaNeueLT Pro 37 ThCn', 'Farah Regular', 'VNI-Duff', 'cmmib6', 'ML-TTChandrika', 'Amatic', 'Khalid Art bold', 'cmmib8', 'cmmib9', 'Ela Sans Light Caps', 'SF Compact Rounded Ultralight', 'Malgun Gothic Semilight', 'Latienne Pro Italic', 'Cortoba', 'Paralucent Heavy', 'VNI-Lithos', 'Shree-Tel-0900', 'MMGreek Italic', 'FML-TTJyothy', 'HelveticaNeueLT Pro 43 LtEx', 'Leitura Display Italic', 'Ostrich Sans', '.VnBahamasB', 'Gill Sans UltraBold', 'FML-Padmanabha', 'Myriad Pro Light', 'PT Serif Italic', 'MMBinary Bold', 'Autumn', 'STIXVariants-Regular', 'Archive', 'Math3', 'Math2', 'Math1', 'FML-TTSarada', 'Euclid Math One', 'Futura LT Condensed Medium Oblique', 'Math4', 'Franklin Gothic Book', 'AR CARTER', 'Xpress SF', 'System Font Light', 'Literation Mono Powerline Bold Italic', 'Lato Semibold Italic', 'SymbolMono BT', 'HGPHeiseiKakugothictaiW5', 'HGPHeiseiKakugothictaiW3', 'Waree', 'PingFang TC Thin', 'Myriad Pro Black Cond', 'Adobe Heiti Std R', 'Learning Curve Dashed Pro', 'Smokum', 'Noto Sans Yi', 'HelveticaNeueLT Std Thin Cn', 'Mesquite Std Medium', 'Blackoak Std', 'kroeger 07', 'ML-TTNanditha', 'cmssi12', 'Avenir Medium', 'MS PGothic', 'Droid Sans', 'Finale Copyist Text', 'Merriweather UltraBold Italic', 'Kohinoor Devanagari Book', 'Reklame Script Black', 'System Font Regular G1', 'Sabrina', 'System Font Regular G3', 'System Font Regular G2', 'Arial Symbol', 'Lantinghei TC Extralight', 'cmbsy9', 'Kozuka Gothic Pr6N', 'Georgia Pro Light', 'Mangal', 'PT Bold Arch', 'JasmineUPC', 'Phosphate', '.VnTifani Heavy', 'MMa CenturyKS', 'Logo3Mtt', 'STHeiti', 'MMNegate', 'AV-Web-Tel1', 'Opus Text', 'PingFang HK Thin', 'Century', 'Playfair Display SC Bold', 'Standard Symbols L', 'BhagirathiMJ', 'Bowlby One SC', 'mono 08', 'cmti7', 'DigifaceWide', 'PujeetaSpecial', 'Avenir Next W1G Medium Italic', 'Iowan Old Style Bold Italic', 'Italic Outline Art', 'cmu10', 'MMa Negate SS', 'Serifa Bold', 'mono 07', 'Dyuthi', 'Sauce Code Powerline ExtraLight', 'ae', 'kroeger 04', 'MMRelation', 'Arno Pro Smbd Display', 'MMRelation Bold Italic', 'Microsoft YaHei UI', 'Lucida Sans Regular', 'FML-TTThiruvathira', 'FREH', 'Nova Round', '18030', 'SWGreks', 'PingFang SC Semibold', 'Adobe Heiti Std', 'Staccato222 BT', 'IDAutomationPDF417n4', 'cmssq8', 'Zapfino Extra LT Four', 'Verdana Pro Light', 'Euclid Fraktur', 'FlemishScript BT', 'AV-Font-Sin1', 'Monospace', 'Gotham Black Italic', 'Madre Script', 'Droid Sans Mono', 'TMBW-TTValluvar', 'cafeta', 'AR JULIAN', 'cmtex10', 'Oriya MN Bold', 'Buxton Sketch', 'HelveticaNeueLT Pro 45 Lt', 'Minion Pro Bold Cond', 'LiHei Pro', 'Raleway Light', '.VnKoala', 'System Font Light Italic', 'Kiran', 'MingLiU-ExtB', 'Nueva Std Condensed Italic', 'Proxima Nova Soft Semibold', 'Circular Std Book', 'Beirut Regular', 'HelveticaNeueLT Pro 55 Roman', 'AR DELANEY', 'Candles', 'Lucida Sans Demibold Italic', 'Myriad Pro Bold Italic', 'Seravek Italic', 'Old English', 'Uttara', 'Formal436 BT', 'Latin Modern Roman Slanted', 'AcadEref', 'Soho Gothic Pro Light', 'Corbel Italic', 'Modern', 'Z@R277C.tmp', 'Microsoft JhengHei UI', 'Lato Heavy Italic', 'Comic Sans MS', 'Trade Gothic LT Std Light', 'Westwood LET', 'Old Antic Bold', 'Futura Std Heavy', 'DaunPenh', 'Euclid Symbol Italic', 'Noteworthy Bold', 'MMa CenturyKSS Bold', 'Year supply of fairy cakes', 'SutonnyOMJ', 'Open Sans Extrabold Italic', 'Tekton Pro Bold Condensed', 'Chancery Cursive', 'Quincho Script PERSONAL USE', 'Modern Antiqua', 'Verdana', 'System Font Thin', 'Merriweather Bold Italic', 'Gisha', 'Chaparral Pro Light Italic', 'MMa CenturyKS Bold', 'BolsterBold', 'AVGmdBU', 'Cir Arial', 'Lithos Pro Black', 'Papyrus Condensed', 'Seravek Medium', 'Chalkduster', 'Noto Sans CJK TC', 'MMa Greek Bold Italic', 'HeadLineA', 'MMVariableA Bold', 'Times New Roman Italic', 'Garuda', 'Permanent Marker', 'Yu Gothic UI Semilight', 'Myriad Pro Black SemiCondensed', 'Apple SD GothicNeo ExtraBold', 'Norasi', 'Arial Nova Light', 'PondFreeBoss', 'Avenir Light Oblique', 'Alice and the Wicked Monster', 'AvantGarde Bk BT', 'Arno Pro SmText', 'GungSeo', 'ori1Uni', 'HelveticaNeueLT Std Blk', 'DIN-LightAlternate', 'MMa CenturyKSS', 'MMa Relation SS', 'Andalus', 'VNI-Zap', 'BN Machine', 'Segoe MDL2 Assets', 'Rotis Sans Serif Std 45 Light', '.VnGothicH', 'Proxima Nova Bold Italic', 'SAF', 'Futura Light Italic BT', 'Vivaldi', '.VnCourier', 'Khmer Sangam MN', 'BorakOMJ', 'Roboto Mono Light Italic for Powerline', 'ML-TTTheyyam', 'Avenir Next Condensed Heavy Italic', 'Caladea', 'Noto Serif Georgian', 'Charlemagne Std Bold', 'HGHeiseiKakugothictaiW5', 'HGHeiseiKakugothictaiW3', 'BerlingRoman', 'Nadeem', 'Source Sans Pro Light Italic', 'Helvetica Neue UltraLight', 'stmary10', 'Impact', 'Sketch Match', 'Songti TC', 'Square721 BT', 'MMa VariableA SS', 'AV-Font-Guj1', 'Georgia Pro', 'DhorolaMJ', 'Yuanti SC Regular', 'Roboto Mono Light for Powerline', 'Poplar Std Black', 'Futura Light Oblique', 'Hypatia Sans Pro ExtraLight', 'ISOCPEUR', 'Alternate Gothic No2 D', 'Gillius ADF', 'copy 10', 'Noto Sans Ugaritic', 'Yuanti TC', 'Charlemagne Std', 'Reswysokr', 'ML-TTNila', 'Pamela want a Bike to Ride', 'Museo 100 Regular', 'Montserrat Ultra Light', 'System Font Bold G3', 'System Font Bold G2', 'System Font Bold G1', 'ChandrabatiMatraMJ', 'MingLiU', 'Noto Sans Tamil', 'NeueHaasGroteskText Pro', 'Savoye LET Plain CC.:1.0', 'classic 10', 'Droid Sans Georgian', 'Merriweather Regular', 'MMa Etc SS', 'Devanagari Sangam MN Bold', 'STIXSizeFiveSym', 'Proxy 2', 'MMEtc', 'SOLIDWORKS GDT', 'Superclarendon Italic', 'Sakkal Majalla', 'TextilePiEF', 'MMa Variable2', 'Songti TC Bold', 'STIXIntegralsD', 'Monotype Koufi', 'DIN Condensed', 'Noto Sans Tamil UI', 'Arial Baltic', 'Terminal Greek 869', 'Chess Berlin', 'System Font UltraLight', 'Microsoft YaHei Light', 'AR Sans Serif', 'FML-TTNalini', 'Noto Sans NKo', 'Joan', 'Adobe Fan Heiti Std', 'RomanC', 'MMa Arrow Bold', 'Verdana Pro Cond Light', 'Kannada Sangam MN Bold', 'Museo Sans 500', 'Bitstream Vera Sans', 'STIXSizeFiveSym-Regular', 'Mistral', 'CloisterBlack BT', 'DhakarchithiMJ', 'Latin Modern Sans Demi Cond', 'Czec', 'GothicE', 'IMG Extreme', 'WST', 'RomanT', 'Adobe Arabic Bold Italic', 'DINPro-Bold', 'Century Schoolbook Bold Italic', '.VnBlack', 'VNI-Fillmore', 'Noto Sans Old Persian', 'Dutch801 XBd BT', '.VnArial Narrow', 'Sathu', 'Avenir Next Medium Italic', 'Lato Heavy', 'MMVariableC Bold', 'Simple Indust Shaded', 'RowdyHeavy', 'Flamenco', 'PanRoman', 'Gotham Narrow Extra Light Italic', 'OLF SimpleSansOC', 'Folio XBd BT', 'Roman Mono', 'System Font Bold Italic G1', 'Sinhala Sangam MN Bold', 'Cataneo BT', 'System Font Bold Italic G2', 'Soho Gothic Pro ExtraBold It', 'Oriya Sangam MN Bold', 'JUSTICE', 'MMa Greek Italic', 'Gotham Medium', 'Arno Pro Light Display', 'Ezra SIL SR', 'Kokila', 'SD-TTSurekh', 'GrilledCheese BTN', 'Kannada MN Bold', 'Heiti SC Medium', 'Avenir Next W1G Heavy Italic', 'PT Serif Caption', 'Hiragino Maru Gothic Pro', 'Monotype Sorts 2', 'Myriad Pro Black SemiCond', 'Swis721 BlkEx BT', 'Tsukushi A Round Gothic', 'Futura LT Extra Bold', 'Titillium Regular Italic', 'French Script MT', 'Tw Cen MT', 'KacstDecorative', 'Lucida Sans Typewriter Oblique', 'Impregnable Personal Use Only', 'MMNegate Italic', 'Whimsy TT', 'Chess Marroquin', 'NBP Informa FiveSix', 'Lucida Sans Demibold Roman', 'msbm10', 'Gill Sans Nova Ultra Bold', 'copy 09', 'Blackmoor LET', 'Castellar', 'IPAMincho', 'MMa VariableB Bold', 'Superclarendon Bold', 'Titillium Black', 'Avenir', 'Lucida Sans Typewriter Bold', 'BrowalliaUPC', 'Steppes TT', 'VNI Cambodia', 'Kefa Bold', 'Helvetica Light Oblique', 'Avenir Next W1G Ultra Light Italic', 'JazzCord', 'Symbol Neu for Powerline', 'Emily Austin', 'Avenir Light', 'Tiranti Solid LET', 'Myriad Hebrew Italic', 'Monotype Corsiva', 'cmitt10', 'DhanshirhiOMJ', 'KacstDigital', 'kawoszeh', 'Cut Me Out 2', 'Cut Me Out 3', 'Myriad Pro Bold Condensed', 'boot', 'Fredericka the Great', 'Symusic', 'balonez fantasia br', 'Bitstream Vera Sans Mono', 'Devanagari MT', 'Noto Sans UI', 'Myriad Pro Semibold Italic', 'Noto Sans Vai', 'Razer Header Regular Oblique', 'Dot', 'Swed', 'ScriptKleio', 'Gillius ADF No2', 'Myriad Pro Bold SemiExtended', 'Prema', 'ConcursoItalian BTN', 'Pricedown Bl', 'Lantinghei SC Extralight', 'GillSans-Bold', 'Urdu Naskh Asiatype', 'Glegoo', 'Kohinoor Devanagari Bold', 'Vollkorn Regular', 'AngsanaUPC', 'Apple Casual', 'Freehand575 BT', 'PingFang SC Regular', 'Aharoni', 'Medlin', 'MMa Relation Bold', 'Arial', 'FML-TTAnjali', 'RADAGUND', 'Noto Sans Mandaic', 'Marion Regular', 'cminch', 'Seagull APL', 'Nueva Std', 'Pamela wants to Ride', 'Monotxt', 'cmtt10', 'TRENDY', 'Alex Brush', 'Playfair Display SC Italic', 'STIXIntegralsUpD-Bold', 'DecoType Naskh', 'Muli', 'Marker Felt Wide', 'Klee', 'PUPPYLIKE', 'Accanthis ADF Std No2', 'Cooper Std', 'Meslo LG L DZ Regular for Powerline', 'Droid Arabic Naskh', 'ITF Devanagari Demi', 'Verdana Pro SemiBold', 'Kalyani', 'Futura Md BT', 'Latino Elongated LET Plain:1.0', 'Brussels', 'Nasalization', 'Thonburi Bold', 'Kohinoor Devanagari Medium', 'Loma', 'Noto Sans Rejang', 'Typewriter Bold', 'Zapfino Extra LT One', 'Futura Heavy', 'Origin', 'Euclid Symbol Bold Italic', 'Gotham Narrow Bold Italic', 'smart watch', 'PFDaVinciScriptPro-Inked', 'Odessa LET', 'KG Fall For You', 'FMLTTAathira', 'MMNegate Bold', 'Gotham Thin', 'Cousine Bold for Powerline', 'Courier New Bold', 'Cracked', 'Arial Bold', 'GoomtiMJ', 'PingFang SC', 'Minion Pro Semibold Italic', 'VNI-WIN Sample Font', 'LA Headlights BTN', 'Moon Flower', 'VNI-Couri', 'Segoe WP Light', 'lcmssi8', 'Carlito', 'Eras Bold ITC', 'Proxima Nova Light', 'Oswald', 'Abel', 'Doulos SIL', 'Sanskrit', 'BRADDON', 'MMa Binary Bold Italic', '.VnStamp', 'Raleway ExtraBold', 'VNI-Vari', 'DhakarchithiOMJ', 'Narkisim', 'Arno Pro Subhead', 'monoeger 05', 'Lithos Pro', 'Noto Sans CJK KR', 'Arial Black', 'Gigi', 'FML-TTVeenaHeavy', 'JaJaDiMJ', 'Supernatural Knight', 'Garamond Premier Pro Semibold', 'Didot', 'MMa Relation Italic', 'IDAutomationPDF417n3', 'Source Sans Pro ExtraLight Italic', 'STZhongsong', 'NSimSun', 'JuneBug', 'Candy Round BTN Lt', 'Georgia Bold Italic', 'BauerBodni BT', 'ML-TTRavivarma', 'Yu Gothic Light', 'monofur italic for Powerline', 'Webdings', 'Courier MM Screenwriter BoldIt', 'STXinwei', 'PenultimateLightItal', '3 of 9 Barcode', 'Rockwell Nova Cond Light', 'Laila Medium', 'FML-TTSurya', 'Shree Devanagari 714 Bold', 'Metamorphous', 'Mekanik LET', 'Serif', 'Verdana Pro Black', 'ML1-TTAmbili', 'Lucida Handwriting Italic', 'Apple Braille Outline 8 Dot', 'Courier New Baltic', 'Euclid Italic', 'Opus Figured Bass Extras', 'Latin Modern Roman Unslanted', 'VNI-Allegie', 'Comic Sans MS Bold', 'Nina', 'ML-TTMalavika', '18thCentury', 'PhrasticMedium', 'Amatic SC', 'Canter Bold 3D', 'Swis721 BlkCn BT', 'KalegongaOMJ', 'Nirmala UI Semilight', 'Lato Light', 'ISABELLE', 'Courier', 'Linux Libertine G', 'copy 08', 'Kedage', 'Raleway Light Italic', '.VnLinus', 'Roboto Medium', 'Lithos Pro Regular', 'STIXNonUnicode-Regular', 'eufb9', 'eufb8', 'MARKETPRO', 'Skia Black Condensed', 'eufb7', 'eufb6', 'eufb5', 'VnTimes2', 'SWMath', 'Bamini', 'Anonymice Powerline Bold', 'Sukhumvit Set Thin', 'STFangsong', 'ML-TTAtchu', 'Cochin Italic', 'hooge 06', 'hooge 04', 'hooge 05', 'Tw Cen MT Italic', 'MMTimes Bold', 'IPAGothic', 'PingFang TC Ultralight', 'Copperplate Light', 'Consolas Italic', 'Kohinoor Telugu Light', 'TAU-Barathi', 'STIXIntegralsUpSm-Regular', 'FML-TTKeerthi', 'Vrinda', 'eurb6', 'KalindiOMJ', 'Blade Runner Movie Font', 'Source Sans Pro Bold Italic', 'TAC-Barathi', 'Adobe Ming Std L', 'PingFang SC Light', 'MMa Gauss', 'kor', 'MMa Variable2 Bold', 'Yu Gothic Medium', 'Tw Cen MT Condensed', 'Damascus Medium', 'Sugarskin BTN', 'QTOptimum Regular', 'Tekton Pro Bold Oblique', 'Adobe Fangsong Std R', 'italic 08', 'Sana Regular', 'MMa Century Bold', 'DIN Condensed Bold', '(AH) Manal Black', 'Wolf in the City Light', 'Scriptina', 'Skinny', 'FML-TTNanditha', 'eusb9', 'Kalpurush ANSI', 'Canter Bold Strips', 'AdineKirnberg-Script', 'Minion Pro Semibold', 'Copperplate Bold', 'Trebuchet MS Italic', 'Myriad Hebrew Bold Italic', 'Hand Me Down S (BRK)', 'Latha', '.VnMonotype corsivaH', 'VNI-Slogan', 'STIXSizeTwoSym', 'Thonburi Light', 'Consolas Bold', 'Orange LET', 'Candara Bold Italic', 'Gotham Light Italic', 'Trade Gothic LT Std Extended', 'Starliner BTN', 'NixieOneRegular', '.VnAristoteH', 'chs', 'Rockwell Condensed', 'ML-TTSarada', 'Map Symbols', 'DejaVu Sans Mono', 'Telugu Sangam MN Bold', 'Courier New Bold Italic', 'Gotham Narrow Ultra', 'Victorian LET', 'Architects Daughter', 'MS Reference 1', 'ML-TTNalini', 'MS Reference 2', 'Dynalight', 'Baskerville Old Face', 'Optima Bold Italic', 'SimSun-ExtB', 'Vladimir Script', 'Hiragino Sans GB W3', 'Rockwell', '63', 'Skia Black Extended', 'Helvetica Neue UltraLight Italic', 'Dominican', 'Futura LT Bold Oblique', 'Franklin Gothic Heavy', 'Cooper Black', 'Baskerville Italic', 'Open Sans Condensed', 'TAU-Kaveri', 'MMa Variable SS', 'Helvetica Neue Thin Italic', 'Arno Pro Display', 'MMa Negate Bold Italic', 'Xingkai SC Bold', 'Montserrat Light', 'cmti9', 'TAC-Kabilar', 'cmssi9', 'Roboto Condensed Light', 'cmssi8', 'Tunga', 'STIXVariants-Bold', 'SWGDT', 'Arabic Typesetting', 'SAS Monospace', 'Martina', 'Myriad Pro Light SemiCondensed Italic', 'Raavi', 'MMTimes', 'VNI-Dur', 'TitilliumText22L-XBold', 'FML-TTVinay', 'Titillium Light Upright', 'Savoye LET Plain CC', 'Bangkok Cirilica', 'Mongolian Baiti', 'Iowan Old Style', 'MMArrow Bold', 'Cairo SF', 'Arno Pro Smbd Subhead', 'Formata Light Condensed', 'PingFang HK Medium', 'Cousine for Powerline', 'Arial Nova', 'Stez Sans', 'FML-LeelaHeavy', 'Century Gothic Bold Italic', 'Mytho', 'STIXIntegralsD-Bold', 'cmsl9', 'Al Nile Bold', 'SWIsot3', 'Great Vibes', 'System Font Italic G2', 'System Font Italic G3', 'System Font Italic G1', 'BlackJackRegular', 'Quicksand Light', 'ZWAdobeF', 'Hypatia Sans Pro', 'Noto Sans Mono CJK SC', 'Nueva Std Condensed', 'SemiBold', 'Avenir Next Condensed Ultra Light', 'Athelas Bold Italic', 'MMa TextBook Italic', 'ML-TTKarthika', 'Swis721 Hv BT', 'AS-TTDurga', 'Clear Sans', 'Led Italic Font', 'Seravek', 'Dirty Headline', 'Lucida Fax Italic', 'Apple SD Gothic Neo Heavy', 'Roboto Mono Medium Italic for Powerline', 'Droid Sans Armenian', 'Hiragino Maru Gothic Pro W4', 'AlekyaBold', 'STIXGeneral-Bold', 'Candara', 'Tekton Pro', 'QuickType II', 'Fixed Miriam Transparent', 'Latienne Pro Bold Italic', 'cmbsy10', 'ABIGAIL', 'Latin Modern Mono Light', 'Bodoni 72 Book', 'Cinzel', 'Monaco', 'Kozuka Gothic Pr6N M', 'Kozuka Gothic Pr6N L', 'msam8', 'PAINTSTROKE', 'ML-TTRohini', 'Kozuka Gothic Pr6N H', 'Fingerpop', 'TRIAL', 'SWGothg', 'SWGothe', 'SWGothi', 'BacktalkSerif BTN', 'Courier New', 'MLU-Panini', 'Marion', 'Zapfino Extra LT Two', 'News Gothic MT Alt 4', 'Miriam Transparent', 'Copperplate Gothic Light', 'BankGothic Md BT', 'MS SystemEx', 'Proxima Nova Condensed Semibold', 'YuMincho  36p Kana Medium', 'Microsoft New Tai Lue', 'SF Slapstick Comic', '.VnExoticH', 'Baron Neue Bold Italic', 'Swis721 LtEx BT', 'PilGi Regular', 'PT Bold Stars', 'Chalkboard SE Light', 'ThoolikaUnicode', 'Muna Regular', 'Nueva Std Bold', 'Roboto Slab Light', 'Khmer OS System', 'NanumMyeongjo ExtraBold', 'Noto Sans Devanagari UI', 'Centaur', 'IM FELL DW Pica', 'Cambria', 'Castro Script PERSONAL USE ONLY', 'JF Armenian Serif', 'MMCenturyNewRD Italic', 'AppleMyungjo Regular', 'PingFang SC Medium', 'Futura LT Condensed Extra Bold', 'Noto Sans Old Italic', 'Bradley Hand Bold', 'Al Bayan Plain', 'STIXSizeOneSym-Regular', 'MMa CenturySS Italic', 'News Gothic MT Italic', 'Gotham Extra Light Italic', 'Wawati SC', 'KB Vibrocentric', 'Anonymice Powerline', 'Harry P', 'Sana', 'Heiti TC Medium', 'News Gothic MT Alt 1', 'DYMO Symbols', 'Futura LT Heavy', 'cmss17', 'ML-TTGopika', 'Symbola', 'Yuppy SC', 'ADMUI2Sm', 'Meiryo', 'Woodcut', 'cmss10', 'OCR-A BT', 'STIXSizeThreeSym', 'Roboto Thin Italic', 'AR CENA', 'Iowan Old Style Roman', 'TlwgTypewriter', 'Baclieu', 'Optima Bold', 'Hannotate TC Bold', 'Adobe Hebrew Bold', 'Gurmukhi Sangam MN Bold', 'X-Files', 'Microsoft Uighur', '.VnExotic', 'Trade Gothic LT Std Bold', 'BankGothic Lt BT', 'Lucida Sans Typewriter', 'MisterEarl BT', 'Parry Hotter', 'Mshtakan', 'Baron Neue', 'FML-TTAshtamudiExBold', 'VNI-Present', 'Hoefler Text Black', 'News Gothic MT Alt 3', 'Verlag Book', 'VNI Helve', 'Lucida Bright Italic', 'Cabin', 'Math1Mono', 'MMa GreekSS Italic', 'TL-TTHemalatha', 'Alibi', 'Roboto', 'Bell Gothic Std Black', 'Lexia', 'Proxima Nova Soft Regular', 'Vollkorn Italic', 'ChandrabatiSushreeMJ', 'Diwani Outline Shaded', 'News Cycle', 'Apple SD Gothic Neo SemiBold', 'Arial CE', 'Z@R1816.tmp', 'SamsungImaginationBold', 'Charter Bold', 'Canter Outline', 'Day Roman', 'ML-TTVinay', 'YuCiril Helvetica', 'Brush Script', 'Sorts Mill Goudy Italic', 'Simple Indust Outline', '36p Kana Demibold', 'Latin Modern Roman Caps', 'Mayence Premium', 'Granjon Italic', 'Aparajita', 'Noto Sans Syloti Nagri', 'Highlight LET', 'Ferro Rosso', 'Hypatia Sans Pro Light', 'Hei Medium', 'ITF Devanagari Light', 'MS UI Gothic', 'OCR A Extended', 'VNI-Ariston', 'SWSimp', 'Holiday Springs BTN Quill', 'WP MathExtendedB', 'FML-TTGeethika', 'Eras Demi ITC', 'Verdana Pro Cond', 'Bordeaux Roman Bold LET', 'Voyager NBP', 'Goudy Old Style Italic', 'Oswald Regular', 'Giddyup Std', 'Harvest', 'Helvetica Neue Medium', 'Paralucent Medium', 'Times New Roman Uni', 'MMCenturyOld Bold', 'Ubuntu Mono derivative Powerline Bold Italic', 'Clarendon Lt BT', 'Emma Script Mvb', 'Raleway Medium Italic', 'Gotham Extra Light', 'Stone Sans Sem ITC TT SemiIta', 'Menlo Bold', 'FZLanTingHeiS-UL-GB', 'MMa Binary S', 'Constantia Bold Italic', 'jpn', 'Myanmar MN', 'MMCenturyOldGreek Bold Italic', 'AGA Arabesque', 'Inconsolata for Powerline', 'Maestro', 'Avenir Next Condensed Bold', 'PT Serif', 'Kozuka Gothic Pr6N EL', 'Myriad Pro SemiExtended', 'Source Code Pro Light', 'cmbx10', 'Bernard MT Condensed', 'Teen', 'Baiduan Number', 'AnticFont', 'Andale Mono', 'CordiaUPC', 'Hobo Std', 'Caviar Dreams Italic', 'Math4Mono', 'ceriph 05', 'Gentium Basic', 'ceriph 07', 'Heather BTN', 'MMVariableB Bold', 'FML-Akhila', 'Bradley Hand', 'Cookie', 'AR HERMANN', 'eusb8', 'MMa Fraktur Bold', 'Soho Gothic Pro Bold', 'Kozuka Mincho Pro R', 'PN-TTAmar', 'eusb6', 'eusb7', 'ML-TTSwathyBold', 'Roboto Light', 'Cochin Bold', 'Symeteo', 'VNI-Internet Mail', 'MMa Greek Bold', 'Kozuka Mincho Pro B', 'Kozuka Mincho Pro M', 'Bodoni 72 Smallcaps Book', 'ZDingbats', 'Proxima Nova Condensed Regular Italic', 'Kozuka Mincho Pro H', 'Superclarendon Light Italic', 'CountryBlueprint', 'MMGreek', 'Juice ITC', 'TanglewoodTales', 'MMa Greek', 'MMEtc Bold', 'Noto Sans CJK JP', 'HelveticaNeueLT Std Lt', 'Apple SD Gothic Neo Medium', 'Microsoft JhengHei UI Light', 'Broadway Copyist Perc', 'Handwriting - Dakota', 'PCMyungjo', 'AIGDT', 'Helvetica Neue Light Italic', 'Museo Sans 500 Italic', 'Oriya MN', 'Arial Unicode MS', 'MMa VariableC SS', 'Roboto Condensed Bold Italic', 'Circular Std Bold', 'GaneshMedium', 'Finale Percussion', 'Titillium Light', 'Arkhip', 'Al Bayan', 'PingFang HK Semibold', 'SAPIcons', 'Noto Sans Samaritan', 'Dancing Script OT', 'ELLIS', 'Museo Sans 700', 'Limousine', 'SF Slapstick Comic Oblique', 'Sukhumvit Set', '.VnUniverse', 'Franklin Gothic Demi Cond', 'KarnaphuliOMJ', 'DFKGothic-Md', 'Monika Italic', 'VNI-Meli', 'MV Boli', 'TeX Gyre Schola', 'Finger Paint', 'Meslo LG M DZ Regular for Powerline', 'TURK', 'Noto Sans Limbu', 'Arimo Italic for Powerline', 'SPAN', 'KG Part of Me', 'Hiragino Kaku Gothic Pro', 'No Flash', 'Zolano Serif BTN', 'DIN Alternate Bold', 'Nanum Pen Script', 'Proxima Nova Lt', 'Commons', 'Lato Light Italic', 'Raleway Black Italic', 'Maiden Orange', 'Lato Bold Italic', 'PondFreeMe', 'Latin Modern Mono Light Cond', 'Myriad Pro Light Cond', 'Baron Neue Bold', 'Malayalam MN', 'Mshtakan Bold', '.VnAvant', 'MMa VariableD S', 'Merriweather UltraBold', 'ITF Devanagari Marathi Book', 'Raleway Thin', 'Amudham', 'MMCenturyNewRD Bold Italic', 'DIN-Bold', 'Miriam Fixed', 'Roboto Mono Bold for Powerline', 'SaiSai', 'Symbol MT', 'Virtual DJ', 'FML-TTRavivarma', '.VnArabiaH', 'FML-TTSruthy', 'HaldaOMJ', 'JazzPerc', 'Gotham Narrow Medium Italic', 'Avenir Black', 'Kalpurush', 'eufb10', 'Raleway', 'Arial Bold Italic', 'Sinhala Sangam MN', 'Inconsolata-dz for Powerline', 'Hiragino Kaku Gothic StdN', 'Lobster Two', 'QuickType II Mono', 'Nova Square', 'MMa CenturyK Bold Italic', 'Roboto Slab Thin', 'Lucida Sans Unicode', 'Coaster Shadow', 'Skia Light Extended', 'Skia Regular', 'Chipotle', 'Thorndale for VST', 'TeX Gyre Adventor', 'SERB', 'Simplex', 'Amiri Quran', 'Ubuntu Mono derivative Powerline Bold', 'Songti TC Light', 'One Stroke Script LET', 'Clarendon Blk BT', 'Poiret One', 'Source Code Pro', 'Fascinate', 'GrilledCheese BTN Wide Blk', 'AV-Font-Tam1', 'SWRomnd', 'Times', 'Noto Sans Ol Chiki', 'Source Code Pro Medium', 'HooglyOMJ', 'Gazzarelli', 'One Dance Bold', 'Myriad Pro Light SemiExtended', 'Math5Mono', 'Raleway ExtraLight Italic', 'VNI-Maria', 'Gotham Narrow Book Italic', 'Roboto Black Italic', 'Tekton Pro Bold Extended', 'Titillium Regular Upright', 'FML-TTGauri', 'Stencil Std Bold', 'Note this', 'Bebas Neue Regular', 'Rod', 'VNI-Times', 'cmsy9', 'cmsy8', 'Just Another Hand', 'lcirclew10', 'INSPECTIONXPERT GDT NOFRMS', 'Accord Light SF', 'MMa VariableA', 'Z@R170E.tmp', 'cmsy5', 'New Peninim MT', 'LuzSans-Book', 'cmsy6', 'CATIA Symbols', 'Bauer Bodoni Std 1 Bold', 'Z@R184B.tmp', 'Trebuchet MS', 'Sukhumvit Set Text', 'Tsukushi B Round Gothic Regular', 'HP Simplified', 'Waseem', 'HelveticaNeueLT Pro 67 MdCn', 'Hiragino Kaku Gothic Std', 'Phosphate Inline', 'PondFreeZoo', 'Arial Narrow Bold Italic', 'Kailasa Regular', 'ML-TTThiruvathira', 'FML-TTKala', 'GiovanniITCTT', 'Stone Sans Sem OS ITCTT SemiIta', 'Arimo', 'Trade Gothic LT Std Bold No. 2', 'Source Sans Pro ExtraLight', 'Soho Gothic Pro Medium Italic', 'Milano LET', 'WP BoxDrawing', 'Titillium Light Italic', 'Open Sans Light Italic', 'FML-Revathi', 'Kartika', 'Chalkboard SE Bold', 'Bickham Script Pro Semibold', 'MMCenturyOld Bold Italic', 'FML-TTKarthika', 'Unknown Caller BTN SC', 'Paralucent Heavy Italic', 'MMArrow Italic', 'PMingLiU', 'Gotham Narrow Thin Italic', 'Andale Mono IPA', 'DecoType Thuluth', '04b', 'Urdu Typesetting', '.VnFree', 'URW Chancery L', 'Apple SD Gothic Neo Bold', 'Noto Sans Tagalog', 'PingFang TC Semibold', 'FML-TTAtchu', 'PR Celtic Narrow', 'Abyssinica SIL', 'JaneAusten', 'TAMILNET', 'Jokerman', 'GDT', 'Dosis Light', 'Adobe Garamond Pro Bold Italic', 'Devanagari MT Bold', 'Arial CYR', 'MMa Extra', 'Poor Richard', 'Weibei SC', 'Existence Light', 'Lucida Bright', 'Tahoma', 'Microsoft Yi Baiti', 'IchamotiMJ', 'HKSCS', 'KG Shake it Off Chunky', 'Gadugi', 'WP Greek Courier', 'Comic Relief', 'KacstFarsi', 'PT Separated Baloon', 'Siyam Rupali', 'ScriptC', 'MMSchoolRD Bold Italic', 'SWTxt', 'DejaVu Sans Mono for Powerline', 'FML-TTTheyyam', 'Berlin Sans FB', 'Terminal', 'HGP-AGothic2-Latin1K', 'Blackadder ITC', 'ScriptS', '.VnCourier NewH', 'Arno Pro Smbd Caption', 'Kristen ITC', 'CLARENCE', 'Source Serif Pro', 'OPENCLASSIC', 'OLIVEOIL', 'YuGothic Bold', 'LCD', 'KasseFLF-Bold', 'HelveticaNeueLT Std Thin Ext', 'CZEC', '3M Circular TT Book', 'Bold Italic Art', 'Goudy Old Style', 'ChunkFive Roman', 'Redressed', 'Chess Alpha', 'Myriad Pro Black SemiCondensed Italic', 'Jameel Noori Nastaleeq', 'Master Of Break', 'Smudger LET', 'Kinnari', 'Apple SD Gothic Neo Light', 'Bellota', 'Helvetica Bold Oblique', 'cmssi17', 'Emmett', 'CabinSketch', 'Songti SC', 'cmex10', 'cmssi10', 'Angiang', 'SF Compact Rounded', 'Meslo LG S Regular for Powerline', 'ItalicT', 'SaiEmbed', 'Museo 900 Regular', 'Heiti TC', 'Futura LT Light Oblique', 'Iowan Old Style Italic', 'VNI-Aptima', 'Gotham Narrow Extra Light', '.VnBodoniH', 'MMVariable Bold', 'MMArrow Bold Italic', 'Fluffy Slacks BTN', 'Gotham Narrow Thin', 'QuickType II Pi', 'lcmssb8', 'ItalicC', 'WP Hebrew David', 'Darlin BTN', 'Skia Extended', 'SF Compact Rounded Light', 'Splash', 'ML-TTSurya', 'Warsaw', 'Noto Sans Ogham', 'DhanshirhiMJ', 'MMa Etc', 'Kunstler Script', 'Brush Script Std Medium', 'Seravek Light Italic', 'Kaiti SC Regular', 'Myriad Pro SemiCondensed Italic', 'Futura Book Italic BT', 'JF Georgian Contrast', 'Songti SC Light', 'AV-Web-Hin1', 'Mudir MT', 'BuiltTitlingRg-Bold', 'Gocong', 'Arial Cyr', 'Corsiva Hebrew', 'Bickham Script Pro Regular', 'VNI-Coronet', 'BlairMdITC TT', 'FML-TTThakazhi', 'ITF Devanagari Marathi Bold', 'Courier MM Screenwriter', 'WenQuanYi Micro Hei', 'Kumudam', 'Stone Sans Sem OS ITC TT Semi', 'WP MultinationalB Roman', 'cmex9', 'Rakesly Bk', 'Times Roman', 'HanziPen SC Regular', 'Press Start 2P', 'Myriad Hebrew', 'Wide Latin', 'Raleway Medium', 'Futura Book', 'American Typewriter Bold', 'Hiragino Kaku Gothic Pro W6', 'MMa Arrow SS', 'HelveticaNeueLT Std Thin', 'HelveticaNeueLT Std Ext', 'KacstPoster', 'HanziPen SC Bold', 'Colbert', 'Proxima Nova Soft Bold', 'Calvin', 'Iowan Old Style Titling', 'MMa VariableF', 'Kozuka Mincho Pro EL', 'MMa VariableD', 'Galeforce BTN', 'MMa VariableB', 'MMa VariableC', 'Minion Pro Medium', 'Damascus Light', 'KacstQurn', 'Raleway SemiBold', 'Book Antiqua Bold Italic', 'Uncial Antiqua', 'Diwani Simple Outline', 'BrahmaputraMJ', 'SWIsot2', 'Gotham Ultra', 'Broadway Copyist', 'Osaka', 'VNI-Vivi', 'Meiryo Bold', 'Segoe WP SemiLight', 'STIX Math', 'SWIsot1', 'VNI-ShellaL', 'STIXIntegralsD-Regular', 'STIXSizeThreeSym-Regular', 'lcmss8', 'Neon Lights', 'Z@R16EB.tmp', 'ML-TTLeelaHeavy', 'ParvathiMedium', 'Clarendon', 'Amethyst', 'EQUIS', 'System Font Black', 'ITF Devanagari Bold', 'Lao Sangam MN', 'PT Serif Bold', 'Snap ITC', 'Inder', 'PT Bold Mirror', 'OCR-B 10 BT', 'MMVariable', 'VANAVIL-Avvaiyar', 'Arial Rounded MT Bold', 'ISOCT2', 'Dosis ExtraBold', 'Chaparral Pro Bold Italic', 'MMTextBookB Bold Italic', 'Times New Roman Symbol', 'VNI-Dom', 'HelveticaNeueLT Pro 95 Blk', 'Baoli SC Regular', 'BurigangaOMJ', 'Avenir Next Condensed Ultra Light Italic', 'Letter Gothic Std', 'JLS Data GothicR  NC', 'Roboto Medium Italic', 'Titillium Bold', 'Bookman Old Style Bold Italic', 'Myriad Pro Semi bold', 'ISOCT3', 'msam10', 'Source Sans Pro Semibold', 'Myriad Pro Semibold SemiCondensed Italic', 'Incised901 NdIt BT', 'DejaVu Sans Light', 'Myriad CAD', 'Light', 'Binhdinh', 'Rachgia', 'HGHeiseiMinchotaiW9', 'ChandrabatiOMJ', '.VnTifani HeavyH', 'System Font Heavy Italic', 'GFS Artemisia', 'WP MultinationalB Helve', 'TAB', '8514oem', 'Hack Bold', 'Athelas Bold', 'ArhialkhanOMJ', 'Calibri Light', 'Hoian', 'Avenir Next W1G Ultra Light', 'Vikatan', 'STKaiti', 'Adobe Hebrew Regular', 'Microsoft PhagsPa', 'Bradley Hand ITC', 'Utopia', 'MMa CenturyS Bold', 'KacstLetter', 'Apple SD Gothic Neo Regular', 'Heiti SC Light', 'ABeeZee', 'Chinyen', 'GB18030 Bitmap', 'Lucida Calligraphy Italic', 'euex10', 'HelveticaNeueLT Std Lt Cn', 'Anonymice Powerline Italic', 'News Gothic MT Alt 2', 'Apple SD Gothic Neo', 'Bell Gothic Std Light', 'MATTEROFFACT', 'Z@R1720.tmp', 'Titillium Bold Upright', 'ENGL', 'Engravers MT', 'Gotham Ultra Italic', 'Didot Italic', 'HelveticaNeueLT Pro 33 ThEx', 'Hot Mustard BTN Poster', 'Farah', 'MMTextBook Bold Italic', 'VNI-Shadow', 'New Gulim', 'MMa CenturyKS Italic', 'GungSeo Regular', 'Droid Sans Mono for Powerline', 'iso 08', 'POLI', 'Nova Slim', 'Hue', 'GothicNo13 BT', 'Proxima Nova Black', 'ML-TTAnjali', 'Caflisch Script Pro', 'Lao MN', 'HP PSG', 'VNI-Heather', 'Gill Sans Nova', 'cht', 'Opus Chords', 'Raleway Bold Italic', 'Informal Roman', 'Junicode', 'IMG Love', 'cmti10', 'Verdana Bold', 'Britannic Bold', 'Saab', 'ADMUI2Lg', 'Superclarendon Black Italic', 'OCR A Std', 'Hot Mustard BTN', 'cmti12', 'Francois One', 'Tsukushi B Round Gothic', 'Literation Mono Powerline', 'MAC C Times', 'Noto Sans Inscriptional Pahlavi', 'Proxima Nova Extrabold', 'Georgia Pro Cond', 'Helvetica Light', 'Remachine Script Personal Use', 'Pump Demi Bold LET', 'DilleniaUPC', 'Gentium Book Basic', 'VNI-Algerian', 'Lato Medium Italic', 'MMArrow', 'Niagara Engraved', 'FML-TTMadhaviExBold', 'SWScrpc', 'STIXSizeFourSym-Regular', 'Nafees Web Naskh', 'JLS Data GothicC  NC', 'TAC-Kambar', 'Century Gothic', 'Microsoft Tai Le Bold', 'SWScrps', 'Proxima Nova Light Italic', 'Tamil MN Bold', 'ML-TTGauri', 'ML-TTGeethika', 'AdineKirnberg', 'Rotis Sans Serif Std 75 Extra Bold', 'AR BERKLEY', 'Farisi', 'Rachana', 'Kerala', 'Chaparral Pro', 'Bubblegum Sans', 'Sasfont', 'System Font Italic', 'WP IconicSymbolsA', 'WP IconicSymbolsB', 'Throw My Hands Up in the Air', 'Sneakerhead BTN', 'CentSchbook BT', 'Incised901 BdCn BT', 'PortagoITC TT', 'HaldaMJ', 'MapInfo Cartographic', 'Belwe Lt BT', 'Kundli', 'Kozuka Mincho Pr6N EL', 'Swis721 Cn BT', 'MMBinary Bold Italic', 'SchoolHouse Printed A', 'VNI-Brush', 'Tsukushi A Round Gothic Regular', 'Vollkorn Bold Italic', 'Kozuka Gothic Pr6N R', 'Vijaya', 'Bodoni Ornaments', 'Futura LT Condensed Light Oblique', 'Nexa Regular Italic', 'KarnaphuliMJ', 'Damascus Bold', 'Gotham Black', 'Kohinoor Bangla', 'Noto Sans Mono CJK JP', 'Constantia Italic', 'ML-TTAshtamudiExBold', 'Angsana New', 'Times Bold', 'Arial Narrow Bold', 'MMa CenturyKSS Italic', 'DhonooMJ', 'Noto Sans Ethiopic', 'HelveticaNeueLT Std Med Ext', 'MMCenturyNewRD Bold', 'Yuppy TC Regular', 'SF Distant Galaxy Alternate', 'PT Sans', 'PingFang HK Ultralight', 'Athelas Italic', 'Sonic XBd BT', 'saxMono', 'Bangla MN Bold', 'Tinos Bold for Powerline', 'ChondanaMJ', 'Yuanti TC Regular', 'HelveticaNeueLT Pro 93 BlkEx', 'FML-TTSugatha', 'Ducmy', 'Germ', 'Padauk', 'YD2002', 'Sitka Subheading', 'Myriad Pro SemiCond', 'FreesiaUPC', 'Myriad Pro SemiExtended Italic', 'WP MathB', 'Noto Sans Buhid', 'Noto Sans Mono CJK TC', 'Noto Sans Inscriptional Parthian', 'msbm6', 'Kefa Regular', 'msbm8', 'msbm9', 'Savoye LET', 'Weibei TC Bold', 'LKLUG', 'FML-TTIndulekha', 'MMTimes Italic', 'Noto Sans Imperial Aramaic', 'VNI-Script', '.VnParkH', 'Noto Sans Old South Arabian', 'Matura MT Script Capitals', 'Kozuka Gothic Pr6N B', 'TitilliumText22L-Medium', 'Euclid Bold Italic', 'Calisto MT Bold', 'Dosis Bold', 'Futura LT Medium', 'FML-TTKanika', 'Kufi Outline Shaded', 'Beirut', 'EXCESS', 'New Peninim MT Bold Inclined', 'Optima', 'Source Sans Pro Italic', '.VnAristote', '.VnTimeH', 'MMa Fermat', 'Tangerine', 'KodchiangUPC', 'Noto Sans Batak', 'eurb8', 'ML-TTPoornima', 'Myriad Web Pro', 'Paralucent Thin Italic', 'Avenir Next Demi Bold', 'msam6', 'MMa Century Italic', 'Ezra SIL', '.VnTime', 'Miama', 'Futura LT Condensed Bold', 'Literation Mono Powerline Bold', 'Myriad Pro Condensed', 'MMa Arrow', 'SimHei', 'FML-TTNandini', 'Kaiti SC', 'SF Compact Rounded Medium', 'KG Primary Penmanship', 'LilyUPC', 'Skia Bold', 'ML-TTMayoori', 'VNI-Tekon', 'Vonique 64', 'Myriad Pro Cond', 'Arial Hebrew Scholar Light', 'Engravers MT Bold', 'Perpetua Italic', 'Arial Greek', 'Noteworthy', 'ML-TTIndulekhaHeavy', 'ISOCTEUR', 'Visitor TT2 BRK', 'Marker Felt', 'cmr17', 'SWAstro', 'LETT', 'AlekyaExtraBold', 'FML-TTYashasri', 'cmr10', 'Gothic720 Lt BT', 'Microdot', '.VnClarendon', 'Book Antiqua Bold', 'HeiT', '.VnAvantH', 'PT Serif Caption Italic', 'Princetown LET', 'Eccentric Std', '8Pin Matrix', 'GangaOMJ', 'Kohinoor Bangla Bold', 'ML-TTJyotsna', 'Hoefler Text Italic', 'Iskoola Pota', 'Bodoni 72 Bold', 'Wingdings', 'Noto Sans Shavian', 'Bahiana', 'Roboto Bold Italic', 'Viner Hand ITC', 'Bauhaus 93', 'VNI-Franko', 'cmbx7', 'cmbx6', 'cmbx5', 'SAPGUI-Icons', 'Charter Italic', 'cmbx9', 'cmbx8', 'Gelfling SF', 'Aileron Black', 'Bookshelf Symbol 1', 'HGPHeiseiKakugothictaiW9', 'FML-TTPooram', 'Raanana', 'OCRA', 'Sanskrit New', 'Khmer UI', 'Cochin', 'Ostrich Sans Rounded', 'TLArabic', 'Latin Modern Mono', 'AG', 'Opus Chords Sans', 'Source Code Pro Bold', 'Source Sans Pro Black Italic', 'BorakMJ', 'Futura Bold', 'Big Caslon', 'Latin Modern Roman Dunhill', 'CAMPBELL', 'Futura Medium Italic', 'FML-TTSuparna', 'Footlight MT Light', 'FML-TTKamini', 'SignPainter', 'Noto Sans Armenian', 'Adobe Caslon Pro Italic', 'Latin Modern Mono Slanted', 'Wawati SC Regular', 'Dayton', 'Roman', 'Newton Phonetic ABBYY', 'MMBinary Italic', 'IMG Travel', 'Helvetica Oblique', 'FELIZ', 'Amiri', 'VNI-Colonna', 'JumunaOMJ', 'DIN Alternate', 'Lohit Devanagari', 'Aileron Thin', 'Tamil MN', 'GhorautraOMJ', 'Bodoni MT Black', 'Wolf in the City', 'FML-TTPoornima', 'Trade Gothic LT Std Bold Extended', 'Complete in Him', 'ITF Devanagari', 'Goudy Stout', 'Diwan Thuluth Regular', '01 Digit', 'TeX Gyre Cursor', 'Playfair Display SC Bold Italic', 'HelveticaNeueLT Std Med Cn', 'Avenir Next Condensed Heavy', 'FrankRuehl', 'Hiragino Sans GB', 'GFS BodoniClassic', 'LightSC', 'Camranh', 'TAM-Kavi', 'Phetsarath OT', 'Symbol', 'High Tower Text', 'Rondalo', 'Miriam', 'Jayanthi', 'MMTextBook Italic', 'Leelawadee UI Semilight', 'OpineHeavy', 'Century Schoolbook Italic', 'Chalkboard SE Regular', 'SWTOR Trajan', 'ML-TTSugatha', 'SF Distant Galaxy Outline', 'Theatre Antoine', 'Heavy Heap', 'ML1-TTIndulekha', 'SFNS Display', 'Nexa Light Italic', 'Linux Biolinum Keyboard O', 'Adobe Devanagari Bold', 'BaluScript', 'Avenir Next Condensed Regular', 'ARDS1', 'cmssqi8', 'Tempus Sans ITC', 'Avenir Next Medium', 'GungsuhChe', 'ChondanaOMJ', 'B095', 'Borealis', 'Seravek ExtraLight Italic', 'Avenir Next Heavy Italic', 'Tamil Sangam MN Bold', 'HelveticaNeue', 'Tsukushi A Round Gothic Bold', 'VNI-Helve-Condense', 'FML-TTAnakha', 'Hiragino Kaku Gothic StdN W8', '.VnMonotype corsiva', 'MMa VariableF S', 'Nightclub BTN', 'Berling', 'MMa VariableB SS', 'Z@R11F8.tmp', 'Suruma', 'Telugu MN', 'Linux Libertine O', 'Italianate', 'Raleway Italic', 'Span', 'ML-TTKeerthi', 'MMa Pascal', 'VNI-Scribble', 'Indie Flower', 'Avenir Next Condensed Demi Bold Italic', 'ML-TTVisakham', 'Arno Pro Caption', 'Qaskin White Personal Use', 'MMTextBookB', 'Al Tarikh', 'Berkshire Swash', 'Hobo Std Medium', 'DINPro-Regular', 'Circular Std Black Italic', 'Muna Bold', 'TechnicBold', 'SWMono', 'Sukhumvit Set Bold', 'Palatino Linotype Bold Italic', '.VnCentury SchoolbookH', 'Euclid Math Two Bold', 'Creepygirl', 'ISOCP3', 'Source Sans Pro Black', 'MMa Relation', 'Futura LT Condensed Medium', 'BongshaiOMJ', 'VNI Aptima', 'Californian FB', 'Leitura Display Swashes', 'Gotham Narrow Ultra Italic', 'Math2Mono', 'Swis721 BdOul BT', 'Clubland', 'English157 BT', 'modstmary10', 'eurm9', 'euex8', 'Diavlo Medium', 'Iowan Old Style Black Italic', 'MMa GreekS', 'Adobe Garamond Pro', 'Cordia New Bold', 'PRETEXT', 'DengXian', 'University Roman LET', 'Open Sans Semibold', 'Soho Gothic Pro Ultra', 'Futura Extra Bold Oblique', 'Roboto Condensed Light Italic', 'Tamil-Aiswarya', 'ML-TTNandini', 'Showcard Gothic', 'Avenir Next Ultra Light Italic', 'Trade Gothic LT Std Bold Condensed No. 20', 'DFKai-SB', 'FML-TTAshtamudi', 'Ostrich Sans Dashed', 'Copperplate', 'Myriad Pro Semibold SemiExtended', 'NewRocker', 'DIN-MediumAlternate', 'Arimo Bold', 'Arial Hebrew', 'TLPashto', 'Gauge', 'Gotham Bold Italic', 'MMVariable2 Bold', 'FFF Tusj', '.VnHelvetInsH', 'Embassy BT', 'MMSchoolRD Italic', 'Bodoni MT Condensed', 'Myriad Pro Semibold', 'CityBlueprint', '.VnGothic', 'Source Code Pro Black', 'Futura Light', 'Baamini', 'Palatino Italic', 'GulimChe', 'SF Distant Galaxy AltOutline', 'Gotham Light', 'AcmeFont', 'Trade Gothic LT Std Bold Condensed No. 20 Oblique', 'DIN-Medium', 'Terminator Real NFI', 'Letter Gothic Std Bold Slanted', 'Gill Sans Light Italic', 'YuMincho Medium', 'Myriad Pro Light Condensed Italic', 'Myriad Pro Black Condensed Italic', 'Osaka-Mono', 'Bodoni 72 Oldstyle', 'Josefin Slab', 'Gurmukhi MN', 'Gauge Heavy', 'Haxton Logos TT', 'Perpetua', 'BhairabMJ', 'Fences', 'Gurmukhi MT', 'Good Times', 'MMa Extra S', 'Benguiat', 'DINPro-Medium', 'MMa Variable2 SS', 'Oswald Stencil', 'Apple Braille', 'HelveticaNeueLT Std Blk Ext', 'Noteworthy Light', 'Scruff LET', 'DIN-BlackAlternate', 'Letter Gothic Std Medium', 'Adobe Pi Std', 'Kozuka Mincho Pr6N', 'Menlo Regular', 'Almonte Snow', 'Belfast Heavy SF', 'Kaiti SC Bold', 'AR CHRISTY', 'VNI-Lydi', 'Cantarell Bold Oblique', 'Gentium', 'Bevan', 'Quicksand Light Regular', 'JLS Space GothicC  NC', 'True Lies', 'STIXVariants', 'MMa TextBook Bold', 'Segoe UI Black', 'Noto Sans Malayalam', 'eurb10', 'Averia Serif', 'Candy Round BTN Cond', 'ML-TTBeckalBold', 'Bariol Regular', 'Avenir Medium Oblique', 'Kohinoor Bangla Semibold', 'Helvetica Neue Bold', 'Broadway', 'ML-TTAmbili', 'Imprint MT Shadow', 'Noto Sans Mono CJK KR', 'cmfi10', 'UnitedStates', 'ML-NILA07', 'Chandas', 'Coolsville', 'Script', 'Franklin Gothic Demi', 'HelveticaNeueLT Pro 63 MdEx', 'Yuanti SC Light', 'FML-TTLeelaHeavy', 'Prisoner SF', 'Times New Roman CYR', 'News Gothic MT Alt 6', 'Bodoni 72 Book Italic', 'Shree-Kan-0853', 'Letter Gothic Std Bold', 'Rekha', 'Akhbar MT', 'DecoType Naskh Regular', 'Segoe Print', 'Gunplay', 'Nadeem Regular', 'Accanthis ADF Std', 'Roboto Condensed Bold', 'Adobe Caslon Pro Bold Italic', 'Helvetica Neue Bold Italic', 'Tlwg Typist', 'SF Compact Rounded Thin', 'Swiss 721 Bold BT', 'Jwala', 'Capitals', 'GFS Theokritos', 'cmr8', 'cmr9', 'cmr6', 'cmr7', 'SWGrekc', 'Timeless', 'w01', 'Microsoft Himalaya', 'Digifit', 'Minion Pro Med', 'Simple Outline Pat', 'MMa Negate Bold', 'Linden Hill', 'Courier New (Arabic)', 'Sauce Code Powerline Black', 'Noto Sans Gothic', 'Adobe Kaiti Std', 'AV-Web-Tam1', 'Athelas Regular', 'FML-TTMangalaExBold', 'Rockwell Bold Italic', 'Visitor TT1 BRK', 'Brandish', 'Futura LT Condensed Extra Bold Oblique', 'Manorly', 'Gotham Narrow Light', 'MS Outlook', 'cmti8', 'DejaVu Serif', 'Allura', 'Kailasa', 'Source Sans Pro Light', 'Burst My Bubble', 'ISOCT', 'Hannotate SC', 'ISOCP', 'Greek Diner Inline TT', 'Paralucent Thin', 'BuiltTitlingRg-Regular', 'Calligraphic', 'SF Slapstick Comic Bold Oblique', 'Soho Gothic Pro Light Italic', 'Euclid Extra', 'Sauce Code Powerline Light', 'Courier New Greek', 'Noto Sans Georgian', 'PT Sans Italic', 'Cousine Bold Italic for Powerline', 'Modern No. 20', 'VNI-Goudy', 'Math3Mono', 'Georgia Italic', 'Luna Bar', 'VNI-Bragga', 'Sawasdee', 'TAMLKamban', 'Paralucent Bold Italic', 'PingFang TC', 'Valken', 'MMCenturyNewRD', 'Meera', 'Saint Andrew des Kiwis', 'Courier Bold Oblique', 'Diavlo Light', 'HGSMinchoL', 'Diwani Bent', 'MMa VariableD Bold', 'Courier New Italic', 'Aileron UltraLight', 'Chess Merida', 'cmsl8', 'Snell Roundhand Black', 'Candara Bold', 'Grafolita Script Medium', 'Diwani Letter', 'Paralucent Bold', 'Adobe Devanagari Italic', 'VNI-Linus', 'cmss12', 'eusm10', 'Avenir Next W1G Light Italic', 'Seravek ExtraLight', 'Magneto', 'Interstate-Black', 'SignPainter-HouseScript', 'Euclid Extra Bold', 'System Font Medium Italic P4', 'TtsNote', 'Quicksand Book Oblique Regular', 'TAMILFIX', 'Industrial736 BT', 'Adobe Arabic Bold', 'InaiMathi', 'Tera Special', 'Myriad Pro Light SemiExtended Italic', 'NanumGothic Bold', 'MMTextBookB Bold', 'JaJaDiOMJ', 'Nimbus Mono L', 'Futura Std Bold', 'Finale Numerics', 'Moon Flower Bold', 'Baskerville', 'Lucida Console', 'Swis721 Lt BT', 'Mael', 'Nexa Heavy Italic', 'Becky', 'ML-TTKaumudi', 'TAU-Kabilar', 'MMa CenturyS Bold Italic', 'Violetta', 'Bell MT Bold', 'Palatino Linotype Italic', 'FML-TTNila', 'FML-Karthika', 'Rotis Sans Serif Std 65 Bold', 'PenultimateLight', 'VNI-Revue', 'Liberation Mono', 'Trade Gothic LT Std Bold No. 2 Oblique', 'GFS Didot', 'Eras Medium ITC', '.VnBlackH', 'MMa Binary SS', 'ML-TTSabari', 'Bangla Sangam MN Bold', 'Stencil', 'AppleMyungjo', 'TM-TTValluvar', 'Gill Sans Ultra Bold Condensed', 'type 07', 'Yu Gothic UI Semibold', 'KN-TTUma', 'Playfair Display', 'Txt', 'Gotham Narrow Light Italic', 'Menlo', 'Zirkon', 'AV-Font-Sin', 'Microsoft Sans Serif', 'Tall Boy West', 'Yu Gothic', 'AMGDT', 'Simplified Arabic Fixed', 'STSong', 'Arimo for Powerline', 'Bell MT', 'KufiStandardGK', 'Nexa Bold', 'TG Pagella Math', 'Adobe Arabic Regular', 'Futura Extra Bold', 'SamsungImagination', 'Mycalc', 'MMa CenturyKSS Bold Italic', 'Superclarendon Black', 'Catull', 'HYSWLongFangSong', 'cmsy10', 'FML-TTAyilyamBold', 'Rakesly Lt', 'Haettenschweiler', 'SF Compact Rounded Heavy', 'Beatnik SF', 'Trajan Pro', 'Sosa Regular', 'Adobe Song Std', 'Raleway Bold', 'Bauer Bodoni Std 1 Italic', 'DholeshwariOMJ', 'VNI-StencilU', 'Kefa', 'STXihei', 'Garamond Bold', 'Trajan Pro Bold', 'Reklame Script Medium', 'AGA Arabesque Desktop', 'Savoye LET Plain', 'BATAVIA', 'Fabrica', 'Gidole', 'Abril Fatface Regular', 'Baskerville SemiBold', 'Gill Sans SemiBold Italic', 'Hombre', 'Helvetica Neue', 'STIXIntegralsUpSm-Bold', 'Vogue', 'Noto Sans Kayah Li', 'Noto Sans Lydian', 'Avenir Next Bold', 'Myriad Pro Light SemiExt', 'VNI-Bodon', 'Estrangelo Edessa', 'Titillium Semibold Upright', 'Kingthings Versalis', 'Droid Sans Mono Slashed for Powerline', 'Patrick Hand SC', '.VnLinusH', 'Galatia SIL', 'Myanmar MN Bold', 'Anonymice Powerline Bold Italic', 'STIXNonUnicode-BoldItalic', 'IMG Seasons', 'KaiTi', 'NEOLITH', 'MS Reference Sans Serif', 'GFS Baskerville', 'PingFang HK', 'Adobe Garamond Pro Italic', 'OCR B MT', 'Bariol Regular Italic', 'Minion Pro Bold', 'Nexa XBold', 'AppleGothic Regular', '.VnMemorandumH', 'HelveticaNeue BlackCond', 'Small Fonts', 'Myriad Pro Italic', 'Symath', 'Times New Roman Baltic', 'Spicy Rice', 'FML-TTMayoori', 'Wingdings 3', 'Wingdings 2', 'Zapf Dingbats', 'Rockwell Bold', 'JomunaMJ', 'Forte', 'Mona Lisa Solid ITC TT', 'FML-TTDevika', 'Gill Sans Nova Cond XBd', 'Lucida Calligraphy', 'HelveticaNeueLT Std UltLt', 'Palatino', 'HanziPen TC', 'Courier New Cyr', 'Seville', 'SF Compact Rounded Black', 'Colonna MT', 'HelveticaNeueLT Std ExtBlk Cn', 'Arial Hebrew Light', 'Canterbury Regular', 'Ital', 'Tekton Pro Ext', 'Dosis ExtraLight', 'Mshtakan BoldOblique', 'New Athena Unicode', 'Ubuntu Condensed', 'SansSerif', 'Century Gothic Bold', 'Nueva Std Cond', 'Malgun Gothic', 'STIXGeneral-Italic', 'Arial Nova Cond Light', 'Tinos for Powerline', 'CSD16', 'PFDaVinciScriptPro-Regular', 'KalindiSMJ', 'MMTimes Bold Italic', 'ML-TTSankara', 'JazzTextExtended', 'Courier MM Screenwriter Bold', 'Minion Pro', 'Calibri Bold Italic', 'Merriweather Light', 'FreeSerif', 'Old English Text MT', 'System Font Bold Italic', 'Baron Neue Black Italic', 'Avenir Next W1G Demi', 'Finale Mallets', 'Circular Std Bold Italic', 'Wawati TC Regular', 'Tinos Italic for Powerline', 'Trade Gothic LT Std Condensed No. 18', 'Paralucent Medium Italic', 'Cumberland AMT', 'VNI Laos', 'Camau', 'Eras Light ITC', 'Segoe UI Symbol', 'Aleo', 'DIN 1451 Mittelschrift', 'VNI-Chaucer', 'Cuulong', '.VnMystical', 'Nexa Heavy', 'Kohinoor Devanagari Regular', 'HolidayPi BT', 'Jokerman LET', 'Salina', 'Arial monospaced for SAP', 'MMa Century', 'Baskerville SemiBold Italic', 'MMa GreekS Italic', 'Lapidary333 Blk BT', 'Lucida Handwriting', 'Adobe Myungjo Std', 'Alfredo', 'Dot-Matrix', 'Thanhoa', 'cmr12', 'Adobe Fangsong Std', 'BatangChe', 'Academy Engraved LET Plain:1.0', 'Calligraph421 BT', 'DejaVu Serif Condensed', 'SWItal', 'Futura LT Book Oblique', 'Noto Sans Lycian', 'Noto Sans Phags Pa', 'SF Compact Text', 'MAXIMO', 'Avanti', 'Adobe Caslon Pro Bold', 'Space Bd BT', 'November', 'Lavanderia', 'Maiandra GD', 'at most sphere', 'Farisi Regular', 'Gill Sans Nova Cond Lt', 'Razer Text Regular', 'VNI-Auchon', 'Myriad Pro Black SemiExt', 'KacstOne', 'Cordia New', 'Gotham Thin Italic', 'Raleway Black', 'Hiragino Sans W9', 'Hiragino Sans W8', 'MoolBoran', 'Penultimate', 'Hiragino Sans W5', 'Hiragino Sans W4', 'Hiragino Sans W7', 'Hiragino Sans W6', 'Hiragino Sans W1', 'Hiragino Sans W0', 'Hiragino Sans W3', 'Hiragino Sans W2', 'Minion Pro Italic', 'Kozuka Mincho Pr6N M', 'Kozuka Mincho Pr6N L', 'Proxima Nova Condensed Semibold Italic', 'Kozuka Mincho Pr6N H', 'Hiragino Maru Gothic ProN W4', 'HelveticaNeueLT Std Extended', 'NanumBarunGothic', 'Kozuka Mincho Pr6N B', 'VNI Russia', 'Reklame Script Bold', 'ML-TTThakazhi', 'MMSchoolRD', 'Futura Std Light', 'Poplar Std', 'Kozuka Mincho Pr6N R', 'Franklin Gothic', 'Paralucent Light', 'ML-TTVaisali', 'cmb10', 'Waseem Light', 'VNI-Cooper', 'Script MT Bold', 'Ethnocentric', 'STIXSizeFourSym', 'Praveen', 'Calibri Bold', 'ML-TTYashasri', 'Swis721 LtCn BT', 'Freestyle Script', 'Snowdrift', 'Myriad Pro Semibold SemiExtended Italic', 'LiSong Pro', 'Myanmar Sangam MN Bold', 'MMCenturyOldGreek Bold', 'VNI-Broad', 'YuGothic', 'American Typewriter Semibold', 'Hannotate SC Bold', 'Opus Ornaments', 'Arimo Italic', 'RamuBrush', 'TechnicLite', 'Geneva', 'Nexa Book', 'FML-IndulekhaHeavy', 'Arimo Bold for Powerline', 'Marion Bold', 'Apple Braille Outline 6 Dot', 'FML-TTBhavana', 'Nanum Myeongjo', 'PT Sans Caption Bold', 'Gotham Medium Italic', 'Vani', 'Quicksand Italic', 'Z@R195D.tmp', 'Soho Gothic Pro Bold Italic', 'Hannotate TC', 'ITF Devanagari Book', 'Cracked Johnnie', 'Rockwell Nova Light', 'HGPMinchoL', 'STIXNonUnicode-Bold', 'VNI-Arial Rounded', 'Braggadocio', 'Swiss921 BT', 'Futura', 'Museo 300 Regular', 'Adobe Arabic Italic', 'Trade Gothic LT Std', 'Titillium Bold Italic', 'VNI-Juni', 'Myriad Pro Bold SemiCondensed Italic', 'SWGamekeys MT', 'Plantagenet Cherokee', 'Comfortaa', 'Baron Neue Black', 'Latin Modern Mono Prop Light', 'Crystal', 'RamuScript', 'SAPDings', 'RadhaBold', 'Superclarendon Bold Italic', 'Libel Suit', 'Sneakerhead BTN Outline', '.VnLincoln', 'MMTextBook', 'Gujarati MT', 'KacstScreen', 'MMEtc Bold Italic', 'Dosis SemiBold'];

	var cross_list = {
		timezone: 'Time Zone',
		cpu_cores: 'Number of Cpu Cores',
		fonts: 'Detected Fonts',
		audio: 'Audio',
		ratio: 'Screen Ratio',
		depth: 'Screen Depth',
		langsdetected: 'Detected Supported Languages (Buggy and not finished)',
		// gpuimgs: 'Hash Value of GPU Rendering Results'
	}
	var cnted_list = {
		timezone: 'Time Zone',
		fonts: 'Detected Fonts'
	}
	var gpu_hashes = [
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27
	]
	var show_list = {
		gpuimgs: 'Hash Value of GPU Rendering Results (partially cross_browser)',
		WebGL: 'WebGL',
		timezone: 'Time Zone',
		adblock: 'Ad Block',
		agent: 'Agent',
		audio: 'Audio',
		depth: 'Screen Depth',
		ratio: 'Screen Ratio',
		canvas_test: 'Canvas Test',
		cookie: 'Cookie Enabled',
		cpu_cores: 'Number of Cpu Cores',
		encoding: 'Encoding',
		fonts: 'Detected Fonts',
		gpu: 'GPU',
		language: 'Language',
		langsdetected: 'Detected Supported Languages (Buggy and not finished)',
		plugins: 'Plugins'
	};
	var gpu_imgs_name = [
		"Cube Test",
		"AA_Cube Test",
		"Camera Test",
		"Curve Test",
		"AA_Curve Test",
		"Texture Test",
		"Two Models",
		"Light Test",
		"Light Test to Two Models",
		"Two Lights to Two Models",
		"AA_Two Lights to Two Models",
		"Rotation Test",
		"Two Lights, Textures, Models",
		"Transparent Test 0",
		"Transparent Test 1",
		"Transparent Test 2",
		"Transparent Test 3",
		"Transparent Test 4",
		"Transparent Test 5",
		"Transparent Test 6",
		"Transparent Test 7",
		"AA_Complex Light Test",
		"Complex Light Test",
		"Clipping Test",
		"Bubble Test",
		"Compressed Texture Test",
		"Shadow Test",
		""
	];
	var language_names = [
		"Latin",
		"Chinese",
		"Arabic",
		"Devanagari",
		"Cyrillic",
		"Bengali/Assamese",
		"Kana",
		"Gurmukhi",
		"Javanese",
		"Hangul",
		"Telugu",
		"Tamil",
		"Malayalam",
		"Burmese",
		"Thai",
		"Sundanese",
		"Kannada",
		"Gujarati",
		"Lao",
		"Odia",
		"Ge-ez",
		"Sinhala",
		"Armenian",
		"Khmer",
		"Greek",
		"Lontara",
		"Hebrew",
		"Tibetan",
		"Georgian",
		"Modern Yi",
		"Mongolian",
		"Tifinagh",
		"Syriac",
		"Thaana",
		"Inuktitut",
		"Cherokee"
	];
	var language_codes = [
		[76, 97, 116, 105, 110],
		[27721, 23383],
		[1575, 1604, 1593, 1585, 1576, 1610, 1577],
		[2342, 2375, 2357, 2344, 2366, 2327, 2352, 2368],
		[1050, 1080, 1088, 1080, 1083, 1080, 1094, 1072],
		[2476, 2494, 2434, 2482, 2494, 32, 47, 32, 2437, 2488, 2478, 2496, 2479, 2492, 2494],
		[20206, 21517],
		[2583, 2625, 2608, 2606, 2625, 2582, 2624],
		[43415, 43438],
		[54620, 44544],
		[3108, 3142, 3122, 3137, 3095, 3137],
		[2980, 2990, 3007, 2996, 3021],
		[3374, 3378, 3375, 3390, 3379, 3330],
		[4121, 4156, 4116, 4154, 4121, 4140],
		[3652, 3607, 3618],
		[7070, 7077, 7060, 7082, 7059],
		[3221, 3240, 3277, 3240, 3233],
		[2711, 2753, 2716, 2736, 2750, 2724, 2752],
		[3749, 3762, 3751],
		[2825, 2852, 2893, 2837, 2867],
		[4877, 4821, 4829],
		[3523, 3538, 3458, 3524, 3517],
		[1344, 1377, 1397, 1400, 1409],
		[6017, 6098, 6040, 6082, 6042],
		[917, 955, 955, 951, 957, 953, 954, 972],
		[6674, 6682, 6664, 6673],
		[1488, 1500, 1508, 1489, 1497, 1514],
		[3926, 3964, 3921, 3851],
		[4325, 4304, 4320, 4311, 4323, 4314, 4312],
		[41352, 41760],
		[6190, 6179, 6185, 6189, 6179, 6191],
		[11612, 11593, 11580, 11593, 11599, 11568, 11606],
		[1808, 1834, 1825, 1821, 1808],
		[1931, 1960, 1928, 1964, 1920, 1960],
		[5123, 5316, 5251, 5198, 5200, 5222],
		[5091, 5043, 5033],
	];

	_GP.trans_data = {};

	function getFontsString(indexes) {
		var value = "";
		var cnt = 0;
		for (var index in indexes) {
			v = indexes[index]; //get every single value of font
			if (v == '1') {
				if (cnt < 10)
					value += '"' + font_list[cnt] + '" ';
				cnt++;
			}
		}
		value += "(" + cnt + " fonts detected)";
		return value;
	}

	function gen_code() {
		res = "";
		for (var feature in show_list) {
			label = 'box_' + feature;
			if (document.getElementById(label).checked) {
				res += _GP.trans_data[feature];
			}
		}

		//this part is used for generate the hash values
		gpu_hash = 0;
		for (gpu_hash in gpu_hashes) {
			label = 'box_' + gpu_hash;
			if (document.getElementById(label).checked) {
				res += _GP.trans_data['gpu_hashes'][gpu_hash];
			}
		}
	}

	function getGPUTable(hashes) {
		res = "<table border='0' id='gputable' class='gpu_table'><tr>";
		var cur = 0;
		var checked = 'checked';
		for (hash in hashes) {
			if (hash >= 1) checked = '';
			res += "<td><label width = '30px'><input id='box_" + hash + "' type='checkbox' " + checked + " onclick='gen_code();'/> " + gpu_imgs_name[hash] + "(" + hashes[hash] + ")</label></td>";
			if (cur++ % 3 == 2)
				res += "</tr><tr>";
		}
		res += "</tr></table>";
		return res;
	}

	function getGPUString() {
		var hashes = {};
		value = _GP.trans_data['gpuimgs'].split(',');
		for (hash in value) {
			cur = value[hash].split('_');
			hashes[cur[0]] = cur[1];
		}
		_GP.trans_data['gpu_hashes'] = hashes;
		value = getGPUTable(hashes);
		return value;
	}

	function getLangsString(sup) {
		res = "<table border='0' class='gpu_table'><tr>";
		for (var s in sup) {
			res += "<td>" + sup[s] + " (";
			index = language_names.indexOf(sup[s]);
			for (var c in language_codes[index]) {
				res += "&#" + language_codes[index][c];
			}
			res += ")</td>"
			if (s % 4 == 3)
				res += "</tr><tr>";
		}
		res += "</tr></table>";
		return res;
	}

	function getTable(name) {
		if (name == "fonts") return getFontsString(_GP.trans_data[name]);
		if (name == "gpuimgs") return getGPUString(_GP.trans_data[name]);
		if (name == "langsdetected") return getLangsString(_GP.trans_data[name].split('_'));
		return _GP.trans_data[name];
	}

	function buildTable(data) {
		_GP.trans_data = data;
		var list = data['resolution'].split('_');
		_GP.trans_data['ratio'] = Math.round(list[0] / list[1] * 100) / 100;
		data['ratio'] = _GP.trans_data['ratio'];
		data['depth'] = list[5];//data['resolution'];

		//If CPU core is not detected, N/A
		if (data['cpu_cores'] == -1 || data['cpu_cores'] == '-1') { //here we can also use == '-1'
			data['cpu_cores'] = 'N/A';
		}

		//convert timezone to a better way
		var timezone = parseInt(data['timezone']);
		var base;
		if (timezone > 0) base = 'UTC-';
		else base = 'UTC+';
		data['timezone'] = 'UTC-' + (timezone / 60).toString();

		$('#result_table').append('<tr><td class = "checkbox"></td><td>Feature</td><td class = "value">Value</td></tr>');
		//$('#result_table').append('<tr><td colspan="3" class = "type">Cross-browser Features</td></tr>');


		for (var cross in cross_list) {
			if (cross in data) {
				value = getTable(cross);
				$('#result_table').append('<tr><td class = "checkbox"> <input id="box_' + cross + '"type="checkbox" onclick="gen_code();" checked></td><td class = "feature">' + cross_list[cross] + '</td><td class = "value">' + value + '</td></tr>');
			}
		}

		// $('#result_table').append('<tr><td colspan="3" class = "type">Features do not recommend for cross_browser</td></tr>');

		for (var feature in show_list) {
			//pass all the cross browser features
			if (feature in cross_list)
				continue;
			if (feature in data) {
				value = getTable(feature);
				$('#result_table').append('<tr><td class = "checkbox"><input id="box_' + feature + '" type="checkbox" onclick="gen_code();"></td><td class = "feature">' + show_list[feature] + '</td><td class = "value">' + value + '</td></tr>');
			}
		}

		//disable the GPU img hashes
		document.getElementById('box_gpuimgs').disabled = "disabled;";
	}


	function getDetails() {
		ip_address = "sec.uniquemachine.org/uniquemachine"
		//ip_address = "aws.songli.us:5000"
		var ID = window.location.href.split("?")[1];
		$("#cur_fingerprint").html("Current Fingerprint: " + ID);

		$.ajax({
			url: "http://" + ip_address + "/details",
			dataType: "json",
			contentType: 'application/json',
			type: 'POST',
			data: JSON.stringify({ "ID": ID }),
			success: function (data) {
				buildTable(data);
			},
			error: function (xhr, ajaxOptions, thrownError) {
				//alert(thrownError);
			}
		});
	}

	!function (n) { "use strict"; function t(n, t) { var r = (65535 & n) + (65535 & t), e = (n >> 16) + (t >> 16) + (r >> 16); return e << 16 | 65535 & r } function r(n, t) { return n << t | n >>> 32 - t } function e(n, e, o, u, c, f) { return t(r(t(t(e, n), t(u, f)), c), o) } function o(n, t, r, o, u, c, f) { return e(t & r | ~t & o, n, t, u, c, f) } function u(n, t, r, o, u, c, f) { return e(t & o | r & ~o, n, t, u, c, f) } function c(n, t, r, o, u, c, f) { return e(t ^ r ^ o, n, t, u, c, f) } function f(n, t, r, o, u, c, f) { return e(r ^ (t | ~o), n, t, u, c, f) } function i(n, r) { n[r >> 5] |= 128 << r % 32, n[(r + 64 >>> 9 << 4) + 14] = r; var e, i, a, h, d, l = 1732584193, g = -271733879, v = -1732584194, m = 271733878; for (e = 0; e < n.length; e += 16)i = l, a = g, h = v, d = m, l = o(l, g, v, m, n[e], 7, -680876936), m = o(m, l, g, v, n[e + 1], 12, -389564586), v = o(v, m, l, g, n[e + 2], 17, 606105819), g = o(g, v, m, l, n[e + 3], 22, -1044525330), l = o(l, g, v, m, n[e + 4], 7, -176418897), m = o(m, l, g, v, n[e + 5], 12, 1200080426), v = o(v, m, l, g, n[e + 6], 17, -1473231341), g = o(g, v, m, l, n[e + 7], 22, -45705983), l = o(l, g, v, m, n[e + 8], 7, 1770035416), m = o(m, l, g, v, n[e + 9], 12, -1958414417), v = o(v, m, l, g, n[e + 10], 17, -42063), g = o(g, v, m, l, n[e + 11], 22, -1990404162), l = o(l, g, v, m, n[e + 12], 7, 1804603682), m = o(m, l, g, v, n[e + 13], 12, -40341101), v = o(v, m, l, g, n[e + 14], 17, -1502002290), g = o(g, v, m, l, n[e + 15], 22, 1236535329), l = u(l, g, v, m, n[e + 1], 5, -165796510), m = u(m, l, g, v, n[e + 6], 9, -1069501632), v = u(v, m, l, g, n[e + 11], 14, 643717713), g = u(g, v, m, l, n[e], 20, -373897302), l = u(l, g, v, m, n[e + 5], 5, -701558691), m = u(m, l, g, v, n[e + 10], 9, 38016083), v = u(v, m, l, g, n[e + 15], 14, -660478335), g = u(g, v, m, l, n[e + 4], 20, -405537848), l = u(l, g, v, m, n[e + 9], 5, 568446438), m = u(m, l, g, v, n[e + 14], 9, -1019803690), v = u(v, m, l, g, n[e + 3], 14, -187363961), g = u(g, v, m, l, n[e + 8], 20, 1163531501), l = u(l, g, v, m, n[e + 13], 5, -1444681467), m = u(m, l, g, v, n[e + 2], 9, -51403784), v = u(v, m, l, g, n[e + 7], 14, 1735328473), g = u(g, v, m, l, n[e + 12], 20, -1926607734), l = c(l, g, v, m, n[e + 5], 4, -378558), m = c(m, l, g, v, n[e + 8], 11, -2022574463), v = c(v, m, l, g, n[e + 11], 16, 1839030562), g = c(g, v, m, l, n[e + 14], 23, -35309556), l = c(l, g, v, m, n[e + 1], 4, -1530992060), m = c(m, l, g, v, n[e + 4], 11, 1272893353), v = c(v, m, l, g, n[e + 7], 16, -155497632), g = c(g, v, m, l, n[e + 10], 23, -1094730640), l = c(l, g, v, m, n[e + 13], 4, 681279174), m = c(m, l, g, v, n[e], 11, -358537222), v = c(v, m, l, g, n[e + 3], 16, -722521979), g = c(g, v, m, l, n[e + 6], 23, 76029189), l = c(l, g, v, m, n[e + 9], 4, -640364487), m = c(m, l, g, v, n[e + 12], 11, -421815835), v = c(v, m, l, g, n[e + 15], 16, 530742520), g = c(g, v, m, l, n[e + 2], 23, -995338651), l = f(l, g, v, m, n[e], 6, -198630844), m = f(m, l, g, v, n[e + 7], 10, 1126891415), v = f(v, m, l, g, n[e + 14], 15, -1416354905), g = f(g, v, m, l, n[e + 5], 21, -57434055), l = f(l, g, v, m, n[e + 12], 6, 1700485571), m = f(m, l, g, v, n[e + 3], 10, -1894986606), v = f(v, m, l, g, n[e + 10], 15, -1051523), g = f(g, v, m, l, n[e + 1], 21, -2054922799), l = f(l, g, v, m, n[e + 8], 6, 1873313359), m = f(m, l, g, v, n[e + 15], 10, -30611744), v = f(v, m, l, g, n[e + 6], 15, -1560198380), g = f(g, v, m, l, n[e + 13], 21, 1309151649), l = f(l, g, v, m, n[e + 4], 6, -145523070), m = f(m, l, g, v, n[e + 11], 10, -1120210379), v = f(v, m, l, g, n[e + 2], 15, 718787259), g = f(g, v, m, l, n[e + 9], 21, -343485551), l = t(l, i), g = t(g, a), v = t(v, h), m = t(m, d); return [l, g, v, m] } function a(n) { var t, r = "", e = 32 * n.length; for (t = 0; t < e; t += 8)r += String.fromCharCode(n[t >> 5] >>> t % 32 & 255); return r } function h(n) { var t, r = []; for (r[(n.length >> 2) - 1] = void 0, t = 0; t < r.length; t += 1)r[t] = 0; var e = 8 * n.length; for (t = 0; t < e; t += 8)r[t >> 5] |= (255 & n.charCodeAt(t / 8)) << t % 32; return r } function d(n) { return a(i(h(n), 8 * n.length)) } function l(n, t) { var r, e, o = h(n), u = [], c = []; for (u[15] = c[15] = void 0, o.length > 16 && (o = i(o, 8 * n.length)), r = 0; r < 16; r += 1)u[r] = 909522486 ^ o[r], c[r] = 1549556828 ^ o[r]; return e = i(u.concat(h(t)), 512 + 8 * t.length), a(i(c.concat(e), 640)) } function g(n) { var t, r, e = "0123456789abcdef", o = ""; for (r = 0; r < n.length; r += 1)t = n.charCodeAt(r), o += e.charAt(t >>> 4 & 15) + e.charAt(15 & t); return o } function v(n) { return unescape(encodeURIComponent(n)) } function m(n) { return d(v(n)) } function p(n) { return g(m(n)) } function s(n, t) { return l(v(n), v(t)) } function C(n, t) { return g(s(n, t)) } function A(n, t, r) { return t ? r ? s(t, n) : C(t, n) : r ? m(n) : p(n) } "function" == typeof define && define.amd ? define(function () { return A }) : "object" == typeof module && module.exports ? module.exports = A : n.md5 = A }(this);
	//# sourceMappingURL=md5.min.js.map
	/***
	* This test uses multiple moving lights of different colors that illuminate
	* a sceen of 5000 metalic rings.  The color and texture of the rings is
	* calculated by the GPU as opposed to loading in a image.  We run this test
	* twice, once with anti-aliasing and once without it
	***/

	var LightingTest = function () {
		this.IDs = _GP.sender.getIDs(2);
		if (!Detector.webgl)
			Detector.addGetWebGLMessage();

		var camera, scene, renderer, light1, light2, light3, light4, light5, light6;

		var FAR = 300;

		Math.seedrandom("Three.js lighting renderer seed");
		init();

		this.begin = function (canvas, cb) { run(canvas, cb, true, this.IDs[0]); };
		function run(canvas, cb, anti, ID) {
			// RENDERER
			//
			var gl;
			if (anti) {
				gl = _GP.getGLAA(_GP.getCanvas("can_aa"));
			} else {
				gl = _GP.getGL(canvas);
			}

			renderer = new THREE.WebGLRenderer({ context: gl, canvas: canvas }, false);

			renderer.setClearColor(scene.fog.color);
			renderer.setPixelRatio(1);
			renderer.setSize(canvas.width, canvas.height);

			renderer.gammaInput = true;
			renderer.gammaOutput = true;

			var freq = 0.035;
			var level = 45;
			var distance = 75;
			var frame;
			function animate() {

				frame = requestAnimationFrame(animate);

				render();
			}
			function render() {
				var time = freq * level;
				light1.position.x = Math.sin(time * 0.7) * distance;
				light1.position.z = Math.cos(time * 0.3) * distance;

				light2.position.x = Math.cos(time * 0.3) * distance;
				light2.position.z = Math.sin(time * 0.7) * distance;

				light3.position.x = Math.sin(time * 0.7) * distance;
				light3.position.z = Math.sin(time * 0.5) * distance;

				light4.position.x = Math.sin(time * 0.3) * distance;
				light4.position.z = Math.sin(time * 0.5) * distance;

				light5.position.x = Math.cos(time * 0.3) * distance;
				light5.position.z = Math.sin(time * 0.5) * distance;

				light6.position.x = Math.cos(time * 0.7) * distance;
				light6.position.z = Math.cos(time * 0.5) * distance;
				++level;

				renderer.render(scene, camera);

				if (level == 50) {
					cancelAnimationFrame(frame);
					_GP.sender.getData(renderer.getContext(), ID);
					if (anti == true)
						run(canvas, cb, false, ID + 1);
					else
						cb();
				}
			}
			requestAnimationFrame(animate);
		};

		function init() {

			// CAMERA

			camera = new THREE.PerspectiveCamera(50, 256 / 256, 1, FAR);
			camera.position.set(0, 15, 150);
			camera.lookAt(new THREE.Vector3());

			// SCENE

			scene = new THREE.Scene();
			scene.fog = new THREE.Fog(0x040306, 10, FAR);

			// TEXTURES

			var textureLoader = new THREE.TextureLoader();

			var texture = textureLoader.load("static/assets/color_3_tex.png");
			texture.repeat.set(20, 10);
			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
			texture.format = THREE.RGBFormat;

			// MATERIALS

			var groundMaterial =
				new THREE.MeshPhongMaterial({ color: 0xffffff, map: texture });
			var objectMaterial = new THREE.MeshStandardMaterial(
				{ color: 0xffffff, roughness: 0.5, metalness: 1.0 });

			// GROUND

			var mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(800, 400, 2, 2),
				groundMaterial);
			mesh.position.y = -5;
			mesh.rotation.x = -Math.PI / 2;
			scene.add(mesh);

			// OBJECTS

			// var objectGeometry = new THREE.BoxGeometry( 0.5, 1, 1 );
			// var objectGeometry = new THREE.SphereGeometry( 1.5, 16, 8 );
			var objectGeometry = new THREE.TorusGeometry(1.5, 0.4, 8, 16);

			for (var i = 0; i < 5000; i++) {

				var mesh = new THREE.Mesh(objectGeometry, objectMaterial);

				mesh.position.x = 400 * (0.5 - Math.random());
				mesh.position.y = 50 * (0.5 - Math.random()) + 25;
				mesh.position.z = 200 * (0.5 - Math.random());

				mesh.rotation.y = 3.14 * (0.5 - Math.random());
				mesh.rotation.x = 3.14 * (0.5 - Math.random());

				mesh.matrixAutoUpdate = false;
				mesh.updateMatrix();
				scene.add(mesh);
			}

			// LIGHTS

			var intensity = 2.5;
			var distance = 100;
			var decay = 2.0;

			var c1 = 0xff0040, c2 = 0x0040ff, c3 = 0x80ff80, c4 = 0xffaa00,
				c5 = 0x00ffaa, c6 = 0xff1100;

			var sphere = new THREE.SphereGeometry(0.25, 16, 8);

			light1 = new THREE.PointLight(c1, intensity, distance, decay);
			light1.add(
				new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({ color: c1 })));
			scene.add(light1);

			light2 = new THREE.PointLight(c2, intensity, distance, decay);
			light2.add(
				new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({ color: c2 })));
			scene.add(light2);

			light3 = new THREE.PointLight(c3, intensity, distance, decay);
			light3.add(
				new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({ color: c3 })));
			scene.add(light3);

			light4 = new THREE.PointLight(c4, intensity, distance, decay);
			light4.add(
				new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({ color: c4 })));
			scene.add(light4);

			light5 = new THREE.PointLight(c5, intensity, distance, decay);
			light5.add(
				new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({ color: c5 })));
			scene.add(light5);

			light6 = new THREE.PointLight(c6, intensity, distance, decay);
			light6.add(
				new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({ color: c6 })));
			scene.add(light6);

			var dlight = new THREE.DirectionalLight(0xffffff, 0.05);
			dlight.position.set(0.5, 1, 0).normalize();
			scene.add(dlight);
		};
		//
	}
}).call(this);
